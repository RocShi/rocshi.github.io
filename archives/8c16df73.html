<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/myfavicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/myfavicon-16x16.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="PNikZLgEROlB0REDk-jntc-fTWVFIkSNJZbICyge9H4">
  <meta name="msvalidate.01" content="5D5B4EDEB3F20663D4B0CBA6229645B0">
  <meta name="baidu-site-verification" content="N9MkUFl4G3">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="fonts.loli.net/css?family=EB Garamond:300,300italic,400,400italic,700,700italic|Cinzel Decorative:300,300italic,400,400italic,700,700italic|Noto Serif SC:300,300italic,400,400italic,700,700italic|Source Code Pro:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://blog.shipengx.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.7.1',
    exturl: true,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":true},
    copycode: {"enable":true,"show_result":true,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: true,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":true,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="本系列文章为阅读《C++ Primer》过程中的书摘与学习笔记，持续更新。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ Primer - 第 16 章 模板与泛型编程">
<meta property="og:url" content="https://blog.shipengx.com/archives/8c16df73.html">
<meta property="og:site_name" content="朝花夕拾">
<meta property="og:description" content="本系列文章为阅读《C++ Primer》过程中的书摘与学习笔记，持续更新。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://image.shipengx.com/%E7%AC%AC%2016%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%881%EF%BC%89.png">
<meta property="og:image" content="https://image.shipengx.com/%E7%AC%AC%2016%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%882%EF%BC%89.png">
<meta property="article:published_time" content="2022-05-15T16:03:00.000Z">
<meta property="article:modified_time" content="2022-05-15T16:32:36.109Z">
<meta property="article:author" content="ShiPeng">
<meta property="article:tag" content="C&#x2F;C++">
<meta property="article:tag" content="C++ Primer">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://image.shipengx.com/%E7%AC%AC%2016%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%881%EF%BC%89.png">

<link rel="canonical" href="https://blog.shipengx.com/archives/8c16df73.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>
<link href="https://fonts.loli.net/css2?family=Noto+Serif+SC:wght@400;500;700&display=swap" rel="stylesheet">
<link href="https://fonts.loli.net/css2?family=ZCOOL+XiaoWei&display=swap" rel="stylesheet">
<link href="https://fonts.loli.net/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
<link href="https://fonts.loli.net/css2?family=Zhi+Mang+Xing&display=swap" rel="stylesheet">

  <title>C++ Primer - 第 16 章 模板与泛型编程 | 朝花夕拾</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">朝花夕拾</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">输出倒逼思考</h1>
      
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">26</span></a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">40</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">86</span></a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-fw fa-book"></i>读书</a>

  </li>
        <li class="menu-item menu-item-zhihu">

    <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9zaGktcGVuZy04"><i class="fa fa-fw fa-columns"></i>知乎</span>

  </li>
        <li class="menu-item menu-item-gitbook">

    <span class="exturl" data-url="aHR0cHM6Ly9ib29rLnNoaXBlbmd4LmNvbQ=="><i class="fa fa-fw fa-pencil"></i>GitBook</span>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JvY3NoaQ==" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://blog.shipengx.com/archives/8c16df73.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="ShiPeng">
      <meta itemprop="description" content="Stay hungry, stay foolish.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          C++ Primer - 第 16 章 模板与泛型编程
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2022-05-16 00:03:00 / 修改时间：00:32:36" itemprop="dateCreated datePublished" datetime="2022-05-16T00:03:00+08:00">2022-05-16</time>
            </span>

          <br>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A0%81/" itemprop="url" rel="index">
                    <span itemprop="name">编码</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A0%81/C-C/" itemprop="url" rel="index">
                    <span itemprop="name">C/C++</span>
                  </a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%BC%96%E7%A0%81/C-C/%E3%80%8AC-Primer%E3%80%8B/" itemprop="url" rel="index">
                    <span itemprop="name">《C++ Primer》</span>
                  </a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/archives/8c16df73.html#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/archives/8c16df73.html" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <div class="post-description">本系列文章为阅读《C++ Primer》过程中的书摘与学习笔记，持续更新。</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="16-1-定义模板" class="heading-control"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板<a class="heading-anchor" href="#16-1-定义模板" aria-hidden="true"></a></h1><h2 id="16-1-1-函数模板" class="heading-control"><a href="#16-1-1-函数模板" class="headerlink" title="16.1.1 函数模板"></a>16.1.1 函数模板<a class="heading-anchor" href="#16-1-1-函数模板" aria-hidden="true"></a></h2><ol>
<li><p>我们可以定义一个通用的<strong>函数模板</strong>（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。</p>
</li>
<li><p>模板定义以关键字 <code>template</code> 开始，后跟一个<strong>模板参数列表</strong>（template parameter list），这是一个逗号分隔的一个或多个<strong>模板参数</strong>（template parameter）的列表，用小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>）包围起来。</p>
<blockquote>
<p><strong>Note：</strong> 在模板定义中，模板参数列表不能为空。</p>
</blockquote>
</li>
<li><p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定<strong>模板实参</strong>（template argument），将其绑定到模板参数上。</p>
</li>
<li><p>当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，编译器使用实参的类型来确定绑定到模板参数 <code>T</code> 的类型。</p>
<p>编译器用推断出的模板参数来为我们<strong>实例化</strong>（instantiate）一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新<strong>实例</strong>（instantiation）。</p>
</li>
<li><p>模板<strong>类型参数</strong>（type parameter）。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</p>
</li>
<li><p>类型参数前必须使用关键字 <code>class</code> 或 <code>typename</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：U 之前必须加上 class 或 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt;</span><br><span class="line"><span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> U &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以同时使用这两个关键字：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确：在模板参数列表中，typename 和 class 没有什么不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">calc</span>(<span class="title">const</span> <span class="title">T</span> &amp;, <span class="title">const</span> <span class="title">U</span> &amp;);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>除了定义类型参数，还可以在模板中定义<strong>非类型参数</strong>（nontype parameter）。<strong>一个非类型参数表示一个值而非一个类型。</strong> 我们通过一个特定的类型名而非关键字 <code>class</code> 或 <code>typename</code> 来指定非类型参数。</p>
<p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。<br>这些值必须是常量表达式，从而允许编译器在编译时实例化模板。</p>
<p>例如，我们可以编写一个 <code>compare</code> 版本处理字符串字面常量。这种字面常量是 <code>const char</code> 的数组。由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用，由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数组的长度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用这个版本的 <code>compare</code> 时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compare(<span class="string">"hi"</span>, <span class="string">"mom"</span>)</span><br></pre></td></tr></table></figure>
<p>编译器会使用字面常量的大小来代替 <code>N</code> 和 <code>M</code>，从而实例化模板。记住，<strong>编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符</strong>，因此编译器会实例化出如下版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[<span class="number">3</span>], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>（需要注意对于字符串字面常量来说，<code>sizeof</code> 和 <code>strlen</code> 的区别——博主注。）</p>
</li>
<li><p><strong>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期，我们不能用一个普通（非 <code>static</code>）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用 <code>nullptr</code> 或一个值为 0 的常量表达式来实例化。</strong></p>
</li>
<li><p>在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小。</p>
<blockquote>
<p><strong>Note：</strong> 非类型模板参数的模板实参必须是常量表达式。</p>
</blockquote>
</li>
<li><p>函数模板可以声明为 <code>inline</code> 或 <code>constexpr</code> 的，如同非模板函数一样。<code>inline</code> 或 <code>constexpr</code> 说明符放在模板参数列表之后，返回类型之前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确：inline 说明符跟在模板参数列表之后</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 错误：inline 说明符的位置不正确</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写泛型代码的两个重要原则：</p>
<ul>
<li>模板中的函数参数是 <code>const</code> 的引用。</li>
<li>函数体中的条件判断仅使用 <code>&lt;</code> 比较运算。</li>
</ul>
</li>
<li><blockquote>
<p><strong>Best Practices：</strong> 模板程序应该尽量减少对实参类型的要求。</p>
</blockquote>
</li>
<li><p><strong>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。</strong></p>
</li>
<li><p>通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同：<strong>为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</strong></p>
<blockquote>
<p><strong>Note：函数模板和类模板成员函数的定义通常放在头文件中。</strong></p>
</blockquote>
</li>
<li><p>模板包含两种名字：</p>
<ul>
<li>那些不依赖于模板参数的名字</li>
<li>那些依赖于模板参数的名字</li>
</ul>
<p><br></p>
<p>当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者来保证的。而且，模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的。</p>
<p>用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
</li>
<li><p>模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。</p>
</li>
<li><p>模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。</p>
<ul>
<li>第一个阶段是<strong>编译模板本身时</strong>。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。</li>
<li>第二个阶段是<strong>编译器遇到模板使用时</strong>。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。</li>
<li>第三个阶段是<strong>模板实例化时</strong>，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li>
</ul>
</li>
<li><blockquote>
<p><strong>WARNING：</strong> 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。</p>
</blockquote>
</li>
</ol>
<h2 id="16-1-2-类模板" class="heading-control"><a href="#16-1-2-类模板" class="headerlink" title="16.1.2 类模板"></a>16.1.2 类模板<a class="heading-anchor" href="#16-1-2-类模板" aria-hidden="true"></a></h2><ol>
<li><p><strong>类模板</strong>（class template）。与函数模板的不同之处是，<strong>编译器不能为类模板推断模板参数类型</strong>。如我们已经多次看到的，为了使用类模板，我们必须在模板名后的尖括号中提供额外信息——用来代替模板参数的模板实参列表。</p>
</li>
<li><p>类似函数模板，类模板以关键字 <code>template</code> 开始，后跟模板参数列表。</p>
</li>
<li><p>当使用一个类模板时，我们必须提供额外信息。这些额外信息是<strong>显式模板实参</strong>（explicit template argument）列表，它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的类。</p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 一个类模板的每个实例都形成一个独立的类。</p>
</blockquote>
</li>
<li><p>类模板的名字不是一个类型名。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。</p>
</li>
<li><p>一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。</p>
</li>
<li><p>与其他任何类相同，我们<strong>既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数</strong>。</p>
</li>
<li><p>类模板的成员函数具有和模板相同的模板参数。因而，<strong>定义在类模板之外的成员函数就必须以关键字 <code>template</code> 开始，后接类模板参数列表</strong>。当我们在类外定义一个成员时，必须说明成员属于哪个类。而且，从一个模板生成的类的名字中必须包含其模板实参。当我们定义一个成员函数时，模板实参与模板形参相同。例如像下面这样定义 <code>Blob</code> 模板类的一些成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::check(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= data-&gt;size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T &amp;Blob&lt;T&gt;::back()</span><br><span class="line">&#123;</span><br><span class="line">    check(o, <span class="string">"back on empty Blob"</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T &amp;Blob&lt;T&gt;::<span class="keyword">operator</span>[](size_type i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 i 太大，check 会抛出异常，阻止访问一个不存在的元素</span></span><br><span class="line">    check(i, <span class="string">"subscript out of range"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::pop_back()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"pop back on empty Blob"</span>);</span><br><span class="line">    data-&gt;pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob() : data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行实例化，这一特性使得即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。</p>
<blockquote>
<p><strong>Note：默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</strong></p>
</blockquote>
</li>
<li><p>当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。<strong>在类模板自己的作用域中，我们可以直接使用模板名而不提供实参</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 若试图访问一个不存在的元素，BlobPtr 抛出一个异常</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BlobPtr() : curr(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    BlobPtr(Blob&lt;T&gt; &amp;a, <span class="keyword">size_t</span> sz = <span class="number">0</span>) : wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr]; <span class="comment">// (*p) 为本对象指向的 vector</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递增和递减</span></span><br><span class="line">    BlobPtr &amp;<span class="keyword">operator</span>++(); <span class="comment">// 前置运算符</span></span><br><span class="line">    BlobPtr &amp;<span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若检查成功，check 返回一个指向 vector 的 shared_ptr</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; <span class="title">check</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 保存一个 weak_ptr，表示底层 vector 可能被销毁</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; wptr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> curr; <span class="comment">// 数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>BlobPtr</code> 的前置递增和递减成员返回 <code>BlobPtr&amp;</code>，而不是 <code>BlobPtr&lt;T&gt;&amp;</code>。<strong>当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样。</strong> 即，就好像我们这样编写代码一样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BlobPtr&lt;T&gt; &amp;<span class="keyword">operator</span>++();</span><br><span class="line">BlobPtr&lt;T&gt; &amp;<span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 后置：递增/递减对象但返回原值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处无须检查；调用前置递增时会进行检查</span></span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>; <span class="comment">// 保存当前值</span></span><br><span class="line">    ++*<span class="keyword">this</span>;             <span class="comment">// 推进一个元素；前置 ++ 检查递增是否合法</span></span><br><span class="line">    <span class="keyword">return</span> ret;          <span class="comment">// 返回保存的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的 <code>BlobPtr</code>，它所用类型与类实例化所用类型一致。在函数体内，我们已经进入类的作用域，因此在定义 <code>ret</code> 时无须重复模板实参。如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。因此，<code>ret</code> 的定义与如下代码等价：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BlobPtr&lt;T&gt; ret = *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：</strong> 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。</p>
</blockquote>
</li>
<li><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。<strong>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</strong></p>
</li>
<li><p>类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。</p>
</li>
<li><p>为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在 Blob 中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span> <span class="comment">// 运算符 == 中的参数所需要的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt; &amp;, <span class="keyword">const</span> Blob&lt;T&gt; &amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 每个 Blob 实例将访问权限授予用相同类型实例化的 BlobPtr 和相等运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;T&gt;;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="keyword">const</span> Blob&lt;T&gt; &amp;, <span class="keyword">const</span> Blob&lt;T&gt; &amp;);</span><br><span class="line">    <span class="comment">// 其他成员定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们首先将 <code>Blob</code>、<code>BlobPtr</code> 和 <code>operator==</code> 声明为模板。这些声明是 <code>operator==</code> 函数的参数声明以及 <code>Blob</code> 中的友元声明所需要的。</p>
<p>友元的声明用 <code>Blob</code> 的模板形参作为它们自己的模板实参。因此，友好关系被限定在用相同类型实例化的 <code>Blob</code> 与 <code>BlobPtr</code> 相等运算符之间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">char</span>&gt; ca; <span class="comment">// BlobPtr&lt;char&gt; 和 operator==&lt;char&gt; 都是本对象的友元</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;  <span class="comment">// BlobPtr&lt;int&gt; 和 operator==&lt;int&gt; 都是本对象的友元</span></span><br></pre></td></tr></table></figure>
<p><code>BlobPtr&lt;char&gt;</code> 的成员可以访问 <code>ca</code>（或任何其他 <code>Blob&lt;char&gt;</code> 对象）的非 <code>public</code> 部分，但 <code>ca</code> 对 <code>ia</code>（或任何其他 <code>Blob&lt;int&gt;</code> 对象）或 <code>Blob</code> 的任何其他实例都没有特殊访问权限。</p>
</li>
<li><p><strong>一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> // <span class="title">C</span> 是一个普通的非模板类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;C&gt;;</span> <span class="comment">// 用类 C 实例化的 Pal 是 C 的一个友元</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pal2 的所有实例都是 C 的友元；这种情况无须前置声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> // <span class="title">C2</span> 本身是一个类模板</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// C2 的每个实例将相同实例化的 Pal 声明为友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;T&gt;;</span> <span class="comment">// Pal 的模板声明必须在作用域之内</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pal2 的所有实例都是 C2 的每个实例的友元，不需要前置声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pal3 是一个非模板类，它是 C2 所有实例的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span> <span class="comment">// 不需要 Pal3 的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</strong></p>
</li>
<li><p><strong>在新标准中，我们可以将模板类型参数声明为友元</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> Type; <span class="comment">// 将访问权限授予用来实例化 Bar 的类型</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此处我们将用来实例化 <code>Bar</code> 的类型声明为友元。因此，对于某个类型名 <code>Foo</code>，<code>Foo</code> 将成为 <code>Bar&lt;Foo&gt;</code> 的友元，<code>Sales_data</code> 将成为 <code>Bar&lt;Sales_data&gt;</code> 的友元，依此类推。</p>
<p>值得注意的是，<strong>虽然友元通常来说应该是一个类或是一个函数，但我们完全可以用一个内置类型来实例化 <code>Bar</code>。这种与内置类型的友好关系是允许的</strong>，以便我们能用内置类型来实例化 <code>Bar</code> 这样的类。</p>
</li>
<li><p>类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个 <code>typedef</code> 来引用实例化的类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br></pre></td></tr></table></figure>
<p><strong>由于模板不是一个类型，我们不能定义一个 <code>typedef</code> 引用一个模板。</strong> 即，无法定义一个 <code>typedef</code> 引用 <code>Blob&lt;T&gt;</code>。</p>
<p>但是，<strong>新标准允许我们为类模板定义一个类型别名</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors; <span class="comment">// authors 是一个 pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们将 <code>twin</code> 定义为成员类型相同的 <code>pair</code> 的别名。这样，<code>twin</code> 的用户只需指定一次类型。一个模板类型别名是一族类的别名：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">twin&lt;<span class="keyword">int</span>&gt; win_loss; <span class="comment">// win_loss 是一个 pair&lt;int, int&gt;</span></span><br><span class="line">twin&lt;<span class="keyword">double</span>&gt; area;  <span class="comment">// area 是一个 pair&lt;double, double&gt;</span></span><br></pre></td></tr></table></figure>
<p>就像使用类模板一样，当我们使用 <code>twin</code> 时，需要指出希望使用哪种特定类型的 <code>twin</code>。<strong>当我们定义一个模板类型别名时，可以固定一个或多个模板参数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br><span class="line"></span><br><span class="line">partNo&lt;<span class="built_in">string</span>&gt; books; <span class="comment">// books 是一个 pair&lt;string, unsigned&gt;</span></span><br><span class="line">partNo&lt;Vehicle&gt; cars; <span class="comment">// cars 是一个 pair&lt;Vehicle, unsigned&gt;</span></span><br><span class="line">partNo&lt;Student&gt; kids; <span class="comment">// kids 是一个 pair&lt;Student, unsigned&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码中我们将 <code>partNo</code> 定义为一族类型的别名，这族类型是 <code>second</code> 成员为 <code>unsigned</code> 的 <code>pair</code>。<code>partNo</code> 的用户需要指出 <code>pair</code> 的 <code>first</code> 成员的类型，但不能指定 <code>second</code> 成员的类型。</p>
</li>
<li><p>与任何其他类相同，<strong>类模板可以声明 <code>static</code> 成员</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line">    <span class="comment">// 其他接口成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line">    <span class="comment">// 其他实现成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>Foo</code> 是一个类模板，它有一个名为 <code>count</code> 的 <code>public static</code> 成员函数和一个名为 <code>ctr</code> 的 <code>private static</code> 数据成员。每个 <code>Foo</code> 的实例都有其自己的 <code>static</code> 成员实例。即，对任意给定类型 <code>X</code>，都有一个 <code>Foo&lt;X&gt;::ctr</code> 和一个 <code>Foo&lt;X&gt;::count</code> 成员。所有 <code>Foo&lt;X&gt;</code> 类型的对象共享相同的 <code>ctr</code> 对象和 <code>count</code> 函数。例如，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化 static 成员 Foo&lt;string&gt;::ctr 和 Foo&lt;string&gt;::count</span></span><br><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs;</span><br><span class="line"><span class="comment">// 所有三个对象共享相同的 Foo&lt;int&gt;::ctr 和 Foo&lt;int&gt;::count 成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2, fi3;</span><br></pre></td></tr></table></figure>
<p>与任何其他 <code>static</code> 数据成员相同，模板类的每个 <code>static</code> 数据成员必须有且仅有一个定义。但是，类模板的每个实例都有一个独有的 <code>static</code> 对象。因此，与定义模板的成员函数类似，我们将 <code>static</code> 数据成员也定义为模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>; <span class="comment">// 定义并初始化 ctr</span></span><br></pre></td></tr></table></figure>
<p>与类模板的其他任何成员类似，定义的开始部分是模板参数列表，随后是我们定义的成员的类型和名字。与往常一样，成员名包括成员的类名，对于从模板生成的类来说，类名包括模板实参。因此，当使用一个特定的模板实参类型实例化 <code>Foo</code> 时，将会为该类类型实例化一个独立的 <code>ctr</code>，并将其初始化为 0。</p>
<p><strong>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的 <code>static</code> 成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问 <code>static</code> 成员，我们必须引用一个特定的实例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;                 <span class="comment">// 实例化 Foo&lt;int&gt; 类和 static 数据成员 ctr</span></span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt;::count(); <span class="comment">// 实例化 Foo&lt;int&gt;::count</span></span><br><span class="line">ct = fi.count();             <span class="comment">// 使用 Foo&lt;int&gt;::count</span></span><br><span class="line">ct = Foo::count();           <span class="comment">// 错误：使用哪个模板实例的 count？</span></span><br></pre></td></tr></table></figure>
<p><strong>类似任何其他成员函数，一个 <code>static</code> 成员函数只有在使用时才会实例化。</strong></p>
</li>
</ol>
<h2 id="16-1-3-模板参数" class="heading-control"><a href="#16-1-3-模板参数" class="headerlink" title="16.1.3 模板参数"></a>16.1.3 模板参数<a class="heading-anchor" href="#16-1-3-模板参数" aria-hidden="true"></a></h2><ol>
<li><p>模板参数遵循普通的作用域规则。<strong>一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A tmp = a; <span class="comment">// tmp 的类型为模板参数 A 的类型，而非 double</span></span><br><span class="line">    <span class="keyword">double</span> B;  <span class="comment">// 错误：重声明模板参数 B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常的名字隐藏规则决定了 <code>A</code> 的 <code>typedef</code> 被类型参数 <code>A</code> 隐藏。因此，<code>tmp</code> 不是一个 <code>double</code>，其类型是使用 <code>f</code> 时绑定到类型参数 <code>A</code> 的类型。由于我们不能重用模板参数名，声明名字为 <code>B</code> 的变量是错误的。</p>
<p><strong>由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：非法重用模板参数名 V</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> V&gt; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模板声明必须包含模板参数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明但不定义 compare 和 Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>与函数参数相同，声明中的模板参数的名字不必与定义中相同</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3 个 calc 都指向相同的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">U <span class="title">calc</span><span class="params">(<span class="keyword">const</span> U &amp;, <span class="keyword">const</span> U &amp;)</span></span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 模板的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">Type <span class="title">calc</span><span class="params">(<span class="keyword">const</span> Type &amp;a, <span class="keyword">const</span> Type &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，<strong>一个给定模板的每个声明和定义必须有相同数量和种类（即，类型或非类型）的参数</strong>。</p>
</li>
<li><blockquote>
<p><strong>Best Practices：一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</strong></p>
</blockquote>
</li>
<li><p><strong>我们用作用域运算符（<code>::</code>）来访 <code>static</code> 成员和类型成员。</strong> 在普通（非模板）代码中，编译器掌握类的定义。因此，它知道通过作用域运算符访问的名字是类型还是 <code>static</code> 成员。</p>
<p>但对于模板代码就存在困难。例如，假定 <code>T</code> 是一个模板类型参数，当编译器遇到类似 <code>T::mem</code> 这样的代码时，它不会知道 <code>mem</code> 是一个类型成员还是一个 <code>static</code> 数据成员，直至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。例如，假定 <code>T</code> 是一个类型参数的名字，当编译器遇到如下形式的语句时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">T::size_type *p;</span><br></pre></td></tr></table></figure>
<p>它需要知道我们是正在定义一个名为 <code>p</code> 的变量还是将一个名为 <code>size_type</code> 的 <code>static</code> 数据成员与名为 <code>p</code> 的变量相乘。</p>
<p><strong>默认情况下，C++ 语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字 <code>typename</code> 来实现这一点</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!c.empty())</span><br><span class="line">        <span class="keyword">return</span> c.back();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：当我们希望通知编译器一个名字表示类型时，必须使用关键字 <code>typename</code>，而不能使用 <code>class</code>。</strong></p>
</blockquote>
</li>
<li><p>就像我们能为函数参数提供默认实参一样，我们也可以提供<strong>默认模板实参</strong>（default template argument）。<strong>在新标准中，我们可以为函数和类模板提供默认实参。</strong> 而更早的 C++ 标准只允许为类模板提供默认实参。</p>
<p>例如，我们重写 <code>compare</code>，默认使用标准库的 <code>less</code> 函数对象模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare 有一个默认模板实参 less&lt;T&gt; 和一个默认函数实参 F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = F())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (f(v1, v2))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (f(v2, v1))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们为模板添加了第二个类型参数，名为 <code>F</code>，表示可调用对象的类型；并定义了一个新的函数参数 <code>f</code>，绑定到一个可调用对象上。</p>
<p>我们为此模板参数提供了默认实参，并为其对应的函数参数也提供了默认实参。默认模板实参指出 <code>compare</code> 将使用标准库的 <code>less</code> 函数对象类，它是使用与 <code>compare</code> 一样的类型参数实例化的。默认函数实参指出 <code>f</code> 将是类型 <code>F</code> 的一个默认初始化的对象。</p>
<p>当用户调用这个版本的 <code>compare</code> 时，可以提供自己的比较操作，但这并不是必需的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> i = compare(<span class="number">0</span>, <span class="number">42</span>); <span class="comment">// 使用 less；i 为 -1</span></span><br><span class="line"><span class="comment">// 结果依赖于 item1 和 item2 中的 isbn</span></span><br><span class="line">Sales_data item1(cin), item2(cin);</span><br><span class="line"><span class="keyword">bool</span> j = compare(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>
<p>第一个调用使用默认函数实参，即，类型 <code>less&lt;T&gt;</code> 的一个默认初始化对象。在此调用中，<code>T</code> 为 <code>int</code>，因此可调用对象的类型为 <code>less&lt;int&gt;</code>，<code>compare</code> 的这个实例化版本将使用 <code>less&lt;int&gt;</code> 进行比较操作。</p>
<p>在第二个调用中，我们传递给 <code>compare</code> 三个实参：<code>compareIsbn</code> 和两个 <code>Sales_data</code> 类型的对象。当传递给 <code>compare</code> 三个实参时，第三个实参的类型必须是一个可调用对象，该可调用对象的返回类型必须能转换为 <code>bool</code> 值，且接受的实参类型必须与 <code>compare</code> 的前两个实参的类型兼容。与往常一样，模板参数的类型从它们对应的函数实参推断而来。在此调用中，<code>T</code> 的类型被推断为 <code>Sales_data</code>，<code>F</code> 被推断为 <code>compareIsbn</code> 的类型。</p>
<p><strong>与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。</strong></p>
</li>
<li><p><strong>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对</strong>（类似于函数调用时必须要要有 <code>()</code>——博主注）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt; // <span class="title">T</span> 默认为 <span class="title">int</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Numbers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Numbers(T v = <span class="number">0</span>) : val(v) &#123;&#125;</span><br><span class="line">    <span class="comment">// 对数值的各种操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空 &lt;&gt; 表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>
<p>此例中我们实例化了两个 <code>Numbers</code> 版本：<code>average_precision</code> 是用 <code>int</code> 代替 <code>T</code> 实例化得到的：<code>lots_of_precision</code> 是用 <code>long double</code> 代替 <code>T</code> 实例化而得到的。</p>
</li>
</ol>
<h2 id="16-1-4-成员模板" class="heading-control"><a href="#16-1-4-成员模板" class="headerlink" title="16.1.4 成员模板"></a>16.1.4 成员模板<a class="heading-anchor" href="#16-1-4-成员模板" aria-hidden="true"></a></h2><ol>
<li><p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为<strong>成员模板</strong>（member template）。<strong>成员模板不能是虚函数。</strong></p>
</li>
<li><p>作为普通类包含成员模板的例子，我们定义一个类，类似 <code>unique_ptr</code> 所使用的默认删除器类型。类似默认删除器，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行 <code>delete</code>。与默认删除器不同，我们的类还将在删除器被执行时打印一条信息。由于希望删除器适用于任何类型，所以我们将调用运算符定义为一个模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数对象类，对给定指针执行 delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DebugDelete(<span class="built_in">std</span>::ostream &amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>) : os(s) &#123;&#125;</span><br><span class="line">    <span class="comment">// 与任何函数模板相同，T 的类型由编译器推断</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">"deleting unique_ptr"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::ostream &amp;os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以像下面这样使用 <code>DebugDelete</code> 类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> *p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d; <span class="comment">// 可像 delete 表达式一样使用的对象</span></span><br><span class="line">d(p);          <span class="comment">// 调用 DebugDelete::operator()(double*)，释放 p</span></span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// 在一个临时 DebugDelete 对象上调用 operator()(int*)</span></span><br><span class="line">DebugDelete()(ip);</span><br></pre></td></tr></table></figure>
<p>由于调用一个 <code>DebugDelete</code> 对象会 <code>delete</code> 其给定的指针，我们也可以将 <code>DebugDelete</code> 用作 <code>unique_ptr</code> 的删除器。为了重载 <code>unique_ptr</code> 的删除器，我们在尖括号内给出删除器类型，并提供一个这种类型的对象给 <code>unique_ptr</code> 的构造函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 销毁 p 指向的对象</span></span><br><span class="line"><span class="comment">// 实例化 DebugDelete::operator()&lt;int&gt;(int*)</span></span><br><span class="line">unique_ptr&lt;int, DebugDelete&gt; p(new int, DebugDelete());</span><br><span class="line"><span class="comment">// 销毁 sp 指向的对象</span></span><br><span class="line"><span class="comment">// 实例化 DebugDelete::operator()&lt;string&gt;(string*)</span></span><br><span class="line">unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的、独立的模板参数。例如，我们将为 <code>Blob</code> 类定义一个构造函数，它接受两个选代器，表示要拷贝的元素范围。由于我们希望支持不同类型序列的选代器，因此将构造函数定义为模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    Blob(It b, It e);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="comment">// 构造函数的类型参数</span></span><br><span class="line">Blob&lt;T&gt;::Blob(It b, It e) : data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(b, e))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。</strong> 与往常一样，我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; vi = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; w = &#123;<span class="string">"now"</span>, <span class="string">"is"</span>, <span class="string">"the"</span>, <span class="string">"time"</span>&#125;;</span><br><span class="line"><span class="comment">// 实例化 Blob&lt;int&gt; 类及其接受两个 int* 参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a1</span><span class="params">(begin(ia), end(ia))</span></span>;</span><br><span class="line"><span class="comment">// 实例化 Blob&lt;int&gt; 类的接受两个 vector&lt;long&gt;::iterator 的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(vi.begin(), vi.end())</span></span>;</span><br><span class="line"><span class="comment">// 实例化 Blob&lt;string&gt; 及其接受两个 list&lt;const char*&gt;::iterator 参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="built_in">string</span>&gt; <span class="title">a3</span><span class="params">(w.begin(), w.end())</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="16-1-5-控制实例化" class="heading-control"><a href="#16-1-5-控制实例化" class="headerlink" title="16.1.5 控制实例化"></a>16.1.5 控制实例化<a class="heading-anchor" href="#16-1-5-控制实例化" aria-hidden="true"></a></h2><ol>
<li><p>当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。<strong>当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</strong></p>
</li>
<li><p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过<strong>显式实例化</strong>（explicit instantiation）来避免这种开销（与自动实例化相对——博主注）。一个显式实例化有如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;        <span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<p>declaration 是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>             <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<p><strong>当编译器遇到 <code>extern</code> 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为 <code>extern</code> 就表示承诺在程序其他位置有该实例化的一个非 <code>extern</code> 声明（定义）。对于一个给定的实例化版本，可能有多个 <code>extern</code> 声明，但必须只有一个定义。</strong></p>
<p><strong>由于编译器在使用一个模板时自动对其实例化，因此 <code>extern</code> 声明必须出现在任何使用此实例化版本的代码之前</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Application.cc</span></span><br><span class="line"><span class="comment">// 这些模板类型必须在程序其他位置进行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line">Blob&lt;<span class="built_in">string</span>&gt; sa1, sa2; <span class="comment">// 实例化会出现在其他位置</span></span><br><span class="line"><span class="comment">// Blob&lt;int&gt; 及其接受 initializer_list 的构造函数在本文件中实例化</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a1 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(a1)</span></span>;              <span class="comment">// 拷贝构造函数在本文件中实例化</span></span><br><span class="line"><span class="keyword">int</span> i = compare(a1[<span class="number">0</span>], a2[<span class="number">0</span>]); <span class="comment">// 实例化出现在其他位置</span></span><br></pre></td></tr></table></figure>
<p>文件 <code>Application.o</code> 将包含 <code>Blob&lt;int&gt;</code> 的实例及其接受 <code>initializer_list</code> 参数的构造函数和拷贝构造函数的实例。而 <code>compare&lt;int&gt;</code> 函数和 <code>Blob&lt;string&gt;</code> 类将不在本文件中进行实例化。这些模板的定义必须出现在程序的其他文件中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// templateBuild.cc</span></span><br><span class="line"><span class="comment">// 实例化文件必须为每个在其他文件中声明为 extern 的类型和函数提供一个（非 extern）</span></span><br><span class="line"><span class="comment">// 的定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span> <span class="comment">// 实例化类模板的所有成员</span></span><br></pre></td></tr></table></figure>
<p>当编译器遇到一个实例化定义（与声明相对）时，它为其生成代码。因此，文件 <code>templateBuild.o</code> 将会包含 <code>compare</code> 的 <code>int</code> 实例化版本的定义和 <code>Blob&lt;string&gt;</code> 类的定义。当我们编译此应用程序时，必须将 <code>templateBuild.o</code> 和 <code>Application.o</code> 链接到一起。</p>
</li>
<li><blockquote>
<p><strong>WARNING：对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</strong></p>
</blockquote>
</li>
<li><p><strong>一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化（自动实例化——博主注）不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。</strong></p>
<blockquote>
<p><strong>Note：</strong> 在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。</p>
</blockquote>
</li>
<li><p><strong>练习 16.26：</strong> 假设 <code>NoDefault</code> 是一个没有默认构造函数的类，我们可以显式实例化 <code>vector&lt;NoDefault&gt;</code> 吗？如果不可以，解释为什么。</p>
<p>答：不可以，因为显示实例化会 <code>vector&lt;NoDefault&gt;</code> 时会实例化 <code>vector</code> 的所有成员函数，包括其接受容器大小的构造函数，该构造函数需要使用元素类型的默认构造函数对容器元素进行值初始化。</p>
</li>
<li><p><strong>练习 16.27：</strong> 对下面每条带标签的语句，解释发生了什么样的实例化（如果有的话）。如果一个模板被实例化，解释为什么；如果未实例化，解释为什么没有。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Stack&lt;<span class="keyword">char</span>&gt;)</span></span>; <span class="comment">// (a)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exercise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Stack&lt;<span class="keyword">double</span>&gt; &amp;rsd; <span class="comment">// (b)</span></span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; si;      <span class="comment">// (c)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">char</span>&gt; *sc;                  <span class="comment">// (d)</span></span><br><span class="line">    f1(*sc);                          <span class="comment">// (e)</span></span><br><span class="line">    <span class="keyword">int</span> iObj = <span class="keyword">sizeof</span>(Stack&lt;<span class="built_in">string</span>&gt;); <span class="comment">// (f)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：(a)、(b)、(c)、(f) 分别会发生 <code>Stack</code> 针对 <code>char</code> <code>double</code> <code>int</code> <code>string</code> 类型的模板自动实例化；(d)、(e) 不会发生实例化，因为所涉及到的模板类类型 <code>Stack&lt;char&gt;</code> 在此前已被实例化出来。</p>
</li>
</ol>
<h2 id="16-1-6-效率与灵活性" class="heading-control"><a href="#16-1-6-效率与灵活性" class="headerlink" title="16.1.6 效率与灵活性"></a>16.1.6 效率与灵活性<a class="heading-anchor" href="#16-1-6-效率与灵活性" aria-hidden="true"></a></h2><ol>
<li><ul>
<li><code>shared_ptr</code> 和 <code>unique_ptr</code> 之间的明显不同是它们管理所保存的指针的策略前者给予我们共享指针所有权的能力；后者则独占指针。</li>
<li>这两个类的另一个差异是它们允许用户重载默认删除器的方式。<strong>我们可以很容易地重载一个 <code>shared_ptr</code> 的删除器，只要在创建或 <code>reset</code> 指针时传递给它一个可调用对象即可。与之相反，删除器的类型是一个 <code>unique_ptr</code> 对象的类型的一部分。用户必须在定义 <code>unique_ptr</code> 时以显式模板实参的形式提供删除器的类型。</strong></li>
</ul>
</li>
<li><p><code>shared_ptr</code> 不是将删除器直接保存为一个成员，因为删除器的类型直到运行时才会知道。实际上，在一个 <code>shared_ptr</code> 的生存期中，我们可以随时改变其删除器的类型。我们可以使用一种类型的删除器构造一个 <code>shared_ptr</code>，随后使用 <code>reset</code> 赋予此 <code>shared_ptr</code> 另一种类型的删除器。通常，类成员的类型在运行时是不能改变的。因此，不能直接保存删除器。</p>
</li>
<li><p>在 <code>unique_ptr</code> 类中，删除器的类型是类类型的一部分。即，<strong><code>unique_ptr</code> 有两个模板参数，一个表示它所管理的指针，另一个表示删除器的类型</strong>。由于删除器的类型是 <code>unique_ptr</code> 类型的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在 <code>unique_ptr</code> 对象中。</p>
</li>
<li><p>通过在编译时绑定删除器，<code>unique_ptr</code> 避免了间接调用删除器的运行时开销（一个 <code>if</code> 判断——博主注）。通过在运行时绑定删除器，<code>shared_ptr</code> 使用户重载删除器更为方便。</p>
</li>
</ol>
<h1 id="16-2-模板实参推断" class="heading-control"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断<a class="heading-anchor" href="#16-2-模板实参推断" aria-hidden="true"></a></h1><ol>
<li>从函数实参来确定模板实参的过程被称为<strong>模板实参推断</strong>（template argument deduction）。</li>
</ol>
<h2 id="16-2-1-类型转换与模板类型参数" class="heading-control"><a href="#16-2-1-类型转换与模板类型参数" class="headerlink" title="16.2.1 类型转换与模板类型参数"></a>16.2.1 类型转换与模板类型参数<a class="heading-anchor" href="#16-2-1-类型转换与模板类型参数" aria-hidden="true"></a></h2><ol>
<li><p>与往常一样，顶层 <code>const</code> 无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。</p>
<ul>
<li><strong><code>const</code> 转换：可以将一个非 <code>const</code> 对象的引用（或指针）传递给一个 <code>const</code> 的引用（或指针）形参。</strong></li>
<li><strong>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</strong></li>
</ul>
<p><br></p>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
</li>
<li><p><strong>如果形参是一个引用，则数组不会转换为指针。</strong></p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有 <code>const</code> 转换及数组或函数到指针的转换。</p>
</blockquote>
</li>
<li><p>一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是错误的。</p>
</li>
<li><p>如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实参类型可以不同，但必须兼容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span><span class="params">(<span class="keyword">const</span> A &amp;v1, <span class="keyword">const</span> B &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数实参不进行特殊处理；它们正常转换为对应形参的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个函数参数是一个已知类型 <code>ostream&amp;</code>。第二个参数 <code>obj</code> 则是模板参数类型。由于 <code>os</code> 的类型是固定的，因此当调用 <code>print</code> 时，传递给它的实参会进行正常的类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">cout</span>, <span class="number">42</span>); <span class="comment">// 实例化 print(ostream&amp;, int)</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span><span class="params">(<span class="string">"output"</span>)</span></span>;</span><br><span class="line">print(f, <span class="number">10</span>); <span class="comment">// 使用 print(ostream&amp;, int)；将 f 转换为 ostream&amp;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：</strong> 如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</p>
</blockquote>
</li>
</ol>
<h2 id="16-2-2-函数模板显式实参" class="heading-control"><a href="#16-2-2-函数模板显式实参" class="headerlink" title="16.2.2 函数模板显式实参"></a>16.2.2 函数模板显式实参<a class="heading-anchor" href="#16-2-2-函数模板显式实参" aria-hidden="true"></a></h2><ol>
<li><p>在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。<strong>当函数返回类型与参数列表中任何类型都不相同时</strong>，这两种情况最常出现。</p>
<p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断 T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在本例中，没有任何函数实参的类型可用来推断 <code>T1</code> 的类型。每次调用 <code>sum</code> 时调用者都必须为 <code>T1</code> 提供一个<strong>显式模板实参</strong>（explicit template argument）。</p>
<p>我们提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在尖括号中给出，位于函数名之后，实参列表之前：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// T1 是显式指定的，T2 和 T3 是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng); <span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure>
<p>此调用显式指定 <code>T1</code> 的类型。而 <code>T2</code> 和 <code>T3</code> 的类型则由编译器从 <code>i</code> 和 <code>lng</code> 的类型推断出来。</p>
</li>
<li><p><strong>显式模板实参按由左至右的顺序与对应的模板参数匹配</strong>；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，依此类推。只有尾部（最右）参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。如果我们的 <code>sum</code> 函数按照如下形式编写：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 糟糕的设计：用户必须指定所有三个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span><span class="params">(T2, T1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>则我们总是必须为所有三个形参指定实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：不能推断前几个模板参数</span></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);</span><br><span class="line"><span class="comment">// 正确：显式指定了所有三个参数</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于用普通类型定义的函数参数，允许进行正常的类型转换，出于同样的原因，<strong>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>);       <span class="comment">// 错误：模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">// 正确：实例化 compare(long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>);  <span class="comment">// 正确：实例化 compare(int, int)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 16.38：</strong> 当我们调用 <code>make_shared</code> 时，必须提供一个显式模板实参。解释为什么需要显式模板实参以及它是如何使用的。</p>
<p>答：<code>make_shared</code> 的返回类型是 <code>shared_ptr</code>，而 <code>shared_ptr</code> 是个类模板，返回类型里的模板参数只能显式指定。</p>
</li>
</ol>
<h2 id="16-2-3-尾置返回类型与类型转换" class="heading-control"><a href="#16-2-3-尾置返回类型与类型转换" class="headerlink" title="16.2.3 尾置返回类型与类型转换"></a>16.2.3 尾置返回类型与类型转换<a class="heading-anchor" href="#16-2-3-尾置返回类型与类型转换" aria-hidden="true"></a></h2><ol>
<li><p>我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个元素的引用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;fcn(It beg, It end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Blob&lt;<span class="built_in">string</span>&gt; ca = &#123;<span class="string">"hi"</span>, <span class="string">"bye"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;i = fcn(vi.begin(), vi.end()); <span class="comment">// fcn 应该返回 int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;s = fcn(ca.begin(), ca.end()); <span class="comment">// fcn 应该返回 string&amp;</span></span><br></pre></td></tr></table></figure>
<p>此例中，我们知道函数应该返回 <code>*beg</code>，而且知道我们可以用 <code>decltype(*beg)</code> 来获取此表达式的类型。但是，在编译器遇到函数的参数列表之前，<code>beg</code> 都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于<strong>尾置返回出现在参数列表之后，它可以使用函数的参数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例中我们通知编译器 <code>fcn</code> 的返回类型与解引用 <code>beg</code> 参数的结果类型相同。<strong>解引用运算符返回一个左值，因此通过 <code>decltype</code> 推断的类型为 <code>beg</code> 表示的元素的类型的引用。</strong> 因此，如果对一个 <code>string</code> 序列调用 <code>fcn</code>，返回类型将是 <code>string&amp;</code>。如果是 <code>int</code> 序列，则返回类型是 <code>int&amp;</code>。</p>
</li>
<li><p>有时我们无法直接获得所需要的类型。例如，我们可能希望编写一个类似 <code>fcn</code> 的函数，但返回一个元素的值而非引用。</p>
<p>在编写这个函数的过程中，我们面临一个问题：对于传递的参数的类型，我们几乎一无所知。在此函数中，我们知道唯一可以使用的操作是迭代器操作，而<strong>所有迭代器操作都不会生成元素，只能生成元素的引用</strong>。</p>
<p>为了获得元素类型，我们可以使用标准库的<strong>类型转换</strong>（type transformation）模板。这些模板定义在头文件 <code>type_traits</code> 中。</p>
<p>在本例中，我们可以使用 <code>remove_reference</code> 来获得元素类型。<code>remove_reference</code> 模板有一个模板类型参数和一个名为 <code>type</code> 的（<code>public</code>）类型成员。如果我们用一个引用类型实例化 <code>remove_reference</code>，则 <code>type</code> 将表示被引用的类型。例如，如果我们实例化 <code>remove_reference&lt;int&amp;&gt;</code>，则 <code>type</code> 成员将是 <code>int</code>。类似的，如果我们实例化 <code>remove_reference&lt;string&amp;&gt;</code>，则 <code>type</code> 成员将是 <code>string</code>，依此类推。更一般的，给定一个迭代器 <code>beg</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br></pre></td></tr></table></figure>
<p>将获得 <code>beg</code> 引用的元素的类型：<code>decltype(*beg)</code> 返回元素类型的引用类型。<code>remove_reference::type</code> 脱去引用，剩下元素类型本身。</p>
<p><strong>组合使用 <code>remove_reference</code>、尾置返回及 <code>decltype</code>，我们就可以在函数中返回元素值的拷贝</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了使用模板参数的成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt;</span><br><span class="line">    <span class="keyword">typename</span> remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，<code>type</code> 是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型的声明中使用 <code>typename</code> 来告知编译器，<code>type</code> 表示一个类型。</strong></p>
</li>
<li><p>下表列出了标准类型转换模板：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-uzvj{border-color:inherit;font-weight:bold;text-align:center;   vertical-align:middle}<br>.tg .tg-g7sd{border-color:inherit;font-weight:bold;text-align:left;   vertical-align:middle}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-uzvj" colspan="3"><center>标准类型转换模板</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-g7sd"><b>对 Mod&lt;T&gt;，其中 Mod 为</b></td>
    <td class="tg-g7sd"><b>若 T 为</b></td>
    <td class="tg-g7sd"><b>则 Mod&lt;T&gt;::type 为</b></td>
  </tr>
  <tr>
    <td class="tg-lboi">remove_reference</td>
    <td class="tg-lboi">X&amp; 或 X&amp;&amp;<br>否则</td>
    <td class="tg-lboi">X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">add_const</td>
    <td class="tg-lboi">X&amp;、const X 或函数<br>否则</td>
    <td class="tg-0pky">T<br>const T</td>
  </tr>
  <tr>
    <td class="tg-lboi">add_lvalue_reference</td>
    <td class="tg-lboi">X&amp;<br>X&amp;&amp;<br>否则</td>
    <td class="tg-lboi">T<br>X&amp;<br>T&amp;</td>
  </tr>
  <tr>
    <td class="tg-lboi">add_rvalue_reference</td>
    <td class="tg-lboi">X&amp; 或 X&amp;&amp;<br>否则</td>
    <td class="tg-lboi">T<br>T&amp;&amp;</td>
  </tr>
  <tr>
    <td class="tg-lboi">remove_pointer</td>
    <td class="tg-lboi">X*<br>否则</td>
    <td class="tg-lboi">X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">add_pointer</td>
    <td class="tg-lboi">X&amp; 或 X&amp;&amp;<br>否则</td>
    <td class="tg-lboi">X*<br>T*</td>
  </tr>
  <tr>
    <td class="tg-lboi">make_signed</td>
    <td class="tg-lboi">unsigned X<br>否则</td>
    <td class="tg-0pky">X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">make_unsigned</td>
    <td class="tg-lboi">带符号类型<br>否则</td>
    <td class="tg-lboi">unsigned X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">remove_extent</td>
    <td class="tg-lboi">X[n]<br>否则</td>
    <td class="tg-0pky">X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">remove_all_extents</td>
    <td class="tg-lboi">X[n1][n2]...<br>否则</td>
    <td class="tg-0pky">X<br>T</td>
  </tr>
</tbody>
</table>

<p>上表中描述的每个类型转换模板的工作方式都与 <code>remove_reference</code> 类似。每个模板都有一个名为 <code>type</code> 的 <code>public</code> 成员，表示一个类型。此类型与模板自身的模板类型参数相关，其关系如模板名所示。如果不可能（或者不必要）转换模板参数，则 <code>type</code> 成员就是模板参数类型本身。例如，如果 <code>T</code> 是一个指针类型，则 <code>remove_pointer&lt;T&gt;::type</code> 是 <code>T</code> 指向的类型。如果 <code>T</code> 不是一个指针，则无须进行任何转换，从而 <code>type</code> 具有与 <code>T</code> 相同的类型。</p>
</li>
</ol>
<h2 id="16-2-4-函数指针和实参推断" class="heading-control"><a href="#16-2-4-函数指针和实参推断" class="headerlink" title="16.2.4 函数指针和实参推断"></a>16.2.4 函数指针和实参推断<a class="heading-anchor" href="#16-2-4-函数指针和实参推断" aria-hidden="true"></a></h2><ol>
<li><p><strong>当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</strong><br>例如，假定我们有一个函数指针，它指向的函数返回 <code>int</code>，接受两个参数，每个参数都是指向 <code>const int</code> 的引用。我们可以使用该指针指向 <code>compare</code> 的一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1 指向实例 int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;) = compare;</span><br></pre></td></tr></table></figure>
<p><code>pf1</code> 中参数的类型决定了 <code>T</code> 的模板实参的类型。在本例中，<code>T</code> 的模板实参类型为 <code>int</code>。指针 <code>pf1</code> 指向 <code>compare</code> 的 <code>int</code> 版本实例。如果不能从函数指针类型确定模板实参，则产生错误：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// func 的重载版本；每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*)(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;))</span></span>;</span><br><span class="line">func(compare); <span class="comment">// 错误：使用 compare 的哪个实例?</span></span><br></pre></td></tr></table></figure>
<p>这段代码的问题在于，通过 <code>func</code> 的参数类型无法确定模板实参的唯一类型。对 <code>func</code> 的调用既可以实例化接受 <code>int</code> 的 <code>compare</code> 版本，也可以实例化接受 <code>string</code> 的版本。由于不能确定 <code>func</code> 的实参的唯一实例化版本，此调用将编译失败。</p>
<p>我们可以通过使用显式模板实参来消除 <code>func</code> 调用的歧义：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确：显式指出实例化哪个 compare 版本</span></span><br><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;); <span class="comment">// 传递 compare(const int&amp;, const int&amp;)</span></span><br></pre></td></tr></table></figure>
<p>此表达式调用的 <code>func</code> 版本接受一个函数指针，该指针指向的函数接受两个 <code>const int&amp;</code> 参数。</p>
<blockquote>
<p><strong>Note：</strong> 当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型或值。</p>
</blockquote>
</li>
</ol>
<h2 id="16-2-5-模板实参推断和引用" class="heading-control"><a href="#16-2-5-模板实参推断和引用" class="headerlink" title="16.2.5 模板实参推断和引用"></a>16.2.5 模板实参推断和引用<a class="heading-anchor" href="#16-2-5-模板实参推断和引用" aria-hidden="true"></a></h2><ol>
<li><p>当一个函数参数是模板类型参数的一个普通（左值）引用时（即，形如 <code>T&amp;</code>），绑定规则告诉我们，只能传递给它一个左值（如，一个变量或一个返回引用类型的表达式）。实参可以是 <code>const</code> 类型，也可以不是。如果实参是 <code>const</code> 的，则 <code>T</code> 将被推断为 <code>const</code> 类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T &amp;)</span></span>; <span class="comment">// 实参必须是一个左值</span></span><br><span class="line"><span class="comment">// 对 f1 的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line">f1(i);  <span class="comment">// i 是一个 int；模板参数类型 T 是 int</span></span><br><span class="line">f1(ci); <span class="comment">// ci 是一个 const int；模板参数 T 是 const int</span></span><br><span class="line">f1(<span class="number">5</span>);  <span class="comment">// 错误：传递给一个 &amp; 参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数参数的类型是 <code>const T&amp;</code>，正常的绑定规则告诉我们可以传递给它任何类型的实参——一个对象（<code>const</code> 或非 <code>const</code>）、一个临时对象或是一个字面常量值。当函数参数本身是 <code>const</code> 时，<code>T</code> 的类型推断的结果不会是一个 <code>const</code> 类型。<code>const</code> 已经是函数参数类型的一部分；因此，它不会也是模板参数类型的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>; <span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">// f2 中的参数是 const &amp;；实参中的 const 是无关的</span></span><br><span class="line"><span class="comment">// 在每个调用中，f2 的函数参数都被推断为 const int&amp;</span></span><br><span class="line">f2(i);  <span class="comment">// i 是一个 int；模板参数 T 是 int</span></span><br><span class="line">f2(ci); <span class="comment">// ci 是一个 const int，但模板参数 T 是 int</span></span><br><span class="line">f2(<span class="number">5</span>);  <span class="comment">// 一个 const &amp; 参数可以绑定到一个右值；T 是 int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个函数参数是一个右值引用（即，形如 <code>T&amp;&amp;</code>）时，正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通左值引用函数参数的推断过程。推断出的 <code>T</code> 的类型是该右值实参的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T &amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>); <span class="comment">// 实参是一个 int 类型的右值；模板参数 T 是 int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通常我们不能将一个右值引用绑定到一个左值上。但是，C++ 语言在正常绑定规则之外定义了两个例外规则，允许这种绑定。这两个例外规则是 <code>move</code> 这种标准库设施正确工作的基础。</p>
<ul>
<li><p>第一个例外规则影响右值引用参数的推断如何进行。<strong>当我们将一个左值（如 <code>i</code>）传递给函数的右值引用参数，且此右值引用指向模板类型参数（如 <code>T&amp;&amp;</code>）时，编译器推断模板类型参数为实参的左值引用类型。</strong> 因此，当我们调用 <code>f3(i)</code> 时，编译器推断 <code>T</code> 的类型为 <code>int&amp;</code>，而非 <code>int</code>。<code>T</code> 被推断为 <code>int&amp;</code> 看起来好像意味着 <code>f3</code> 的函数参数应该是一个类型 <code>int&amp;</code> 的右值引用。<strong>通常，我们不能（直接）定义一个引用的引用。但是，通过类型别名或通过模板类型参数间接定义是可以的。</strong></p>
</li>
<li><p>在这种情况下，我们可以使用第二个例外绑定规则：<strong>如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。在所有情况下（除了一个例外），引用会折叠成一个普通的左值引用类型。在新标准中，折叠规则扩展到右值引用。只在一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。</strong> 即，对于一个给定类型 <code>X</code>：</p>
<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code> 和 <code>X&amp;&amp; &amp;</code> 都折叠成类型 <code>X&amp;</code></li>
<li>类型 <code>X&amp;&amp; &amp;&amp;</code> 折叠成 <code>X&amp;&amp;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note：</strong> 引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。</p>
</blockquote>
</li>
<li><p>如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着我们可以对一个左值调用 <code>f3</code>。当我们将一个左值传递给 <code>f3</code> 的（右值引用）函数参数时，编译器推断 <code>T</code> 为一个左值引用类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f3(i);  <span class="comment">// 实参是一个左值；模板参数 T 是 int&amp;</span></span><br><span class="line">f3(ci); <span class="comment">// 实参是一个左值；模板参数 T 是一个 const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>当一个模板参数 <code>T</code> 被推断为引用类型时，折叠规则告诉我们函数参数 <code>T&amp;&amp;</code> 折叠为一个左值引用类型。例如，<code>f3(i)</code> 的实例化结果可能像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无效代码，只是用于演示目的</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span> &amp;&gt;(<span class="keyword">int</span> &amp; &amp;&amp;); <span class="comment">// 当 T 是 int&amp; 时，函数参数为 int&amp; &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p><code>f3</code> 的函数参数是 <code>T&amp;&amp;</code> 且 <code>T</code> 是 <code>int&amp;</code>，因此 <code>T&amp;&amp;</code> 是 <code>int&amp; &amp;&amp;</code>，会折叠成 <code>int&amp;</code>。因此，即使 <code>f3</code> 的函数参数形式是一个右值引用（即，<code>T&amp;&amp;</code>），此调用也会用一个左值引用类型（即，<code>int&amp;</code>）实例化 <code>f3</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span> &amp;&gt;(<span class="keyword">int</span> &amp;); <span class="comment">// 当 T 是 int&amp; 时，函数参数折叠为 int&amp;</span></span><br></pre></td></tr></table></figure>
<p>这两个规则导致了两个重要结果：</p>
<ul>
<li><strong>如果一个函数参数是一个指向模板类型参数的右值引用（如，<code>T&amp;&amp;</code>），则它可以被绑定到一个左值；且</strong></li>
<li><strong>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用参数（<code>T&amp;</code>）</strong></li>
</ul>
<p>另外值得注意的是，这两个规则暗示，我们<strong>可以将任意类型的实参传递给 <code>T&amp;&amp;</code> 类型的函数参数</strong>。对于这种类型的参数，（显然）可以传递给它右值，而如我们刚刚看到的，也可以传递给它左值。</p>
<blockquote>
<p><strong>Note：如果一个函数参数是指向模板参数类型的右值引用（如，<code>T&amp;&amp;</code>），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（<code>T&amp;</code>）。</strong></p>
</blockquote>
</li>
<li><p>模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T &amp;&amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = val;  <span class="comment">// 拷贝还是绑定一个引用？</span></span><br><span class="line">    t = fcn(t); <span class="comment">// 赋值只改变 t 还是既改变 t 又改变 val？</span></span><br><span class="line">    <span class="keyword">if</span> (val == t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line">    &#125; <span class="comment">// 若 T 是引用类型，则一直为 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们对一个右值调用 <code>f3</code> 时，例如字面常量 <code>42</code>，<code>T</code> 为 <code>int</code>。在此情况下，局部变量 <code>t</code> 的类型为 <code>int</code>，且通过拷贝参数 <code>val</code> 的值被初始化。当我们对 <code>t</code> 赋值时，参数 <code>val</code> 保持不变。</p>
<p>另一方面，当我们对一个左值 <code>i</code> 调用 <code>f3</code> 时，则 <code>T</code> 为 <code>int&amp;</code>。当我们定义并初始化局部变量 <code>t</code> 时，赋予它类型 <code>int&amp;</code>。因此，对 <code>t</code> 的初始化将其绑定到 <code>val</code>。当我们对 <code>t</code> 赋值时，也同时改变了 <code>val</code> 的值。在 <code>f3</code> 的这个实例化版本中，<code>if</code> 判断永远得到 <code>true</code>。</p>
</li>
<li><p><strong>练习 16.42：</strong> 对下面每个调用，确定 <code>T</code> 和 <code>val</code> 的类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T &amp;&amp;val)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br></pre></td></tr></table></figure>
<p>（a）g(i)；（b）g(ci)；（c）g(i * ci)；</p>
<p>答：（a）<code>int&amp;</code>；（b）<code>int&amp;</code>；（c）<code>const int&amp;&amp;</code>；</p>
</li>
</ol>
<h2 id="16-2-6-理解-std-move" class="heading-control"><a href="#16-2-6-理解-std-move" class="headerlink" title="16.2.6 理解 std::move"></a>16.2.6 理解 std::move<a class="heading-anchor" href="#16-2-6-理解-std-move" aria-hidden="true"></a></h2><ol>
<li><p>虽然不能直接将一个右值引用绑定到一个左值上，但可以用 <code>move</code> 获得一个绑定到左值上的右值引用。</p>
<p>标准库是这样定义 <code>move</code> 的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在返回类型和类型转换中也要用到 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type &amp;&amp;<span class="title">move</span><span class="params">(T &amp;&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们<strong>既可以传递给 <code>move</code> 一个左值，也可以传递给它一个右值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string s1("hi!"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"bye!"</span>)); <span class="comment">// 正确：从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1);             <span class="comment">// 正确：但在赋值之后，s1 的值是不确定的</span></span><br></pre></td></tr></table></figure>
<p>在第一个赋值中，传递给 <code>move</code> 的实参是 <code>string</code> 的构造函数的右值结果 <code>string(&quot;bye!&quot;)</code>。如我们已经见到过的，<strong>当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型</strong>。因此，在 <code>std::move(string(&quot;bye!&quot;))</code> 中：</p>
<ul>
<li>推断出的 <code>T</code> 的类型为 <code>string</code>。</li>
<li>因此，<code>remove_reference</code> 用 <code>string</code> 进行实例化。</li>
<li><code>remove_reference&lt;string&gt;</code> 的 <code>type</code> 成员是 <code>string</code>。</li>
<li><code>move</code> 的返回类型是 <code>string&amp;&amp;</code>。</li>
<li><code>move</code> 的函数参数 <code>t</code> 的类型为 <code>string&amp;&amp;</code>。</li>
</ul>
<p>因此，这个调用实例化 <code>move&lt;string&gt;</code>，即函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;&amp;<span class="title">move</span><span class="params">(<span class="built_in">string</span> &amp;&amp;t)</span></span></span><br></pre></td></tr></table></figure>
<p>函数体返回 <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。<code>t</code> 的类型已经是 <code>string&amp;&amp;</code>，于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用。</p>
<p>第二个赋值中调用了 <code>std::move()</code>。在此调用中，传递给 <code>move</code> 的实参是一个左值。这样：</p>
<ul>
<li>推断出的 <code>T</code> 的类型为 <code>string&amp;</code>（<code>string</code> 的引用，而非普通 <code>string</code>）。</li>
<li>因此，<code>remove_reference</code> 用 <code>string&amp;</code> 进行实例化。</li>
<li><code>remove_reference&lt;string&amp;&gt;</code> 的 <code>type</code> 成员是 <code>string</code>。</li>
<li><code>move</code> 的返回类型仍是 <code>string&amp;&amp;</code>。</li>
<li><code>move</code> 的函数参数 <code>t</code> 实例化为 <code>string&amp; &amp;&amp;</code>，会折叠为 <code>string&amp;</code>。</li>
</ul>
<p>因此，这个调用实例化 <code>move&lt;string&amp;&gt;</code>，即</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;&amp;<span class="title">move</span><span class="params">(<span class="built_in">string</span> &amp;t)</span></span></span><br></pre></td></tr></table></figure>
<p>这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回 <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。在此情况下，<code>t</code> 的类型为 <code>string&amp;</code>，<code>cast</code> 将其转换为 <code>string&amp;&amp;</code>。</p>
</li>
<li><p>虽然不能隐式地将一个左值转换为右值引用，但我们可以用 <code>static_cast</code> 显示地将一个左值转换为一个右值引用。</p>
</li>
</ol>
<h2 id="16-2-7-转发" class="heading-control"><a href="#16-2-7-转发" class="headerlink" title="16.2.7 转发"></a>16.2.7 转发<a class="heading-anchor" href="#16-2-7-转发" aria-hidden="true"></a></h2><ol>
<li><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是 <code>const</code> 的以及实参是左值还是右值。</p>
</li>
<li><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数（无论是左值还是右值）使得我们可以保持 <code>const</code> 属性，因为在引用类型中的 <code>const</code> 是底层的。如果我们将函数参数定义为 <code>T1&amp;&amp;</code> 和 <code>T2&amp;&amp;</code>，通过引用折叠就可以保持翻转实参的左值/右值属性：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与较早的版本一样，如果我们调用 <code>flip2(f, j, 42)</code>，将传递给参数 <code>t1</code> 一个左值 <code>j</code>。但是，在 <code>flip2</code> 中，推断出的 <code>T1</code> 的类型为 <code>int&amp;</code>，这意味着 <code>t1</code> 的类型会折叠为 <code>int&amp;</code>。由于是引用类型，<code>t1</code> 被绑定到 <code>j</code> 上。</p>
<blockquote>
<p><strong>Note：如果一个函数参数是指向模板类型参数的右值引用（如 <code>T&amp;&amp;</code>），它对应的实参的 <code>const</code> 属性和左值/右值属性将得到保持。</strong></p>
</blockquote>
<p>这个版本的 <code>flip2</code> 解决了一半问题。它对于接受一个左值引用的函数工作得很好，但不能用于接受右值引用参数的函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们试图通过 <code>flip2</code> 调用 <code>g</code>，则参数 <code>t2</code> 将被传递给 <code>g</code> 的右值引用参数。即使我们传递一个右值给 <code>flip2</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flip2(g, i, <span class="number">42</span>); <span class="comment">// 错误：不能从一个左值实例化 int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>传递给 <code>g</code> 的将是 <code>flip2</code> 中名为 <code>t2</code> 的参数。函数参数与其他任何变量一样，都是左值表达式。因此，<code>flip2</code> 中对 <code>g</code> 的调用将传递给 <code>g</code> 的右值引用参数一个左值。</p>
</li>
<li><p>我们可以使用一个名为 <code>forward</code> 的新标准库设施来传递 <code>flip2</code> 的参数，它能保持原始实参的类型。<strong>类似 <code>move</code>，<code>forward</code> 定义在头文件 <code>utility</code> 中。与 <code>move</code> 不同，<code>forward</code> 必须通过显式模板实参来调用。<code>forward</code> 返回该显式实参类型的右值引用。</strong> 即，<code>forward&lt;T&gt;</code> 的返回类型是 <code>T&amp;&amp;</code>。</p>
<p><strong>通常情况下，我们使用 <code>forward</code> 传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，<code>forward</code> 可以保持给定实参的左值/右值属性</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">intermediary(Type &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line">    finalFcn(<span class="built_in">std</span>::forward&lt;Type&gt;(arg));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中我们使用 <code>Type</code> 作为 <code>forward</code> 的显式模板实参类型，它是从 <code>arg</code> 推断出来的。由于 <code>arg</code> 是一个模板类型参数的右值引用，<code>Type</code> 将表示传递给 <code>arg</code> 的实参的所有类型信息。如果实参是一个右值，则 <code>Type</code> 是一个普通（非引用）类型，<code>forward&lt;Type&gt;</code> 将返回 <code>Type&amp;&amp;</code>。如果实参是一个左值，则通过引用折叠，<code>Type</code> 本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对 <code>forward&lt;Type&gt;</code> 的返回类型进行引用折叠，将返回一个左值引用类型。</p>
<blockquote>
<p><strong>Note：当用于一个指向模板参数类型的右值引用函数参数（<code>T&amp;&amp;</code>）时，<code>forward</code> 会保持实参类型的所有细节。</strong></p>
</blockquote>
<p>使用 <code>forward</code>，我们可以再次重写翻转函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：</strong> 与 <code>std::move</code> 相同，对 <code>std::forward</code> 不使用 <code>using</code> 声明是一个好主意。</p>
</blockquote>
</li>
</ol>
<h1 id="16-3-重载与模板" class="heading-control"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板<a class="heading-anchor" href="#16-3-重载与模板" aria-hidden="true"></a></h1><ol>
<li><p>函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。</p>
</li>
<li><p>如果涉及函数模板，则函数匹配规则会在以下几方面受到影响：</p>
<ul>
<li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</li>
<li>候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。</li>
<li>与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的。</li>
<li>与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是，如果有多个函数提供同样好的匹配，则：<ul>
<li>如果同样好的函数中只有一个是非模板函数，则选择此函数。</li>
<li>如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。</li>
<li>否则，此调用有歧义。</li>
</ul>
</li>
</ul>
</li>
<li><p>我们有下面两个函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; t;         <span class="comment">// 使用 T 的输出运算符打印 t 的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.str(); <span class="comment">// 返回 ret 绑定的 string 的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">// 注意：此函数不能用于 char*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">"pointer:"</span> &lt;&lt; p; <span class="comment">// 打印指针本身的值</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">""</span> &lt;&lt; debug_rep(*p); <span class="comment">// 打印 p 指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">"null pointer"</span>; <span class="comment">// 或指出 p 为空</span></span><br><span class="line">    <span class="keyword">return</span> ret.str();          <span class="comment">// 返回 ret 绑定的 string 的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个模板不能用于打印字符指针，因为 IO 库为 <code>char*</code> 值定义了一个 <code>&lt;&lt;</code> 版本。此 <code>&lt;&lt;</code> 版本假定指针表示一个空字符结尾的字符数组，并打印数组的内容而非地址值。</p>
<p>我们可以这样使用这些函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hi"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>对于这个调用，只有第一个版本的 <code>debug_rep</code> 是可行的。第二个 <code>debug_rep</code> 版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。由于只有一个可行函数，所以此函数被调用。</p>
<p>如果我们用一个指针调用 <code>debug_rep</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(&amp;s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>两个函数都生成可行的实例：</p>
<ul>
<li><code>debug_rep(const string *&amp;)</code>，由第一个版本的 <code>debug_rep</code> 实例化而来，<code>T</code> 被绑定到 <code>string *</code>。</li>
<li><code>debug_rep(string *)</code>，由第二个版本的 <code>debug_rep</code> 实例化而来，<code>T</code> 被绑定到 <code>string</code>。</li>
</ul>
<p>第二个版本的 <code>debug_rep</code> 的实例是此调用的精确匹配。第一个版本的实例需要进行普通指针到 <code>const</code> 指针的转换。正常函数匹配规则告诉我们应该选择第二个模板，实际上编译器确实选择了这个版本。</p>
<p>作为另外一个例子，考虑下面的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *sp = &amp;s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(sp) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>此例中的两个模板都是可行的，而且两个都是精确匹配：</p>
<ul>
<li><code>debug_rep(const string *&amp;)</code>，由第一个版本的 <code>debug_rep</code> 实例化而来，<code>T</code> 被绑定到 <code>string *</code>。</li>
<li><code>debug_rep(const string *)</code>，由第二个版本的 <code>debug_rep</code> 实例化而来，<code>T</code> 被绑定到 <code>const string</code>。</li>
</ul>
<p>在此情况下，正常函数匹配规则无法区分这两个函数。我们可能觉得这个调用将是有歧义的。但是，根据重载函数模板的特殊规则，此调用被解析为 <code>debug_rep(T *)</code>，即，更特例化的版本。</p>
<p>设计这条规则的原因是，没有它，将无法对一个 <code>const</code> 的指针调用指针版本的 <code>debug_rep</code>。问题在于模板 <code>debug_rep(const T &amp;)</code> 本质上可以用于任何类型，包括指针类型。此模板比 <code>debug_rep(T *)</code> 更通用，后者只能用于指针类型。没有这条规则，传递 <code>const</code> 的指针的调用永远是有歧义的。</p>
</li>
<li><blockquote>
<p><strong>Note：当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。</strong>（我们都更倾向于确定性——博主注）</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>Note：对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</strong></p>
</blockquote>
</li>
<li><p>考虑这个调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(<span class="string">"hi world!"</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 debug_rep(T *)</span></span><br></pre></td></tr></table></figure>
<p>所有三个 <code>debug_rep</code> 版本都是可行的：</p>
<ul>
<li><code>debug_rep(const T &amp;)</code>，<code>T</code> 被绑定到 <code>char[10]</code>。</li>
<li><code>debug_rep(T *)</code>，<code>T</code> 被绑定到 <code>const char</code>。</li>
<li><code>debug_rep(const string &amp;)</code>，要求从 <code>const char *</code> 到 <code>string</code> 的类型。</li>
</ul>
<p>对给定实参来说，两个模板都提供精确匹配——第二个模板需要进行一次（许可的）数组到指针的转换，而对于函数匹配来说，这种转换被认为是精确匹配。非模板版本是可行的，但需要进行一次用户定义的类型转换，因此它没有精确匹配那么好，所以两个模板成为可能调用的函数。与之前一样，<code>T*</code> 版本更加特例化，编译器会选择它。</p>
</li>
<li><p>通常，如果使用了一个忘记声明的函数，代码将编译失败。但对于重载函数模板的函数而言，则不是这样。如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不重要了。</p>
<blockquote>
<p><strong>Tip：</strong> 在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</p>
</blockquote>
</li>
<li><p><strong>练习 16.49：</strong> 解释下面每个调用会发生什么：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T *)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T *)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, *p2 = &amp;ci;</span><br><span class="line">g(<span class="number">42</span>); g(p); g(ci); g(p2);</span><br><span class="line">f(<span class="number">42</span>); f(p); f(ci); f(p2);</span><br></pre></td></tr></table></figure>
<p>答：<code>g(42)</code>：匹配 <code>g(T)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>g(p)</code>：匹配 <code>g(T *)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>g(ci)</code>：匹配 <code>g(T)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>g(p2)</code>：匹配 <code>g(T *)</code>，<code>T</code> 被推断为 <code>const int</code>；<br><code>f(42)</code>：匹配 <code>f(T)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>f(p)</code>：匹配 <code>f(T)</code>，<code>T</code> 被推断为 <code>int *</code>；<br><code>f(ci)</code>：匹配 <code>f(T)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>f(p2)</code>：匹配 <code>f(const T *)</code>，<code>T</code> 被推断为 <code>int</code>。</p>
<p>验证代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    Called function: f(T)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T: "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T is const: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;T&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    Called function: f(const T*)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T: "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T is const: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;T&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    Called function: g(T)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T: "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T is const: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;T&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    Called function: g(T *)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T: "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T is const: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;T&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, *p2 = &amp;ci;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g(42)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">g(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g(p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">g(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g(ci)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">g(ci);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g(p2)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">g(p2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(42)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">f(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">f(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(ci)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">f(ci);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(p2)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">f(p2);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="16-4-可变参数模板" class="heading-control"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板<a class="heading-anchor" href="#16-4-可变参数模板" aria-hidden="true"></a></h1><ol>
<li><p>一个<strong>可变参数模板</strong>（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>（parameter packet）。存在两种参数包：<strong>模板参数包</strong>（template parameter packet），表示零个或多个模板参数；<strong>函数参数包</strong>（function parameter packet），表示零个或多个函数参数。</p>
</li>
<li><p>我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，<code>class...</code> 或 <code>typename...</code> 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Args 是一个模板参数包；rest 是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args 表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest 表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args &amp;...rest)</span></span>;</span><br></pre></td></tr></table></figure>
<p>声明了 <code>foo</code> 是一个可变参数函数模板，它有一个名为 <code>T</code> 的类型参数，和一个名为 <code>Args</code> 的模板参数包。这个包表示零个或多个额外的类型参数。<code>foo</code> 的函数参数列表包含一个 <code>const &amp;</code> 类型的参数，指向 <code>T</code> 的类型，还包含一个名为 <code>rest</code> 的函数参数包，此包表示零个或多个函数参数。</p>
<p>与往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译器还会推断包中参数的数目。例如，给定下面的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"how now brown cow"</span>;</span><br><span class="line">foo(i, s, <span class="number">42</span>, d); <span class="comment">// 包中有三个参数</span></span><br><span class="line">foo(s, <span class="number">42</span>, <span class="string">"hi"</span>); <span class="comment">// 包中有两个参数</span></span><br><span class="line">foo(d, s);        <span class="comment">// 包中有一个参数</span></span><br><span class="line">foo(<span class="string">"hi"</span>);        <span class="comment">// 空包</span></span><br></pre></td></tr></table></figure>
<p>编译器会为 <code>foo</code> 实例化出四个不同的版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">double</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>] &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>] &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在每个实例中，<code>T</code> 的类型都是从第一个实参的类型推断出来的。剩下的实参（如果有的话）提供函数额外实参的数目和类型。</p>
</li>
<li><p>当我们需要知道包中有多少元素时，可以使用 <code>sizeof...</code> 运算符，<code>sizeof...</code> 也返回一个常量表达式，而且不会对其实参求值：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 类型参数的数目</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="16-4-1-编写可变参数函数模板" class="heading-control"><a href="#16-4-1-编写可变参数函数模板" class="headerlink" title="16.4.1 编写可变参数函数模板"></a>16.4.1 编写可变参数函数模板<a class="heading-anchor" href="#16-4-1-编写可变参数函数模板" aria-hidden="true"></a></h2><ol>
<li><p>可以使用一个 <code>initializer_list</code> 来定义一个可接受可变数目实参的函数。但是，所有实参必须具有相同的类型（或它们的类型可以转换为同一个公共类型）。</p>
</li>
<li><p><strong>可变参数函数通常是递归的。</strong> 第一步调用处理包中的第一个实参，然后用剩余实参调用自身。我们的 <code>print</code> 函数也是这样的模式，每次递归调用将第二个实参打印到第一个实参表示的流中。为了终止递归，我们还需要定义一个非可变参数的 <code>print</code> 函数，它接受一个流和一个对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">// 此函数必须在可变参数版本的 print 定义之前声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t; <span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的 print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args &amp;...rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">","</span>;            <span class="comment">// 打印第一个实参</span></span><br><span class="line">    <span class="keyword">return</span> print(os, rest...); <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个版本的 <code>print</code> 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 <code>print</code> 是可变参数版本，它打印绑定到 <code>t</code> 的实参，并调用自身来打印函数参数包中的剩余值。</p>
<p>这段程序的关键部分是可变参数函数中对 <code>print</code> 的调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> print(os, rest...); <span class="comment">// 递归调用，打印其他实参</span></span><br></pre></td></tr></table></figure>
<p><strong>我们的可变参数版本的 <code>print</code> 函数接受三个参数：一个 <code>ostream &amp;</code>，一个 <code>const T &amp;</code> 和一个参数包。而此调用只传递了两个实参。其结果是 <code>rest</code> 中的第一个实参被绑定到 <code>t</code>，剩余实参形成下一个 <code>print</code> 调用的参数包。因此，在每个调用中，包中的第一个实参被移除，成为绑定到 <code>t</code> 的实参。</strong> 即，给定：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">cout</span>, i, s, <span class="number">42</span>); <span class="comment">// 包中有两个参数</span></span><br></pre></td></tr></table></figure>
<p>递归会执行如下：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;   font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;   font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;   vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-fymr">调用</th>
    <th class="tg-fymr">t</th>
    <th class="tg-fymr">rest...</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">print(cout, i, s, 42)</td>
    <td class="tg-0pky">i</td>
    <td class="tg-0pky">s, 42</td>
  </tr>
  <tr>
    <td class="tg-0pky">print(cout, s, 42)</td>
    <td class="tg-0pky">s</td>
    <td class="tg-0pky">42</td>
  </tr>
  <tr>
    <td class="tg-0pky" colspan="3">print(cout, 42) 调用非可变参数版本的 print</td>
  </tr>
</tbody>
</table>

<p>前两个调用只能与可变参数版本的 <code>print</code> 匹配，非可变参数版本是不可行的，因为这两个调用分别传递四个和三个实参，而非可变参数 <code>print</code> 只接受两个实参。</p>
<p>对于最后一次递归调用 <code>print(cout, 42)</code>，两个 <code>print</code> 版本都是可行的。这个调用传递两个实参，第一个实参的类型为 <code>ostream &amp;</code>。因此，可变参数版本的 <code>print</code> 可以实例化为只接受两个参数：一个是 <code>ostream &amp;</code> 参数，另一个是 <code>const T &amp;</code> 参数。</p>
<p>对于最后一个调用，两个函数提供同样好的匹配。但是，<strong>非可变参数模板比可变参数模板更特例化</strong>，因此编译器选择非可变参数版本。</p>
<blockquote>
<p><strong>WARNING：</strong> 当定义可变参数版本的 <code>print</code> 时，非可变参数版本的声明必须在作用域中。否则，可变参数版本会无限递归。</p>
</blockquote>
</li>
</ol>
<h2 id="16-4-2-包扩展" class="heading-control"><a href="#16-4-2-包扩展" class="headerlink" title="16.4.2 包扩展"></a>16.4.2 包扩展<a class="heading-anchor" href="#16-4-2-包扩展" aria-hidden="true"></a></h2><ol>
<li><p>对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是<strong>扩展</strong>（expand）它。当扩展一个包时，我们还要提供用于每个扩展元素的<strong>模式</strong>（pattern）。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边放一个省略号（<code>...</code>）来触发扩展操作。</p>
<p>例如，我们的 <code>print</code> 函数包含两个扩展：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args &amp;...rest)</span> <span class="comment">// 扩展 Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">return</span> print(os, rest...); <span class="comment">// 扩展 rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个扩展操作扩展模板参数包，为 <code>print</code> 生成函数参数列表。第二个扩展操作出现在对 <code>print</code> 的调用中。此模式为 <code>print</code> 调用生成实参列表。</p>
<p>对 <code>Args</code> 的扩展中，编译器将模式 <code>const Arg &amp;</code> 应用到模板参数包 <code>Args</code> 中的每个元素。因此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如 <code>const type &amp;</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">cout</span>, i, s, <span class="number">42</span>); <span class="comment">// 包中有两个参数</span></span><br></pre></td></tr></table></figure>
<p>最后两个实参的类型和模式一起确定了尾置参数的类型。此调用被实例化为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第二个扩展发生在对 <code>print</code> 的（递归）调用中。在此情况下，模式是函数参数包的名字（即 <code>rest</code>）。此模式扩展出一个由包中元素组成的、逗号分隔的列表。因此，这个调用等价于：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(os, s, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>print</code> 中的函数参数包扩展仅仅将包扩展为其构成元素，C++ 语言还允许更复杂的扩展模式。例如，我们可以编写第二个可变参数函数，对其每个实参调用 <code>debug_rep</code>，然后调用 <code>print</code> 打印结果 <code>string</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 print 调用中对每个实参调用 debug_rep</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args &amp;...rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line">    <span class="keyword">return</span> print(os, debug_rep(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>print</code> 调用使用了模式 <code>debug_rep(rest)</code>。此模式表示我们希望对函数参数包 <code>rest</code> 中的每个元素调用 <code>debug_rep</code>。扩展结果将是一个逗号分隔的 <code>debug_rep</code> 调用列表。即，下面调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">errorMsg(<span class="built_in">cerr</span>, fcnName, code.num(), otherData, <span class="string">"other"</span>, item);</span><br></pre></td></tr></table></figure>
<p>就好像我们这样编写代码一样</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">cerr</span>, debug_rep(fcnName), debug_rep(code.num()), debug_rep(otherData),</span><br><span class="line">      debug_rep(<span class="string">"otherData"</span>), debug_rep(item));</span><br></pre></td></tr></table></figure>
<p>与之相对，下面的模式会编译失败</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将包传递给 debug_rep； print(os, debug_rep(al, a2, ..., an))</span></span><br><span class="line">print(os, debug_rep(rest...)); <span class="comment">// 错误：此调用无匹配函数</span></span><br></pre></td></tr></table></figure>
<p>这段代码的问题是我们在 <code>debug_rep</code> 调用中扩展了 <code>rest</code>，它等价于</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">cerr</span>, debug_rep(fcnName, code.num(), otherData, <span class="string">"otherData"</span>, item));</span><br></pre></td></tr></table></figure>
<p>在这个扩展中，我们试图用一个五个实参的列表来调用 <code>debug_rep</code>，但并不存在与此调用匹配的 <code>debug_rep</code> 版本。<code>debug_rep</code> 函数不是可变参数的，而且没有哪个 <code>debug_rep</code> 版本接受五个参数。</p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 扩展中的模式会独立地应用于包中的每个元素。</p>
</blockquote>
</li>
</ol>
<h2 id="16-4-3-转发参数包" class="heading-control"><a href="#16-4-3-转发参数包" class="headerlink" title="16.4.3 转发参数包"></a>16.4.3 转发参数包<a class="heading-anchor" href="#16-4-3-转发参数包" aria-hidden="true"></a></h2><ol>
<li><p>在新标准下，我们可以组合使用可变参数模板与 <code>forward</code> 机制来编写函数，实现将其实参不变地传递给其他函数。</p>
</li>
<li><p><strong>标准库容器的 <code>emplace_back</code> 成员是一个可变参数成员模板，它用其实参在容器管理的内存空间中直接构造一个元素。</strong></p>
</li>
<li><p><strong>保持类型信息是一个两阶段的过程。首先，为了保持实参中的类型信息，必须将 <code>emplace_back</code> 的函数参数定义为模板类型参数的右值引用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">emplace_back</span>(<span class="title">Args</span> &amp;&amp;...);</span></span><br><span class="line">    <span class="comment">// 其他成员的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板参数包扩展中的模式是 <code>&amp;&amp;</code>，意味着每个函数参数将是一个指向其对应实参的右值引用。</p>
<p><strong>其次，当 <code>emplace_back</code> 将这些实参传递给 <code>construct</code> 时，我们必须使用 <code>forward</code> 来保持实参的原始类型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">StrVec</span>:</span>:emplace_back(Args &amp;&amp;...args)</span><br><span class="line">&#123;</span><br><span class="line">    chk_n_alloc(); <span class="comment">// 如果需要的话重新分配 StrVec 内存空间</span></span><br><span class="line">    alloc.construct(first_free++, <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>emplace_back</code> 的函数体调用了 <code>chk_n_alloc</code> 来确保有足够的空间容纳一个新元素，然后调用了 <code>construct</code> 在 <code>first_free</code> 指向的位置中创建了一个元素。<code>construct</code> 调用中的扩展为</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward&lt;Args&gt;(args)...</span><br></pre></td></tr></table></figure>
<p>它既扩展了模板参数包 <code>Args</code>，也扩展了函数参数包 <code>args</code>。此模式生成如下形式的元素</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward&lt;Ti&gt;(ti)</span><br></pre></td></tr></table></figure>
<p>其中 <code>Ti</code> 表示模板参数包中第 <code>i</code> 个元素的类型，<code>ti</code> 表示函数参数包中第 <code>i</code> 个元素。例如，假定 <code>svec</code> 是一个 <code>StrVec</code>，如果我们调用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svec.emplace_back(<span class="number">10</span>, <span class="string">'c'</span>); <span class="comment">// 将 cccccccccc 添加为新的尾元素</span></span><br></pre></td></tr></table></figure>
<p><code>construct</code> 调用中的模式会扩展出</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>), <span class="built_in">std</span>::forward&lt;<span class="keyword">char</span>&gt;(c)</span><br></pre></td></tr></table></figure>
<p>通过在此调用中使用 <code>forward</code>，我们保证如果用一个右值调用 <code>emplace_back</code>，则 <code>construct</code> 也会得到一个右值。例如，在下面的调用中：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">svec.emplace_back(s1 + s2); <span class="comment">// 使用移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>传递给 <code>emplace_back</code> 的实参是一个右值，它将以如下形式传递给 <code>construct</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward&lt;<span class="built_in">string</span>&gt;(<span class="built_in">string</span>(<span class="string">"the end"</span>))</span><br></pre></td></tr></table></figure>
<p><code>forward&lt;string&gt;</code> 的结果类型是 <code>string &amp;&amp;</code>，因此 <code>construct</code> 将得到一个右值引用实参。<code>construct</code> 会继续将此实参传递给 <code>string</code> 的移动构造函数来创建新元素。</p>
</li>
<li><p>可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的 <code>emplace_back</code> 函数一样的形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fun 有零个或多个参数，每个参数都是一个模板参数类型的右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Args &amp;&amp;...args)</span> <span class="comment">// 将 Args 扩展为一个右值引用的列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// work 的实参既扩展 Args 又扩展 args</span></span><br><span class="line">    work(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们希望将 <code>fun</code> 的所有实参转发给另一个名为 <code>work</code> 的函数，假定由它完成函数的实际工作。类似 <code>emplace_back</code> 中对 <code>construct</code> 的调用，<code>work</code> 调用中的扩展既扩展了模板参数包也扩展了函数参数包。</p>
<p>由于 <code>fun</code> 的参数是右值引用，因此我们可以传递给它任意类型的实参；由于我们使用 <code>std::forward</code> 传递这些实参，因此它们的所有类型信息在调用 <code>work</code> 时都会得到保持。</p>
</li>
<li><p><strong>右值引用引用的是右值，但右值引用本身是左值。能被赋值的一定是左值，但左值不一定能被赋值，例如右值引用。</strong>——博主注</p>
</li>
<li><p><strong>使用变参模板的关键——完美转发：右值引用 + <code>forward</code>。</strong>——博主注</p>
</li>
</ol>
<h1 id="16-5-模板特例化" class="heading-control"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化<a class="heading-anchor" href="#16-5-模板特例化" aria-hidden="true"></a></h1><ol>
<li><p>在某些情况下，通用模板的定义对特定类型是不适合的：通用定义可能编译失败或做得不正确。当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。</p>
</li>
<li><p>我们希望 <code>compare</code> 通过调用 <code>strcmp</code> 比较两个字符指针而非比较指针值。实际上，我们已经重载了 <code>compare</code> 函数来处理字符串字面常量：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一个版本；可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 第二个版本处理字符串字面常量</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是，只有当我们传递给 <code>compare</code> 一个字符串字面常量或者一个数组时，编译器才会调用接受两个非类型模板参数的版本。如果我们传递给它字符指针，就会调用第一个版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">"hi"</span>, *p2 = <span class="string">"mom"</span>;</span><br><span class="line">compare(p1, p2);      <span class="comment">// 调用第一个模板</span></span><br><span class="line">compare(<span class="string">"hi"</span>, <span class="string">"mom"</span>); <span class="comment">// 调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>
<p>我们<strong>无法将一个指针转换为一个数组的引用</strong>，因此当参数是 p1 和 p2 时，第二个版本的 <code>compare</code> 是不可行的。</p>
<p>为了处理字符指针（而不是数组），可以为第一个版本的 <code>compare</code> 定义一个<strong>模板特例化</strong>（template specialization）版本。一个特例化版本就是模板的一个独立的定义，在其中个或多个模板参数被指定为特定的类型。</p>
</li>
<li><p><strong>当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。</strong> 为了指出我们正在实例化一个模板，应使用关键字 <code>template</code> 后跟一个空尖括号对（<code>&lt;&gt;</code>）。空尖括号指出我们将为原模板的所有模板参数提供实参：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare 的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。本例中我们特例化：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中函数参数为一个 <code>const</code> 类型的引用。我们希望定义此函数的一个特例化版本，其中 <code>T</code> 为 <code>const char*</code>。我们的函数要求一个指向此类型 <code>const</code> 版本的引用。一个指针类型的 <code>const</code> 版本是一个常量指针而不是指向 <code>const</code> 类型的指针。我们需要在特例化版本中使用的类型是 <code>const char* const&amp;</code>，即一个指向 <code>const char</code> 的 <code>const</code> 指针的引用。</p>
<blockquote>
<p>函数模板只允许全特化，不允许偏特化。——博主注</p>
</blockquote>
</li>
<li><p>当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而非函数名的一个重载版本。</p>
<blockquote>
<p><strong>Note：</strong> 特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。</p>
</blockquote>
</li>
<li><p>我们将一个特殊的函数定义为一个特例化版本还是一个独立的非模板函数，会影响到函数匹配。例如，我们已经定义了两个版本的 <code>compare</code> 函数模板，一个接受数组引用参数，另一个接受 <code>const T&amp;</code>。我们还定义了一个特例化版本来处理字符指针，这对函数匹配没有影响。当我们对字符串字面常量调用 <code>compare</code> 时</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compare(<span class="string">"hi"</span>, <span class="string">"mom"</span>)</span><br></pre></td></tr></table></figure>
<p>对此调用，两个函数模板都是可行的，且提供同样好的（即精确的）匹配。但是，接受字符数组参数的版本更特例化，因此编译器会选择它。</p>
<p>如果我们将接受字符指针的 <code>compare</code> 版本定义为一个普通的非模板函数（而不是模板的一个特例化版本），此调用的解析就会不同。在此情况下，将会有三个可行的函数：两个模板和非模板的字符指针版本。所有三个函数都提供同样好的匹配。如前所述，当一个非模板函数提供与函数模板同样好的匹配时，编译器会选择非模板版本。</p>
<blockquote>
<p>当提供同样好的匹配时，非模板函数优先于模板函数，特例化模板函数优先于非特例化模板函数。——博主注</p>
</blockquote>
</li>
<li><p>为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中。</p>
<p>对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。</p>
<p>如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是，这种错误编译器又无法发现。</p>
<blockquote>
<p><strong>Best Practices：模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</strong></p>
</blockquote>
</li>
<li><p>除了特例化函数模板，我们还可以特例化类模板。默认情况下，无序容器使用 <code>hash&lt;key_type&gt;</code> 来组织其元素。为了让我们自己的数据类型也能使用这种默认组织方式，必须定义 <code>hash</code> 模板的一个特例化版本。一个特例化 <code>hash</code> 类必须定义：</p>
<ul>
<li>一个重载的调用运算符，它接受一个容器关键字类型的对象，返回一个 <code>size_t</code>。</li>
<li>两个类型成员，<code>result_type</code> 和 <code>argument_type</code>，分别是调用运算符的返回类型和参数类型。</li>
<li>默认构造函数和拷贝赋值运算符（可以隐式定义）。</li>
</ul>
<p>在定义此特例化版本的 <code>hash</code> 时，唯一复杂的地方是：必须在原模板定义所在的命名空间中特例化它。我们可以向命名空间添加成员。</p>
<p>下面的代码定义了一个能处理 <code>Sales_data</code> 的特例化 <code>hash</code> 版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打开 std 命名空间，以便特例化 std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 我们正在定义一个特例化版本，模板参数为 Sales_data</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;Sales_data&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">    <span class="keyword">typedef</span> Sales_data argument_type; <span class="comment">// 默认情况下，此类型需要 ==</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 我们的类使用合成的拷贝控制成员和默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> hash&lt;Sales_data&gt;::<span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data &amp;s) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(s.bookNo) ^ hash&lt;<span class="keyword">unsigned</span>&gt;()(s.units_sold) ^</span><br><span class="line">           hash&lt;<span class="keyword">double</span>&gt;()(s.revenue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure>
<p>我们的 <code>hash&lt;Sales_data&gt;</code> 定义以 <code>template &lt;&gt;</code> 开始，指出我们正在定义一个全特例化的模板。重载的调用运算符必须为给定类型的值定义一个哈希函数。对于一个给定值，任何时候调用此函数都应该返回相同的结果。一个好的哈希函数对不相等的对象（几乎总是）应该产生不同的结果。标准库为内置类型和很多标准库类型定义了 <code>hash</code> 类的特例化版本。</p>
<p>默认情况下，为了处理特定关键字类型，无序容器会组合使用 <code>key_type</code> 对应的特例化 <code>hash</code> 版本和 <code>key_type</code> 上的相等运算符。假定我们的特例化版本在作用域中，当将 <code>Sales_data</code> 作为容器的关键字类型时，编译器就会自动使用此特例化版本：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 hash&lt;Sales_data&gt; 和 Sales_data 的 operator==</span></span><br><span class="line"><span class="built_in">unordered_multiset</span>&lt;Sales_data&gt; SDset;</span><br></pre></td></tr></table></figure>
<p>由于 <code>hash&lt;Sales_data&gt;</code> 使用 <code>Sales_data</code> 的私有成员，我们必须将它声明为 <code>Sales_data</code> 的友元：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">std</span>:</span>:hash; <span class="comment">// 友元声明所需要的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:hash&lt;Sales_data&gt;;</span><br><span class="line">    <span class="comment">// 其他成员定义，如前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码指出特殊实例 <code>hash&lt;Sales_data&gt;</code> 是 <code>Sales_data</code> 的友元。由于此实例定义在 <code>std</code> 命名空间中，我们必须记得在 <code>friend</code> 声明中应使用 <code>std::hash</code>。</p>
<blockquote>
<p><strong>Note：</strong> 为了让 <code>Sales_data</code> 的用户能使用 <code>hash</code> 的特例化版本，我们应该在 <code>Sales_data</code> 的头文件中定义该特例化版本。</p>
</blockquote>
</li>
<li><p>与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的<strong>部分特例化</strong>（partial specialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p>
<blockquote>
<p><strong>Note：我们只能部分特例化类模板，而不能部分特例化函数模板。</strong></p>
</blockquote>
</li>
<li><p>标准库 <code>remove_reference</code> 类型是通过一系列的特例化版本来完成其功能的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始的、最通用的版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">remove_reference</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 部分特例化版本，将用于左值引用和右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">remove_reference</span>&lt;T &amp;&gt; // 左值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">remove_reference</span>&lt;T &amp;&amp;&gt; // 右值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个模板定义了最通用的模板。它可以用任意类型实例化；它将模板实参作为 <code>type</code> 成员的类型。接下来的两个类是原始模板的部分特例化版本。</p>
<p>由于一个部分特例化版本本质是一个模板，与往常一样，我们首先定义模板参数。类似任何其他特例化版本，部分特例化版本的名字与原模板的名字相同。对每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，我们为要特例化的模板参数指定实参，这些实参列于模板名之后的尖括号中。这些实参与原始模板中的参数按位置对应。</p>
<p>部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例化版本。在本例中，特例化版本的模板参数的数目与原始模板相同，但是类型不同。两个特例化版本分别用于左值引用和右值引用类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// decltype(42) 为 int，使用原始模板</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;</span><br><span class="line"><span class="comment">// decltype(i) 为 int&amp;，使用第一个（T&amp;）部分特例化版本</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(i)&gt;::type b;</span><br><span class="line"><span class="comment">// decitype(std::move(i)) 为int&amp;&amp;，使用第二个（即 T&amp;&amp;）部分特例化版本</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="built_in">std</span>::move(i))&gt;::type c;</span><br></pre></td></tr></table></figure>
<p>三个变量 a、b 和 c 均为 <code>int</code> 类型。</p>
</li>
<li><p>我们可以只特例化特定成员函数而不是特例化整个模板。例如，如果 <code>Foo</code> 是一个模板类，包含一个成员 <code>Bar</code>，我们可以只特例化该成员：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">const</span> T &amp;t = T()) : mem(t) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    T mem;</span><br><span class="line">    <span class="comment">// Foo 的其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;          <span class="comment">// 我们正在特例化一个模板</span></span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar() <span class="comment">// 我们正在特例化 Foo&lt;int&gt; 的成员 Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 进行应用于 int 的特例化处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中我们只特例化 <code>Foo&lt;int&gt;</code> 类的一个成员，其他成员将由 <code>Foo</code> 模板提供：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs; <span class="comment">// 实例化 Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.Bar();       <span class="comment">// 实例化 Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;    <span class="comment">// 实例化 Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.Bar();       <span class="comment">// 使用我们特例化版本的 Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure>
<p>当我们用 <code>int</code> 之外的任何类型使用 <code>Foo</code> 时，其成员像往常一样进行实例化。当我们用 <code>int</code> 使用 <code>Foo</code> 时，<code>Bar</code> 之外的成员像往常一样进行实例化。如果我们使用 <code>Foo&lt;int&gt;</code> 的成员 <code>Bar</code>，则会使用我们定义的特例化版本。</p>
</li>
</ol>
<h1 id="小结" class="heading-control"><a href="#小结" class="headerlink" title="小结"></a>小结<a class="heading-anchor" href="#小结" aria-hidden="true"></a></h1><ol>
<li><p>一个模板就是一个编译器用米生成特定类类型或函数的蓝图。生成特定类或函数的过程称为实例化。标准库算法都是函数模板，标准库容器都是类模板。</p>
</li>
<li><p>显式模板实参允许我们固定一个或多个模板参数的类型或值。对于指定了显式模板实参的模板参数，可以应用正常的类型转换。</p>
</li>
</ol>
<h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%AC%AC%2016%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%881%EF%BC%89.png" alt="第 16 章术语表（1）"></p>
<p><img data-src="https://image.shipengx.com/%E7%AC%AC%2016%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%882%EF%BC%89.png" alt="第 16 章术语表（2）"></p>
<hr>

    </div>

    
    
    
      
  <div class="popular-posts-header">猜你喜欢</div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\f82eac24.html" rel="bookmark">C++ Primer - 第 10 章 泛型算法</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\19565df.html" rel="bookmark">C++ Primer - 第 11 章 关联容器</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\4094be86.html" rel="bookmark">C++ Primer - 第 12 章 动态内存</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\5ac252d6.html" rel="bookmark">C++ Primer - 第 14 章 操作重载与类型转换</a></div>
    </li>
    <li class="popular-posts-item">
      <div class="popular-posts-title"><a href="\archives\3fc34abb.html" rel="bookmark">C++ Primer - 第 1 章 开始</a></div>
    </li>
  </ul>

        <div class="reward-container">
  <div>Thank you for your donate!</div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="ShiPeng 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.jpg" alt="ShiPeng 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>ShiPeng
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://blog.shipengx.com/archives/8c16df73.html" title="C++ Primer - 第 16 章 模板与泛型编程">https://blog.shipengx.com/archives/8c16df73.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/C-C/" rel="tag"><i class="fa fa-tag"></i> C/C++</a>
              <a href="/tags/C-Primer/" rel="tag"><i class="fa fa-tag"></i> C++ Primer</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/archives/ed6ff3ad.html" rel="prev" title="使用 clang-format 进行 C++ 代码风格管理">
      <i class="fa fa-chevron-left"></i> 使用 clang-format 进行 C++ 代码风格管理
    </a></div>
      <div class="post-nav-item">
    <a href="/archives/5029459.html" rel="next" title="C++ Primer - 第 18 章 用于大型程序的工具">
      C++ Primer - 第 18 章 用于大型程序的工具 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#16-1-定义模板"><span class="nav-text">16.1 定义模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-1-函数模板"><span class="nav-text">16.1.1 函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-2-类模板"><span class="nav-text">16.1.2 类模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-3-模板参数"><span class="nav-text">16.1.3 模板参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-4-成员模板"><span class="nav-text">16.1.4 成员模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-5-控制实例化"><span class="nav-text">16.1.5 控制实例化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-1-6-效率与灵活性"><span class="nav-text">16.1.6 效率与灵活性</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-2-模板实参推断"><span class="nav-text">16.2 模板实参推断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-1-类型转换与模板类型参数"><span class="nav-text">16.2.1 类型转换与模板类型参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-2-函数模板显式实参"><span class="nav-text">16.2.2 函数模板显式实参</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-3-尾置返回类型与类型转换"><span class="nav-text">16.2.3 尾置返回类型与类型转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-4-函数指针和实参推断"><span class="nav-text">16.2.4 函数指针和实参推断</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-5-模板实参推断和引用"><span class="nav-text">16.2.5 模板实参推断和引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-6-理解-std-move"><span class="nav-text">16.2.6 理解 std::move</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-2-7-转发"><span class="nav-text">16.2.7 转发</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-3-重载与模板"><span class="nav-text">16.3 重载与模板</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-4-可变参数模板"><span class="nav-text">16.4 可变参数模板</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#16-4-1-编写可变参数函数模板"><span class="nav-text">16.4.1 编写可变参数函数模板</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-4-2-包扩展"><span class="nav-text">16.4.2 包扩展</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-4-3-转发参数包"><span class="nav-text">16.4.3 转发参数包</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#16-5-模板特例化"><span class="nav-text">16.5 模板特例化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#小结"><span class="nav-text">小结</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#术语表"><span class="nav-text">术语表</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <a href="/">
      <img class="site-author-image" itemprop="image" alt="ShiPeng"
        src="/images/avatar.jpg">
    </a>
  <p class="site-author-name" itemprop="name">ShiPeng</p>
  <div class="site-description" itemprop="description">Stay hungry, stay foolish.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">86</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JvY1NoaQ==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;RocShi"><i class="fa fa-fw fa-github"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9zaGktcGVuZy04" title="Zhihu → https:&#x2F;&#x2F;www.zhihu.com&#x2F;people&#x2F;shi-peng-8"><i class="fa fa-fw fa-columns"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9ib29rLnNoaXBlbmd4LmNvbQ==" title="GitBook → https:&#x2F;&#x2F;book.shipengx.com"><i class="fa fa-fw fa-pencil"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOlJvY1NoaUBvdXRsb29rLmNvbQ==" title="E-Mail → mailto:RocShi@outlook.com"><i class="fa fa-fw fa-envelope"></i></span>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        
  <div class="beian"><span class="exturl" data-url="aHR0cDovL3d3dy5iZWlhbi5taWl0Lmdvdi5jbg==">冀ICP备20003148号 </span>
  </div>

<div class="copyright">
  
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ShiPeng</span>
</div>

        








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.1' zIndex='-1' count='99' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el: '#valine-comments',
      verify: false,
      notify: false,
      appId: 'qTmJq982bELvDc6itJCViXS7-gzGzoHsz',
      appKey: '5d8qvijq5fYokwrhKWKYu5F0',
      placeholder: "请写下您的评论，如果您想及时收到回复并被告知，请在上方填写您的昵称与个人邮箱。",
      avatar: 'monsterid',
      meta: guest,
      pageSize: '10' || 10,
      visitor: false,
      lang: 'zh-cn' || 'zh-cn',
      path: location.pathname,
      recordIP: true,
      serverURLs: ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
