<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Apollo 6.0 Perception 模块 Fusion 组件（一）：构建与启动流程分析</title>
    <url>/archives/e8e6ccc3.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%9B%AE%E5%BD%95-Apollo%206.0%20Perception%20%E6%A8%A1%E5%9D%97%20Fusion%20%E7%BB%84%E4%BB%B6%E6%9E%84%E5%BB%BA%E4%B8%8E%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="目录-Apollo 6.0 Perception 模块 Fusion 组件构建与启动流程分析"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>关于 Apollo Perception 模块 Fusion 组件的分析文章已经有很多了，但大多集中在从 Fusion 组件的 <code>Init</code> 方法和 <code>Proc</code> 方法开始解析组件内部的算法流程，对于 <code>Init</code> 和 <code>Proc</code> 是在何时被谁调用的却鲜有提及，至多顺便提下通过 DAG（Directed Acyclic Graph，有向无环图）文件或 Launch 文件启动模块，对于模块的具体启动流程以及模块与组件间的关系仍然模棱两可，这显然不利于对 Apollo 框架的整体把握。知其然，更要知其所以然。</p>
<p>本文从 Apollo Cyber​​ RT 框架、Perception 模块、DreamView 模块的构建着手，旨在详细分析 Perception 模块及其 Fusion 组件的启动流程，并回答上文提到的 <code>Init</code> 和 <code>Proc</code> 方法的调用时机及调用对象问题。</p>
<h1 id="1-构建" class="heading-control"><a href="#1-构建" class="headerlink" title="1 构建"></a>1 构建<a class="heading-anchor" href="#1-构建" aria-hidden="true"></a></h1><p>Apollo 使用 <span class="exturl" data-url="aHR0cHM6Ly9iYXplbC5idWlsZC8=" title="https://bazel.build/">Bazel<i class="fa fa-external-link"></i></span> 进行代码构建，Bazel 是由 Google 开源的一款高效的软件构建工具。使用 Bazel 时，我们需要为每个参与构建的目录创建一个 BUILD 文件来定义一些构建规则，BUILD 文件使用类似 Python 的语法，我们看下 Apollo 代码仓库根目录下的 BUILD 文件（只列出关键部分，下同）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">install(</span><br><span class="line">    name = <span class="string">"install"</span>,</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"//cyber:install"</span>,</span><br><span class="line">        <span class="string">"//cyber/examples:install"</span>,</span><br><span class="line">        <span class="string">"//docker/scripts:install"</span>,</span><br><span class="line">        <span class="string">"//docs:install"</span>,</span><br><span class="line">        <span class="string">"//modules/audio:install"</span>,</span><br><span class="line">        <span class="string">"//modules/bridge:install"</span>,</span><br><span class="line">        <span class="string">"//modules/canbus:install"</span>,</span><br><span class="line">        <span class="string">"//modules/common:install"</span>,</span><br><span class="line">        <span class="string">"//modules/contrib/cyber_bridge:install"</span>,</span><br><span class="line">        <span class="string">"//modules/control:install"</span>,</span><br><span class="line">        <span class="string">"//modules/dreamview:install"</span>,</span><br><span class="line">        <span class="string">"//modules/drivers:install"</span>,</span><br><span class="line">        <span class="string">"//modules/guardian:install"</span>,</span><br><span class="line">        <span class="string">"//modules/localization:install"</span>,</span><br><span class="line">        <span class="string">"//modules/map:install"</span>,</span><br><span class="line">        <span class="string">"//modules/monitor:install"</span>,</span><br><span class="line">        <span class="string">"//modules/perception:install"</span>,</span><br><span class="line">        <span class="string">"//modules/planning:install"</span>,</span><br><span class="line">        <span class="string">"//modules/prediction:install"</span>,</span><br><span class="line">        <span class="string">"//modules/routing:install"</span>,</span><br><span class="line">        <span class="string">"//modules/storytelling:install"</span>,</span><br><span class="line">        <span class="string">"//modules/task_manager:install"</span>,</span><br><span class="line">        <span class="string">"//modules/third_party_perception:install"</span>,</span><br><span class="line">        <span class="string">"//modules/tools:install"</span>,</span><br><span class="line">        <span class="string">"//modules/transform:install"</span>,</span><br><span class="line">        <span class="string">"//modules/v2x:install"</span>,</span><br><span class="line">        <span class="string">"//scripts:install"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这里我们只关注 <code>deps</code> 参数中与本文有关的三个字段：</p>
<ul>
<li><code>&quot;//cyber:install&quot;</code></li>
<li><code>&quot;//modules/perception:install&quot;</code></li>
<li><code>&quot;//modules/dreamview:install&quot;</code></li>
</ul>
<p>从字面意思不难猜想到，上面三个字段分别引用了 Apollo 对应目录下其它 BUILD 文件的 <code>Install</code> 规则，我们依次进行说明。</p>
<h2 id="1-1-Cyber-RT-构建" class="heading-control"><a href="#1-1-Cyber-RT-构建" class="headerlink" title="1.1 Cyber RT 构建"></a>1.1 Cyber RT 构建<a class="heading-anchor" href="#1-1-Cyber-RT-构建" aria-hidden="true"></a></h2><p><span class="exturl" data-url="aHR0cHM6Ly9hcG9sbG8uYXV0by9kb2N1bWVudF9jbi5odG1sP2RvbWFpbj1BcG9sbG8tSG9tZXBhZ2UtRG9jdW1lbnQmYW1wO3JlcG89QXBvbGxvX0RvY19DTl82XzAmYW1wO2ZpbGVwYXRoPS8=" title="https://apollo.auto/document_cn.html?domain=Apollo-Homepage-Document&amp;repo=Apollo_Doc_CN_6_0&amp;filepath=/">Cyber​​ RT<i class="fa fa-external-link"></i></span> 是百度开源的一款源于 ROS 的、专为自动驾驶场景而设计的高性能运行时框架，并针对自动驾驶的高并发、低延迟、高吞吐量进行了大幅优化。Cyber RT 自 Apollo 3.5 版本开始启用，此处我们不展开细节，接上文直接看下 <code>apollo/cyber/</code> 目录下 BUILD 文件的主要内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">install(</span><br><span class="line">    name = <span class="string">"install"</span>,</span><br><span class="line">    data = [</span><br><span class="line">        <span class="string">":.release.bash"</span>,</span><br><span class="line">        <span class="string">":cyber_conf"</span>,</span><br><span class="line">        <span class="string">"//cyber/python/cyber_py3:runtime_files"</span>,</span><br><span class="line">    ],</span><br><span class="line">    rename = &#123;</span><br><span class="line">        <span class="string">"cyber/.release.bash"</span>: <span class="string">"setup.bash"</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">":pb_cyber"</span>,</span><br><span class="line">        <span class="string">"//cyber/mainboard:install"</span>,</span><br><span class="line">        <span class="string">"//cyber/python/internal:install"</span>,</span><br><span class="line">        <span class="string">"//cyber/tools:install"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>根据 <code>deps</code> 参数中的 <code>&quot;//cyber/mainboard:install&quot;</code> 字段，我们看下 <code>apollo/cyber/mainboard/</code> 目录下 BUILD 文件的主要内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"mainboard"</span>,</span><br><span class="line">    srcs = [</span><br><span class="line">        <span class="string">"mainboard.cc"</span>,</span><br><span class="line">        <span class="string">"module_argument.cc"</span>,</span><br><span class="line">        <span class="string">"module_argument.h"</span>,</span><br><span class="line">        <span class="string">"module_controller.cc"</span>,</span><br><span class="line">        <span class="string">"module_controller.h"</span>,</span><br><span class="line">    ],</span><br><span class="line">    linkopts = [<span class="string">"-pthread"</span>],</span><br><span class="line">    linkstatic = <span class="literal">False</span>,</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"//cyber:cyber_core"</span>,</span><br><span class="line">        <span class="string">"//cyber/proto:dag_conf_cc_proto"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">install(</span><br><span class="line">    name = <span class="string">"install"</span>,</span><br><span class="line">    targets = [<span class="string">":mainboard"</span>],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>从 <code>install</code> 规则的 <code>targets</code> 参数我们可以知道，Cyber RT 最终会被编译成名为 <code>mainboard</code> 的可执行文件，从 <code>cc_binary</code> 规则的 <code>srcs</code> 参数我们又可以知道，<code>mainboard</code> 编译了五个文件，其中的 <code>mainboard.cc</code> 极有可能是主入口文件（这一点对于我们后面的分析很重要）。</p>
<h2 id="1-2-Perception-模块构建" class="heading-control"><a href="#1-2-Perception-模块构建" class="headerlink" title="1.2 Perception 模块构建"></a>1.2 Perception 模块构建<a class="heading-anchor" href="#1-2-Perception-模块构建" aria-hidden="true"></a></h2><p>延续上面的分析思路，我们看下 <code>apollo/modules/perception/</code> 目录下 BUILD 文件的主要内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">install(</span><br><span class="line">    name = <span class="string">"install"</span>,</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">":pb_perception"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/data:install"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/onboard/component:install"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/production:install"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>根据 <code>deps</code> 参数中的 <code>&quot;//modules/perception/onboard/component:install&quot;</code> 字段，我们看下 <code>apollo/modules/perception/onboard/component/</code> 目录下 BUILD 文件的主要内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">install(</span><br><span class="line">    name = <span class="string">"install"</span>,</span><br><span class="line">    targets = [</span><br><span class="line">        <span class="string">":libperception_component_camera.so"</span>,</span><br><span class="line">        <span class="string">":libperception_component_lidar.so"</span>,</span><br><span class="line">    ],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"//cyber:install"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/production:install"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"libperception_component_lidar.so"</span>,</span><br><span class="line">    linkshared = <span class="literal">True</span>,</span><br><span class="line">    linkstatic = <span class="literal">False</span>,</span><br><span class="line">    deps = [<span class="string">":perception_component_inner_lidar"</span>],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_library(</span><br><span class="line">    name = <span class="string">"perception_component_inner_lidar"</span>,</span><br><span class="line">    copts = [</span><br><span class="line">        <span class="string">'-DMODULE_NAME=\\"perception\\"'</span>,</span><br><span class="line">    ],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">":detection_component"</span>,</span><br><span class="line">        <span class="string">":fusion_component"</span>,</span><br><span class="line">        <span class="string">":radar_detection_component"</span>,</span><br><span class="line">        <span class="string">":recognition_component"</span>,</span><br><span class="line">    ],</span><br><span class="line">    alwayslink = <span class="literal">True</span>,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">cc_library(</span><br><span class="line">    name = <span class="string">"fusion_component"</span>,</span><br><span class="line">    srcs = [<span class="string">"fusion_component.cc"</span>],</span><br><span class="line">    hdrs = [<span class="string">"fusion_component.h"</span>],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"//cyber/time:clock"</span>,</span><br><span class="line">        <span class="string">"//modules/common/util:perf_util"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/base"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/fusion/app:obstacle_multi_sensor_fusion"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/fusion/lib/dummy:dummy_algorithms"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/fusion/lib/fusion_system/probabilistic_fusion"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/fusion/lib/interface"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/fusion/lib/interface:base_multisensor_fusion"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/lib/registerer"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/lidar/lib/classifier/fused_classifier"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/lidar/lib/classifier/fused_classifier:ccrf_type_fusion"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/map/hdmap:hdmap_input"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/onboard/common_flags"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/onboard/inner_component_messages"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/onboard/msg_serializer"</span>,</span><br><span class="line">        <span class="string">"//modules/perception/onboard/proto:fusion_component_config_cc_proto"</span>,</span><br><span class="line">        <span class="string">"@eigen"</span>,</span><br><span class="line">    ],</span><br><span class="line">    alwayslink = <span class="literal">True</span>,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>从 <code>install</code> 规则的 <code>targets</code> 参数我们得到一个很重要的事实：Perception 模块最终被编译成了两个分别命名为 <code>libperception_component_camera.so</code> 和 <code>libperception_component_lidar.so</code> 的动态库文件。意即，整个 Perception 功能模块被划分为 Camera 感知和 Lidar 感知。</p>
<p>到这里，可能会有疑问：Radar 呢？Fusion 呢？我们继续看 <code>install</code> 下面的规则会发现，<code>libperception_component_lidar.so</code> 存在下面这样的层次依赖关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">libperception_component_lidar.so</span><br><span class="line">└── perception_component_inner_lidar</span><br><span class="line">    ├── detection_component</span><br><span class="line">    ├── fusion_component</span><br><span class="line">    ├── radar_detection_component</span><br><span class="line">    └── recognition_component</span><br></pre></td></tr></table></figure>
<p>所以，最终 Radar 和 Fusion 等组件会被集成到 <code>libperception_component_lidar.so</code> 中。从 <code>fusion_component</code> 的 <code>cc_library</code> 规则我们又可以知道，Fusion 组件的入口在 <code>fusion_component.h</code> 和 <code>fusion_component.cc</code> 中，这两个文件包含了 Fusion 组件类的声明及定义。</p>
<h2 id="1-3-DreamView-模块构建" class="heading-control"><a href="#1-3-DreamView-模块构建" class="headerlink" title="1.3 DreamView 模块构建"></a>1.3 DreamView 模块构建<a class="heading-anchor" href="#1-3-DreamView-模块构建" aria-hidden="true"></a></h2><p>我们继续看 <code>apollo/modules/dreamview/</code> 目录下 BUILD 文件的主要内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cc_binary(</span><br><span class="line">    name = <span class="string">"dreamview"</span>,</span><br><span class="line">    srcs = [<span class="string">"main.cc"</span>],</span><br><span class="line">    copts = DREAMVIEW_COPTS + copts_if_teleop(),</span><br><span class="line">    data = [</span><br><span class="line">        <span class="string">":frontend"</span>,</span><br><span class="line">    ],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"//modules/dreamview/backend"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">install(</span><br><span class="line">    name = <span class="string">"install"</span>,</span><br><span class="line">    data = [</span><br><span class="line">        <span class="string">":dreamview_conf"</span>,</span><br><span class="line">        <span class="string">":frontend"</span>,</span><br><span class="line">    ],</span><br><span class="line">    targets = [<span class="string">"dreamview"</span>],</span><br><span class="line">    deps = [</span><br><span class="line">        <span class="string">"//cyber:install"</span>,</span><br><span class="line">    ],</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>从 <code>install</code> 规则的 <code>targets</code> 参数可以知道，DreamView 模块最终会被编译成名为 <code>dreamview</code> 的可执行文件；从 <code>cc_binary</code> 规则的 <code>srcs</code> 参数又可以知道，<code>dreamview</code> 可执行文件的入口在 <code>main.cc</code> 中。</p>
<h1 id="2-启动-Perception-模块" class="heading-control"><a href="#2-启动-Perception-模块" class="headerlink" title="2 启动 Perception 模块"></a>2 启动 Perception 模块<a class="heading-anchor" href="#2-启动-Perception-模块" aria-hidden="true"></a></h1><h2 id="2-1-从-DAG-文件启动" class="heading-control"><a href="#2-1-从-DAG-文件启动" class="headerlink" title="2.1 从 DAG 文件启动"></a>2.1 从 DAG 文件启动<a class="heading-anchor" href="#2-1-从-DAG-文件启动" aria-hidden="true"></a></h2><h3 id="2-1-1-DAG-文件的组织形式" class="heading-control"><a href="#2-1-1-DAG-文件的组织形式" class="headerlink" title="2.1.1 DAG 文件的组织形式"></a>2.1.1 DAG 文件的组织形式<a class="heading-anchor" href="#2-1-1-DAG-文件的组织形式" aria-hidden="true"></a></h3><p>DAG 文件是模块拓扑关系的配置文件，可以在 DAG 文件中定义各模块所使用的组件，及各组件对应的配置文件路径、上游/下游通道（channel）等信息。例如，Perception 模块对应的 DAG 文件为 <code>apollo/modules/perception/production/dag/dag_streaming_perception.dag</code>，我们看下其包含的具体内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">module_config &#123;</span><br><span class="line">  module_library : <span class="string">"/apollo/bazel-bin/modules/perception/onboard/component/libperception_component_camera.so"</span></span><br><span class="line">  components &#123;</span><br><span class="line">    class_name : <span class="string">"FusionCameraDetectionComponent"</span></span><br><span class="line">    config &#123;</span><br><span class="line">      name: <span class="string">"FusionCameraComponent"</span></span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/camera/fusion_camera_detection_component.pb.txt"</span></span><br><span class="line">      flag_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/perception_common.flag"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_config &#123;</span><br><span class="line">  module_library : <span class="string">"/apollo/bazel-bin/modules/perception/onboard/component/libperception_component_lidar.so"</span></span><br><span class="line"></span><br><span class="line">  components &#123;</span><br><span class="line">    class_name : <span class="string">"DetectionComponent"</span></span><br><span class="line">    config &#123;</span><br><span class="line">      name: <span class="string">"Velodyne128Detection"</span></span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/lidar/velodyne128_detection_conf.pb.txt"</span></span><br><span class="line">      flag_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/perception_common.flag"</span></span><br><span class="line">      readers &#123;</span><br><span class="line">        channel: <span class="string">"/apollo/sensor/lidar128/compensator/PointCloud2"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  components &#123;</span><br><span class="line">    class_name : <span class="string">"RecognitionComponent"</span></span><br><span class="line">    config &#123;</span><br><span class="line">      name: <span class="string">"RecognitionComponent"</span></span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/lidar/recognition_conf.pb.txt"</span></span><br><span class="line">      readers &#123;</span><br><span class="line">        channel: <span class="string">"/perception/inner/DetectionObjects"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  components &#123;</span><br><span class="line">    class_name: <span class="string">"RadarDetectionComponent"</span></span><br><span class="line">    config &#123;</span><br><span class="line">      name: <span class="string">"FrontRadarDetection"</span></span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/radar/front_radar_component_conf.pb.txt"</span></span><br><span class="line">      flag_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/perception_common.flag"</span></span><br><span class="line">      readers &#123;</span><br><span class="line">        channel: <span class="string">"/apollo/sensor/radar/front"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  components &#123;</span><br><span class="line">    class_name: <span class="string">"RadarDetectionComponent"</span></span><br><span class="line">    config &#123;</span><br><span class="line">      name: <span class="string">"RearRadarDetection"</span></span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/radar/rear_radar_component_conf.pb.txt"</span></span><br><span class="line">      flag_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/perception_common.flag"</span></span><br><span class="line">      readers &#123;</span><br><span class="line">        channel: <span class="string">"/apollo/sensor/radar/rear"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  components &#123;</span><br><span class="line">    class_name: <span class="string">"FusionComponent"</span></span><br><span class="line">    config &#123;</span><br><span class="line">      name: <span class="string">"SensorFusion"</span></span><br><span class="line">      config_file_path: <span class="string">"/apollo/modules/perception/production/conf/perception/fusion/fusion_component_conf.pb.txt"</span></span><br><span class="line">      readers &#123;</span><br><span class="line">        channel: <span class="string">"/perception/inner/PrefusedObjects"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_config &#123;</span><br><span class="line">  module_library : <span class="string">"/apollo/bazel-bin/modules/v2x/fusion/apps/libv2x_fusion_component.so"</span></span><br><span class="line"></span><br><span class="line">  components &#123;</span><br><span class="line">    class_name : <span class="string">"V2XFusionComponent"</span></span><br><span class="line">    config &#123;</span><br><span class="line">      name : <span class="string">"v2x_fusion"</span></span><br><span class="line">      flag_file_path : <span class="string">"/apollo/modules/v2x/conf/v2x_fusion_tracker.conf"</span></span><br><span class="line">      readers: [</span><br><span class="line">        &#123;</span><br><span class="line">          channel: <span class="string">"/perception/vehicle/obstacles"</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个 DAG 文件虽然冗长，但分析起来很简单，它包含了三个子功能模块：</p>
<ul>
<li><code>libperception_component_camera.so</code></li>
<li><code>libperception_component_lidar.so</code></li>
<li><code>libv2x_fusion_component.so</code></li>
</ul>
<p>我们着重看所关心的 Lidar 部分，<code>libperception_component_lidar.so</code> 子功能模块下包含了四类组件及各自对应的配置文件路径和输入 channel：</p>
<ul>
<li><code>DetectionComponent</code></li>
<li><code>RecognitionComponent</code></li>
<li><code>RadarDetectionComponent</code></li>
<li><code>FusionComponent</code></li>
</ul>
<p>如果细心得话可以发现，<code>RadarDetectionComponent</code> 被包含了两次，这其实表示得是 <code>RadarDetectionComponent</code> 组件类会被创建两个实例，一个用于处理前毫米波雷达数据，另一个用于处理后毫米波雷达数据。</p>
<h3 id="2-1-2-加载-DAG-文件并启动功能模块" class="heading-control"><a href="#2-1-2-加载-DAG-文件并启动功能模块" class="headerlink" title="2.1.2 加载 DAG 文件并启动功能模块"></a>2.1.2 加载 DAG 文件并启动功能模块<a class="heading-anchor" href="#2-1-2-加载-DAG-文件并启动功能模块" aria-hidden="true"></a></h3><p>所有的功能模块都在 Cyber RT 框架下进行任务调度和通信，上文中我们已经提到，Cyber RT 最终会被编译成名为 <code>mainboard</code> 的可执行文件，我们可以在 Apollo 源码仓库的根目录下执行下述命令来加载上述的 DAG 文件并启动其中包含的子功能模块与组件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mainboard -d modules/perception/production/dag/dag_streaming_perception.dag</span><br></pre></td></tr></table></figure>
<p><code>-d</code> 选项后面跟的是 DAG 文件路径，我们可以像下面这样为 <code>mainboard</code> 传入多个 DAG 文件，<code>mainboard</code> 会循环处理每个 DAG 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mainboard -d a.dag -d b.dag -d c.dag</span><br></pre></td></tr></table></figure>
<p>mainboard 还有两个参数选项：</p>
<ul>
<li><code>-p</code>：进程所在命名空间</li>
<li><code>-s</code>：进程所使用的调度策略</li>
</ul>
<p>那 <code>mainboard</code> 具体是如何启动的 DAG 文件中包含的子功能模块与相应组件的呢？根据 1.1 章节中的结论，我们打开 <code>apollo/cyber/mainboard/mainboard.cc</code> 文件，发现其中包含了 <code>mainboard</code> 的 <code>main</code> 入口函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// parse the argument</span></span><br><span class="line">  ModuleArgument module_args;</span><br><span class="line">  module_args.ParseArgument(argc, argv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// initialize cyber</span></span><br><span class="line">  apollo::cyber::Init(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// start module</span></span><br><span class="line">  <span class="function">ModuleController <span class="title">controller</span><span class="params">(module_args)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (!controller.Init()) &#123;</span><br><span class="line">    controller.Clear();</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"module start error."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  apollo::cyber::WaitForShutdown();</span><br><span class="line">  controller.Clear();</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"exit mainboard."</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该入口函数主要做了三件事：</p>
<ol>
<li>解析传入参数</li>
<li>初始化 Cyber RT</li>
<li>实例化模块控制器类（<code>ModuleController</code>），并进行初始化</li>
</ol>
<p>我们进入模块控制器初始化方法 <code>ModuleController::Init</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">ModuleController::Init</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> LoadAll(); &#125;</span><br></pre></td></tr></table></figure>
<p><code>ModuleController::Init</code> 会间接调用 <code>ModuleController::LoadAll</code>，<code>LoadAll</code> 的核心任务是循环处理我们为 <code>mainboard</code> 传入的每个 DAG 文件，并针对每个 DAG 文件最终调用 <code>ModuleController::LoadModule</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ModuleController::LoadModule</span><span class="params">(<span class="keyword">const</span> DagConfig&amp; dag_config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> work_root = common::WorkRoot();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> module_config : dag_config.module_config()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> load_path;</span><br><span class="line">    <span class="keyword">if</span> (module_config.module_library().front() == <span class="string">'/'</span>) &#123;</span><br><span class="line">      load_path = module_config.module_library();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      load_path =</span><br><span class="line">          common::GetAbsolutePath(work_root, module_config.module_library());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!common::PathExists(load_path)) &#123;</span><br><span class="line">      AERROR &lt;&lt; <span class="string">"Path does not exist: "</span> &lt;&lt; load_path;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    class_loader_manager_.LoadLibrary(load_path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : module_config.components()) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name = component.class_name();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ComponentBase&gt; base =</span><br><span class="line">          class_loader_manager_.CreateClassObj&lt;ComponentBase&gt;(class_name);</span><br><span class="line">      <span class="keyword">if</span> (base == <span class="literal">nullptr</span> || !base-&gt;Initialize(component.config())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      component_list_.emplace_back(<span class="built_in">std</span>::move(base));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : module_config.timer_components()) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name = component.class_name();</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ComponentBase&gt; base =</span><br><span class="line">          class_loader_manager_.CreateClassObj&lt;ComponentBase&gt;(class_name);</span><br><span class="line">      <span class="keyword">if</span> (base == <span class="literal">nullptr</span> || !base-&gt;Initialize(component.config())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      component_list_.emplace_back(<span class="built_in">std</span>::move(base));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ModuleController::LoadModule</code> 方法并不复杂，其主要做了三件事，下面我们依次展开。</p>
<h4 id="2-1-2-1-加载子功能模块并注册其中的各个组件" class="heading-control"><a href="#2-1-2-1-加载子功能模块并注册其中的各个组件" class="headerlink" title="2.1.2.1 加载子功能模块并注册其中的各个组件"></a>2.1.2.1 加载子功能模块并注册其中的各个组件<a class="heading-anchor" href="#2-1-2-1-加载子功能模块并注册其中的各个组件" aria-hidden="true"></a></h4><p><code>ModuleController::LoadModule</code> 方法通过 <code>ClassLoaderManager::LoadLibrary</code> 方法间接调用 Linux 底层的 <code>dlopen</code> 函数来加载 DAG 文件中各个子功能模块的 <code>.so</code> 动态库文件，具体细节不再展开。</p>
<p>每个子功能模块的组件注册过程是随着模块 <code>.so</code> 动态库文件的加载一同进行的，以 Fusion 组件为例，为分析其注册过程我们需要先看下对应组件类的定义。如上文所述，Fusion 组件的入口在 <code>fusion_component.h</code> 中，我们打开 <code>apollo/modules/perception/onboard/component/fusion_component.h</code> 一探究竟：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FusionComponent</span> :</span> <span class="keyword">public</span> cyber::Component&lt;SensorFrameMessage&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  ~FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Proc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt;&amp; message)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InitAlgorithmPlugin</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InternalProc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage <span class="keyword">const</span>&gt;&amp; in_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PerceptionObstacles&gt; out_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; viz_message)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::mutex s_mutex_;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint32_t</span> s_seq_num_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_name_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_method_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fusion_main_sensors_;</span><br><span class="line">  <span class="keyword">bool</span> object_in_roi_check_ = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">double</span> radius_for_roi_object_check_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fusion::BaseMultiSensorFusion&gt; fusion_;</span><br><span class="line">  <span class="built_in">map</span>::HDMapInput* hdmap_input_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;PerceptionObstacles&gt;&gt; writer_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;SensorFrameMessage&gt;&gt; inner_writer_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">CYBER_REGISTER_COMPONENT(FusionComponent);</span><br></pre></td></tr></table></figure>
<p>望文生义，最下面的 <code>CYBER_REGISTER_COMPONENT</code> 宏就是用于组件注册的，我们层层递进，看看最后发生了什么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">CYBER_REGISTER_COMPONENT(FusionComponent);</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\Downarrow</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYBER_REGISTER_COMPONENT(name) \</span></span><br><span class="line">  CLASS_LOADER_REGISTER_CLASS(name, apollo::cyber::ComponentBase)</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\Downarrow</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_LOADER_REGISTER_CLASS(Derived, Base) \</span></span><br><span class="line">  CLASS_LOADER_REGISTER_CLASS_INTERNAL_1(Derived, Base, __COUNTER__)</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\Downarrow</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_LOADER_REGISTER_CLASS_INTERNAL_1(Derived, Base, UniqueID) \</span></span><br><span class="line">  CLASS_LOADER_REGISTER_CLASS_INTERNAL(Derived, Base, UniqueID)</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\Downarrow</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLASS_LOADER_REGISTER_CLASS_INTERNAL(Derived, Base, UniqueID)     \</span></span><br><span class="line">  <span class="keyword">namespace</span> &#123;                                                             \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ProxyType</span>##<span class="title">UniqueID</span> &#123;</span>                                            \</span><br><span class="line">    ProxyType##UniqueID() &#123;                                               \</span><br><span class="line">      apollo::cyber::class_loader::utility::RegisterClass&lt;Derived, Base&gt;( \</span><br><span class="line">          #Derived, #Base);                                               \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;;                                                                      \</span><br><span class="line">  <span class="keyword">static</span> ProxyType##UniqueID g_register_class_##UniqueID;                 \</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">
\Downarrow</script><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Derived, <span class="keyword">typename</span> Base&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RegisterClass</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; base_class_name)</span> </span>&#123;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"registerclass:"</span> &lt;&lt; class_name &lt;&lt; <span class="string">","</span> &lt;&lt; base_class_name &lt;&lt; <span class="string">","</span></span><br><span class="line">        &lt;&lt; GetCurLoadingLibraryName();</span><br><span class="line"></span><br><span class="line">  utility::AbstractClassFactory&lt;Base&gt;* new_class_factory_obj =</span><br><span class="line">      <span class="keyword">new</span> utility::ClassFactory&lt;Derived, Base&gt;(class_name, base_class_name);</span><br><span class="line">  new_class_factory_obj-&gt;AddOwnedClassLoader(GetCurActiveClassLoader());</span><br><span class="line">  new_class_factory_obj-&gt;SetRelativeLibraryPath(GetCurLoadingLibraryName());</span><br><span class="line"></span><br><span class="line">  GetClassFactoryMapMapMutex().lock();</span><br><span class="line">  ClassClassFactoryMap&amp; factory_map =</span><br><span class="line">      GetClassFactoryMapByBaseClass(<span class="keyword">typeid</span>(Base).name());</span><br><span class="line">  factory_map[class_name] = new_class_factory_obj;</span><br><span class="line">  GetClassFactoryMapMapMutex().unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将 <code>FusionComponent</code> 和 <code>apollo::cyber::ComponentBase</code> 代入模板函数 <code>RegisterClass</code>，其内部将使用工厂方法模式为 <code>FusionComponent</code> 组件类创建对应的类工厂对象，并为类工厂对象添加类加载器，设置动态库路径，最后将 <code>FusionComponent</code> 及其类工厂对象的映射关系添加到 <code>factory_map</code> 中。后续 <code>FusionComponent</code> 的实例化步骤将依赖 <code>factory_map</code> 中的注册结果。</p>
<h4 id="2-1-2-2-实例化具体组件类" class="heading-control"><a href="#2-1-2-2-实例化具体组件类" class="headerlink" title="2.1.2.2 实例化具体组件类"></a>2.1.2.2 实例化具体组件类<a class="heading-anchor" href="#2-1-2-2-实例化具体组件类" aria-hidden="true"></a></h4><p>我们跳回到前面的 <code>ModuleController::LoadModule</code> 方法，找到其中循环处理子功能模块中每个组件的代码段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; component : module_config.components()) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; class_name = component.class_name();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ComponentBase&gt; base =</span><br><span class="line">      class_loader_manager_.CreateClassObj&lt;ComponentBase&gt;(class_name);</span><br><span class="line">  <span class="keyword">if</span> (base == <span class="literal">nullptr</span> || !base-&gt;Initialize(component.config())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  component_list_.emplace_back(<span class="built_in">std</span>::move(base));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们将 <code>FusionComponent</code> 作为一次轮询代入上面这个 <code>for</code> 循环，其中下面的语句完成了组件类的实例化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;ComponentBase&gt; base =</span><br><span class="line">    class_loader_manager_.CreateClassObj&lt;ComponentBase&gt;(FusionComponent);</span><br></pre></td></tr></table></figure>
<p><code>CreateClassObj</code> 方法的实现并不复杂，细节不再展开，其最后主要是在上文组件注册过程中提及的 <code>factory_map</code> 中查找 <code>FusionComponent</code> 对应的类工厂对象，并通过该类工厂对象最终向 <code>base</code> 返回一个 <code>FusionComponent</code> 指针。看到这里应该可以发现，<code>base</code> 的静态类型是一个指向 <code>ComponentBase</code> 的共享智能指针，但却动态绑定到了一个派生类对象上，这意味着后面很有可能会发生多态调用。</p>
<h4 id="2-1-2-3-初始化具体组件实例，进入组件内部算法流程" class="heading-control"><a href="#2-1-2-3-初始化具体组件实例，进入组件内部算法流程" class="headerlink" title="2.1.2.3 初始化具体组件实例，进入组件内部算法流程"></a>2.1.2.3 初始化具体组件实例，进入组件内部算法流程<a class="heading-anchor" href="#2-1-2-3-初始化具体组件实例，进入组件内部算法流程" aria-hidden="true"></a></h4><p><strong>第一次多态调用</strong></p>
<p>完成 Fusion 组件类 <code>FusionComponent</code> 的实例化后，紧接着调用了 <code>base</code> 的 <code>Initialize</code> 方法，<code>Initialize</code> 是 <code>FusionComponent</code> 的间接基类 <code>ComponentBase</code> 中的 <code>virtual</code> 函数，此时会按照继承体系多态调用 <code>FusionComponent</code> 直接基类 <code>Component&lt;SensorFrameMessage&gt;</code>（只接受一个消息类型参数的 <code>Component</code> 类）中的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M0&gt;</span><br><span class="line"><span class="keyword">bool</span> Component&lt;M0, NullType, NullType, NullType&gt;::Initialize(</span><br><span class="line">    <span class="keyword">const</span> ComponentConfig&amp; config) &#123;</span><br><span class="line">  node_.reset(<span class="keyword">new</span> Node(config.name()));</span><br><span class="line">  LoadConfigFiles(config);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (config.readers_size() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Invalid config file: too few readers."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!Init()) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Component Init() failed."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> is_reality_mode = GlobalData::Instance()-&gt;IsRealityMode();</span><br><span class="line"></span><br><span class="line">  ReaderConfig reader_cfg;</span><br><span class="line">  reader_cfg.channel_name = config.readers(<span class="number">0</span>).channel();</span><br><span class="line">  reader_cfg.qos_profile.CopyFrom(config.readers(<span class="number">0</span>).qos_profile());</span><br><span class="line">  reader_cfg.pending_queue_size = config.readers(<span class="number">0</span>).pending_queue_size();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::weak_ptr&lt;Component&lt;M0&gt;&gt; self =</span><br><span class="line">      <span class="built_in">std</span>::dynamic_pointer_cast&lt;Component&lt;M0&gt;&gt;(shared_from_this());</span><br><span class="line">  <span class="keyword">auto</span> func = [self](<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;M0&gt;&amp; msg) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ptr = self.lock();</span><br><span class="line">    <span class="keyword">if</span> (ptr) &#123;</span><br><span class="line">      ptr-&gt;Process(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      AERROR &lt;&lt; <span class="string">"Component object has been destroyed."</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Reader&lt;M0&gt;&gt; reader = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cyber_likely(is_reality_mode)) &#123;</span><br><span class="line">    reader = node_-&gt;CreateReader&lt;M0&gt;(reader_cfg);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reader = node_-&gt;CreateReader&lt;M0&gt;(reader_cfg, func);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (reader == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Component create reader failed."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  readers_.emplace_back(<span class="built_in">std</span>::move(reader));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (cyber_unlikely(!is_reality_mode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data::VisitorConfig conf = &#123;readers_[<span class="number">0</span>]-&gt;ChannelId(),</span><br><span class="line">                              readers_[<span class="number">0</span>]-&gt;PendingQueueSize()&#125;;</span><br><span class="line">  <span class="keyword">auto</span> dv = <span class="built_in">std</span>::make_shared&lt;data::DataVisitor&lt;M0&gt;&gt;(conf);</span><br><span class="line">  croutine::RoutineFactory factory =</span><br><span class="line">      croutine::CreateRoutineFactory&lt;M0&gt;(func, dv);</span><br><span class="line">  <span class="keyword">auto</span> sched = scheduler::Instance();</span><br><span class="line">  <span class="keyword">return</span> sched-&gt;CreateTask(factory, node_-&gt;Name());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二次多态调用</strong></p>
<p><code>Initialize</code> 方法首先会创建一个与 DAG 文件中 <code>FusionComponent</code> 的 <code>config.name</code> 参数（SensorFusion）同名的节点，然后会调用 <code>Init</code> 方法，这是 <code>ComponentBase</code> 中的一个 <code>pure virtual</code> 函数，且 <code>ComponentBase</code> 的直接派生类 <code>Component</code> 未对 <code>Init</code> 进行重写，所以最终会按照继承体系多态调用 <code>ComponentBase</code> 间接派生类 <code>FusionComponent</code> 中的版本，至此，Fusion 组件的初始化完成了！</p>
<p><strong>第三次多态调用</strong></p>
<p><code>Initialize</code> 方法后面又会创建一个 lambda 函数对象 <code>func</code>，<code>func</code> 中会调用 <code>Component</code> 类的 <code>Process</code> 方法，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> M0&gt;</span><br><span class="line"><span class="keyword">bool</span> Component&lt;M0, NullType, NullType, NullType&gt;::Process(</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;M0&gt;&amp; msg) &#123;</span><br><span class="line">  <span class="keyword">if</span> (is_shutdown_.load()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Proc(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Process</code> 方法中调用的 <code>Proc</code> 方法是 <code>Component</code> 类的一个 <code>pure virtual</code> 函数，因此会按照继承体系多态调用 <code>Component</code> 派生类 <code>FusionComponent</code> 中的版本，但 <code>func</code> 对象最终又是在哪里被调用的呢？继续看 <code>Initialize</code> 方法后面的代码不难发现，<code>func</code> 的调用流程是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建协程工厂，并将 func 对象绑定到该协程工厂 --&gt;</span><br><span class="line"></span><br><span class="line">为 Initialize 方法最开始创建的 SensorFusion 节点创建调度任务 --&gt;</span><br><span class="line"></span><br><span class="line">使用协程工厂创建协程，并将其分配给调度任务 --&gt;</span><br><span class="line"></span><br><span class="line">分发调度任务 --&gt;</span><br><span class="line"></span><br><span class="line">组件对应 channel 上的消息回调触发调度器进行任务调度</span><br></pre></td></tr></table></figure>
<p>最终，<code>FusionComponent</code> 中的 <code>Proc</code> 方法将成为对应 channel 上消息的回调函数。至此，进入了 Fusion 组件的内部算法流程！文章最开始的问题得到圆满解答。同时，根据上面的分析过程，我们还可以得出一个拓展结论：<strong>每个组件最终会分别对应一个协程</strong>。</p>
<h2 id="2-2-从-Launch-文件启动" class="heading-control"><a href="#2-2-从-Launch-文件启动" class="headerlink" title="2.2 从 Launch 文件启动"></a>2.2 从 Launch 文件启动<a class="heading-anchor" href="#2-2-从-Launch-文件启动" aria-hidden="true"></a></h2><p>Launch 文件只是对 DAG 文件进行了又一次封装，方便我们更灵活地组织工作。Perception 模块对应的 Launch 文件为 <code>apollo/modules/perception/production/launch/perception.launch</code>，我们看下其包含的具体内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--this file list the modules which will be loaded dynamicly and</span></span><br><span class="line"><span class="comment">    their process name to be running in --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cyber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">desc</span>&gt;</span>cyber modules list config<span class="tag">&lt;/<span class="name">desc</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- sample module config, and the files should have relative path like</span></span><br><span class="line"><span class="comment">         ./bin/cyber_launch</span></span><br><span class="line"><span class="comment">         ./bin/mainboard</span></span><br><span class="line"><span class="comment">         ./conf/dag_streaming_0.conf --&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>perception_lidar<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dag_conf</span>&gt;</span>/apollo/modules/perception/production/dag/dag_streaming_perception.dag<span class="tag">&lt;/<span class="name">dag_conf</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- if not set, use default process --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">process_name</span>&gt;</span>perception_lidar<span class="tag">&lt;/<span class="name">process_name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>motion_service<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dag_conf</span>&gt;</span>/apollo/modules/perception/production/dag/dag_motion_service.dag<span class="tag">&lt;/<span class="name">dag_conf</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- if not set, use default process --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">process_name</span>&gt;</span>motion_service<span class="tag">&lt;/<span class="name">process_name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cyber</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中：</p>
<ul>
<li><code>module</code> 字段用于区分不同的模块</li>
<li><code>name</code> 字段表示模块名称</li>
<li><code>dag_conf</code> 字段为对应的 DAG 文件路径</li>
<li><code>process_name</code> 字段表示为模块开辟的进程名</li>
</ul>
<p>我们可以在 Apollo 源码仓库的根目录下执行下述命令来加载上述 Launch 文件并启动其中包含的 DAG 文件中的子功能模块和相关组件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cyber_launch start modules/perception/production/launch/perception.launch</span><br></pre></td></tr></table></figure>
<p><code>cyber_launch</code> 其实对应的是一个 Python 脚本 <code>apollo/cyber/tools/cyber_launch/cyber_launch.py</code>，上述语句最终会通过调用 Python <code>subprocess</code> 库的 <code>Popen</code> 函数为 Launch 文件中的每个 DAG 文件创建一个独立线程，并像 2.1 章节中描述的那样执行对应的 <code>mainboard</code> 启动语句，此处不再赘述。</p>
<h2 id="2-3-从-DreamView-启动" class="heading-control"><a href="#2-3-从-DreamView-启动" class="headerlink" title="2.3 从 DreamView 启动"></a>2.3 从 DreamView 启动<a class="heading-anchor" href="#2-3-从-DreamView-启动" aria-hidden="true"></a></h2><p>在此前的文章<a href="https://blog.shipengx.com/archives/e4b9c8ad.html">《Apollo 6.0 安装完全指南》</a>中我们已经知道，通过下面的命令行我们可以启动 DreamView GUI 界面：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./scripts/bootstrap.sh start</span><br></pre></td></tr></table></figure>
<p>在 GUI 界面上我们可以进行各种操作，无需通过前文介绍的 <code>mainboard</code> 或 <code>cyber_launch</code> 的方式单独启动模块，这是怎么做到的呢？如果我们打开 <code>apollo/scripts/bootstrap.sh</code>，并层层递进，会发现最终调用了 <code>apollo/scripts/apollo_base.sh</code> 中的 <code>start_customized_path</code> 函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">start_customized_path</span></span>() &#123;</span><br><span class="line">  MODULE_PATH=<span class="variable">$1</span></span><br><span class="line">  MODULE=<span class="variable">$2</span></span><br><span class="line">  <span class="built_in">shift</span> 2</span><br><span class="line"></span><br><span class="line">  is_stopped_customized_path <span class="string">"<span class="variable">$&#123;MODULE_PATH&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;MODULE&#125;</span>"</span></span><br><span class="line">  <span class="keyword">if</span> [ $? -eq 1 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">eval</span> <span class="string">"nohup cyber_launch start <span class="variable">$&#123;APOLLO_ROOT_DIR&#125;</span>/modules/<span class="variable">$&#123;MODULE_PATH&#125;</span>/launch/<span class="variable">$&#123;MODULE&#125;</span>.launch &amp;"</span></span><br><span class="line">    sleep 0.5</span><br><span class="line">    is_stopped_customized_path <span class="string">"<span class="variable">$&#123;MODULE_PATH&#125;</span>"</span> <span class="string">"<span class="variable">$&#123;MODULE&#125;</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [ $? -eq 0 ]; <span class="keyword">then</span></span><br><span class="line">      ok <span class="string">"Launched module <span class="variable">$&#123;MODULE&#125;</span>."</span></span><br><span class="line">      <span class="built_in">return</span> 0</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      error <span class="string">"Could not launch module <span class="variable">$&#123;MODULE&#125;</span>. Is it already built?"</span></span><br><span class="line">      <span class="built_in">return</span> 1</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    info <span class="string">"Module <span class="variable">$&#123;MODULE&#125;</span> is already running - skipping."</span></span><br><span class="line">    <span class="built_in">return</span> 2</span><br><span class="line">  <span class="keyword">fi</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键的是其中的 <code>eval</code> 这条语句，我们显示地给出语句中的变量值，则最终下面这条语句会被执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup cyber_launch start apollo/modules/dream/launch/dream.launch &amp;</span><br></pre></td></tr></table></figure>
<p>这条语句表示无挂断地（<code>nohup</code>）在后台（<code>&amp;</code>）执行 <code>cyber_launch</code> 脚本，命令参数是 <code>start</code> 和 <code>apollo/modules/dream/launch/dream.launch</code>，我们看下 Launch 文件中的内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">cyber</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">module</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>dreamview<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dag_conf</span>&gt;</span><span class="tag">&lt;/<span class="name">dag_conf</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">type</span>&gt;</span>binary<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">process_name</span>&gt;</span></span><br><span class="line">           /apollo/bazel-bin/modules/dreamview/dreamview --flagfile=/apollo/modules/common/data/global_flagfile.txt</span><br><span class="line">        <span class="tag">&lt;/<span class="name">process_name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">exception_handler</span>&gt;</span>respawn<span class="tag">&lt;/<span class="name">exception_handler</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">cyber</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>type</code> 属性为 <code>binary</code>，<code>cyber_launch</code> 脚本直接调用 Python <code>subprocess</code> 库的 <code>Popen</code> 函数来执行下面的语句：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/apollo/bazel-bin/modules/dreamview/dreamview --flagfile=/apollo/modules/common/data/global_flagfile.txt</span><br></pre></td></tr></table></figure>
<p>前文曾提到，DreamView 模块最终会被编译成名为 <code>dreamview</code> 的可执行文件，所以上面的语句会启动 <code>dreamview</code> 程序，我们打开 <code>apollo/modules/dreamview/main.cc</code> 文件，看下 <code>dreamview</code> 的 <code>main</code> 入口函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  google::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// Added by caros to improve dv performance</span></span><br><span class="line">  apollo::cyber::GlobalData::Instance()-&gt;SetProcessGroup(<span class="string">"dreamview_sched"</span>);</span><br><span class="line">  apollo::cyber::Init(argv[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  apollo::dreamview::Dreamview dreamview;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">bool</span> init_success = dreamview.Init().ok() &amp;&amp; dreamview.Start().ok();</span><br><span class="line">  <span class="keyword">if</span> (!init_success) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to initialize dreamview server"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  apollo::cyber::WaitForShutdown();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该入口函数主要做了三件事：</p>
<ol>
<li>解析传入参数</li>
<li>初始化 Cyber RT</li>
<li>实例化 <code>Dreamview</code> 类，并进行初始化和启动</li>
</ol>
<p>这里我们只需要关注 <code>Dreamview::Init</code> 方法内部间接发生的两个事实：</p>
<p><strong>1. 加载 HMI 模式</strong></p>
<p>在<a href="https://blog.shipengx.com/archives/e4b9c8ad.html">《Apollo 6.0 安装完全指南》</a>中我们提到，需要在 DreamView 界面的对应下拉框中选择驾驶模式为“Mkz Standard Debug”，这里的驾驶模式其实对应了 <code>apollo/modules/dreamview/conf/hmi_modes/mkz_standard_debug.pb.txt</code> 模式配置文件，该文件描述了“Mkz Standard Debug”驾驶模式下需要启动哪些功能模块，我们看下其中与 Perception 模块对应的字段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cyber_modules &#123;</span><br><span class="line">  key: &quot;Perception&quot;</span><br><span class="line">  value: &#123;</span><br><span class="line">    dag_files: &quot;&#x2F;apollo&#x2F;modules&#x2F;perception&#x2F;production&#x2F;dag&#x2F;dag_streaming_perception.dag&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>cyber_modules</code> 表示功能模组，是比功能模块更大一级的概念，一个 <code>cyber_modules</code> 可以包含多个功能模块；<code>key</code> 表示 <code>cyber_modules</code> 的名称；<code>value</code> 包含 <code>cyber_modules</code> 依赖的所有 DAG 文件与 <code>cyber_modules</code> 所在的进程组 <code>process_group</code>（此处未显式给出，为空）。<code>Dreamview::Init</code> 方法间接调用 <code>apollo/modules/dreamview/backend/hmi/hmi_worker.cc</code> 中的 <code>HMIWorker::LoadMode</code> 方法来处理模式配置文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HMIMode <span class="title">HMIWorker::LoadMode</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; mode_config_path)</span> </span>&#123;</span><br><span class="line">  HMIMode mode;</span><br><span class="line">  ACHECK(cyber::common::GetProtoFromFile(mode_config_path, &amp;mode))</span><br><span class="line">      &lt;&lt; <span class="string">"Unable to parse HMIMode from file "</span> &lt;&lt; mode_config_path;</span><br><span class="line">  <span class="comment">// Translate cyber_modules to regular modules.</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; iter : mode.cyber_modules()) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; module_name = iter.first;</span><br><span class="line">    <span class="keyword">const</span> CyberModule&amp; cyber_module = iter.second;</span><br><span class="line">    <span class="comment">// Each cyber module should have at least one dag file.</span></span><br><span class="line">    ACHECK(!cyber_module.dag_files().empty())</span><br><span class="line">        &lt;&lt; <span class="string">"None dag file is provided for "</span> &lt;&lt; module_name &lt;&lt; <span class="string">" module in "</span></span><br><span class="line">        &lt;&lt; mode_config_path;</span><br><span class="line"></span><br><span class="line">    Module&amp; <span class="keyword">module</span> = LookupOrInsert(mode.mutable_modules(), module_name, &#123;&#125;);</span><br><span class="line">    <span class="keyword">module</span>.set_required_for_safety(cyber_module.required_for_safety());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct start_command:</span></span><br><span class="line">    <span class="comment">//     nohup mainboard -p &lt;process_group&gt; -d &lt;dag&gt; ... &amp;</span></span><br><span class="line">    <span class="keyword">module</span>.set_start_command(<span class="string">"nohup mainboard"</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; process_group = cyber_module.process_group();</span><br><span class="line">    <span class="keyword">if</span> (!process_group.empty()) &#123;</span><br><span class="line">      absl::StrAppend(<span class="keyword">module</span>.mutable_start_command(), <span class="string">" -p "</span>, process_group);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; dag : cyber_module.dag_files()) &#123;</span><br><span class="line">      absl::StrAppend(<span class="keyword">module</span>.mutable_start_command(), <span class="string">" -d "</span>, dag);</span><br><span class="line">    &#125;</span><br><span class="line">    absl::StrAppend(<span class="keyword">module</span>.mutable_start_command(), <span class="string">" &amp;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct stop_command: pkill -f '&lt;dag[0]&gt;'</span></span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; first_dag = cyber_module.dag_files(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">module</span>.set_stop_command(absl::StrCat(<span class="string">"pkill -f \""</span>, first_dag, <span class="string">"\""</span>));</span><br><span class="line">    <span class="comment">// Construct process_monitor_config.</span></span><br><span class="line">    <span class="keyword">module</span>.mutable_process_monitor_config()-&gt;add_command_keywords(<span class="string">"mainboard"</span>);</span><br><span class="line">    <span class="keyword">module</span>.mutable_process_monitor_config()-&gt;add_command_keywords(first_dag);</span><br><span class="line">  &#125;</span><br><span class="line">  mode.clear_cyber_modules();</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Loaded HMI mode: "</span> &lt;&lt; mode.DebugString();</span><br><span class="line">  <span class="keyword">return</span> mode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HMIWorker::LoadMode</code> 方法实现并不复杂，它读取模式配置文件，为每一个 <code>cyber_modules</code> 功能模组生成对应的启动命令 <code>start_command</code>，<code>cyber_modules</code> 中 <code>value</code> 项下的每一个 <code>dag_files</code> 对应启动命令中的一个 <code>-d</code> 选项，例如会为上面提到的 <code>apollo/modules/dreamview/conf/hmi_modes/mkz_standard_debug.pb.txt</code> 中的 Perception 模块字段生成下面的 <code>start_command</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nohup mainboard -d /apollo/modules/perception/production/dag/dag_streaming_perception.dag &amp;</span><br></pre></td></tr></table></figure>
<p>模式配置文件中所有的 <code>cyber_modules</code> 最终会显示在 DreamView 的 Module Controller 界面上：</p>
<p><img data-src="https://image.shipengx.com/DreamView%20Module%20Controller.png" alt="DreamView Module Controller"></p>
<p><strong>2. 启动功能模块</strong></p>
<p>通过 DreamView Module Controller 前端界面上的滑动按钮可以打开或关闭对应模块，当我们滑动某个模块的按钮至开启状态时，相应动作会通过 WebSocket 由前端传递至后端并触发执行 <code>apollo/modules/dreamview/backend/hmi/hmi_worker.cc</code> 中的 <code>HMIWorker::StartModule</code> 方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HMIWorker::StartModule</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; <span class="keyword">module</span>)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Module* module_conf = FindOrNull(current_mode_.modules(), <span class="keyword">module</span>);</span><br><span class="line">  <span class="keyword">if</span> (module_conf != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    System(module_conf-&gt;start_command());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Cannot find module "</span> &lt;&lt; <span class="keyword">module</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">module</span> == <span class="string">"Recorder"</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span>* monitors = FuelMonitorManager::Instance()-&gt;GetCurrentMonitors();</span><br><span class="line">    <span class="keyword">if</span> (monitors != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">      <span class="keyword">auto</span> iter = monitors-&gt;find(FLAGS_data_collection_monitor_name);</span><br><span class="line">      <span class="keyword">if</span> (iter != monitors-&gt;end()) &#123;</span><br><span class="line">        <span class="keyword">auto</span>* data_collection_monitor = iter-&gt;second.get();</span><br><span class="line">        <span class="keyword">if</span> (data_collection_monitor-&gt;IsEnabled() &amp;&amp; record_count_ == <span class="number">0</span>) &#123;</span><br><span class="line">          data_collection_monitor-&gt;Restart();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ++record_count_;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>HMIWorker::StartModule</code> 方法将来自前端的被触发模块的 <code>start_command</code> 传入 <code>System</code> 函数并执行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">System</span><span class="params">(<span class="built_in">std</span>::string_view cmd)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> ret = <span class="built_in">std</span>::system(cmd.data());</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"SUCCESS: "</span> &lt;&lt; cmd;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"FAILED("</span> &lt;&lt; ret &lt;&lt; <span class="string">"): "</span> &lt;&lt; cmd;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>System</code> 函数最终会通过标准库函数 <code>std::system</code> 执行 <code>start_command</code> 中的命令行语句。至此，又回到了 2.1 章节中叙述的启动方式。</p>
<h1 id="3-总结" class="heading-control"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结<a class="heading-anchor" href="#3-总结" aria-hidden="true"></a></h1><p>概括全文，我们可以得到以下结论：</p>
<p><strong>1)</strong> Cyber RT 被构建成名为 <code>mainboard</code> 的可执行文件，Perception 模块被构建成两个分别命名为 <code>libperception_component_camera.so</code> 和 <code>libperception_component_lidar.so</code> 的动态库文件，DreamView 模块被构建成名为 <code>dreamview</code> 的可执行文件；</p>
<p><strong>2)</strong> 对于模块启动，可以使用 <code>mainboard</code> 直接从 DAG 文件启动，也可以使用 <code>cyber_launch</code> 脚本从 Launch 文件间接启动，或者通过 DreamView Module Controller 前端界面进行启动，后面两种方式根本上也是通过 <code>mainboard</code> 读入了相应 DAG 文件进行启动；</p>
<p><strong>3)</strong> 使用 <code>mainboard</code> 从 DAG 文件启动相应功能模块时，主要发生了三件事：</p>
<ul>
<li><strong>加载子功能模块并注册其中的各个组件。</strong> 通过 <code>ClassLoaderManager::LoadLibrary</code> 函数间接调用 Linux 底层的 <code>dlopen</code> 函数来加载 DAG 文件中的各个子功能模块的 <code>.so</code> 动态库文件，每个子功能模块的组件注册过程随着模块 <code>.so</code> 动态库文件的加载一同进行，最终通过 <code>CYBER_REGISTER_COMPONENT</code> 宏来实现组件注册；</li>
<li><strong>实例化具体组件类。</strong> 在 <code>factory_map</code> 中查找各个具体组件类注册过程中生成的对应的类工厂对象，并通过该类工厂对象返回一个具体组件类的指针；</li>
<li><strong>初始化具体组件实例，进入组件内部算法流程。</strong> 每个具体组件类的 <code>Init</code> 方法会在 <code>Component</code> 类的 <code>Initialize</code> 方法中被多态调用一次，而每个具体组件类的 <code>Proc</code> 方法将成为对应 channel 上的消息回调函数，最终，每个组件会对应一个协程。</li>
</ul>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9hcG9sbG8uYXV0by9kb2N1bWVudF9jbi5odG1sP2RvbWFpbj1BcG9sbG8tSG9tZXBhZ2UtRG9jdW1lbnQmYW1wO3JlcG89QXBvbGxvX0RvY19DTl82XzAmYW1wO2ZpbGVwYXRoPS8=" title="https://apollo.auto/document_cn.html?domain=Apollo-Homepage-Document&amp;repo=Apollo_Doc_CN_6_0&amp;filepath=/">CyberRT 介绍<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RhdmlkaG9wcGVyL2FydGljbGUvZGV0YWlscy84NTI0ODc5OQ==" title="https://blog.csdn.net/davidhopper/article/details/85248799">Apollo 3.5 各功能模块的启动过程解析<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTAzNTU4Nzg=" title="https://zhuanlan.zhihu.com/p/350355878">apollo 介绍之 cyber 启动(十九)<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>Apollo</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>Apollo</tag>
        <tag>多传感器信息融合</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 10 章 泛型算法</title>
    <url>/archives/f82eac24.html</url>
    <content><![CDATA[<h1 id="10-1-概述" class="heading-control"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a>10.1 概述<a class="heading-anchor" href="#10-1-概述" aria-hidden="true"></a></h1><ol>
<li><p>标准库的 <a href="http://www.cplusplus.com/reference/algorithm/find/" target="_blank" rel="noopener"><code>find</code></a> 算法可用于查找<strong>输入范围</strong>中是否包含某个指定元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">InputIterator</span> <span class="title">find</span> (<span class="title">InputIterator</span> <span class="title">first</span>, <span class="title">InputI</span></span></span><br><span class="line"><span class="class">  <span class="title">terator</span> <span class="title">last</span>, <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first == val) <span class="keyword">return</span> first;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>标准库的 <a href="http://www.cplusplus.com/reference/algorithm/count/" target="_blank" rel="noopener"><code>count</code></a> 算法可用于查找某个指定元素在输入范围中出现的次数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class">  <span class="title">typename</span> <span class="title">iterator_traits</span>&lt;InputIterator&gt;:</span>:difference_type</span><br><span class="line">    count (InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp; val)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type ret = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">    <span class="keyword">if</span> (*first == val) ++ret;</span><br><span class="line">    ++first;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="10-2-初识泛型算法" class="heading-control"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a>10.2 初识泛型算法<a class="heading-anchor" href="#10-2-初识泛型算法" aria-hidden="true"></a></h1><ol>
<li>除了少数例外，标准库算法都对一个范围内的元素进行操作。我们将此元素范围称为“输入范围”。接受输入范围的算法总是使用前两个参数来表示此范围，两个参数分别是指向要处理的第一个元素和尾元素之后位置的迭代器。</li>
</ol>
<h2 id="10-2-1-只读算法" class="heading-control"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a>10.2.1 只读算法<a class="heading-anchor" href="#10-2-1-只读算法" aria-hidden="true"></a></h2><ol>
<li><p>另一个只读算法是 <code>accumulate</code>，它定义在头文件 <code>numeric</code> 中。<code>accumulate</code> 函数接受三个参数，前两个指出了需要求和的元素的范围，第三个参数是和的初值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对 vec 中的元素求和，和的初值是 0</span></span><br><span class="line"><span class="keyword">int</span> sum = accumulate(vec.cbegin(), vec.cend(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>用于连接 <code>string</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="built_in">string</span>(<span class="string">""</span>));</span><br></pre></td></tr></table></figure>
<p>将空串当做一个字符串字面值传递给第三个参数是不可以的，会导致一个编译错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误：const char* 上没有定义 + 运算符</span></span><br><span class="line"><span class="built_in">string</span> sum = accumulate(v.cbegin(), v.cend(), <span class="string">""</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>另一个只读算法是 <code>equal</code>，用于确定两个序列是否保存相同的值。它将第一个序列中的每个元素与第二个序列中的对应元素进行比较。如果所有对应元素都相等，则返回 <code>true</code>，否则返回 <code>false</code>。此算法接受三个迭代器：前两个（与以往一样）表示第一个序列中的元素范围，第三个表示第二个序列的首元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// roster2 中的元素数目应该至少与 roster1 一样多</span></span><br><span class="line">equal(roster1.cbegin(), roster1.cend(), roster2.cbegin());</span><br></pre></td></tr></table></figure>
<p>由于 <code>equal</code> 利用迭代器完成操作，因此我们可以通过调用 <code>equal</code> 来比较两个不同类型的容器中的元素。而且，元素类型也不必一样，只要我们能用 <code>==</code> 来比较两个元素类型即可。<br>例如，在此例中，roster1 可以是 <code>vector&lt;string&gt;</code>，而 roster2 是 <code>list&lt;const char*&gt;</code>。但是，<strong>equal 基于一个非常重要的假设：它假定第二个序列至少与第一个序列一样长。此算法要处理第一个序列中的每个元素，它假定每个元素在第二个序列中都有一个与之对应的元素</strong>。</p>
</li>
</ol>
<h2 id="10-2-2-写容器元素的算法" class="heading-control"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a>10.2.2 写容器元素的算法<a class="heading-anchor" href="#10-2-2-写容器元素的算法" aria-hidden="true"></a></h2><ol>
<li><p>使用 <code>fill</code> 算法填充容器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">fill(vec.begin(), vec.end(), <span class="number">0</span>); <span class="comment">// 将每个元素重置为 0</span></span><br><span class="line"><span class="comment">// 将容器的一个子序列设置为 10</span></span><br><span class="line">fill(vec.begin(), vec.begin() + vec.size() / <span class="number">2</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>fill_n</code> 算法也可用于填充容器，它接受的是一个迭代器、一个计数值和一个值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">// 空 vector</span></span><br><span class="line"><span class="comment">// 使用 vec，赋予它不同值</span></span><br><span class="line">fill_n(vec.begin(), vec.size(), <span class="number">0</span>); <span class="comment">// 将所有元素重置为 0</span></span><br></pre></td></tr></table></figure>
<p>容易犯的错误是在一个空容器上调用 <code>fill_n</code>（或类似的写元素的算法）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">// 空向量</span></span><br><span class="line"><span class="comment">// 灾难：修改 vec 中的 10 个（不存在）元素</span></span><br><span class="line">fill_n(vec.begin(), <span class="number">10</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARNING：</strong> 向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素。</p>
</blockquote>
</li>
<li><p>一种保证算法有足够元素空间来容纳输出数据的方法是使用<strong>插入迭代器</strong>（insert iterator）。当我们通过一个插入迭代器赋值时，一个与赋值号右侧值相等的元素被添加到容器中。</p>
</li>
<li><p>一个典型的插入迭代器是 <strong><code>back_inserter</code></strong>，它定义在头文件 <code>iterator</code> 中。<code>back_inserter</code> 接受一个指向容器的引用，返回一个与该容器绑定的插入迭代器。当我们通过此迭代器赋值时，赋值运算符会调用 <code>push_back</code> 将一个具有给定值的元素添加到容器中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;              <span class="comment">// 空向量</span></span><br><span class="line"><span class="keyword">auto</span> it = back_inserter(vec); <span class="comment">// 通过它赋值会将元素添加到 vec 中</span></span><br><span class="line">*it = <span class="number">42</span>;                     <span class="comment">// vec 中现在有一个元素，值为42</span></span><br></pre></td></tr></table></figure>
<p>通常使用 <code>back_inserter</code> 来创建一个迭代器，作为算法的目的位置来使用。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec; <span class="comment">// 空向量</span></span><br><span class="line"><span class="comment">// 正确：back_inserter 创建一个插入迭代器，可用来向 vec 添加元素</span></span><br><span class="line">fill_n(back_inserter(vec), <span class="number">10</span>, <span class="number">0</span>); <span class="comment">// 添加 10 个元素到 vec</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以通过 <code>copy</code> 算法实现内置数组的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> al[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> a2[<span class="keyword">sizeof</span>(al) / <span class="keyword">sizeof</span>(*al)]; <span class="comment">// a2 与 a1 大小一样</span></span><br><span class="line"><span class="comment">// ret 指向拷贝到 a2 的尾元素之后的位置</span></span><br><span class="line"><span class="keyword">auto</span> ret = copy(begin(al), end(al), a2); <span class="comment">// 把 a1 的内容拷贝给 a2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>replace</code> 算法读入一个序列，并将其中所有等于给定值的元素都改为另一个值。此算法接受 4 个参数：前两个是迭代器，表示输入序列，后两个一个是要搜索的值，另一个是新值。它将所有等于第一个值的元素替换为第二个值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有值为 0 的元素改为 42</span></span><br><span class="line">replace(ilst.begin(), ilst.end(), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>此调用将序列中所有的 0 都替换为 42。如果我们希望保留原序列不变，可以调用 <code>replace_copy</code>。此算法接受额外第三个迭代器参数，指出调整后序列的保存位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 back_inserter 按需要增长目标序列</span></span><br><span class="line">replace_copy(ilst.cbegin(), ilst.cend(), back_inserter(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>此调用后，ilst 并未改变，ivec 包含 ilst 的一份拷贝，不过原来在 ilst 中值为 0 的元素在 ivec 中都变为 42。</p>
</li>
</ol>
<h2 id="10-2-3-重排容器元素的算法" class="heading-control"><a href="#10-2-3-重排容器元素的算法" class="headerlink" title="10.2.3 重排容器元素的算法"></a>10.2.3 重排容器元素的算法<a class="heading-anchor" href="#10-2-3-重排容器元素的算法" aria-hidden="true"></a></h2><ol>
<li><p>调用 <a href="http://www.cplusplus.com/reference/algorithm/sort/" target="_blank" rel="noopener"><code>sort</code></a> 会重排输入序列中的元素，使之有序，它是利用元素类型的 <code>&lt;</code> 运算符来实现排序的。</p>
</li>
<li><p><strong><a href="http://www.cplusplus.com/reference/algorithm/unique/" target="_blank" rel="noopener"><code>unique</code></a> 算法重排输入序列，将相邻的重复项“消除”，并返回一个指向不重复值范围末尾的迭代器。<code>unique</code> 并不真的删除任何元素，它只是覆盖相邻的重复元素，使得不重复元素出现在序列开始部分。<code>unique</code> 返回的迭代器指向最后一个不重复元素之后的位置，此位置之后的元素仍然存在，但我们不知道它们的值是什么。</strong></p>
</li>
</ol>
<h1 id="10-3-定制操作" class="heading-control"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a>10.3 定制操作<a class="heading-anchor" href="#10-3-定制操作" aria-hidden="true"></a></h1><h2 id="10-3-1-向算法传递函数" class="heading-control"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a>10.3.1 向算法传递函数<a class="heading-anchor" href="#10-3-1-向算法传递函数" aria-hidden="true"></a></h2><ol>
<li><p><code>sort</code> 默认使用 <code>&lt;</code> 运算符进行排序，还可以传给它一个二元比较函数来进行排序，这个二元比较函数称为<strong>谓词</strong>（predicate），标准库算法所使用的谓词分为两类：<strong>一元谓词</strong>（unary predicate，意味着它们只接受单一参数）和<strong>二元谓词</strong>（binary predicate，意味着它们有两个参数）。</p>
</li>
<li><p><a href="http://www.cplusplus.com/reference/algorithm/stable_sort/" target="_blank" rel="noopener"><code>stable_sort</code></a> 算法维持相等元素的原有顺序。</p>
</li>
<li><p><strong>标准库定义了名为 <a href="http://www.cplusplus.com/reference/algorithm/partition/" target="_blank" rel="noopener"><code>partition</code></a> 的算法，它接受一个谓词，对容器内容进行划分，使得谓词为 true 的值会排在容器的前半部分，而使谓词为 false 的值会排在后半部分。算法返回一个迭代器，指向最后一个使谓词为 true 的元素之后的位置。</strong></p>
</li>
</ol>
<h2 id="10-3-2-lambda-表达式" class="heading-control"><a href="#10-3-2-lambda-表达式" class="headerlink" title="10.3.2 lambda 表达式"></a>10.3.2 lambda 表达式<a class="heading-anchor" href="#10-3-2-lambda-表达式" aria-hidden="true"></a></h2><ol>
<li><p>标准库的 <a href="http://www.cplusplus.com/reference/algorithm/find_if/" target="_blank" rel="noopener"><code>find_if</code></a> 算法接受一对迭代器，表示一个范围。但与 <code>find</code> 不同的是，<code>find_if</code> 的第三个参数是一个谓词。<code>find_if</code> 算法对输入序列中的每个元素调用给定的这个谓词。它返回第一个使谓词返回非 0 值的元素，如果不存在这样的元素，则返回尾迭代器。</p>
<blockquote>
<p>Returns an iterator to the first element in the range [first,last) for which pred returns true. If no such element is found, the function returns last.</p>
</blockquote>
</li>
<li><p><strong>lambda 表达式</strong>（lambda expression）是一个<strong>可调用对象</strong>（callable object）。一个 lambda 表达式表示一个可调用的代码单元。我们可以将其理解为一个未命名的内联函数。与任何函数类似，一个 lambda 具有一个返回类型、一个参数列表和一个函数体。但与函数不同，<strong>lambda 可能定义在函数内部</strong>。一个 lambda 表达式具有如下形式：</p>
<p>[capture list] (parameter list) -&gt; return type { fiunction body }</p>
<p>其中，capture list（捕获列表）是一个 lambda 所在函数中定义的局部变量的列表（通常为空）；return type、parameter list 和 function body 与任何普通函数一样，分别表示返回类型、参数列表和函数体。但是，与普通函数不同，lambda 必须使用尾置返回来指定返回类型。<strong>我们可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在 lambda 中忽略括号和参数列表等价于指定一个空参数列表。<strong>如果忽略返回类型，lambda 根据函数体中的代码推断出返回类型。如果函数体只是一个 <code>return</code> 语句，则返回类型从返回的表达式的类型推断而来。否则，返回类型为 <code>void</code>。</strong></p>
<blockquote>
<p><strong>Note：</strong> 如果 lambda 的函数体包含任何单一 <code>return</code> 语句之外的内容，且未指定返回类型，则返回 <code>void</code>。</p>
</blockquote>
</li>
<li><p>与一个普通函数调用类似，调用一个 lambda 时给定的实参被用来初始化 lambda 的形参。通常，实参和形参的类型必须匹配。但与普通函数不同，<strong>lambda 不能有默认参数</strong>。因此，一个 lambda 调用的实参数目永远与形参数目相等。一旦形参初始化完毕，就可以执行函数体了。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span><br><span class="line">&#123; <span class="keyword">return</span> a.size() &lt; b.size(); &#125;</span><br></pre></td></tr></table></figure>
<p>空捕获列表表明此 lambda 不使用它所在函数中的任何局部变量。</p>
</li>
<li><p>虽然一个 lambda 可以出现在一个函数中，使用其局部变量，但它只能使用那些明确指明的变量。一个 lambda 通过将局部变量包含在其捕获列表中来指出将会使用这些变量。捕获列表指引 lambda 在其内部包含访问局部变量所需的信息。</p>
<blockquote>
<p><strong>Note：</strong> 一个 lambda 只有在其捕获列表中捕获一个它所在函数中的局部变量，才能在函数体中使用该变量。</p>
</blockquote>
</li>
<li><p><code>for_each</code> 算法接受一个可调用对象，并对输入序列中每个元素调用此对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印长度大于等于给定值的单词，每个单词后面接一个空格</span></span><br><span class="line">for_each(wc, words.end(),</span><br><span class="line">         [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">         &#123; <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="string">""</span>; &#125;);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p><strong>Note：捕获列表只用于局部非 <code>static</code> 变量，lambda 可以直接使用局部 <code>static</code> 变量和在它所在函数之外声明的名字。</strong></p>
</blockquote>
</li>
</ol>
<h2 id="10-3-3-lambda-捕获和返回" class="heading-control"><a href="#10-3-3-lambda-捕获和返回" class="headerlink" title="10.3.3 lambda 捕获和返回"></a>10.3.3 lambda 捕获和返回<a class="heading-anchor" href="#10-3-3-lambda-捕获和返回" aria-hidden="true"></a></h2><ol>
<li><p>当定义一个 lambda 时，编译器生成一个与 lambda 对应的新的（未命名的）类类型。可以这样理解，当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象：传递的参数就是此编译器生成的类类型的未命名对象。类似的，当使用 <code>auto</code> 定义一个用 lambda 初始化的变量时，定义了一个从 lambda 生成的类型的对象。</p>
</li>
<li><p>默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员。类似任何普通类的数据成员，lambda 的数据成员也在 lambda 对象创建时被初始化。</p>
</li>
<li><p>类似参数传递，变量的捕获方式也可以是值或引用。<strong>与传值参数类似，采用值捕获的前提是变量可以拷贝。与参数不同，被捕获的变量的值是在 lambda 创建时拷贝，而不是调用时拷贝。由于被捕获变量的值是在 lambda 创建时拷贝，因此随后对其修改不会影响到 lambda 内对应的值。</strong></p>
</li>
<li><p>一个以引用方式捕获的变量与其他任何类型的引用的行为类似。当我们在 lambda 函数体内使用此变量时，实际上使用的是引用所绑定的对象。<strong>如果我们采用引用方式捕获一个变量，就必须确保被引用的对象在 lambda 执行的时候是存在的。</strong> lambda 捕获的都是局部变量，这些变量在函数结束后就不复存在了。如果 lambda 可能在函数结束后执行，捕获的引用指向的局部变量已经消失。</p>
</li>
<li><p>我们也可以从一个函数返回 lambda。函数可以直接返回一个可调用对象，或者返回一个类对象，该类含有可调用对象的数据成员。<strong>如果函数返回一个 lambda，则与函数不能返回一个局部变量的引用类似，此 lambda 也不能包含引用捕获。</strong></p>
</li>
<li><blockquote>
<p><strong>WARNING：当以引用方式捕获一个变量时，必须保证在 lambda 执行时变量是存在的。</strong></p>
</blockquote>
</li>
<li><blockquote>
<p><strong>建议：尽量保持 lambda 的变量捕获简单化。</strong> 如果我们捕获一个指针或迭代器，或采用引用捕获方式，就必须确保在 lambda 执行时，绑定到迭代器、指针或引用的对象仍然存在。而且，需要保证对象具有预期的值。在 lambda 从创建到它执行的这段时间内，可能有代码改变绑定的对象的值。也就是说，在指针（或引用）被捕获的时刻，绑定的对象的值是我们所期望的，但在 lambda 执行时，该对象的值可能已经完全不同了。一般来说，我们应该尽量减少捕获的数据量，来避免潜在的捕获导致的问题。而且，如果可能的话，应该避免捕获指针或引用。</p>
</blockquote>
</li>
<li><p>除了显式列出我们希望使用的来自所在函数的变量之外，还可以让编译器根据 lambda 体中的代码来推断我们要使用哪些变量。<strong>为了指示编译器推断捕获列表，应在捕获列表中写一个 <code>&amp;</code> 或 <code>=</code>。<code>&amp;</code> 告诉编译器采用捕获引用方式，<code>=</code> 则表示采用值捕获方式。</strong></p>
</li>
<li><p>如果我们希望对一部分变量采用值捕获，对其他变量采用引用捕获，可以混合使用隐式捕获和显式捕获：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os 隐式捕获，引用捕获方式；c 显式捕获，值捕获方式</span></span><br><span class="line">for_each(words.begin(), words.end(),</span><br><span class="line">         [&amp;, c](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">         &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br><span class="line"><span class="comment">// os 显式捕获，引用捕获方式；c 隐式捕获，值捕获方式</span></span><br><span class="line">for_each(words.begin(), words.end(),</span><br><span class="line">         [=, &amp;os](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span><br><span class="line">         &#123; os &lt;&lt; s &lt;&lt; c; &#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当我们混合使用隐式捕获和显式捕获时，捕获列表中的第一个元素必须是一个 <code>&amp;</code> 或<code>=</code>。此符号指定了默认捕获方式为引用或值。当混合使用隐式捕获和显式捕获时，显式捕获的变量必须使用与隐式捕获不同的方式。即，如果隐式捕获是引用方式（使用了 <code>&amp;</code>），则显式捕获命名变量必须采用值方式，因此不能在其名字前使用 <code>&amp;</code>。类似的，如果隐式捕获采用的是值方式（使用了 <code>=</code>），则显式捕获命名变量必须采用引用方式，即，在名字前使用 <code>&amp;</code>。</strong></p>
</li>
<li><p>lambda 捕获列表：</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>lambda 捕获列表</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-cly1">[]</td>
    <td class="tg-0lax">空捕获列表。lambda 不能使用所在函数中的变量。一个 lambda 只有捕获变量后才能使用它们</td>
  </tr>
  <tr>
    <td class="tg-cly1">[names]</td>
    <td class="tg-0lax">names 是一个逗号分隔的名字列表，这些名字都是 lambda 所在函数的局部变量。默认情况下，捕获列表中的变量都被拷贝。名字前如果使用了 &amp;，则采用引用捕获方式</td>
  </tr>
  <tr>
    <td class="tg-cly1">[&amp;]</td>
    <td class="tg-0lax">隐式捕获列表，采用引用捕获方式。lambda 体中所使用的来自所在函数的实体都采用引用方式使用</td>
  </tr>
  <tr>
    <td class="tg-cly1">[=]</td>
    <td class="tg-0lax">隐式捕获列表，采用值捕获方式。lambda 体将拷贝所使用的来自所在函数的实体的值</td>
  </tr>
  <tr>
    <td class="tg-cly1">[&amp;, identifier_list]</td>
    <td class="tg-0lax">identifier_list 是一个逗号分隔的列表，包含 0 个或多个来自所在函数的变量。这些变量采用值捕获方式，而任何隐式捕获的变量都采用引用方式捕获。identifier_list 中的名字前面不能使用 &amp;</td>
  </tr>
  <tr>
    <td class="tg-cly1">[=, identifier_list]</td>
    <td class="tg-0lax">identifier_list 中的变量都采用引用方式捕获，而任何隐式捕获的变量都采用值方式捕获。identifier_list 中的名字不能包括 this，且这些名字之前必须使用 &amp;</td>
  </tr>
</tbody>
</table>
</li>
<li><p>默认情况下，对于一个值被拷贝的变量，lambda 不会改变其值。如果我们希望能改变一个被捕获的变量的值，就必须在参数列表首加上关键字 <code>mutable</code>。因此，可变 lambda 能省略参数列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fcn3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> v1 = <span class="number">42</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="comment">// f 可以改变它所捕获的变量的值</span></span><br><span class="line">    <span class="keyword">auto</span> f = [v1]() <span class="keyword">mutable</span> &#123; <span class="keyword">return</span> ++v1; &#125;;</span><br><span class="line">    v1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">auto</span> j = f(); <span class="comment">// j 为 43</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个引用捕获的变量是否（如往常一样）可以修改依赖于此引用指向的是一个 <code>const</code> 类型还是一个非 <code>const</code> 类型。</p>
</li>
<li><p>默认情况下，如果一个 lambda 体包含 <code>return</code> 之外的任何语句，则编译器假定此 lambda 返回 <code>void</code>。与其他返回 <code>void</code> 的函数类似，被推断返回 <code>void</code> 的 lambda 不能返回值。</p>
</li>
<li><p>可以使用标准库 <code>transform</code> 算法和一个 lambda 来将一个序列中的每个负数替换为其绝对值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">transform(vi.begin(), vi.end(), vi.begin(),</span><br><span class="line">          [](<span class="keyword">int</span> i)</span><br><span class="line">          &#123; <span class="keyword">return</span> i &lt; <span class="number">0</span> ? -i : i; &#125;);</span><br></pre></td></tr></table></figure>
<p>函数 <code>transform</code> 接受三个迭代器和一个可调用对象。前两个迭代器表示输入序列，第三个迭代器表示目的位置。算法对输入序列中每个元素调用可调用对象，并将结果写到目的位置。如本例所示，目的位置迭代器与表示输入序列开始位置的迭代器可以是相同的。当输入迭代器和目的迭代器相同时，<code>transform</code> 将输入序列中每个元素替换为可调用对象操作该元素得到的结果。</p>
</li>
<li><p>当我们需要为一个 lambda 定义返回类型时，必须使用尾置返回类型。</p>
</li>
<li><p>标准库定义了一个名为 <code>count_if</code> 的算法。类似 <code>find_if</code>，此函数接受一对迭代器，表示一个输入范围，还接受一个谓词，会对输入范围中每个元素执行。<strong><code>count_if</code> 返回一个计数值，表示谓词有多少次为真。</strong></p>
</li>
<li><p><strong>练习 10.21：</strong> 编写一个 lambda，捕获一个局部 <code>int</code> 变量，并递减变量值，直至它变为 0。一旦变量变为 0，再调用 lambda 应该不再递减变量。lambda 应该返回一个 <code>bool</code> 值，指出捕获的变量是否为 0。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> func = [&amp;sum]() -&gt; <span class="keyword">bool</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        --sum;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="10-3-4-参数绑定" class="heading-control"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a>10.3.4 参数绑定<a class="heading-anchor" href="#10-3-4-参数绑定" aria-hidden="true"></a></h2><ol>
<li><p>对于那种只在一两个地方使用的简单操作，lambda 表达式是最有用的。如果我们需要在很多地方使用相同的操作，通常应该定义一个函数，而不是多次编写相同的 lambda 表达式。类似的，如果一个操作需要很多语句才能完成，通常使用函数更好。</p>
</li>
<li><p>C++11 引入一个名为 <a href="http://www.cplusplus.com/reference/functional/bind/" target="_blank" rel="noopener"><code>bind</code></a> 的标准库函数，它定义在头文件 <code>functional</code> 中。可以将 <code>bind</code> 函数看作一个通用的函数适配器，它接受一个可调用对象，生成一个新的可调用对象来“适应”原对象的参数列表。调用 <code>bind</code> 的一般形式为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list);</span><br></pre></td></tr></table></figure>
<p>其中，newCallable 本身是一个可调用对象，arg_list 是一个逗号分隔的参数列表，对应给定的 callable 的参数。即，当我们调用 newCallable 时，newCallable 会调用 callable，并传递给它 arg_list 中的参数。arg_list 中的参数可能包含形如 _n 的名字，其中 n 是一个整数。这些参数是“占位符”，表示 newCallable 的参数，它们占据了传递给 newCallable 的参数的“位置”。数值 n 表示生成的可调用对象中参数的位置：1 为 newCallable 的第一个参数，2 为第二个参数，依此类推。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// check6 是一个可调用对象，接受一个 string 类型的参数</span></span><br><span class="line"><span class="comment">// 并用此 string 和值 6 来调用 check_size</span></span><br><span class="line"><span class="keyword">auto</span> check6 = bind(check_size, _1, <span class="number">6</span>);</span><br></pre></td></tr></table></figure>
<p>此 <code>bind</code> 调用只有一个占位符，表示 check6 只接受单一参数。占位符出现在 arg_list 的第一个位置，表示 check6 的此参数对应 check_size 的第一个参数。</p>
</li>
<li><p>名字 _n 都定义在一个名为 <code>placeholders</code> 的命名空间中，而这个命名空间本身定义在 <code>std</code> 命名空间中。<code>placeholders</code> 命名空间也定义在 <code>functional</code> 头文件中。</p>
</li>
<li><p>下面的典型示例说明了 <code>bind</code> 的用法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// g 是一个有两个参数的可调用对象</span></span><br><span class="line"><span class="keyword">auto</span> g = bind(f, a, b, _2, c, _1);</span><br></pre></td></tr></table></figure>
<p>上述 <code>bind</code> 调用生成一个新的可调用对象，它有两个参数，分别用占位符 _2 和 _1 表示。这个新的可调用对象将它自己的参数作为第三个和第五个参数传递给 f。f 的第一个、第二个和第四个参数分别被绑定到给定的值 a、b 和 c 上。</p>
<p>传递给 g 的参数按位置绑定到占位符。即，第一个参数绑定到 _1，第二个参数绑定到 _2。因此，当我们调用 g 时，其第一个参数将被传递给 f 作为最后一个参数，第二个参数将被传递给 f 作为第三个参数。实际上，这个 <code>bind</code> 调用会将</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">g(_1, _2);</span><br></pre></td></tr></table></figure>
<p>映射为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f(a, b, _2, c, _1)</span><br></pre></td></tr></table></figure>
<p>即，对 g 的调用会调用 f，用 g 的参数代替占位符，再加上绑定的参数 a、b 和 c。例如，调用 g(X, Y) 会调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f(a, b, Y, c, X)</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认情况下，<code>bind</code> 的那些不是占位符的参数被拷贝到 <code>bind</code> 返回的可调用对象中。但是，与 lambda 类似，有时对有些绑定的参数我们希望以引用方式传递，或是要绑定参数的类型无法拷贝，例如 <code>ostream</code> 类型，我们不能拷贝一个 <code>ostream</code>。如果我们希望传递给 <code>bind</code> 一个对象而又不拷贝它，就必须使用标准库 <strong><code>ref</code></strong> 函数，函数 <code>ref</code> 返回一个对象，包含给定的引用，此对象是可以拷贝的。标准库中还有一个 <code>cref</code> 函数，生成一个保存 <code>const</code> 引用的类。与 <code>bind</code> 一样，函数 <code>ref</code> 和 <code>cref</code> 也定义在头文件 <code>functional</code> 中。</p>
</li>
<li><p><strong>练习 10.24：</strong> 给定一个 <code>string</code>，使用 <code>bind</code> 和 <code>check_size</code> 在一个 <code>int</code> 的 <code>vector</code> 中查找第一个大于 <code>string</code> 长度的值。</p>
<p>注意是要查找第一个大于 <code>string</code> 长度的值，而 <code>check_size</code> 检查的是 <code>sz</code> 是否小于等于 <code>string</code> 长度，所以此处使用 <code>find_if_not</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s, <span class="built_in">string</span>::size_type sz)</span> </span>&#123; <span class="keyword">return</span> s.size() &gt;= sz; &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">"test"</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">10</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> iter = find_if_not(vec.begin(), vec.end(), bind(check_size, str, _1));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"result is "</span> &lt;&lt; (iter == vec.end() ? <span class="string">"null"</span> : to_string(*iter)) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="10-4-再探迭代器" class="heading-control"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a>10.4 再探迭代器<a class="heading-anchor" href="#10-4-再探迭代器" aria-hidden="true"></a></h1><ol>
<li>除了容器迭代器，标准库在头文件 <code>iterator</code> 中还定义了额外几种迭代器：<ul>
<li><strong>插入迭代器</strong>（insert iterator）：这些迭代器被绑定到一个容器上，可用来向容器插入元素。</li>
<li><strong>流迭代器</strong>（stream iterator）：这些迭代器被绑定到输入或输出流上，可用来遍历所关联的 IO 流。</li>
<li><strong>反向迭代器</strong>（reverse iterator）：这些迭代器向后而不是向前移动。除了 <code>forward_list</code> 之外的标准库容器都有反向迭代器。</li>
<li><strong>移动迭代器</strong>（move iterator）：这些专用的迭代器不是拷贝其中的元素，而是移动它们。</li>
</ul>
</li>
</ol>
<h2 id="10-4-1-插入迭代器" class="heading-control"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a>10.4.1 插入迭代器<a class="heading-anchor" href="#10-4-1-插入迭代器" aria-hidden="true"></a></h2><ol>
<li><p>插入器有三种类型，差异在于元素插入的位置：</p>
<ul>
<li><strong><code>back_inserter</code></strong> 创建一个使用 <code>push_back</code> 的迭代器。</li>
<li><strong><code>front_inserter</code></strong> 创建一个使用 <code>push_front</code> 的迭代器。</li>
<li><strong><code>inserter</code></strong> 创建一个使用 <code>insert</code> 的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器。元素将被插入到给定迭代器所表示的元素之前。</li>
</ul>
<blockquote>
<p>只有在容器支持 <code>push_front</code> 的情况下，我们才可以使用 <code>front_inserter</code>。类似的，只有在容器支持 <code>push_back</code> 的情况下，我们才能使用 <code>back_inserter</code>。</p>
</blockquote>
</li>
<li><p>如果 it 是由 <code>inserter</code> 生成的迭代器，则下面这样的赋值语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*it = val;</span><br></pre></td></tr></table></figure>
<p>其效果与下面代码一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">it = c.insert(it, val); <span class="comment">// it 指向新加入的元素</span></span><br><span class="line">++it;                   <span class="comment">// 递增 it 使它指向原来的元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>front_inserter</code> 生成的迭代器的行为与 <code>inserter</code> 生成的迭代器完全不一样。<strong>当我们使用 <code>front_inserter</code> 时，元素总是插入到容器第一个元素之前。即使我们传递给 <code>inserter</code> 的位置原来指向第一个元素，只要我们在此元素之前插入一个新元素，此元素就不再是容器的首元素了</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2, lst3; <span class="comment">// 空 list</span></span><br><span class="line"><span class="comment">// 拷贝完成之后，lst2 包含 4 3 2 1</span></span><br><span class="line">copy(lst.cbegin(), lst.cend(), front_inserter(lst2));</span><br><span class="line"><span class="comment">// 拷贝完成之后，1st3 包含 1 2 3 4</span></span><br><span class="line">copy(lst.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));</span><br></pre></td></tr></table></figure>
<p>当调用 <code>front_inserter(c)</code> 时，我们得到一个插入迭代器，接下来会调用 <code>push_front</code>。当每个元素被插入到容器 c 中时，它变为 c 的新的首元素。因此，<code>front_inserter</code> 生成的迭代器会将插入的元素序列的顺序颠倒过来，而 <code>inserter</code> 和 <code>back_inserter</code> 则不会。</p>
</li>
<li><p>除了 <code>unique</code> 之外，标准库还定义了名为 <code>unique_copy</code> 的函数，它接受第三个迭代器，表示拷贝不重复元素的目的位置。</p>
</li>
</ol>
<h2 id="10-4-2-iostream-迭代器" class="heading-control"><a href="#10-4-2-iostream-迭代器" class="headerlink" title="10.4.2 iostream 迭代器"></a>10.4.2 iostream 迭代器<a class="heading-anchor" href="#10-4-2-iostream-迭代器" aria-hidden="true"></a></h2><ol>
<li><p>虽然 <code>iostream</code> 类型不是容器，但标准库定义了可以用于这些 IO 类型对象的迭代器。<code>istream_iterator</code> 读取输入流，<code>ostream_iterator</code> 向一个输出流写数据。这些迭代器将它们对应的流当作一个特定类型的元素序列来处理。通过使用流迭代器，我们可以用泛型算法从流对象读取数据以及向其写入数据。</p>
</li>
<li><p>当创建一个流迭代器时，必须指定迭代器将要读写的对象类型。一个 <code>istream_iterator</code> 使用 <code>&gt;&gt;</code> 来读取流。因此，<code>istream_iterator</code> 要读取的类型必须定义了输入运算符。<strong>当创建一个 <code>istream_iterator</code> 时，我们可以将它绑定到一个流。当然，我们还可以默认初始化迭代器，这样就创建了一个可以当作尾后值使用的迭代器。</strong></p>
</li>
<li><p>下面是一个用 <code>istream_iterator</code> 从标准输入读取数据，存入一个 <code>vector</code> 的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">in_iter</span><span class="params">(<span class="built_in">cin</span>)</span></span>; <span class="comment">// 从 cin 读取 int</span></span><br><span class="line">istream_iterator&lt;<span class="keyword">int</span>&gt; eof;          <span class="comment">// istream 尾后迭代器</span></span><br><span class="line"><span class="keyword">while</span> (in_iter != eof)              <span class="comment">// 当有数据可供读取时</span></span><br><span class="line">    <span class="comment">// 后置递增运算读取流，返回迭代器的旧值</span></span><br><span class="line">    <span class="comment">// 解引用迭代器，获得从流读取的前一个值</span></span><br><span class="line">    vec.push_back(*in_iter++);</span><br></pre></td></tr></table></figure>
<p><strong>对于一个绑定到流的迭代器，一旦其关联的流遇到文件尾或遇到 IO 错误，迭代器的值就与尾后迭代器相等。</strong></p>
</li>
<li><p>通过 <code>istream_iterator</code> 从 <code>cin</code> 中读取数据，并直接构造 <code>vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in_iter(cin), eof; // 从 cin 读取 int</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;           <span class="comment">// 从迭代器范围构造 vec</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>istream_iterator</code> 支持的操作：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>istream_iterator 操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi">istream_iterator&lt;T&gt; in(is);</td>
    <td class="tg-0pky">in 从输入流 is 读取类型为 T 的值</td>
  </tr>
  <tr>
    <td class="tg-0pky">istream_iterator&lt;T&gt; end;</td>
    <td class="tg-0pky">读取类型为 T 的值的 istream_iterator 迭代器，表示尾后位置</td>
  </tr>
  <tr>
    <td class="tg-lboi">in1 == in2</td>
    <td class="tg-lboi" rowspan="2">in1 和 in2 必须读取相同类型。如果它们都是尾后迭代器，或绑定到相同的输入，则两者相等</td>
  </tr>
  <tr>
    <td class="tg-0pky">in1 != in2</td>
  </tr>
  <tr>
    <td class="tg-lboi">*in</td>
    <td class="tg-0pky">返回从流中读取的值</td>
  </tr>
  <tr>
    <td class="tg-lboi">in-&gt;mem</td>
    <td class="tg-0pky">与 (*in).mem 的含义相同</td>
  </tr>
  <tr>
    <td class="tg-0lax">++in，in++</td>
    <td class="tg-0lax">使用元素类型所定义的 &gt;&gt; 运算符从输入流中读取下一个值。与以往一样，前置版本返回一个指向递增后迭代器的引用，后置版本返回旧值</td>
  </tr>
</tbody>
</table>
</li>
<li><p>可以用一对 <code>istream_iterator</code> 来调用 <code>accumulate</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in(cin), eof;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(in, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们将一个 <code>istream_iterator</code> 绑定到一个流时，标准库并不保证迭代器立即从流读取数据。具体实现可以推迟从流中读取数据，直到我们使用迭代器时才真正读取。标准库中的实现所保证的是，在我们第一次解引用迭代器之前，从流中读取数据的操作已经完成了。对于大多数程序来说，立即读取还是推迟读取没什么差别。但是，如果我们创建了一个 <code>istream_iterator</code>，没有使用就销毁了，或者我们正在从两个不同的对象同步读取同一个流，那么何时读取可能就很重要了。</p>
</li>
<li><p>我们可以对任何具有输出运算符（<code>&lt;&lt;</code> 运算符）的类型定义 <code>ostream_iterator</code>。当创建一个 <code>ostream_iterator</code> 时，我们可以提供（可选的）第二参数，它是一个字符串，在输出每个元素后都会打印此字符串。此字符串必须是一个 C 风格字符串（即，一个字符串字面常量或者一个指向以空字符结尾的字符数组的指针）。<strong>必须将 <code>ostream_iterator</code> 绑定到一个指定的流，不允许空的或表示尾后位置的 <code>ostream_iterator</code>。</strong></p>
</li>
<li><p><code>ostream_iterator</code> 支持的操作：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>ostream_iterator 操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi">ostream_iterator out(os);</td>
    <td class="tg-0pky">out 将类型为 T 的值写到输出流 os 中</td>
  </tr>
  <tr>
    <td class="tg-0pky">ostream_iterator out(os, d);</td>
    <td class="tg-0pky">out 将类型为 T 的值写到输出流 os 中，每个值后面都输出一个 d。d 指向一个空字符结尾的字符数组</td>
  </tr>
  <tr>
    <td class="tg-0pky">out = val</td>
    <td class="tg-0pky">用 &lt;&lt; 运算符将 val 写入到 out 所绑定的 ostream 中。val 的类型必须与 out 可写的类型兼容</td>
  </tr>
  <tr>
    <td class="tg-lboi">*out, ++out, out++</td>
    <td class="tg-0pky">这些运算符是存在的，但不对 out 做任何事情。每个运算符都返回 out</td>
  </tr>
</tbody>
</table>
</li>
<li><p>我们可以用 <code>ostream_iterator</code> 来输出值的序列：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="keyword">int</span>&gt; <span class="title">out_iter</span><span class="params">(<span class="built_in">cout</span>, <span class="string">""</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">    *out_iter++ = e; <span class="comment">// 赋值语句实际上将元素写到 cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>此程序将 vec 中的每个元素写到 <code>cout</code>，每个元素后加一个空格。每次向 out_iter 赋值时，写操作就会被提交。值得注意的是，当我们向 out_iter 赋值时，可以忽略解引用和递增运算。即，循环可以重写成下面的样子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> e : vec)</span><br><span class="line">    out_iter = e; <span class="comment">// 赋值语句将元素写到 cout</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>运算符 <code>*</code> 和 <code>++</code> 实际上对 <code>ostream_iterator</code> 对象不做任何事情，因此忽略它们对我们的程序没有任何影响。但是，推荐第一种形式。在这种写法中，流迭代器的使用与其他迭代器的使用保持一致。如果想将此循环改为操作其他迭代器类型，修改起来非常容易。而且，对于读者来说，此循环的行为也更为清晰。</p>
</li>
<li><p>可以通过调用 <code>copy</code> 来打印 vec 中的元素，这比编写循环更为简单：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">copy(vec.begin(), vec.end(), out_iter);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们可以为任何定义了输入运算符（<code>&gt;&gt;</code>）的类型创建 <code>istream_iterator</code> 对象。类似的，只要类型有输出运算符（<code>&lt;&lt;</code>），我们就可以为其定义 <code>ostream_iterator</code>。</p>
</li>
</ol>
<h2 id="10-4-3-反向迭代器" class="heading-control"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a>10.4.3 反向迭代器<a class="heading-anchor" href="#10-4-3-反向迭代器" aria-hidden="true"></a></h2><ol>
<li><p>反向迭代器就是在容器中从尾元素向首元素反向移动的迭代器。对于反向迭代器，递增（以及递减）操作的含义会颠倒过来。<strong>递增一个反向迭代器（<code>++it</code>）会移动到前一个元素；递减一个迭代器（<code>--it</code>）会移动到下一个元素。</strong></p>
</li>
<li><p>除了 <code>forward_list</code> 之外，其他容器都支持反向迭代器。我们可以通过调用 <code>rbegin</code>、<code>rend</code>、<code>crbegin</code> 和 <code>crend</code> 成员函数来获得反向迭代器。这些成员函数返回指向容器尾元素和首元素之前一个位置的迭代器。与普通迭代器一样，反向迭代器也有 <code>const</code> 和非 <code>const</code> 版本。</p>
</li>
<li><p>可以通过向 <code>sort</code> 传递一对反向迭代器来将 <code>vector</code> 整理为递减序。</p>
</li>
<li><p>除了 <code>forward_list</code> 之外，标准容器上的其他迭代器都既支持递增运算又支持递减运算。但是，<strong>流迭代器不支持递减运算，因为不可能在一个流中反向移动</strong>。因此，<strong>不可能从一个 <code>forward_list</code> 或一个流迭代器创建反向迭代器</strong>。</p>
</li>
<li><p>通过调用 <code>reverse_iterator</code> 的 <code>base</code> 成员函数可以返回其对应的普通迭代器。下图展示了反向迭代器和普通迭代器间的关系：</p>
<p><img data-src="https://image.shipengx.com/%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E6%99%AE%E9%80%9A%E8%BF%AD%E4%BB%A3%E5%99%A8%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="反向迭代器和普通迭代器间的关系"></p>
<p><code>rcomma</code> 和 <code>rcomma.base()</code> 指向不同的元素，<code>line.crbegin</code> 和 <code>line.cend()</code> 也是如此。这些不同保证了元素范围无论是正向处理还是反向处理都是相同的。</p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 反向迭代器的目的是表示元素范围，而这些范围是不对称的，这导致一个重要的结果：<strong>当我们从一个普通迭代器初始化一个反向迭代器，或是给一个反向迭代器赋值时，结果迭代器与原迭代器指向的并不是相同的元素</strong>。</p>
</blockquote>
</li>
</ol>
<h1 id="10-5-泛型算法结构" class="heading-control"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a>10.5 泛型算法结构<a class="heading-anchor" href="#10-5-泛型算法结构" aria-hidden="true"></a></h1><h2 id="10-5-1-5-类迭代器" class="heading-control"><a href="#10-5-1-5-类迭代器" class="headerlink" title="10.5.1 5 类迭代器"></a>10.5.1 5 类迭代器<a class="heading-anchor" href="#10-5-1-5-类迭代器" aria-hidden="true"></a></h2><ol>
<li><blockquote>
<p><strong>WARNING：</strong> 对于向一个算法传递错误类别的迭代器的问题，很多编译器不会给出任何警告或提示。</p>
</blockquote>
</li>
<li><p>迭代器有 5 类：</p>
<ul>
<li><strong>输入迭代器</strong>（input iterator）。算法 <code>find</code> 和 <code>accumulate</code> 要求输入迭代器；而 <code>istream_iterator</code> 是一种输入迭代器。</li>
<li><strong>输出迭代器</strong>（output iterator）。<code>copy</code> 函数的第三个参数就是输出迭代器。<code>ostream_iterator</code> 类型也是输出迭代器。</li>
<li><strong>前向迭代器</strong>（forward iterator）。算法 <code>replace</code> 要求前向迭代器，<code>forward_list</code> 上的迭代器是前向迭代器。</li>
<li><strong>双向迭代器</strong>（bidirectional iterator）。算法 <code>reverse</code> 要求双向迭代器，除了 <code>forward_list</code> 之外，其他标准库都提供符合双向迭代器要求的迭代器。</li>
<li><strong>随机访问迭代器</strong>（random-access iterator）。算法 <code>sort</code> 要求随机访问迭代器。<code>array</code>、<code>deque</code>、<code>string</code> 和 <code>vector</code> 的迭代器都是随机访问迭代器，用于访问内置数组元素的指针也是。</li>
</ul>
</li>
</ol>
<h2 id="10-5-2-算法形参模式" class="heading-control"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a>10.5.2 算法形参模式<a class="heading-anchor" href="#10-5-2-算法形参模式" aria-hidden="true"></a></h2><ol>
<li><p>大多数算法具有如下 4 种形式之一：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alg(beg, end, other args);</span><br><span class="line">alg(beg, end, dest, other args);</span><br><span class="line">alg(beg, end, beg2, other args);</span><br><span class="line">alg(beg, end, beg2, end2, other args);</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARNING：</strong> 向输出迭代器写入数据的算法都假定目标空间足够容纳写入的数据。</p>
</blockquote>
<p>如果 dest 是一个直接指向容器的迭代器，那么算法将输出数据写到容器中已存在的元素内。更常见的情况是，dest 被绑定到一个插入迭代器或是一个 <code>ostream_iterator</code>。插入迭代器会将新元素添加到容器中，因而保证空间是足够的。<code>ostream_iterator</code> 会将数据写入到一个输出流，同样不管要写入多少个元素都没有问题。</p>
<blockquote>
<p><strong>WARNING：</strong> 接受单独 beg2 的算法假定从 beg2 开始的序列与 beg 和 end 所表示的范围至少一样大。</p>
</blockquote>
</li>
</ol>
<h2 id="10-5-3-算法命名规范" class="heading-control"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a>10.5.3 算法命名规范<a class="heading-anchor" href="#10-5-3-算法命名规范" aria-hidden="true"></a></h2><ol>
<li><p>接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，该版本接受一个谓词代替元素值。接受谓词参数的算法都有附加的 <code>if</code> 前缀：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">find(beg, end, val);     <span class="comment">// 查找输入范围中 val 第一次出现的位置</span></span><br><span class="line">find_if(beg, end, pred); <span class="comment">// 查找第一个令 pred 为真的元素</span></span><br></pre></td></tr></table></figure>
<p>这两个算法都在输入范围中查找特定元素第一次出现的位置。算法 <code>find</code> 查找一个指定值；算法 <code>find_if</code> 查找使得 pred 返回非零值的元素。</p>
</li>
<li><p>默认情况下，重排元素的算法将重排后的元素写回给定的输入序列中。这些算法还提供另一个版本，将元素写到一个指定的输出目的位置。如我们所见，写到额外目的空间的算法都在名字后面附加一个 <code>_copy</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">reverse(beg, end);            <span class="comment">// 反转输入范围中元素的顺序</span></span><br><span class="line">reverse_copy(beg, end, dest); <span class="comment">// 将元素按逆序拷贝到 dest</span></span><br></pre></td></tr></table></figure>
<p>一些算法同时提供 <code>_copy</code> 和 <code>_if</code> 版本。这些版本接受一个目的位置迭代器和一个谓词：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从 v1 中删除奇数元素</span></span><br><span class="line">remove_if(v1.begin(), v1.end(),</span><br><span class="line">          [](<span class="keyword">int</span> i)</span><br><span class="line">          &#123; <span class="keyword">return</span> i % <span class="number">2</span>; &#125;);</span><br><span class="line"><span class="comment">// 将偶数元素从 v1 拷贝到 v2；v1 不变</span></span><br><span class="line">remove_copy_if(v1.begin(), v1.end(), back_inserter(v2),</span><br><span class="line">               [](<span class="keyword">int</span> i)</span><br><span class="line">               &#123; <span class="keyword">return</span> i % <span class="number">2</span>; &#125;);</span><br></pre></td></tr></table></figure>
<p>两个算法都调用了 lambda 来确定元素是否为奇数。在第一个调用中，我们从输入序列中将奇数元素删除。在第二个调用中，我们将非奇数（亦即偶数）元素从输入范围拷贝到 v2 中。</p>
</li>
</ol>
<h1 id="10-6-特定容器算法" class="heading-control"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a>10.6 特定容器算法<a class="heading-anchor" href="#10-6-特定容器算法" aria-hidden="true"></a></h1><ol>
<li><p><code>list</code> 和 <code>forward_list</code> 定义了独有的 <code>sort</code>、<code>merge</code>、<code>remove</code>、<code>reverse</code> 和 <code>unique</code>。链表类型定义的其他算法的通用版本可以用于链表，但代价太高。这些算法需要交换输入序列中的元素。一个链表可以通过改变元素间的链接而不是真的交换它们的值来快速“交换”元素。因此，这些链表版本的算法的性能比对应的通用版本好得多。</p>
<blockquote>
<p><strong>最佳实践：对于 <code>list</code> 和 <code>forward_list</code>，应该优先使用成员函数版本的算法而不是通用算法。</strong></p>
</blockquote>
</li>
<li><p><code>list</code> 和 <code>forward_list</code> 成员函数版本的算法如下表所示，这些操作都返回 <code>void</code>：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>list 和 forward_list 成员函数版本的算法</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi">lst.merge(lst2)</td>
    <td class="tg-lboi" rowspan="2">将来自 lst2 的元素合并入 lst。lst 和 lst2 都必须是有序的。元素将从 lst2 中删除。在合并之后，lst2 变为空。第一个版本使用 &lt; 运算符；第二个版本使用给定的比较操作</td>
  </tr>
  <tr>
    <td class="tg-0pky">lst.merge(lst2, comp)</td>
  </tr>
  <tr>
    <td class="tg-0pky">lst.remove(val)</td>
    <td class="tg-lboi" rowspan="2">调用 erase 删除掉与给定值相等（==）或令一元谓词为真的每个元素</td>
  </tr>
  <tr>
    <td class="tg-lboi">lst.remove_if(pred)</td>
  </tr>
  <tr>
    <td class="tg-0lax">lst.reverse()</td>
    <td class="tg-0lax">反转 lst 中元素的顺序</td>
  </tr>
  <tr>
    <td class="tg-0lax">lst.sort()</td>
    <td class="tg-cly1" rowspan="2">使用 &lt; 或给定比较操作排序元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">lst.sort(comp)</td>
  </tr>
  <tr>
    <td class="tg-0lax">lst.unique()</td>
    <td class="tg-cly1" rowspan="2">调用 erase 删除同一个值的连续拷贝。第一个版本使用 ==；第二个版本使用给定的二元谓词</td>
  </tr>
  <tr>
    <td class="tg-0lax">lst.unique(pred)</td>
  </tr>
</tbody>
</table>
</li>
<li><p>链表类型还定义了 <code>splice</code> 算法，此算法是链表数据结构所特有的：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>list 和 forward_list 的 splice 成员函数的参数</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi" colspan="2">lst.splice(args) 或 flst.splice_after(args)</td>
  </tr>
  <tr>
    <td class="tg-0lax">(p, lst2)</td>
    <td class="tg-0lax">p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。函数将 lst2 的所有元素移动到 lst 中 p 之前的位置或是 flst 中 p 之后的位置。将元素从 lst2 中删除。lst2 的类型必须与 lst 或 flst 相同，且不能是同一个链表</td>
  </tr>
  <tr>
    <td class="tg-0lax">(p, lst2, p2)</td>
    <td class="tg-cly1">p2 是一个指向 lst2 中位置的有效的迭代器。将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中。lst2 可以是与 lst 或 flst 相同的链表</td>
  </tr>
  <tr>
    <td class="tg-0lax">(p, lst2, b, e)</td>
    <td class="tg-0lax">b 和 e 必须表示 lst2 中的合法范围。将给定范围中的元素从 lst2 移动到 lst 或 flst。lst2 与 lst（或 flst）可以是相同的链表，但 p 不能指向给定范围中元素</td>
  </tr>
</tbody>
</table>
</li>
<li><p>链表特有版本与通用版本间的一个至关重要的区别是链表版本会改变底层的容器。例如，<code>remove</code> 的链表版本会删除指定的元素。<code>unique</code> 的链表版本会删除第二个和后继的重复元素。</p>
<p>类似的，<code>merge</code> 和 <code>splice</code> 会销毁其参数。例如，通用版本的 <code>merge</code> 将合并的序列写到一个给定的目的迭代器；两个输入序列是不变的。而链表版本的 <code>merge</code> 函数会销毁给定的链表———元素从参数指定的链表中删除，被合并到调用 <code>merge</code> 的链表对象中。在 <code>merge</code> 之后，来自两个链表中的元素仍然存在，但它们都已在同一个链表中。</p>
</li>
</ol>
<h1 id="小结" class="heading-control"><a href="#小结" class="headerlink" title="小结"></a>小结<a class="heading-anchor" href="#小结" aria-hidden="true"></a></h1><h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%AC%AC%2010%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%881%EF%BC%89.png" alt="第 10 章术语表（1）"></p>
<p><img data-src="https://image.shipengx.com/%E7%AC%AC%2010%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%882%EF%BC%89.png" alt="第 10 章术语表（2）"></p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 11 章 关联容器</title>
    <url>/archives/19565df.html</url>
    <content><![CDATA[<h1 id="11-1-使用关联容器" class="heading-control"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a>11.1 使用关联容器<a class="heading-anchor" href="#11-1-使用关联容器" aria-hidden="true"></a></h1><ol>
<li><p><code>set</code> 支持高效的关键字查询操作——检查一个给定关键字是否在 <code>set</code> 中。</p>
</li>
<li><p>标准库提供 8 个关联容器，如下表所示：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-g7sd{border-color:inherit;font-weight:bold;text-align:left;vertical-align:middle}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>关联容器类型</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <th class="tg-7btt" colspan="2">按关键字有序保存元素</th>
  </tr>
  <tr>
    <td class="tg-0pky">map</td>
    <td class="tg-0pky">关联数组；保存关键字-值对</td>
  </tr>
  <tr>
    <td class="tg-0pky">set</td>
    <td class="tg-0pky">关键字即值，即只保存关键字的容器</td>
  </tr>
  <tr>
    <td class="tg-0pky">multimap</td>
    <td class="tg-lboi">关键字可重复出现的 map</td>
  </tr>
  <tr>
    <td class="tg-0pky">multiset</td>
    <td class="tg-0pky">关键字可重复出现的 set</td>
  </tr>
  <tr>
    <th class="tg-7btt" colspan="2">无序集合</th>
  </tr>
  <tr>
    <td class="tg-0pky">unordered_map</td>
    <td class="tg-0pky">用哈希函数组织的 map</td>
  </tr>
  <tr>
    <td class="tg-0pky">unordered_set</td>
    <td class="tg-0pky">用哈希函数组织的 set</td>
  </tr>
  <tr>
    <td class="tg-0pky">unordered_multimap</td>
    <td class="tg-0pky">哈希组织的 map；关键字可以重复出现</td>
  </tr>
  <tr>
    <td class="tg-0pky">unordered_multiset</td>
    <td class="tg-0pky">哈希组织的 set；关键字可以重复出现</td>
  </tr>
</tbody>
</table>

<p>这 8 个容器间的不同体现在三个维度上：每个容器（1）或者是一个 <code>set</code>，或者是一个 <code>map</code>；（2）或者要求不重复的关键字，或者允许重复关键字；（3）按顺序保存元素，或无序保存。</p>
</li>
<li><p>类型 <code>map</code> 和 <code>multimap</code> 定义在头文件 <code>map</code> 中；<code>set</code> 和 <code>multiset</code> 定义在头文件 <code>set</code> 中；无序容器则定义在头文件 <code>unordered_map</code> 和 <code>unordered_set</code> 中。</p>
</li>
<li><p>使用下标查找 <code>map</code> 中的元素时，若元素不存在，则会新建。</p>
</li>
<li><p>当从 <code>map</code> 中提取一个元素时，会得到一个 <code>pair</code> 类型的对象，简单来说，<code>pair</code> 是一个模板类型，保存两个名为 <code>first</code> 和 <code>second</code> 的（公有）数据成员。<code>map</code> 所使用的 <code>pair</code> 用 <code>first</code> 成员保存关键字，用 <code>second</code> 成员保存对应的值。</p>
</li>
<li><p>与顺序容器类似，可以对一个关联容器的元素进行列表初始化。</p>
</li>
</ol>
<h1 id="11-2-关联容器概述" class="heading-control"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a>11.2 关联容器概述<a class="heading-anchor" href="#11-2-关联容器概述" aria-hidden="true"></a></h1><ol>
<li><p>关联容器不支持顺序容器的位置相关的操作，例如 <code>push_front</code> 或 <code>push_back</code>。原因是关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。而且，关联容器也不支持构造函数或插入操作这些接受一个元素值和一个数量值的操作。</p>
</li>
<li><p>关联容器的迭代器都是双向的。</p>
</li>
</ol>
<h2 id="11-2-1-定义关联容器" class="heading-control"><a href="#11-2-1-定义关联容器" class="headerlink" title="11.2.1 定义关联容器"></a>11.2.1 定义关联容器<a class="heading-anchor" href="#11-2-1-定义关联容器" aria-hidden="true"></a></h2><ol>
<li><p>每个关联容器都定义了一个默认构造函数，它创建一个指定类型的空容器。我们也可以将关联容器初始化为另一个同类型容器的拷贝，或是从一个值范围来初始化关联容器，只要这些值可以转化为容器所需类型就可以。在新标准下，我们也可以对关联容器进行值初始化。</p>
</li>
<li><p>一个 <code>map</code> 或 <code>set</code> 中的关键字必须是唯一的，即，对于一个给定的关键字，只能有一个元素的关键字等于它。容器 <code>multimap</code> 和 <code>multiset</code> 没有此限制，它们都允许多个元素具有相同的关键字。</p>
</li>
<li><p>观察下述代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个有 20 个元素的 vector，保存 0 到 9 每个整数的两个拷贝</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    ivec.push_back(i);</span><br><span class="line">    ivec.push_back(i); <span class="comment">// 每个数重复保存一次</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// iset 包含来自 ivec的 不重复的元素；miset 包含所有 20 个元素</span></span><br><span class="line"><span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(ivec.cbegin(), ivec.cend())</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; <span class="title">miset</span><span class="params">(ivec.cbegin(), ivec.cend())</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ivec.size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印出 20</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; iset.size() &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 打印出 10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; miset.size() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印出 20</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="11-2-2-关键字类型的要求" class="heading-control"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a>11.2.2 关键字类型的要求<a class="heading-anchor" href="#11-2-2-关键字类型的要求" aria-hidden="true"></a></h2><ol>
<li><p><strong>对于有序容器——<code>map</code>、<code>multimap</code>、<code>set</code> 以及 <code>multiset</code>，关键字类型必须定义元素比较的方法。</strong>默认情况下，标准库使用关键字类型的运算符来比较两个关键字。在集合类型中，关键字类型就是元素类型；在映射类型中，关键字类型是元素的第一部分的类型。</p>
</li>
<li><p>可以向一个算法提供我们自己定义的比较操作，与之类似，也可以提供自己定义的操作来代替关键字上的 <code>&lt;</code> 运算符。<strong>所提供的操作必须在关键字类型上定义一个严格弱序（strict weak ordering）。可以将严格弱序看作“小于等于”。</strong></p>
</li>
<li><p>如果两个关键字是等价的（即，任何一个都不“小于等于”另一个），那么容器将它们视作相等来处理。当用作 <code>map</code> 的关键字时，只能有一个元素与这两个关键字关联，我们可以用两者中任意一个来访问对应的值。</p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 在实际编程中，重要的是，如果一个类型定义了“行为正常”的 <code>&lt;</code> 运算符，则它可以用作关键字类型。</p>
</blockquote>
</li>
<li><p><strong>为了指定使用自定义的操作，必须在定义关联容器类型时提供此操作的类型。</strong>如前所述，用尖括号指出要定义哪种类型的容器，<strong>自定义的操作类型必须在尖括号中紧跟着元素类型给出</strong>。在尖括号中出现的每个类型，就仅仅是一个类型而已。当我们创建一个容器（对象）时，才会以构造函数参数的形式提供真正的比较操作（其类型必须与在尖括号中指定的类型相吻合）。</p>
</li>
<li><p>假如我们有个 <code>compareIsbn</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">compareIsbn</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() &lt; rhs.isbn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此函数在 Sales_data 对象的 ISBN 成员上定义了一个严格弱序，假设我们想定义一个 Sales_data 的 <code>multiset</code>，为了使用自己定义的操作，在定义 <code>multiset</code> 时我们必须提供两个类型：关键字类型 Sales_data，以及比较操作类型——应该是一种函数指针类型，可以指向 <code>compareIsbn</code>。当定义此容器类型的对象时，需要提供想要使用的操作的指针：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bookstore 中多条记录可以有相同的 ISBN</span></span><br><span class="line"><span class="comment">// bookstore 中的元素以 ISBN 的顺序进行排列</span></span><br><span class="line">multiset&lt;Sales_data, decltype(compareIsbn) *&gt; bookstore(compareIsbn);</span><br></pre></td></tr></table></figure>
<p>此处，我们使用 <code>decltype</code> 来指出自定义操作的类型。记住，<strong>当用 <code>decltype</code> 来获得一个函数指针类型时，必须加上一个 <code>*</code> 来指出我们要使用一个给定函数类型的指针</strong>。用 <code>compareIsbn</code> 来初始化 bookstore 对象，这表示当我们向 bookstore 添加元素时，通过调用 <code>compareIsbn</code> 来为这些元素排序。即，bookstore 中的元素将按它们的 ISBN 成员的值排序。可以用 <code>compareIsbn</code> 代替 <code>&amp;compareIsbn</code> 作为构造函数的参数，因为<strong>当我们使用一个函数的名字时，在需要的情况下它会自动转化为一个指针</strong>。</p>
</li>
</ol>
<h2 id="11-2-3-pair-类型" class="heading-control"><a href="#11-2-3-pair-类型" class="headerlink" title="11.2.3 pair 类型"></a>11.2.3 pair 类型<a class="heading-anchor" href="#11-2-3-pair-类型" aria-hidden="true"></a></h2><ol>
<li><p><strong><code>pair</code></strong> 标准库类型定义在头文件 <code>utility</code>。</p>
</li>
<li><p><code>pair</code> 的默认构造函数对数据成员进行值初始化，也可以为每个成员提供初始化器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pair&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; author&#123;<span class="string">"James"</span>, <span class="string">"Joyce"</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与其他标准库类型不同，<code>pair</code> 的数据成员是 <code>public</code> 的，两个成员分别命名为 <code>first</code> 和 <code>second</code>。我们用普通的成员访问符号来访问他们。</p>
</li>
<li><p>标准库只定义了有限的几个 <code>pair</code> 操作：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>pair 上的操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi">pair&lt;T1, T2&gt; p;</td>
    <td class="tg-0pky">p 是一个 pair，两个类型分别为 T1 和 T2 的成员都进行了值初始化</td>
  </tr>
  <tr>
    <td class="tg-lboi">pair&lt;T1, T2&gt; p(v1,v2)</td>
    <td class="tg-0pky">p 是一个成员类型为 T1 和 T2 的 pair；first 和 second 成员分别用 v1 和 v2 进行初始化</td>
  </tr>
  <tr>
    <td class="tg-lboi">pair&lt;T1, T2&gt; p = {v1,v2};</td>
    <td class="tg-lboi">等价于 p(v1, v2)</td>
  </tr>
  <tr>
    <td class="tg-lboi">make_pair(v1,v2)</td>
    <td class="tg-0pky">返回一个用 v1 和 v2 初始化的 pair。pair 的类型从 v1 和 v2 的类型推断出来</td>
  </tr>
  <tr>
    <td class="tg-lboi">p.first</td>
    <td class="tg-0pky">返回 p 的名为 first 的（公有）数据成员</td>
  </tr>
  <tr>
    <td class="tg-lboi">p.second</td>
    <td class="tg-0pky">返回 p 的名为 second 的（公有）数据成员</td>
  </tr>
  <tr>
    <td class="tg-lboi">p1 relop p2</td>
    <td class="tg-0pky">关系运算符（&lt;、&gt;、&lt;=、&gt;=）按字典序定义：例如，当 p1.first &lt; p2.first 或 !(p2.first &lt; p1.first) &amp;&amp; p1.second &lt; p2.second 成立时，p1 &lt; p2 为 true。关系运算利用元素的 &lt; 运算符来实现</td>
  </tr>
  <tr>
    <td class="tg-lboi">p1 == p2</td>
    <td class="tg-lboi" rowspan="2">当 first 和 second 成员分别相等时，两个 pair 相等。相等性判断利用元素的 == 运算符实现</td>
  </tr>
  <tr>
    <td class="tg-lboi">p1 != p2</td>
  </tr>
</tbody>
</table>

</li>
</ol>
<h1 id="11-3-关联容器操作" class="heading-control"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a>11.3 关联容器操作<a class="heading-anchor" href="#11-3-关联容器操作" aria-hidden="true"></a></h1><ol>
<li><p>关联容器定义了几个额外的类型别名：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>关联容器额外的类型别名</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi">key_type</td>
    <td class="tg-0pky">此容器类型的关键字类型</td>
  </tr>
  <tr>
    <td class="tg-lboi">mapped_type</td>
    <td class="tg-0pky">每个关键字关联的类型；只适用于 map</td>
  </tr>
  <tr>
    <td class="tg-lboi">value_type</td>
    <td class="tg-lboi">对于 set，与 key_type 相同；对于 map，为 pair&lt;const key_type, mapped_type&gt;</td>
  </tr>
</tbody>
</table>

<p>对于 <code>set</code> 类型，<code>key_type</code> 和 <code>value_type</code> 是一样的；<code>set</code> 中保存的值就是关键字。在一个 <code>map</code> 中，元素是关键字-值对。即，每个元素是一个 <code>pair</code> 对象，包含一个关键字和一个关联的值。由于我们不能改变一个元素的关键字，因此这些 <code>pair</code> 的关键字部分是 <code>const</code> 的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::value_type v1;       <span class="comment">// v1 是一个 string</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;::key_type v2;         <span class="comment">// v2 是一个 string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::value_type v3;  <span class="comment">// v3 是一个 pair&lt;const string, int&gt;</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::key_type v4;    <span class="comment">// v4 是一个 string</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;::mapped_type v5; <span class="comment">// v5 是一个 int</span></span><br></pre></td></tr></table></figure>
<p>我们使用作用域运算符来提取一个类型的成员——例如，<code>map&lt;string, int&gt;::key_type</code>。</p>
</li>
</ol>
<h2 id="11-3-1-关联容器迭代器" class="heading-control"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a>11.3.1 关联容器迭代器<a class="heading-anchor" href="#11-3-1-关联容器迭代器" aria-hidden="true"></a></h2><ol>
<li><p>当解引用一个关联容器迭代器时，我们会得到一个类型为容器的 <code>value_type</code> 的值的引用。对 <code>map</code> 而言，<code>value_type</code> 是一个 <code>pair</code> 类型，其 <code>first</code> 成员保存 <code>const</code> <code>的关键字，second</code> 成员保存值。</p>
<blockquote>
<p><strong>Note：</strong> 必须记住，一个 <code>map</code> 的 <code>value_type</code> 是一个 <code>pair</code>，我们可以改变 <code>pair</code> 的值，但不能改变关键字成员的值。</p>
</blockquote>
</li>
<li><p>虽然 <code>set</code> 类型同时定义了 <code>iterator</code> 和 <code>const iterator</code> 类型，但两种类型都只允许只读访问 <code>set</code> 中的元素。<strong>与不能改变一个 <code>map</code> 元素的关键字一样，一个 <code>set</code> 中的关键字也是 <code>const</code> 的。可以用一个 <code>set</code> 迭代器来读取元素的值，但不能修改。</strong></p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 当使用一个迭代器遍历一个 <code>map</code>、<code>multimap</code>、<code>set</code> 或 <code>multiset</code> 时，迭代器按关键字升序遍历元素。</p>
</blockquote>
</li>
<li><p><strong>我们通常不对关联容器使用泛型算法。</strong> 关键字是 <code>const</code> 这一特性意味着不能将关联容器传递给修改或重排容器元素的算法，因为这类算法需要向元素写入值，而 <code>set</code> 类型中的元素是 <code>const</code> 的，<code>map</code> 中的元素是 <code>pair</code>，其第一个成员是 <code>const</code> 的。关联容器可用于只读取元素的算法。但是，很多这类算法都要搜索序列。由于关联容器中的元素不能通过它们的关键字进行（快速）查找，因此对其使用泛型搜索算法几乎总是个坏主意。关联容器定义了一个名为 <code>find</code> 的成员，它通过一个给定的关键字直接获取元素。<strong>我们可以用泛型 <code>find</code> 算法来查找一个元素，但此算法会进行顺序搜索。使用关联容器定义的专用的 <code>find</code> 成员会比调用泛型 <code>find</code> 快得多。</strong></p>
</li>
<li><p><strong>练习 11.17：</strong> 假定 c 是一个 <code>string</code> 的 <code>multiset</code>，v 是一个 <code>string</code> 的 <code>vector</code>，解释下面的调用。指出每个调用是否合法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">copy(v.begin(), v.end(), inserter(c, c.end())); <span class="comment">// 合法</span></span><br><span class="line">copy(v.begin(), v.end(), back_inserter(c));     <span class="comment">// 不合法</span></span><br><span class="line">copy(c.begin(), c.end(), inserter(v, v.end())); <span class="comment">// 合法</span></span><br><span class="line">copy(c.begin(), c.end(), back_inserter(v));     <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure>
<p><code>back_inserter</code> 会调用容器的 <code>push_back</code> 方法，但关联容器不包含该方法。</p>
</li>
</ol>
<h2 id="11-3-2-添加元素" class="heading-control"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a>11.3.2 添加元素<a class="heading-anchor" href="#11-3-2-添加元素" aria-hidden="true"></a></h2><ol>
<li><p>关联容器的 <code>insert</code> 成员向容器中添加一个元素或一个元素范围。由于 <code>map</code> 和 <code>set</code>（以及对应的无序类型）包含不重复的关键字，因此插入一个已存在的元素对容器没有任何影响：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;; <span class="comment">// ivec 有 8 个元素</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; set2;                               <span class="comment">// 空集合</span></span><br><span class="line">set2.insert(ivec.cbegin(), ivec.cend());     <span class="comment">// set2 有 4 个元素</span></span><br><span class="line">set2.insert(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;);       <span class="comment">// set2 现在有 8 个元素</span></span><br></pre></td></tr></table></figure>
<p><code>insert</code> 有两个版本，分别接受一对迭代器，或是一个初始化器列表，这两个版本的行为类似对应的构造函数——对于一个给定的关键字，只有第一个带此关键字的元素才被插入到容器中。</p>
</li>
<li><p>对一个 <code>map</code> 进行 <code>insert</code> 操作时，必须记住元素类型是 <code>pair</code>。通常，对于想要插入的数据，并没有一个现成的 <code>pair</code> 对象。可以在 <code>insert</code> 的参数列表中创建一个 <code>pair</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向 word_count 插入 word 的 4 种方法</span></span><br><span class="line">word_count.insert(&#123;word, <span class="number">1</span>&#125;);</span><br><span class="line">word_count.insert(make_pair(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(pair&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;(word, <span class="number">1</span>));</span><br><span class="line">word_count.insert(<span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">size_t</span>&gt;::value_type(word, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>在 C++11 新标准下，创建一个 <code>pair</code> 最简单的方法是在参数列表中使用花括号初始化。也可以调用 <code>make_pair</code> 或显式构造 <code>pair</code>。</p>
</li>
<li><p>关联容器的 <code>insert</code> 操作：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>关联容器 insert 操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi">c.insert(v)</td>
    <td class="tg-lboi" rowspan="2">v 是 value_type 类型的对象；args 用来构造一个元素<br>对于 map 和 set，只有当元素的关键字不在 c 中时才插入（或构造）元素。函数返回一个 pair，包含一个迭代器，指向具有指定关键字的元素，以及一个指示插入是否成功的 bool 值<br>对于 multimap 和 multiset，总会插入（或构造）给定元素，并返回一个指向新元素的迭代器</td>
  </tr>
  <tr>
    <td class="tg-lboi">c.emplace(args)</td>
  </tr>
  <tr>
    <td class="tg-lboi">c.insert(b, e)</td>
    <td class="tg-lboi" rowspan="2">b 和 e 是迭代器，表示一个 c::value_type 类型值的范围；il 是这种值的花括号列表。函数返回 void<br>对于 map 和 set，只插入关键字不在 c 中的元素。对于 multimap 和 multiset，则会插入范围中的每个元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.insert(il)</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.insert(p, v)</td>
    <td class="tg-cly1" rowspan="2">类似 insert(v)（或 emplace(args)），但将迭代器 p 作为一个提示，指出从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有给定关键字的元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.emplace(p, args)</td>
  </tr>
</tbody>
</table>
</li>
<li><p><code>insert</code>（或 <code>emplace</code>）返回的值依赖于容器类型和参数。对于不包含重复关键字的容器，添加单一元素的 <code>insert</code> 和 <code>emplace</code> 版本返回一个 <code>pair</code>，告诉我们插入操作是否成功。<code>pair</code> 的 <code>first</code> 成员是一个迭代器，指向具有给定关键字的元素；<code>second</code> 成员是一个 <code>bool</code> 值，指出元素是插入成功还是已经存在于容器中。如果关键字已在容器中，则 <code>insert</code> 什么事情也不做，且返回值中的 <code>bool</code> 部分为 <code>false</code>。如果关键字不存在，元素被插入容器中，且 <code>bool</code> 值为 <code>true</code>。</p>
</li>
<li><p><strong>练习 11.21：</strong> 假定 word_count 是一个 <code>string</code> 到 <code>size_t</code> 的 <code>map</code>，word 是一个 <code>string</code>，解释下面循环的作用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    ++word_count.insert(&#123;word, <span class="number">0</span>&#125;).first-&gt;second;</span><br></pre></td></tr></table></figure>
<p>答：读取标准输入到 word 中，使用 word 和 0 组成花括号列表，并 <code>insert</code> 到 word_count 中，<code>insert</code> 返回一个 <code>pair</code>，<code>pair</code> 的首元素是指向新插入元素（也是个 <code>pair</code>）的迭代器，新插入元素的 <code>second</code> 是计数器，对其实施前置递增。</p>
</li>
<li><p><strong>练习 11.22：</strong> 给定一个 <code>map&lt;string, vector&lt;int&gt;&gt;</code>，对此容器的插入一个元素的 <code>insert</code> 版本，写出其参数类型和返回类型。</p>
<p>答：参数类型 <code>pair&lt;string, vector&lt;int&gt;&gt;</code>；返回类型 <code>pair&lt;map&lt;string, vector&lt;int&gt;&gt;::iterator, bool&gt;</code>。</p>
</li>
</ol>
<h2 id="11-3-3-删除元素" class="heading-control"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a>11.3.3 删除元素<a class="heading-anchor" href="#11-3-3-删除元素" aria-hidden="true"></a></h2><ol>
<li><p>关联容器定义了三个版本的 <code>erase</code>，与顺序容器一样，我们可以通过传递给 <code>erase</code> 一个迭代器或一个迭代器对来删除一个元素或者一个元素范围。</p>
<p><strong>关联容器提供一个额外的 <code>erase</code> 操作，它接受一个 <code>key_type</code> 参数。此版本删除所有匹配给定关键字的元素（如果存在的话），返回实际删除的元素的数量。</strong> 使用这个 <code>erase</code> 操作时：对于保存不重复关键字的容器，<code>erase</code> 的返回值总是 0 或 1，若返回值为 0，则表明想要删除的元素并不在容器中；对允许重复关键字的容器，删除元素的数量可能大于 1。</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>从关联容器删除元素</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi">c.erase(k)</td>
    <td class="tg-lboi">从 c 中删除每个关键字为 k 的元素。返回一个 size_type 值，指出删除的元素的数量</td>
  </tr>
  <tr>
    <td class="tg-lboi">c.erase(p)</td>
    <td class="tg-0pky">从 c 中删除迭代器 p 指定的元素。p 必须指向 c 中一个真实元素，不能等于 c.end()。返回一个指向 p 之后元素的迭代器，若 p 指向 c 中的尾元素，则返回 c.end()</td>
  </tr>
  <tr>
    <td class="tg-lboi">c.erase(b, e)</td>
    <td class="tg-lboi">删除迭代器对 b 和 e 所表示的范围中的元素。返回 e</td>
  </tr>
</tbody>
</table>

</li>
</ol>
<h2 id="11-3-4-map-的下标操作" class="heading-control"><a href="#11-3-4-map-的下标操作" class="headerlink" title="11.3.4 map 的下标操作"></a>11.3.4 map 的下标操作<a class="heading-anchor" href="#11-3-4-map-的下标操作" aria-hidden="true"></a></h2><ol>
<li><p><code>map</code> 和 <code>unordered_map</code> 容器提供了下标运算符和一个对应的 <code>at</code> 函数：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>map 和 unordered_map 的下标操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi">c[k]</td>
    <td class="tg-lboi">返回关键字为 k 的元素；如果 k 不在 c 中，添加一个关键字为 k 的元素，对其进行值初始化</td>
  </tr>
  <tr>
    <td class="tg-lboi">c.at(k)</td>
    <td class="tg-0pky">访问关键字为 k 的元素，带参数检查；若 k 不在 c 中，抛出一个 out_of_range 异常</td>
  </tr>
</tbody>
</table>

<p><code>set</code> 类型不支持下标，因为 <code>set</code> 中没有与关键字相关联的“值”。我们不能对一个 <code>multimap</code> 或一个 <code>unordered_multimap</code> 进行下标操作，因为这些容器中可能有多个值与一个关键字相关联。</p>
</li>
<li><p>类似我们用过的其他下标运算符，<code>map</code> 下标运算符接受一个索引（即，一个关键字），获取与此关键字相关联的值。但是，与其他下标运算符不同的是，<strong>如果关键字并不在 <code>map</code> 中，会为它创建一个元素并插入到 <code>map</code> 中，关联值将进行值初始化。由于下标运算符可能插入一个新元素，我们只可以对非 <code>const</code> 的 <code>map</code> 使用下标操作。</strong></p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 对一个 <code>map</code> 使用下标操作，其行为与数组或 <code>vector</code> 上的下标操作很不相同：使用一个不在容器中的关键字作为下标，会添加一个具有此关键字的元素到 <code>map</code> 中。</p>
</blockquote>
</li>
<li><p><code>map</code> 的下标运算符与我们用过的其他下标运算符的另一个不同之处是其返回类型。<strong>通常情况下，解引用一个迭代器所返回的类型与下标运算符返回的类型是一样的。但对 <code>map</code> 则不然：当对一个 <code>map</code> 进行下标操作时，会获得一个 <code>mapped_type</code> 对象；但当解引用一个 <code>map</code> 迭代器时，会得到一个 <code>value_type</code> 对象。</strong>与其他下标运算符相同的是，<code>map</code> 的下标运算符返回一个左值。由于返回的是一个左值，所以我们既可以读也可以写元素。</p>
<blockquote>
<p>与 <code>vector</code> 与 <code>string</code> 不同，<code>map</code> 的下标运算符返回的类型与解引用 <code>map</code> 选代器得到的类型不同。</p>
</blockquote>
</li>
<li><p>如果关键字还未在 <code>map</code> 中，下标运算符会添加一个新元素，有时只是想知道一个元素是否已在 <code>map</code> 中，但在不存在时并不想添加元素。在这种情况下，就不能使用下标运算符。</p>
</li>
</ol>
<h2 id="11-3-5-访问元素" class="heading-control"><a href="#11-3-5-访问元素" class="headerlink" title="11.3.5 访问元素"></a>11.3.5 访问元素<a class="heading-anchor" href="#11-3-5-访问元素" aria-hidden="true"></a></h2><ol>
<li><p>关联容器提供多种查找一个指定元素的方法，<code>lower_bound</code> 和 <code>upper_bound</code> 不适用于无序容器。下标和 <code>at</code> 操作只适用于非 <code>const</code> 的 <code>map</code> 和 <code>unordered_map</code>：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>在一个关联容器中查找元素的操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-lboi">c.find(k)</td>
    <td class="tg-lboi">返回一个迭代器，指向第一个关键字为 k 的元素，若 k 不在容器中，则返回尾后迭代器</td>
  </tr>
  <tr>
    <td class="tg-lboi">c.count(k)</td>
    <td class="tg-0pky">返回关键字等于 k 的元素的数量。对于不允许重复关键字的容器，返回值永远是 0 或 1</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.lower_bound(k)</td>
    <td class="tg-0lax">返回一个迭代器，指向第一个关键字不小于 k 的元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.upper_bound(k)</td>
    <td class="tg-0lax">返回一个迭代器，指向第一个关键字大于 k 的元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.equal_range(k)</td>
    <td class="tg-0lax">返回一个迭代器 pair，表示关键字等于 k 的元素的范围。若 k 不存在，pair 的两个成员均等于 c.end()</td>
  </tr>
</tbody>
</table>
</li>
<li><p>如果我们所关心的只不过是一个特定元素是否已在容器中，可能 <code>find</code> 是最佳选择。对于不允许重复关键字的容器，可能使用 <code>find</code> 还是 <code>count</code> <code>没什么区别。但对于允许重复关键字的容器，count</code> 还会做更多的工作：如果元素在容器中，它还会统计有多少个元素有相同的关键字。如果不需要计数，最好使用 <code>find</code>。</p>
</li>
<li><p><strong>使用下标操作有一个严重的副作用：如果关键字还未在 <code>map</code> 中，下标操作会插入一个具有给定关键字的元素。</strong></p>
</li>
<li><p><strong>如果一个 <code>multimap</code> 或 <code>multiset</code> 中有多个元素具有给定关键字，则这些元素在容器中会相邻存储。</strong></p>
</li>
<li><p>如果关键字在容器中，<code>lower_bound</code> 返回的迭代器将指向第一个具有给定关键字的元素，而 <code>upper_bound</code> 返回的迭代器则指向最后一个匹配给定关键字的元素之后的位置。如果元素不在 <code>multimap</code> 中，则 <code>lower_bound</code> 和 <code>upper_bound</code> 会返回相等的迭代器——指向一个不影响排序的关键字插入位置。因此，用相同的关键字调用 <code>lower_bound</code> 和 <code>upper_bound</code> 会得到一个迭代器范围，表示所有具有该关键字的元素的范围。</p>
</li>
<li><p><strong>如果我们查找的元素具有容器中最大的关键字，则此关键字的 <code>upper_bound</code> 返回尾后迭代器。如果关键字不存在，且大于容器中任何关键字，则 <code>lower_bound</code> 返回的也是尾后送代器。</strong></p>
</li>
<li><blockquote>
<p><strong>Note：<code>lower_bound</code> 返回的迭代器可能指向一个具有给定关键字的元素，但也可能不指向。如果关键字不在容器中，则 <code>lower_bound</code> 会返回关键字的第一个安全插入点——不影响容器中元素顺序的插入位置。</strong></p>
</blockquote>
</li>
<li><p><strong>如果没有元素与给定关键字匹配，则 <code>lower_bound</code> 和 <code>upper_bound</code> 会返回相等的迭代器——都指向给定关键字的插入点，能保持容器中元素顺序的插入位置。</strong></p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 如果 <code>lower_bound</code> 和 <code>upper_bound</code> 返回相同的迭代器，则给定关键字不在容器中。</p>
</blockquote>
</li>
<li><p><code>equal_range</code> 函数接受一个关键字，返回一个迭代器 <code>pair</code>。若关键字存在，则第一个迭代器指向第一个与关键字匹配的元素，第二个迭代器指向最后一个匹配元素之后的位置。若未找到匹配元素，则两个迭代器都指向关键字可以插入的位置。</p>
</li>
</ol>
<h2 id="11-3-6-一个单词转换的-map" class="heading-control"><a href="#11-3-6-一个单词转换的-map" class="headerlink" title="11.3.6 一个单词转换的 map"></a>11.3.6 一个单词转换的 map<a class="heading-anchor" href="#11-3-6-一个单词转换的-map" aria-hidden="true"></a></h2><h1 id="11-4-无序容器" class="heading-control"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a>11.4 无序容器<a class="heading-anchor" href="#11-4-无序容器" aria-hidden="true"></a></h1><ol>
<li><p><strong>无序关联容器</strong>（unordered associative container）。这些容器不是使用比较运算符来组织元素，而是使用一个<strong>哈希函数</strong>（hash function）和关键字类型的 <code>==</code> 运算符。在关键字类型的元素没有明显的序关系的情况下，无序容器是非常有用的。在某些应用中，维护元素的序代价非常高昂，此时无序容器也很有用。</p>
</li>
<li><p>虽然理论上哈希技术能获得更好的平均性能，但在实际中想要达到很好的效果还需要进行一些性能测试和调优工作。因此，使用无序容器通常更为简单（通常也会有更好的性能）。</p>
</li>
<li><blockquote>
<p><strong>Tip：</strong> 如果关键字类型固有就是无序的，或者性能测试发现问题可以用哈希技术解决，就可以使用无序容器。</p>
</blockquote>
</li>
<li><p>通常可以用一个无序容器替换对应的有序容器，反之亦然。</p>
</li>
<li><p>无序容器在存储上组织为一组桶，每个桶保存零个或多个元素。无序容器使用一个哈希函数将元素映射到桶。为了访问一个元素，容器首先计算元素的哈希值，它指出应该搜索哪个桶。容器将具有一个特定哈希值的所有元素都保存在相同的桶中。如果容器允许重复关键字，所有具有相同关键字的元素也都会在同一个桶中。因此，无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
</li>
<li><p>对于相同的参数，哈希函数必须总是产生相同的结果。理想情况下，哈希函数还能将每个特定的值映射到唯一的桶。但是，将不同关键字的元素映射到相同的桶也是允许的。当一个桶保存多个元素时，需要顺序搜索这些元素来查找我们想要的那个。计算一个元素的哈希值和在桶中搜索通常都是很快的操作。但是，如果一个桶中保存了很多元素，那么查找一个特定元素就需要大量比较操作。</p>
</li>
<li><p>无序容器提供了一组管理桶的函数，这些成员函数允许我们查询容器的状态以及在必要时强制容器进行重组：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-1wig{font-weight:bold;text-align:left;vertical-align:top}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-g7sd{border-color:inherit;font-weight:bold;text-align:left;vertical-align:middle}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>无序容器管理操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <th class="tg-g7sd" colspan="2">桶接口
  </th></tr>
  <tr>
    <td class="tg-lboi">c.bucket_count()</td>
    <td class="tg-0pky">正在使用的桶的数目</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.max_bucket_count()</td>
    <td class="tg-0pky">容器能容纳的最多的桶的数量</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.bucket_size(n)</td>
    <td class="tg-0pky">第 n 个桶中有多少个元素</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.bucket(k)</td>
    <td class="tg-0pky">关键字为 k 的元素在哪个桶中</td>
  </tr>
  <tr>
    <th class="tg-fymr" colspan="2">桶迭代
  </th></tr>
  <tr>
    <td class="tg-0lax">local_iterator</td>
    <td class="tg-0lax">可以用来访问桶中元素的迭代器类型</td>
  </tr>
  <tr>
    <td class="tg-0lax">const_local_iterator</td>
    <td class="tg-0lax">桶迭代器的 const 版本</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.begin(n), c.end(n)</td>
    <td class="tg-0lax">桶 n 的首元素迭代器和尾后迭代器</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.cbegin(n), c.cend(n)</td>
    <td class="tg-0lax">与前两个函数类似，但返回 const_local_iterator</td>
  </tr>
  <tr>
    <th class="tg-1wig" colspan="2">哈希策略
  </th></tr>
  <tr>
    <td class="tg-0lax">c.load_factor()</td>
    <td class="tg-0lax">每个桶的平均元素数量，返回 float 值</td>
  </tr>
  <tr>
    <td class="tg-cly1">c.max_load_factor()</td>
    <td class="tg-0lax">c 试图维护的平均桶大小，返回 float 值。c 会在需要时添加新的桶，以使得 load_factor &lt;= max_load_factor</td>
  </tr>
  <tr>
    <td class="tg-cly1">c.rehash(n)</td>
    <td class="tg-0lax">重组存储，使得 bucket count &gt;= n<br>且 bucket_count &gt; size/max_load_factor</td>
  </tr>
  <tr>
    <td class="tg-cly1">c.reserve(n)</td>
    <td class="tg-0lax">重组存储，使得 c 可以保存 n 个元素且不必 rehash</td>
  </tr>
</tbody>
</table>
</li>
<li><p>默认情况下，无序容器使用关键字类型的 <code>==</code> 运算符来比较元素，它们还使用一个 <code>hash&lt;key_type&gt;</code> 类型的对象来生成每个元素的哈希值。标准库为内置类型（包括指针）提供了 <code>hash</code> 模板。还为一些标准库类型，包括 <code>string</code> 和智能指针类型定义了 <code>hash</code>。因此，我们可以直接定义关键字是内置类型（包括指针类型）、<code>string</code> 还有智能指针类型的无序容器。</p>
</li>
<li><p><strong>不能直接定义关键字类型为自定义类类型的无序容器。</strong> 与容器不同，不能直接使用哈希模板，而必须提供我们自己的 <code>hash</code> 模板版本。我们不使用默认的 <code>hash</code>，而是使用另一种方法，类似于为有序容器重载关键字类型的默认比较操作。为了能将 Sales_data 用作关键字，我们需要提供函数来替代 <code>==</code> 运算符和哈希值计算函数。我们从定义这些重载函数开始：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;sd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(sd.isbn());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">eqOp</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.isbn() == rhs.isbn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们使用这些函数来定义一个 <code>unordered_multiset</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SD_multiset = <span class="built_in">unordered_multiset</span>&lt;Sales_data,</span><br><span class="line">                                       <span class="keyword">decltype</span>(hasher) *,</span><br><span class="line">                                       <span class="keyword">decltype</span>(eqOp) *&gt;;</span><br><span class="line"><span class="comment">// 参数是桶大小、哈希函数指针和相等性判断运算符指针</span></span><br><span class="line"><span class="function">SD_multiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqOp)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 11.37：</strong> 一个无序容器与其有序版本相比有何优势？有序版本有何优势？</p>
<p>答：无序关联容器效率更高，有序关联容器默认将元素根据键进行排序。</p>
</li>
</ol>
<h1 id="小结" class="heading-control"><a href="#小结" class="headerlink" title="小结"></a>小结<a class="heading-anchor" href="#小结" aria-hidden="true"></a></h1><ol>
<li><p>关联容器支持通过关键字高效查找和提取元素。对关键字的使用将关联容器和顺序容器区分开来，顺序容器中是通过位置访问元素的。</p>
</li>
<li><p>有序容器使用比较函数来比较关键字，从而将元素按顺序存储。默认情况下，比较操作是采用关键字类型的 <code>&lt;</code> 运算符。无序容器使用关键字类型的 <code>==</code> 运算符和一个 <code>hash&lt;key_type&gt;</code> 类型的对象来组织元素。</p>
</li>
<li><p>有序容器的迭代器通过关键字有序访问容器中的元素。<strong>无论在有序容器中还是在无序容器中，具有相同关键字的元素都是相邻存储的。</strong></p>
</li>
</ol>
<h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%AC%AC%2011%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%881%EF%BC%89.png" alt="第 11 章术语表（1）"></p>
<p><img data-src="https://image.shipengx.com/%E7%AC%AC%2011%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%882%EF%BC%89.png" alt="第 11 章术语表（2）"></p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Apollo 6.0 安装完全指南</title>
    <url>/archives/e4b9c8ad.html</url>
    <content><![CDATA[<p><img data-src="https://image.shipengx.com/Apollo%206.0%20%E5%AE%89%E8%A3%85%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97.png" alt="Apollo 6.0 安装完全指南"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fwb2xsb0F1dG8vYXBvbGxv" title="https://github.com/ApolloAuto/apollo">Apollo<i class="fa fa-external-link"></i></span> 是优秀的自动驾驶开发框架，出自百度之手，目前已更新到 6.0 版本，本文旨在详细记录 Apollo 6.0 在 Ubuntu 18.04 中的完整安装及运行过程，并会阐述在虚拟机和物理机中进行安装时的细微区别。</p>
<h1 id="1-前置依赖软件安装" class="heading-control"><a href="#1-前置依赖软件安装" class="headerlink" title="1 前置依赖软件安装"></a>1 前置依赖软件安装<a class="heading-anchor" href="#1-前置依赖软件安装" aria-hidden="true"></a></h1><ul>
<li>安装 Ubuntu 18.04</li>
<li>安装 NVIDIA 显卡驱动</li>
<li>安装 Docker 引擎</li>
<li>安装 NVIDIA 容器工具包</li>
</ul>
<h2 id="1-1-安装-Ubuntu-18-04" class="heading-control"><a href="#1-1-安装-Ubuntu-18-04" class="headerlink" title="1.1 安装 Ubuntu 18.04"></a>1.1 安装 Ubuntu 18.04<a class="heading-anchor" href="#1-1-安装-Ubuntu-18-04" aria-hidden="true"></a></h2><p><strong>系统安装</strong></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9yZWxlYXNlcy51YnVudHUuY29tLzE4LjA0LjUv" title="https://releases.ubuntu.com/18.04.5/">Ubuntu 18.04.5 LTS (Bionic Beaver)<i class="fa fa-external-link"></i></span> 是官方推荐版本，笔者此处使用的即为该版本。下载系统镜像，使用 <span class="exturl" data-url="aHR0cDovL3J1ZnVzLmllL3poLw==" title="http://rufus.ie/zh/">Rufus<i class="fa fa-external-link"></i></span> 开源工具制作安装启动盘，在虚拟机环境或物理机环境（单系统 or 双系统）中安装系统。关于 VMWare 虚拟机的安装配置可以参考此前的文章<a href="https://blog.shipengx.com/archives/5103b2eb.html">《Win 10 中通过 VMWare 16 在 UEFI 引导模式下安装 Ubuntu 18.04 虚拟机并自定义分区》</a>。</p>
<p><strong>更新和升级</strong></p>
<p>完成系统安装后，配置 Ubuntu 软件仓库，并选择国内更稳定的镜像源，例如清华源：<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL3VidW50dS8=" title="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/<i class="fa fa-external-link"></i></span></p>
<p><img data-src="https://image.shipengx.com/%E9%85%8D%E7%BD%AE%20Ubuntu%20%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93.png" alt="配置 Ubuntu 软件仓库"></p>
<p>随后，进行更新和升级：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get upgrade</span><br></pre></td></tr></table></figure>
<h2 id="1-2-安装-NVIDIA-显卡驱动" class="heading-control"><a href="#1-2-安装-NVIDIA-显卡驱动" class="headerlink" title="1.2 安装 NVIDIA 显卡驱动"></a>1.2 安装 NVIDIA 显卡驱动<a class="heading-anchor" href="#1-2-安装-NVIDIA-显卡驱动" aria-hidden="true"></a></h2><p>如果是在物理机中安装的 Ubuntu，且机器配有 NVIDIA 显卡，需要安装对应驱动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-add-repository multiverse</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install nvidia-driver-455</span><br></pre></td></tr></table></figure>
<p>随后，可以通过在终端中执行 <code>nvidia-smi</code> 命令来查看 NVIDIA 显卡工作是否正常（完成驱动安装后可能需要重启），正常情况下终端将显示下面的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Prompt&gt; nvidia-smi</span><br><span class="line">Mon Jan 25 15:51:08 2021</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| NVIDIA-SMI 460.27.04    Driver Version: 460.27.04    CUDA Version: 11.2     |</span><br><span class="line">|-------------------------------+----------------------+----------------------+</span><br><span class="line">| GPU  Name        Persistence-M| Bus-Id        Disp.A | Volatile Uncorr. ECC |</span><br><span class="line">| Fan  Temp  Perf  Pwr:Usage&#x2F;Cap|         Memory-Usage | GPU-Util  Compute M. |</span><br><span class="line">|                               |                      |               MIG M. |</span><br><span class="line">|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;+&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</span><br><span class="line">|   0  GeForce RTX 3090    On   | 00000000:65:00.0  On |                  N&#x2F;A |</span><br><span class="line">| 32%   29C    P8    18W &#x2F; 350W |    682MiB &#x2F; 24234MiB |      7%      Default |</span><br><span class="line">|                               |                      |                  N&#x2F;A |</span><br><span class="line">+-------------------------------+----------------------+----------------------+</span><br><span class="line"></span><br><span class="line">+-----------------------------------------------------------------------------+</span><br><span class="line">| Processes:                                                                  |</span><br><span class="line">|  GPU   GI   CI        PID   Type   Process name                  GPU Memory |</span><br><span class="line">|        ID   ID                                                   Usage      |</span><br><span class="line">|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|</span><br><span class="line">|    0   N&#x2F;A  N&#x2F;A      1286      G   &#x2F;usr&#x2F;lib&#x2F;xorg&#x2F;Xorg                 40MiB |</span><br><span class="line">|    0   N&#x2F;A  N&#x2F;A      1517      G   &#x2F;usr&#x2F;bin&#x2F;gnome-shell              120MiB |</span><br><span class="line">|    0   N&#x2F;A  N&#x2F;A      1899      G   &#x2F;usr&#x2F;lib&#x2F;xorg&#x2F;Xorg                342MiB |</span><br><span class="line">|    0   N&#x2F;A  N&#x2F;A      2037      G   &#x2F;usr&#x2F;bin&#x2F;gnome-shell               69MiB |</span><br><span class="line">|    0   N&#x2F;A  N&#x2F;A      4148      G   ...gAAAAAAAAA --shared-files      105MiB |</span><br><span class="line">+-----------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 如果是在虚拟机中安装的 Ubuntu 或物理机没有配置 NVIDIA 显卡，此步务必跳过，否则将导致后续步骤中启动 Apollo 开发容器时失败。虚拟机情况下这样做的根本原因是，虚拟机中无法虚拟 NVIDIA 显卡。</p>
</blockquote>
<h2 id="1-3-安装-Docker-引擎" class="heading-control"><a href="#1-3-安装-Docker-引擎" class="headerlink" title="1.3 安装 Docker 引擎"></a>1.3 安装 Docker 引擎<a class="heading-anchor" href="#1-3-安装-Docker-引擎" aria-hidden="true"></a></h2><p>Apollo 6.0 需要 Docker 19.03 及以上版本，在终端中直接执行下述命令即可完成 Docker 社区版的安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://get.docker.com | sh</span><br><span class="line">sudo systemctl start docker &amp;&amp; sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
<p>重启 Docker 守护进程以使改动生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>完成 Docker 安装后，在终端中执行下述命令并重启系统，这样可以免去每次执行 Docker 命令时需要添加 <code>sudo</code> 的繁琐：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker your_username</span><br></pre></td></tr></table></figure>
<h2 id="1-4-安装-NVIDIA-容器工具包" class="heading-control"><a href="#1-4-安装-NVIDIA-容器工具包" class="headerlink" title="1.4 安装 NVIDIA 容器工具包"></a>1.4 安装 NVIDIA 容器工具包<a class="heading-anchor" href="#1-4-安装-NVIDIA-容器工具包" aria-hidden="true"></a></h2><p>如果是在物理机中安装的 Ubuntu，且机器配有 NVIDIA 显卡，在安装了驱动的前提下，还需要安装 NVIDIA 容器工具包以运行 Apollo Docker 镜像中的 CUDA：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">distribution=$(. /etc/os-release;<span class="built_in">echo</span> <span class="variable">$ID</span><span class="variable">$VERSION_ID</span>)</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/gpgkey | sudo apt-key add -</span><br><span class="line">curl -s -L https://nvidia.github.io/nvidia-docker/<span class="variable">$distribution</span>/nvidia-docker.list | sudo tee /etc/apt/sources.list.d/nvidia-docker.list</span><br><span class="line">sudo apt-get -y update</span><br><span class="line">sudo apt-get install -y nvidia-docker2</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong> 如果是在虚拟机中安装的 Ubuntu 或物理机没有配置 NVIDIA 显卡，此步同样需要跳过。</p>
</blockquote>
<h1 id="2-克隆-Apollo-源码" class="heading-control"><a href="#2-克隆-Apollo-源码" class="headerlink" title="2 克隆 Apollo 源码"></a>2 克隆 Apollo 源码<a class="heading-anchor" href="#2-克隆-Apollo-源码" aria-hidden="true"></a></h1><p>通过 SSH 方式或 HTTPS 方式克隆 Apollo 源码仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 SSH 的方式</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:ApolloAuto/apollo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 HTTPS 的方式</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/ApolloAuto/apollo.git</span><br></pre></td></tr></table></figure>
<p>GitHub 在国内访问速度可能很慢，可以使用 Gitee 替代：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 SSH 的方式</span></span><br><span class="line">git <span class="built_in">clone</span> git@gitee.com:ApolloAuto/apollo.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 HTTPS 的方式</span></span><br><span class="line">git <span class="built_in">clone</span> https://gitee.com/ApolloAuto/apollo.git</span><br></pre></td></tr></table></figure>
<h1 id="3-启动-Apollo-Docker-开发容器" class="heading-control"><a href="#3-启动-Apollo-Docker-开发容器" class="headerlink" title="3 启动 Apollo Docker 开发容器"></a>3 启动 Apollo Docker 开发容器<a class="heading-anchor" href="#3-启动-Apollo-Docker-开发容器" aria-hidden="true"></a></h1><p>进入到 Apollo 源码根目录，打开终端，执行下述命令以启动 Apollo Docker 开发容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./docker/scripts/dev_start.sh</span><br></pre></td></tr></table></figure>
<p>不出意外得话，启动成功后将得到下面信息：</p>
<p><img data-src="https://image.shipengx.com/%E6%88%90%E5%8A%9F%E5%90%AF%E5%8A%A8%20Apollo%20docker%20%E5%BC%80%E5%8F%91%E5%AE%B9%E5%99%A8.png" alt="成功启动 Apollo docker 开发容器"></p>
<p>如果是在虚拟机中安装的 Ubuntu 或物理机没有配置 NVIDIA 显卡，但却又安装了 NVIDIA 驱动，则在执行上述启动容器的操作时将遇到下面的报错：</p>
<p><img data-src="https://image.shipengx.com/%E6%97%A0%E6%B3%95%E5%90%AF%E5%8A%A8%20Apollo%20docker%20%E5%BC%80%E5%8F%91%E5%AE%B9%E5%99%A8.png" alt="无法启动 Apollo docker 开发容器"></p>
<p>解决方法是直接卸载 NVIDIA 相关安装项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt purge nvidia*</span><br></pre></td></tr></table></figure>
<h1 id="4-进入-Apollo-Docker-开发容器" class="heading-control"><a href="#4-进入-Apollo-Docker-开发容器" class="headerlink" title="4 进入 Apollo Docker 开发容器"></a>4 进入 Apollo Docker 开发容器<a class="heading-anchor" href="#4-进入-Apollo-Docker-开发容器" aria-hidden="true"></a></h1><p>启动 Apollo Docker 开发容器后，执行下述命令进入容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./docker/scripts/dev_into.sh</span><br></pre></td></tr></table></figure>
<p>可以发现，进入容器后终端信息发生了相应变化，后面的操作都将在容器中进行：</p>
<p><img data-src="https://image.shipengx.com/%E8%BF%9B%E5%85%A5%20Apollo%20docker%20%E5%BC%80%E5%8F%91%E5%AE%B9%E5%99%A8.png" alt="进入 Apollo docker 开发容器"></p>
<blockquote>
<p>笔者是在 VMWare 虚拟机中进行的上述所有步骤，所以会看到上面黄色的 WARNING 信息。</p>
</blockquote>
<h1 id="5-在容器中构建-Apollo" class="heading-control"><a href="#5-在容器中构建-Apollo" class="headerlink" title="5 在容器中构建 Apollo"></a>5 在容器中构建 Apollo<a class="heading-anchor" href="#5-在容器中构建-Apollo" aria-hidden="true"></a></h1><p>进入 Apollo Docker 开发容器后，在容器终端中执行下述命令构建 Apollo：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./apollo.sh build</span><br></pre></td></tr></table></figure>
<p>构建成功后将得到下面的信息：</p>
<p><img data-src="https://image.shipengx.com/Apollo%20%E6%9E%84%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="Apollo 构建成功"></p>
<blockquote>
<p>如果报无权限创建目录的问题，在命令前加 <code>sudo</code> 即可。</p>
</blockquote>
<h1 id="6-运行-Apollo" class="heading-control"><a href="#6-运行-Apollo" class="headerlink" title="6 运行 Apollo"></a>6 运行 Apollo<a class="heading-anchor" href="#6-运行-Apollo" aria-hidden="true"></a></h1><h2 id="6-1-启动-Apollo" class="heading-control"><a href="#6-1-启动-Apollo" class="headerlink" title="6.1 启动 Apollo"></a>6.1 启动 Apollo<a class="heading-anchor" href="#6-1-启动-Apollo" aria-hidden="true"></a></h2><p>完成 Apollo 构建后，在容器终端中执行下述命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./scripts/bootstrap.sh start</span><br></pre></td></tr></table></figure>
<p>上述命令会启动 DreamView 并使能模块监控机制，在浏览器中访问 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4ODg4" title="http://localhost:8888">http://localhost:8888<i class="fa fa-external-link"></i></span> 来显示 DreamView 界面：</p>
<p><img data-src="https://image.shipengx.com/DreamView%20%E7%95%8C%E9%9D%A2.png" alt="DreamView 界面"></p>
<h2 id="6-2-选择驾驶模式和地图" class="heading-control"><a href="#6-2-选择驾驶模式和地图" class="headerlink" title="6.2 选择驾驶模式和地图"></a>6.2 选择驾驶模式和地图<a class="heading-anchor" href="#6-2-选择驾驶模式和地图" aria-hidden="true"></a></h2><p>在 DreamView 界面的对应下拉框中选择驾驶模式为“Mkz Standard Debug”，选择地图为“Sunnyvale with Two Offices”：</p>
<p><img data-src="https://image.shipengx.com/DreamView%20%E4%B8%AD%E9%80%89%E6%8B%A9%E9%A9%BE%E9%A9%B6%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%9C%B0%E5%9B%BE.png" alt="DreamView 中选择驾驶模式和地图"></p>
<h2 id="6-3-回放-Demo-数据" class="heading-control"><a href="#6-3-回放-Demo-数据" class="headerlink" title="6.3 回放 Demo 数据"></a>6.3 回放 Demo 数据<a class="heading-anchor" href="#6-3-回放-Demo-数据" aria-hidden="true"></a></h2><p>在容器终端中执行下述命令下载 demo 数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> docs/demo_guide/</span><br><span class="line">python3 record_helper.py demo_3.5.record</span><br></pre></td></tr></table></figure>
<p>由于网络原因，下载可能失败，可以点击<a href="https://blog.shipengx.com/download/demo_3.5.record">这里</a>手动下载并将数据放到 <code>apollo/docs/demo_guide/</code> 目录下。继续在容器终端中执行下述命令来播放数据，<code>-l</code> 表示循环播放（loop）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cyber_recorder play -f demo_3.5.record -l</span><br></pre></td></tr></table></figure>
<p>至此，DreamView 界面中将呈现出自车规划轨迹、他车预测轨迹、路网等各种信息：</p>
<p><img data-src="https://image.shipengx.com/%E5%9B%9E%E6%94%BE%20Log%20%E6%97%B6%E7%9A%84%20DreamView%20%E7%95%8C%E9%9D%A2.png" alt="回放 Log 时的 DreamView 界面"></p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vQXBvbGxvQXV0by9hcG9sbG8vYmxvYi9tYXN0ZXIvZG9jcy9zcGVjcy9wcmVyZXF1aXNpdGVfc29mdHdhcmVfaW5zdGFsbGF0aW9uX2d1aWRlLm1k" title="https://gitee.com/ApolloAuto/apollo/blob/master/docs/specs/prerequisite_software_installation_guide.md">Pre-requisite Software Installation Guide<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vQXBvbGxvQXV0by9hcG9sbG8vYmxvYi9tYXN0ZXIvZG9jcy9xdWlja3N0YXJ0L2Fwb2xsb19zb2Z0d2FyZV9pbnN0YWxsYXRpb25fZ3VpZGVfY24ubWQ=" title="https://gitee.com/ApolloAuto/apollo/blob/master/docs/quickstart/apollo_software_installation_guide_cn.md">Apollo 软件安装指南<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vQXBvbGxvQXV0by9hcG9sbG8vYmxvYi9tYXN0ZXIvZG9jcy9ob3d0by9ob3dfdG9fbGF1bmNoX2FuZF9ydW5fYXBvbGxvLm1kI3J1bi1hcG9sbG8=" title="https://gitee.com/ApolloAuto/apollo/blob/master/docs/howto/how_to_launch_and_run_apollo.md#run-apollo">How to Launch and Run Apollo<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxMTI5MTkxNzY3MC9hcnRpY2xlL2RldGFpbHMvMTE1MDEzODQ5" title="https://blog.csdn.net/qq1291917670/article/details/115013849">在虚拟机上安装运行百度 Apollo 6.0<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTcwMDYyMTU=" title="https://zhuanlan.zhihu.com/p/357006215">在 vmware 上跑 apollo 6.0 (无 GPU)<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>Apollo</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>Apollo</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 12 章 动态内存</title>
    <url>/archives/4094be86.html</url>
    <content><![CDATA[<ol>
<li><p>全局对象在程序启动时分配，在程序结束时销毁。对于局部自动对象，当我们进入其定义所在的程序块时被创建，在离开块时销毁。局部 <code>static</code> 对象在第一次使用前分配，在程序结束时销毁。</p>
</li>
<li><p>静态内存用来保存局部 <code>static</code> 对象、类 <code>static</code> 数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非 <code>static</code> 对象。分配在静态或栈内存中的对象由编译器自动创建和销毁。对于栈对象，仅在其定义的程序块运行时才存在；<code>static</code> 对象在使用之前分配，在程序结束时销毁。</p>
</li>
<li><p>除了静态内存和栈内存，每个程序还拥有一个内存池。这部分内存被称作<strong>自由空间</strong>（free store）或<strong>堆</strong>（heap）。程序用堆来存储<strong>动态分配</strong>（dynamically allocate）的对象——即，那些在程序运行时分配的对象。</p>
</li>
</ol>
<h1 id="12-1-动态内存与智能指针" class="heading-control"><a href="#12-1-动态内存与智能指针" class="headerlink" title="12.1 动态内存与智能指针"></a>12.1 动态内存与智能指针<a class="heading-anchor" href="#12-1-动态内存与智能指针" aria-hidden="true"></a></h1><ol>
<li><p><strong><code>new</code></strong>，在动态内存中为对象分配空间并返回一个指向该对象的指针，我们可以选择对对象进行初始化；<strong><code>delete</code></strong>，接受一个动态对象的指针，销毁该对象，并释放与之关联的内存。</p>
</li>
<li><p>智能指针的行为类似常规指针，重要的区别是它负责自动释放所指向的对象。新标准库提供的两种智能指针的区别在于管理底层指针的方式：<strong><code>shared_ptr</code></strong> 允许多个指针指向同一个对象；<strong><code>unicue_ptr</code></strong> 则“独占”所指向的对象。标准库还定义了一个名为 <strong><code>weak_ptr</code></strong> 的伴随类，它是一种弱引用，指向 <code>shared_ptr</code> 所管理的对象。这三种类型都定义在 <code>memory</code> 头文件中。</p>
</li>
</ol>
<h2 id="12-1-1-shared-ptr-类" class="heading-control"><a href="#12-1-1-shared-ptr-类" class="headerlink" title="12.1.1 shared_ptr 类"></a>12.1.1 shared_ptr 类<a class="heading-anchor" href="#12-1-1-shared-ptr-类" aria-hidden="true"></a></h2><ol>
<li><p>类似 <code>vector</code>，智能指针也是模板。因此，当我们创建一个智能指针时，必须提供额外的信息——指针可以指向的类型。与 <code>vector</code> 一样，我们在尖括号内给出类型，之后是所定义的这种智能指针的名字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1;    <span class="comment">// shared_ptr，可以指向 string</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&gt; p2; <span class="comment">// shared ptr，可以指向 int 的 list</span></span><br></pre></td></tr></table></figure>
<p>默认初始化的智能指针中保存着一个空指针。</p>
</li>
<li><p>解引用一个智能指针返回它指向的对象。如果在一个条件判断中使用智能指针，效果就是检测它是否为空。</p>
</li>
<li><p>以下操作同时适用于 <code>shared_ptr</code> 和 <code>unique_ptr</code>：</p>
<p> <style type="text/css"><br> .tg  {border-collapse:collapse;border-spacing:0;}<br> .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>   overflow:hidden;padding:10px 5px;word-break:normal;}<br> .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>   font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br> .tg .tg-cly1{text-align:left;vertical-align:middle}<br> .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}<br> .tg .tg-0lax{text-align:left;vertical-align:top}<br> .tg .tg-nrix{text-align:center;vertical-align:middle}
 </style></p>
 <table class="tg">
 <thead>
   <tr>
     <th class="tg-amwm" colspan="2"><center>shared_ptr 和 unique_ptr 都支持的操作</center></th>
   </tr>
 </thead>
 <tbody>
   <tr>
     <td class="tg-0lax">shared_ptr&lt;T&gt; sp</td>
     <td class="tg-nrix" rowspan="2">空智能指针，可以指向类型为 T 的对象</td>
   </tr>
   <tr>
     <td class="tg-0lax">unique_ptr&lt;T&gt; up</td>
   </tr>
   <tr>
     <td class="tg-0lax">p</td>
     <td class="tg-0lax">将 p 用作一个条件判断，若 p 指向一个对象，则为 true</td>
   </tr>
   <tr>
     <td class="tg-0lax">*p</td>
     <td class="tg-0lax">解引用 p，获得它指向的对象</td>
   </tr>
   <tr>
     <td class="tg-0lax">p-&gt;mem</td>
     <td class="tg-0lax">等价于 (*p).mem</td>
   </tr>
   <tr>
     <td class="tg-0lax">p.get()</td>
     <td class="tg-0lax">返回 p 中保存的指针。要小心使用，若智能指针释放了其对象，返回的指针所指向的对象也就消失了</td>
   </tr>
   <tr>
     <td class="tg-0lax">swap(p, q)</td>
     <td class="tg-cly1" rowspan="2">交换 p 和 q 中的指针</td>
   </tr>
   <tr>
     <td class="tg-0lax">p.swap(q)</td>
   </tr>
 </tbody>
 </table>

<p>以下操作则仅适用于 <code>shared_ptr</code>：</p>
<p> <style type="text/css"><br> .tg  {border-collapse:collapse;border-spacing:0;}<br> .tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br> overflow:hidden;padding:10px 5px;word-break:normal;}<br> .tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br> .tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}<br> .tg .tg-0lax{text-align:left;vertical-align:top}
 </style></p>
 <table class="tg">
 <thead>
   <tr>
     <th class="tg-amwm" colspan="2"><center>shared_ptr 独有的操作</center></th>
   </tr>
 </thead>
 <tbody>
   <tr>
     <td class="tg-0lax">make_shared&lt;T&gt; (args)</td>
     <td class="tg-0lax">返回一个 shared_ptr，指向一个动态分配的类型为 T 的对象。使用 args 初始化此对象</td>
   </tr>
   <tr>
     <td class="tg-0lax">shared_ptr&lt;T&gt; p(q)</td>
     <td class="tg-0lax">p 是 shared_ptr q 的拷贝；此操作会递增 q 中的计数器。q 中的指针必须能转换为 T*</td>
   </tr>
   <tr>
     <td class="tg-0lax">p = q</td>
     <td class="tg-0lax">p 和 q 都是 shared_ptr，所保存的指针必须能相互转换。此操作会递减 p 的引用计数，递增 q 的引用计数；若 p 的引用计数变为 0，则将其管理的原内存释放</td>
   </tr>
   <tr>
     <td class="tg-0lax">p-&gt;mem</td>
     <td class="tg-0lax">等价于 (*p).mem</td>
   </tr>
   <tr>
     <td class="tg-0lax">p.unique()</td>
     <td class="tg-0lax">若 p.use_count() 为 1，返回 true；否则返回 false</td>
   </tr>
   <tr>
     <td class="tg-0lax">p.use_count()</td>
     <td class="tg-0lax">返回与 p 共享对象的智能指针数量；可能很慢，主要用于调试</td>
   </tr>
 </tbody>
 </table>
</li>
<li><p>最安全的分配和使用动态内存的方法是调用一个名为 <code>make_shared</code> 的标准库函数。此函数在动态内存中分配一个对象并初始化它，返回指向此对象的 <code>shared_ptr</code>。与智能指针一样，<code>make_shared</code> 也定义在头文件 <code>memory</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指向一个值为 42 的 int 的 shared_ptr</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3 = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// p4 指向一个值为“9999999999"的 string</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p4 = make_shared&lt;<span class="built_in">string</span>&gt;(<span class="number">10</span>, <span class="string">'9'</span>);</span><br><span class="line"><span class="comment">// p5 指向一个值初始化的 int，即，值为 0</span></span><br><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p5 = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之我见。make_shared 做的三件事：<br>1、申请分配动态内存；<br>2、在动态内存上调用模板参数类型对应的构造函数进行对象构造；<br>3、返回指向新分配动态内存的 shared_ptr 对象。</p>
</blockquote>
</li>
<li><p>通常用 <code>auto</code> 定义一个对象来保存 <code>make_shared</code> 的结果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p6 指向一个动态分配的空 vector&lt;string&gt;</span></span><br><span class="line"><span class="keyword">auto</span> p6 = make_shared&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p>当进行拷贝或赋值操作时，每个 <code>shared_ptr</code> 都会记录有多少个其他 <code>shared_ptr</code> 指向相同的对象。可以认为每个 <code>shared_ptr</code> 都有一个关联的计数器，通常称其为<strong>引用计数</strong>（reference count）。无论何时我们拷贝一个 <code>shared_ptr</code>，计数器都会递增。例如，<strong>当用一个 <code>shared_ptr</code> 初始化另一个 <code>shared_ptr</code>，或将它作为参数传递给一个函数以及作为函数的返回值时，它所关联的计数器就会递增</strong>。当我们<strong>给 <code>shared_ptr</code> 赋予一个新值或是 <code>shared_ptr</code> 被销毁（例如一个局部的 <code>shared_ptr</code> 离开其作用域）时，计数器就会递减</strong>。一旦一个 <code>shared_ptr</code> 的计数器变为 0，它就会自动释放自己所管理的对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> r = make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">42</span>); <span class="comment">// r 指向的 int 只有一个引用者</span></span><br><span class="line">r = q;                         <span class="comment">// 给 r 赋值，令它指向另一个地址</span></span><br><span class="line">                               <span class="comment">// 递增 q 指向的对象的引用计数</span></span><br><span class="line">                               <span class="comment">// 递减 r 原来指向的对象的引用计数</span></span><br><span class="line">                               <span class="comment">// r 原来指向的对象已没有引用者，会自动释放</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当指向一个对象的最后一个 <code>shared_ptr</code> 被销毁时，<code>shared_ptr</code> 类会自动销毁此对象。<code>shared_ptr</code> 的析构函数会递减它所指向的对象的引用计数。如果引用计数变为 0，<code>shared_ptr</code> 的析构函数就会销毁对象，并释放它占用的内存。</p>
</li>
<li><p>由于在最后一个 <code>shared_ptr</code> 销毁前内存都不会释放，保证 <code>shared_ptr</code> 在无用之后不再保留就非常重要了。<strong>如果你忘记了销毁程序不再需要的 <code>shared_ptr</code>，程序仍会正确执行，但会浪费内存。</strong> <code>share_ptr</code> 在无用之后仍然保留的一种可能情况是，你将 <code>shared_ptr</code> 存放在一个容器中，随后重排了容器，从而不再需要某些元素。在这种情况下，你应该确保用 <code>erase</code> 删除那些不再需要的 <code>shared_ptr</code> 元素。</p>
<blockquote>
<p><strong>Note：</strong> 如果你将 <code>shared_ptr</code> 存放于一个容器中，而后不再需要全部元素，而只使用其中一部分，要记得用 <code>erase</code> 删除不再需要的那些元素。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>Note：</strong> 使用动态内存的一个常见原因是允许多个对象共享相同的状态。</p>
</blockquote>
</li>
</ol>
<h2 id="12-1-2-直接管理内存" class="heading-control"><a href="#12-1-2-直接管理内存" class="headerlink" title="12.1.2 直接管理内存"></a>12.1.2 直接管理内存<a class="heading-anchor" href="#12-1-2-直接管理内存" aria-hidden="true"></a></h2><ol>
<li><p>在自由空间分配的内存是无名的，因此 <code>new</code> 无法为其分配的对象命名，而是返回一个指向该对象的指针。<strong>默认情况下，动态分配的对象是默认初始化的，这意味着内置类型或组合类型的对象的值将是未定义的，而类类型对象将用默认构造函数进行初始化。</strong></p>
</li>
<li><p>初始化动态分配的对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);          <span class="comment">// pi 指向的对象的值为 1024</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'9'</span>); <span class="comment">// *ps 为 "9999999999"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// vector 有 10 个元素，值依次从 0 到 9</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pv = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *ps1 = <span class="keyword">new</span> <span class="built_in">string</span>;  <span class="comment">// 默认初始化为空 string</span></span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(); <span class="comment">// 值初始化为空 string</span></span><br><span class="line"><span class="keyword">int</span> *pi1 = <span class="keyword">new</span> <span class="keyword">int</span>;        <span class="comment">// 默认初始化；*pi1 的值未定义</span></span><br><span class="line"><span class="keyword">int</span> *pi2 = <span class="keyword">new</span> <span class="keyword">int</span>();      <span class="comment">// 值初始化为 0；*pi2 为 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p><strong>最佳实践：</strong> 出于与变量初始化相同的原因，对动态分配的对象进行初始化通常是个好主意。</p>
</blockquote>
</li>
<li><p>如果我们提供了一个括号包围的初始化器，就可以使用 <code>auto</code> 从此初始化器来推断我们想要分配的对象的类型。但是，由于编译器要用初始化器的类型来推断要分配的类型，只有当括号中仅有单一初始化器时才可以使用 <code>auto</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pl = <span class="keyword">new</span> <span class="keyword">auto</span>(obj);      <span class="comment">// p 指向一个与 obj 类型相同的对象</span></span><br><span class="line">                              <span class="comment">// 该对象用 obj 进行初始化</span></span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span> &#123;a, b, c&#125;; <span class="comment">// 错误：括号中只能有单个初始化器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用 <code>new</code> 分配 <code>const</code> 对象是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配并初始化一个 const int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pci = <span class="keyword">new</span> <span class="keyword">const</span> <span class="keyword">int</span>(<span class="number">1024</span>);</span><br><span class="line"><span class="comment">// 分配并默认初始化一个 const 的空 string</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *pcs = <span class="keyword">new</span> <span class="keyword">const</span> <span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
<p>类似其他任何 <code>const</code> 对象，一个动态分配的 <code>const</code> 对象必须进行初始化。对于一个定义了默认构造函数的类类型，其 <code>const</code> 动态对象可以隐式初始化，而其他类型的对象就必须显式初始化。由于分配的对象是 <code>const</code> 的，<code>new</code> 返回的指针是一个指向 <code>const</code> 的指针。</p>
</li>
<li><p>如果 <code>new</code> 不能分配所要求的内存空间，它会抛出一个类型为 <code>bad_alloc</code> 的异常。我们可以改变使用 <code>new</code> 的方式来阻止它抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;           <span class="comment">// 如果分配失败，new 抛出 std::bad_alloc</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>; <span class="comment">// 如果分配失败，new 返回一个空指针</span></span><br></pre></td></tr></table></figure>
<p>称这种形式的 <code>new</code> 为<strong>定位 <code>new</code></strong>（placement new），定位 <code>new</code> 表达式允许我们向 <code>new</code> 传递额外的参数。<code>bad_alloc</code> 和 <code>nothrow</code> 都定义在头文件 <code>new</code> 中。</p>
</li>
<li><p><strong>我们传递给 <code>delete</code> 的指针必须指向动态分配的内存，或者是一个空指针。释放一块并非 <code>new</code> 分配的内存，或者将相同的指针值释放多次，其行为是未定义的。</strong></p>
</li>
<li><p>通常情况下，编译器不能分辨一个指针指向的是静态还是动态分配的对象。类似的，编译器也不能分辨一个指针所指向的内存是否已经被释放了。对于这些 <code>delete</code> 表达式，大多数编译器会编译通过，尽管它们是错误的。</p>
</li>
<li><p>虽然一个 <code>const</code> 对象的值不能被改变，但它本身是可以被销毁的。如同任何其他动态对象一样，想要释放一个 <code>const</code> 动态对象，只要 <code>delete</code> 指向它的指针即可。</p>
</li>
<li><blockquote>
<p><strong>WARNING：</strong> 由内置指针（而不是智能指针）管理的动态内存在被显式释放前一直都会存在。</p>
</blockquote>
</li>
<li><blockquote>
<p>使用 <code>new</code> 和 <code>delete</code> 管理动态内存存在三个常见问题：</p>
<ol>
<li>忘记 <code>delete</code> 内存；</li>
<li>使用已经释放掉的对象；</li>
<li>同一块内存释放两次。</li>
</ol>
</blockquote>
</li>
<li><blockquote>
<p><strong>最佳实践：</strong> 坚持只使用智能指针。</p>
</blockquote>
</li>
<li><p><code>new</code> 出来的动态内存在 <code>delete</code> 之后应将相应的指针变量赋值为 <code>nullptr</code>。</p>
</li>
</ol>
<h2 id="12-1-3-shared-ptr-和-new-结合使用" class="heading-control"><a href="#12-1-3-shared-ptr-和-new-结合使用" class="headerlink" title="12.1.3 shared_ptr 和 new 结合使用"></a>12.1.3 shared_ptr 和 new 结合使用<a class="heading-anchor" href="#12-1-3-shared-ptr-和-new-结合使用" aria-hidden="true"></a></h2><ol>
<li><p>接受指针参数的智能指针构造函数是 <code>explicit</code> 的。因此，我们不能将一个内置指针隐式转换为一个智能指针，必须使用直接初始化形式来初始化一个智能指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>); <span class="comment">// 错误：必须使用直接初始化形式</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;  <span class="comment">// 正确：使用了直接初始化形式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>定义和改变 <code>shared_ptr</code> 的其他方法：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-9wq8{border-color:inherit;text-align:center;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>定义和改变 shared_ptr 的其他方法</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">shared_ptr&lt;T&gt; p(q)</td>
    <td class="tg-lboi">p 管理内置指针 q 所指向的对象；q 必须指向 new 分配的内存，且能够转换为 T* 类型</td>
  </tr>
  <tr>
    <td class="tg-0pky">shared_ptr&lt;T&gt; p(u)</td>
    <td class="tg-lboi">p 从 unique_ptr u 那里接管了对象的所有权；将 u 置为空</td>
  </tr>
  <tr>
    <td class="tg-0pky">shared_ptr&lt;T&gt; p(q, d)</td>
    <td class="tg-lboi">p 接管了内置指针 q 所指向的对象的所有权。q 必须能转换为 T* 类型。p 将使用可调用对象 d 来代替 delete</td>
  </tr>
  <tr>
    <td class="tg-0pky">shared_ptr&lt;T&gt; p(p2, d)</td>
    <td class="tg-lboi">p 是 shared_ptr p2 的拷贝，唯一的区别是 p 将用可调用对象 d 来代替 delete</td>
  </tr>
  <tr>
    <td class="tg-0pky">p.reset()</td>
    <td class="tg-lboi" rowspan="3">若 p 是唯一指向其对象的 shared_ptr，reset 会释放此对象。若传递了可选的参数内置指针 q，会令 p 指向 q，否则会将 p 置为空。若还传递了参数 d，将会调用 d 而不是 delete 来释放 q</td>
  </tr>
  <tr>
    <td class="tg-0pky">p.reset(q)</td>
  </tr>
  <tr>
    <td class="tg-0pky">p.reset(q, d)</td>
  </tr>
</tbody>
</table>
</li>
<li><p>假设我们有这样一个 <code>process</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 使用 ptr</span></span><br><span class="line">&#125; <span class="comment">// ptr 离开作用域，被销毁</span></span><br></pre></td></tr></table></figure>
<p><code>process</code> 函数的参数传递方式为传值，在其内部会创建所传入的 <code>shared_ptr</code> 实参的副本，增加对所使用的动态内存的引用计数（至少为 2），<code>process</code> 结束时，方才使用的动态内存的引用计数会递减，但不会变为 0，因此不会被释放，正确使用 <code>process</code> 函数的方式是传递给它一个 <code>shared_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>; <span class="comment">// 引用计数为 1</span></span><br><span class="line">process(p);                     <span class="comment">// 拷贝 p 会递增它的引用计数；在 process 中引用计数值为 2</span></span><br><span class="line"><span class="keyword">int</span> i = *p;                     <span class="comment">// 正确：引用计数值为 1</span></span><br></pre></td></tr></table></figure>
<p>向 <code>process</code> 传入一个由内置指针显式构造的临时的 <code>shared_ptr</code> 可能会引发错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">x</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;       <span class="comment">// 危险：x是一个普通指针，不是一个智能指针</span></span><br><span class="line">process(x);                  <span class="comment">// 错误：不能将 int* 转换为一个 shared_ptr&lt;int&gt;</span></span><br><span class="line">process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(x)); <span class="comment">// 合法的，但内存会被释放！</span></span><br><span class="line"><span class="keyword">int</span> j = *x;                  <span class="comment">// 未定义的：x 是一个空悬指针！</span></span><br></pre></td></tr></table></figure>
<p>在上面的调用中，我们将一个临时 <code>shared_ptr</code> 传递给 <code>process</code>。当这个调用所在的表达式结束时，这个临时对象就被销毁了。销毁这个临时变量会递减引用计数，此时引用计数就变为 0 了。因此，当临时对象被销毁时，它所指向的内存会被释放。但 x 继续指向（已经释放的）内存，从而变成一个空悬指针。如果试图使用 x 的值，其行为是未定义的。</p>
</li>
<li><p>当将一个 <code>shared_ptr</code> 绑定到一个普通指针时，我们就将内存的管理责任交给了这个 <code>shared_ptr</code>。一旦这样做了，我们就不应该再使用内置指针来访问 <code>shared_ptr</code> 所指向的内存了。</p>
</li>
<li><blockquote>
<p><strong>WARNING：</strong> 使用一个内置指针来访问一个智能指针所负责的对象是很危险的，因为我们无法知道对象何时会被销毁。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>WARNING：</strong> <code>get</code> 用来将指针的访问权限传递给代码，你只有在确定代码不会 <code>delete</code> 指针的情况下，才能使用 <code>get</code>。特别是，永远不要用 <code>get</code> 初始化另一个智能指针或者为另一个智能指针赋值。</p>
</blockquote>
</li>
<li><p><code>reset</code> 成员经常与 <code>unique</code> 一起使用，来控制多个 <code>shared_ptr</code> 共享的对象。在改变底层对象之前，我们检查自己是否是当前对象仅有的用户。如果不是，在改变之前要制作一份新的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p.unique())</span><br><span class="line">    p.reset(<span class="keyword">new</span> <span class="built_in">string</span>(*p)); <span class="comment">// 我们不是唯一用户；分配新的拷贝</span></span><br><span class="line">*p += newVal;                <span class="comment">// 现在我们知道自己是唯一的用户，可以改变对象的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 12.10：</strong> 下面的代码调用了上文中定义的 <code>process</code> 函数，解释此调用是否正确。如果不正确，应如何修改？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">42</span>))</span></span>;</span><br><span class="line">process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(p));</span><br></pre></td></tr></table></figure>
<p>答：正确，创建 p 的临时拷贝，p 中的引用计数会增加。</p>
</li>
<li><p><strong>练习 12.11：</strong> 如果我们像下面这样调用 <code>process</code>，会发生什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(p.get()));</span><br></pre></td></tr></table></figure>
<p>答：<code>p.get()</code> 返回 p 所管理的动态内存的内置指针，使用该指针初始化一个临时的 <code>shared_ptr</code>，离开 <code>process</code> 后动态内存会被释放，后面对 p 的使用存在危险。</p>
</li>
<li><p><strong>练习 12.12：</strong> p 和 q 的定义如下，对于接下来的对 <code>process</code> 的每个调用，如果合法，解释它做了什么，如果不合法，解释错误原因：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> <span class="keyword">int</span>();</span><br><span class="line"><span class="keyword">auto</span> sp = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">(a) process(sp);</span><br><span class="line">(b) process(<span class="keyword">new</span> <span class="keyword">int</span>());</span><br><span class="line">(c) process(p);</span><br><span class="line">(d) process(<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;(p));</span><br></pre></td></tr></table></figure>
<p>答：（a）合法，创建一个 sp 的临时拷贝，<code>process</code> 内 sp 的引用计数加 1，离开 <code>process</code> 后 sp 的引用计数恢复；（b）不合法，不存在内置指针向 <code>shared_ptr</code> 的隐式转换；（c）不合法，同（b）；（d）合法，创建临时的 <code>shared_ptr</code> 管理 p 所指向的内存，离开 <code>process</code> 后内存会被释放，p 将继续指向已不再可用的内存，虽然合法，但是危险。</p>
</li>
<li><p><strong>练习 12.13：</strong> 如果执行下面的代码，会发生什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> sp = make_shared&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line"><span class="keyword">auto</span> p = sp.get();</span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
<p>答：sp 管理一块动态内存，p 通过 <code>sp.get()</code> 获得这块动态内存的访问权限，随后 <code>delete</code> 释放了内存，但 sp 的引用计数并未随之减 1，后续 sp 析构时会再次释放内存。</p>
</li>
</ol>
<h2 id="12-1-4-智能指针和异常" class="heading-control"><a href="#12-1-4-智能指针和异常" class="headerlink" title="12.1.4 智能指针和异常"></a>12.1.4 智能指针和异常<a class="heading-anchor" href="#12-1-4-智能指针和异常" aria-hidden="true"></a></h2><ol>
<li><p>如果使用内置指针管理内存，且在 <code>new</code> 之后在对应的 <code>delete</code> 之前发生了异常，则内存不会被释放。</p>
</li>
<li><p>当一个 <code>shared_ptr</code> 被销毁时，它默认地对它管理的指针进行 <code>delete</code> 操作。当我们创建一个 <code>shared_ptr</code> 时，可以传递一个（可选的）指向删除器函数的参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 当 f 退出时（即使是由于异常而退出），connection 会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了正确使用智能指针，我们必须坚持一些基本规范：</p>
<ul>
<li>不使用相同的内置指针值初始化（或 <code>reset</code>）多个智能指针；</li>
<li>不 <code>delete</code> <code>get()</code> 返回的指针；</li>
<li>不使用 <code>get()</code> 初始化或 <code>reset</code> 另一个智能指针；</li>
<li>如果你使用 <code>get()</code> 返回的指针，记住当最后一个对应的智能指针销毁后，你的指针就变为无效了；</li>
<li>如果你使用智能指针管理的资源不是 <code>new</code> 分配的内存，记住传递给它一个删除器。</li>
</ul>
</li>
</ol>
<h2 id="12-1-5-unique-ptr" class="heading-control"><a href="#12-1-5-unique-ptr" class="headerlink" title="12.1.5 unique_ptr"></a>12.1.5 unique_ptr<a class="heading-anchor" href="#12-1-5-unique-ptr" aria-hidden="true"></a></h2><ol>
<li><p>一个 <code>unique_ptr</code>“拥有”它所指向的对象。与 <code>shared_ptr</code> 不同，某个时刻只能有一个 <code>unique_ptr</code> 指向一个给定对象。当 <code>unique_ptr</code> 被销毁时，它所指向的对象也被销毁。</p>
</li>
<li><p>与 <code>shared_ptr</code> 不同，没有类似 <code>make_shared</code> 的标准库函数返回一个 <code>unique_ptr</code>。当我们定义一个 <code>unique_ptr</code> 时，需要将其绑定到一个 <code>new</code> 返回的指针上。</p>
</li>
<li><p>由于一个 <code>unique_ptr</code> 拥有它指向的对象，因此 <code>unique_ptr</code> 不支持普通的拷贝或赋值操作。</p>
</li>
<li><p><code>unituq_ptr</code> 支持的操作：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-amwm" colspan="2"><center>unique_ptr 支持的操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">unique_ptr&lt;T&gt; u1</td>
    <td class="tg-cly1" rowspan="2">空 unique_ptr，可以指向类型为 T 的对象。u1 会使用 delete 来释放它的指针；u2 会使用一个类型为 D 的可调用对象来释放它的指针</td>
  </tr>
  <tr>
    <td class="tg-0lax">unique_ptr&lt;T, D&gt; u2</td>
  </tr>
  <tr>
    <td class="tg-0lax">unique_ptr&lt;T, D&gt; u(d)</td>
    <td class="tg-0lax">空 unique_ptr，指向类型为 T 的对象，用类型为 D 的对象 d 代替 delete</td>
  </tr>
  <tr>
    <td class="tg-0lax">u = nullptr</td>
    <td class="tg-0lax">释放 u 指向的对象，将 u 置为空</td>
  </tr>
  <tr>
    <td class="tg-0lax">u.release()</td>
    <td class="tg-0lax">u 放弃对指针的控制权，返回指针，并将 u 置为空</td>
  </tr>
  <tr>
    <td class="tg-0lax">u.reset()</td>
    <td class="tg-0lax">释放 u 指向的对象</td>
  </tr>
  <tr>
    <td class="tg-0lax">u.reset(q)</td>
    <td class="tg-cly1" rowspan="2">如果提供了内置指针 q，令 u 指向这个对象；否则将 u 置为空</td>
  </tr>
  <tr>
    <td class="tg-0lax">u.reset(nullptr)</td>
  </tr>
</tbody>
</table>
</li>
<li><p>虽然我们不能拷贝或赋值 <code>unique_ptr</code>，但可以通过调用 <code>release</code> 或 <code>reset</code> 将指针的所有权从一个（非 <code>const</code>）<code>unique_ptr</code> 转移给另一个 <code>unique_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有权从 p1 转移给 p2</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p2</span><span class="params">(p1.release())</span></span>; <span class="comment">// release 将 p1 置为空</span></span><br><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"Trex"</span>))</span></span>;</span><br><span class="line"><span class="comment">// 将所有权从 p3 转移给 p2</span></span><br><span class="line">p2.reset(p3.release()); <span class="comment">// reset 释放了 p2 原来指向的内存</span></span><br></pre></td></tr></table></figure>
<p><code>release</code> 成员返回 <code>unique_ptr</code> 当前保存的指针并将其置为空。调用 <code>release</code> 会切断 <code>unique_ptr</code> 和它原来管理的对象间的联系。<code>release</code> 返回的指针通常被用来初始化另一个智能指针或给另一个智能指针赋值。在本例中，管理内存的责任简单地从一个智能指针转移给另一个。但是，如果我们不用另一个智能指针来保存 <code>release</code> 返回的指针，我们的程序就要负责资源的释放。</p>
</li>
<li><p>不能拷贝 <code>unique_ptr</code> 的规则有一个例外：<strong>我们可以拷贝或赋值一个将要被销毁的 <code>unique_ptr</code></strong>。最常见的例子是从函数返回一个 <code>unique_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 正确：从 int* 创建一个 unique_ptr&lt;int&gt;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以返回一个局部对象的拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ret</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(p))</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于两段代码，编译器都知道要返回的对象将要被销毁。在此情况下，编译器执行一种特殊的“拷贝”。</p>
</li>
<li><p><strong>向后兼容：<code>auto_ptr</code>。</strong> 标准库的较早版本包含了一个名为 <code>auto_ptr</code> 的类，它具有 <code>unique_ptr</code> 的部分特性，但不是全部。特别是，我们不能在容器中保存 <code>auto_ptr</code>，也不能从函数中返回 <code>auto_ptr</code>。虽然 <code>auto_ptr</code> 仍是标准库的一部分，但编写程序时应该使用 <code>unique_ptr</code>。</p>
<blockquote>
<p>《Effective C++》第三版中使用的仍然是 <code>auto_ptr</code>。</p>
</blockquote>
</li>
<li><p>为 <code>unique_ptr</code> 对象指定删除器的方式与 <code>shared_ptr</code> 有所不同：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p 指向一个类型为 objT 的对象，并使用一个类型为 delT 的对象释放 objT 对象</span></span><br><span class="line"><span class="comment">// 它会调用一个名为 fcn 的 delT 类型对象</span></span><br><span class="line">unique_ptr&lt;objT, delT&gt; p(new objT, fcn);</span><br></pre></td></tr></table></figure>
<p>我们使用 <code>unique_ptr</code> 代替 <code>shared_ptr</code> 重写前面的连接程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他需要的参数 */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connectionc = connect(&amp;d); <span class="comment">// 打开连接</span></span><br><span class="line">    <span class="comment">// 当 p 被销毁时，连接将会关闭</span></span><br><span class="line">    unique_ptr&lt;connection, decltype(end_connection) *&gt; p(&amp;c, end_connection);</span><br><span class="line">    <span class="comment">// 使用连接</span></span><br><span class="line">    <span class="comment">// 当 f 退出时（即使是由于异常而退出），connection 会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 12.17：</strong> 下面的 <code>unique_ptr</code> 声明中，哪些是合法的，哪些可能导致后续的程序错误？解释每个错误的问题在哪里。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ix = <span class="number">1024</span>, *pi = &amp;ix, *pi2 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2048</span>);</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; IntP;</span><br><span class="line"></span><br><span class="line">(a) <span class="function">IntP <span class="title">p0</span><span class="params">(ix)</span></span>;</span><br><span class="line">(b) <span class="function">IntP <span class="title">p1</span><span class="params">(pi)</span></span>;</span><br><span class="line">(c) <span class="function">IntP <span class="title">p2</span><span class="params">(pi2)</span></span>;</span><br><span class="line">(d) <span class="function">IntP <span class="title">p3</span><span class="params">(&amp;ix)</span></span>;</span><br><span class="line">(e) <span class="function">IntP <span class="title">p4</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2048</span>))</span></span>;</span><br><span class="line">(f) <span class="function">IntP <span class="title">p5</span><span class="params">(p2.get())</span></span>;</span><br></pre></td></tr></table></figure>
<p>答：（a）不合法，<code>unique_ptr</code> 对象需要用指针进行初始化；（b）合法，但 pi 是个栈区地址；（c）合法，但很危险，因为通过 <code>unique_ptr</code> 和 pi2 都可以操作内存，有可能出现一方释放了内存，但另一方仍在使用内存；（d）合法，但存在和（b）相同的问题；（e）合法，且安全；（f）合法，但两个 <code>unique_ptr</code> 共享对一块内存的拥有权，应使用 <code>release</code> 方法。</p>
</li>
</ol>
<h2 id="12-1-6-weak-ptr" class="heading-control"><a href="#12-1-6-weak-ptr" class="headerlink" title="12.1.6 weak_ptr"></a>12.1.6 weak_ptr<a class="heading-anchor" href="#12-1-6-weak-ptr" aria-hidden="true"></a></h2><ol>
<li><p><code>weak_ptr</code> 是一种不控制所指向对象生存期的智能指针，它指向由一个 <code>shared_ptr</code> 管理的对象。将一个 <code>weak_ptr</code> 绑定到一个 <code>shared_ptr</code> 不会改变 <code>shared_ptr</code> 的引用计数。一旦最后一个指向对象的 <code>shared_ptr</code> 被销毁，对象就会被释放。即使有 <code>weak_ptr</code> 指向对象，对象也还是会被释放。</p>
</li>
<li><p><code>weak_ptr</code> 支持的操作：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>weak_ptr</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">weak_ptr&lt;T&gt; w</td>
    <td class="tg-0pky">空 weak_ptr 可以指向类型为 T 的对象</td>
  </tr>
  <tr>
    <td class="tg-0pky">weak_ptr&lt;T&gt; w(sp)</td>
    <td class="tg-0pky">与 shared_ptr sp 指向相同对象的 weak_ptr。T 必须能转换为 sp 指向的类型</td>
  </tr>
  <tr>
    <td class="tg-0pky">w = p</td>
    <td class="tg-0pky">p 可以是一个 shared_ptr 或一个 weak_ptr。赋值后 w 与 p 共享对象</td>
  </tr>
  <tr>
    <td class="tg-0pky">w.reset()</td>
    <td class="tg-0pky">将 w 置为空</td>
  </tr>
  <tr>
    <td class="tg-0pky">w.use_count()</td>
    <td class="tg-0pky">与 w 共享对象的 shared_ptr 的数量</td>
  </tr>
  <tr>
    <td class="tg-0pky">w.expired()</td>
    <td class="tg-lboi">若 w.use_count() 为 0，返回 true，否则返回 false</td>
  </tr>
  <tr>
    <td class="tg-0pky">w.lock()</td>
    <td class="tg-0pky">如果 expired 为 true，返回一个空 shared_ptr；否则返回一个指向 w 的对象的 shared_ptr</td>
  </tr>
</tbody>
</table>

</li>
</ol>
<h1 id="12-2-动态数组" class="heading-control"><a href="#12-2-动态数组" class="headerlink" title="12.2 动态数组"></a>12.2 动态数组<a class="heading-anchor" href="#12-2-动态数组" aria-hidden="true"></a></h1><ol>
<li><blockquote>
<p><strong>最佳实践：</strong> 大多数应用应该使用标准库容器而不是动态分配的数组。使用容器更为简单、更不容易出现内存管理错误并且可能有更好的性能。</p>
</blockquote>
</li>
</ol>
<h2 id="12-2-1-new-和数组" class="heading-control"><a href="#12-2-1-new-和数组" class="headerlink" title="12.2.1 new 和数组"></a>12.2.1 new 和数组<a class="heading-anchor" href="#12-2-1-new-和数组" aria-hidden="true"></a></h2><ol>
<li><p>在下例中，<code>new</code> 分配要求数量的对象并（假定分配成功后）返回指向第一个对象的指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 get_size 确定分配多少个 int</span></span><br><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()]; <span class="comment">// pia 指向第一个 int</span></span><br></pre></td></tr></table></figure>
<p>方括号中的大小必须是整型，但不必是常量。</p>
</li>
<li><p>也可以用一个表示数组类型的类型别名来分配一个数组，这样，<code>new</code> 表达式中就不需要方括号了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>]; <span class="comment">// arrT 表示 42 个 int 的数组类型</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;    <span class="comment">// 分配一个 42 个 int 的数组；p 指向第一个 int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当用 <code>new</code> 分配一个数组时，我们并未得到一个数组类型的对象，而是得到一个数组元素类型的指针。即使我们使用类型别名定义了一个数组类型，<code>new</code> 也不会分配一个数组类型的对象。由于分配的内存并不是一个数组类型，因此不能对动态数组调用 <code>begin</code> 或 <code>end</code>，这些函数使用数组维度来返回指向首元素和尾后元素的指针。出于相同的原因，也不能用范围 <code>for</code> 语句来处理（所谓的）动态数组中的元素。</p>
</li>
<li><blockquote>
<p><strong>WARNING：</strong> 动态数组并不是数组类型。</p>
</blockquote>
</li>
<li><p>默认情况下，<code>new</code> 分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。可以对数组中的元素进行值初始化，方法是在大小之后跟一对空括号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];          <span class="comment">// 10 个未初始化的 int</span></span><br><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();       <span class="comment">// 10 个值初始化为 0 的 int</span></span><br><span class="line"><span class="built_in">string</span> *psa = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>];    <span class="comment">// 10 个空 string</span></span><br><span class="line"><span class="built_in">string</span> *psa2 = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>](); <span class="comment">// 10 个空 string</span></span><br></pre></td></tr></table></figure>
<p>在新标准中，我们还可以提供一个元素初始化器的花括号列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 10 个 int 分别用列表中对应的初始化器初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="comment">// 10 个 string，前 4 个用给定的初始化器初始化，剩余的进行值初始化</span></span><br><span class="line"><span class="built_in">string</span> *psa3 = <span class="keyword">new</span> <span class="built_in">string</span>[<span class="number">10</span>]&#123;<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>, <span class="built_in">string</span>(<span class="number">3</span>, <span class="string">'x'</span>)&#125;;</span><br></pre></td></tr></table></figure>
<p>与内置数组对象的列表初始化一样，初始化器会用来初始化动态数组中开始部分的元素。如果初始化器数目小于元素数目，剩余元素将进行值初始化。如果初始化器数目大于元素数目，则 <code>new</code> 表达式失败，不会分配任何内存。</p>
</li>
<li><p><strong>动态分配一个空数组是合法的。</strong> 当我们用 <code>new</code> 分配一个大小为 0 的数组时，<code>new</code> 返回一个合法的非空指针。此指针保证与 <code>new</code> 返回的其他任何指针都不相同。对于零长度的数组来说，此指针就像尾后指针一样，我们可以像使用尾后迭代器一样使用这个指针。可以用此指针进行比较操作。可以向此指针加上（或从此指针减去）0，也可以从此指针减去自身从而得到 0。但此指针不能解引用——毕竟它不指向任何元素。</p>
</li>
<li><p>释放动态数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span>[] pa; <span class="comment">// pa 必须指向一个动态分配的数组或为空</span></span><br></pre></td></tr></table></figure>
<p>数组中的元素按逆序销毁，即，最后一个元素首先被销毁，然后是倒数第二个，依此类推。其中的 <code>[]</code> 是必须的，即使是用 <code>typedef</code> 定义的数组类型别名申请的动态内存：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">42</span>]; <span class="comment">// arrT 是 42 个 int 的数组的类型别名</span></span><br><span class="line"><span class="keyword">int</span> *p = <span class="keyword">new</span> arrT;    <span class="comment">// 分配一个 42 个 int 的数组；p 指向第一个元素</span></span><br><span class="line"><span class="keyword">delete</span>[] p;           <span class="comment">// 方括号是必需的，因为我们当初分配的是一个数组</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对应《Effective C++》第三版条款 16。</p>
</blockquote>
</li>
<li><p>可以使用 <code>unique_ptr</code> 方便地管理动态数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// up 指向一个包含 10 个未初始化 int 的数组</span></span><br><span class="line">unique_ptr&lt;int[]&gt; up(new int[10]);</span><br><span class="line">up.release(); <span class="comment">// 自动用 delete[] 销毁其指针</span></span><br></pre></td></tr></table></figure>
<p>由于 up 指向一个数组，当 up 销毁它管理的指针时，会自动使用 <code>delete[]</code>。</p>
</li>
<li><p>当一个 <code>unique_ptr</code> 指向一个数组时，我们不能使用点和箭头成员运算符，可以使用下标运算符来访问数组中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    up[i] = i; <span class="comment">// 为每个元素赋予一个新值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与 <code>unique_ptr</code> 不同，<code>shared_ptr</code> 不直接支持管理动态数组。<strong>如果希望使用 <code>shared_ptr</code> 管理一个动态数组，必须提供自己定义的删除器</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了使用 shared_ptr，必须提供一个删除器</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p) &#123; <span class="keyword">delete</span>[] p; &#125;)</span></span>;</span><br><span class="line">sp.reset(); <span class="comment">// 使用我们提供的 lambda 释放数组，它使用 delete[]</span></span><br></pre></td></tr></table></figure>
<p>如果未提供删除器，这段代码将是未定义的。默认情况下，<code>shared_ptr</code> 使用 <code>delete</code> 销毁它指向的对象。如果此对象是一个动态数组，对其使用 <code>delete</code> 所产生的问题与释放一个动态数组指针时忘记 <code>[]</code> 产生的问题一样。</p>
</li>
<li><p><code>shared_ptr</code> 不直接支持动态数组管理这一特性会影响我们如何访问数组中的元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// shared_ptr 未定义下标运算符，并且不支持指针的算术运算</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">    *(sp.get() + i) = i; <span class="comment">// 使用 get 获取一个内置指针</span></span><br></pre></td></tr></table></figure>
<p><code>shared_ptr</code> 未定义下标运算符，而且智能指针类型不支持指针算术运算。因此，为了访问数组中的元素，必须用 <code>get</code> 获取一个内置指针，然后用它来访问数组元素。</p>
</li>
</ol>
<h2 id="12-2-2-allocator-类" class="heading-control"><a href="#12-2-2-allocator-类" class="headerlink" title="12.2.2 allocator 类"></a>12.2.2 allocator 类<a class="heading-anchor" href="#12-2-2-allocator-类" aria-hidden="true"></a></h2><ol>
<li><p>标准库 <code>allocator</code> 类定义在头文件 <code>memory</code> 中，它帮助我们将内存分配和对象构造分离开采。它提供一种类型感知的内存分配方法，它分配的内存是原始的、未构造的。</p>
</li>
<li><p><code>allocator</code> 是一个模板，当一个 <code>allocator</code> 对象分配内存时，它会根据给定的对象类型来确定恰当的内存大小和对齐位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">allocator&lt;<span class="built_in">string</span>&gt; alloc;          <span class="comment">// 可以分配 string 的 allocator 对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="keyword">const</span> p = alloc.allocate(n); <span class="comment">// 分配 n 个未初始化的 string</span></span><br></pre></td></tr></table></figure>
<p>这个 <code>allocate</code> 调用为 n 个 <code>string</code> 分配了内存。</p>
</li>
<li><p><code>allocator</code> 支持的操作：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>标准库 allocator 类及其算法</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">allocator&lt;T&gt; a</td>
    <td class="tg-0pky">定义了一个名为 a 的 allocator 对象，它可以为类型为 T 的对象分配内存</td>
  </tr>
  <tr>
    <td class="tg-0lax">a.allocate(n)</td>
    <td class="tg-0lax">分配一段原始的、未构造的内存，保存 n 个类型为 T 的对象</td>
  </tr>
  <tr>
    <td class="tg-0lax">a.deallocate(p, n)</td>
    <td class="tg-0lax">释放从 T* 指针 p 中地址开始的内存，这块内存保存了 n 个类型为 T 的对象；p 必须是一个先前由 allocate 返回的指针，且 n&nbsp;&nbsp;必须是 p 创建时所要求的大小。在调用 deallocate 之前，用户必须对每个在这块内存中创建的对象调用 destroy</td>
  </tr>
  <tr>
    <td class="tg-0lax">a.construct(p, args)</td>
    <td class="tg-0lax">p 必须是一个类型为 T* 的指针，指向一块原始内存；arg 被传递给类型为 T 的构造函数，用来在 p 指向的内存中构造一个对象</td>
  </tr>
  <tr>
    <td class="tg-0lax">a.destroy(p)</td>
    <td class="tg-0lax">p 为 T* 类型的指针，此算法对 p 指向的对象执行析构函数</td>
  </tr>
</tbody>
</table>
</li>
<li><blockquote>
<p><strong>WARNING：</strong> 为了使用 <code>allocate</code> 返回的内存，我们必须用 <code>construct</code> 构造对象。使用未构造的内存，其行为是未定义的。</p>
</blockquote>
</li>
<li><p>标准库还为 <code>allocator</code> 类定义了两个伴随算法，可以在未初始化内存中创建对象，它们都定义在头文件 <code>memory</code> 中：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>allocator 算法</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">uninitialized_copy(b, e, b2)</td>
    <td class="tg-0pky">从迭代器 b 和 e 指出的输入范围中拷贝元素到迭代器 b2 指定的未构造的原始内存中。b2 指向的内存必须足够大，能容纳输入序列中元素的拷贝</td>
  </tr>
  <tr>
    <td class="tg-0lax">uninitialized_copy_n(b, n, b2)</td>
    <td class="tg-0lax">从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2 开始的内存中</td>
  </tr>
  <tr>
    <td class="tg-0lax">uninitialized_fill(b, e, t)</td>
    <td class="tg-0lax">在迭代器 b 和 e 指定的原始内存范围中创建对象，对象的值均为 t 的拷贝</td>
  </tr>
  <tr>
    <td class="tg-0lax">uninitialized_fill_n(b, n, t)</td>
    <td class="tg-0lax">从迭代器 b 指向的内存地址开始创建 n 个对象。b 必须指向足够大的未构造的原始内存，能够容纳给定数量的对象</td>
  </tr>
</tbody>
</table>

<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配比 vi 中元素所占用空间大一倍的动态内存</span></span><br><span class="line"><span class="keyword">auto</span> p = alloc.allocate(vi.size() * <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 通过拷贝 vi 中的元素来构造从 p 开始的元素</span></span><br><span class="line"><span class="keyword">auto</span> q = uninitialized_copy(vi.begin(), vi.end(), p);</span><br><span class="line"><span class="comment">// 将剩余元素初始化为 42</span></span><br><span class="line">uninitialized_fill_n(q, vi.size(), <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>类似 <code>copy</code>，<code>uninitialized_copy</code> 返回（递增后的）目的位置迭代器。因此，一次 <code>uninitialized_copy</code> 调用会返回一个指针，指向最后一个构造的元素之后的位置。</p>
</li>
</ol>
<h1 id="12-3-使用标准库：文本查询程序" class="heading-control"><a href="#12-3-使用标准库：文本查询程序" class="headerlink" title="12.3 使用标准库：文本查询程序"></a>12.3 使用标准库：文本查询程序<a class="heading-anchor" href="#12-3-使用标准库：文本查询程序" aria-hidden="true"></a></h1><h2 id="12-3-1-文本查询程序设计" class="heading-control"><a href="#12-3-1-文本查询程序设计" class="headerlink" title="12.3.1 文本查询程序设计"></a>12.3.1 文本查询程序设计<a class="heading-anchor" href="#12-3-1-文本查询程序设计" aria-hidden="true"></a></h2><h2 id="12-3-2-文本查询程序类的定义" class="heading-control"><a href="#12-3-2-文本查询程序类的定义" class="headerlink" title="12.3.2 文本查询程序类的定义"></a>12.3.2 文本查询程序类的定义<a class="heading-anchor" href="#12-3-2-文本查询程序类的定义" aria-hidden="true"></a></h2><h1 id="小结" class="heading-control"><a href="#小结" class="headerlink" title="小结"></a>小结<a class="heading-anchor" href="#小结" aria-hidden="true"></a></h1><h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%AC%AC%2012%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8.png" alt="第 12 章术语表"></p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 14 章 操作重载与类型转换</title>
    <url>/archives/5ac252d6.html</url>
    <content><![CDATA[<ol>
<li><p>和内置类型的转换一样，类类型转换隐式地将一种类型的对象转换成另一种我们所需类型的对象。</p>
</li>
<li><p>当运算符作用于类类型的运算对象时，可以通过运算符重载重新定义该运算符的含义。</p>
</li>
</ol>
<h1 id="14-1-基本概念" class="heading-control"><a href="#14-1-基本概念" class="headerlink" title="14.1 基本概念"></a>14.1 基本概念<a class="heading-anchor" href="#14-1-基本概念" aria-hidden="true"></a></h1><ol>
<li><p><strong>重载的运算符是具有特殊名字的函数：它们的名字由关键字 <code>operator</code> 和其后要定义的运算符号共同组成。和其他函数一样，重载的运算符也包含返回类型、参数列表以及函数体。</strong></p>
<p>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，而右侧运算对象传递给第二个参数。<strong>除了重载的函数调用运算符 <code>operator()</code> 之外，其他重载运算符不能含有默认实参。</strong></p>
<p><strong>如果一个运算符函数是成员函数，则它的第一个（左侧）运算对象绑定到隐式的 <code>this</code> 指针上，因此，成员运算符函数的（显式）参数数量比运算符的运算对象总数少一个。</strong></p>
<blockquote>
<p>Note：当一个重载的运算符是成员函数时，<code>this</code> 绑定到左侧运算对象。成员运算符函数的（显式）参数数量比运算对象的数量少一个。</p>
</blockquote>
</li>
<li><p>对于一个运算符函数来说，它或者是类的成员，或者至少含有一个类类型的参数。这一约定意味着当运算符作用于内置类型的运算对象时，我们无法改变该运算符的含义。</p>
</li>
<li><p>我们可以重载大多数（但不是全部）运算符：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-1wig{font-weight:bold;text-align:left;vertical-align:top}<br>.tg .tg-baqh{text-align:center;vertical-align:top}<br>.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-amwm" colspan="6"><center>运算符</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-1wig" colspan="6"><b>可以被重载的运算符</b></td>
  </tr>
  <tr>
    <td class="tg-baqh">+</td>
    <td class="tg-baqh">-</td>
    <td class="tg-baqh">*</td>
    <td class="tg-baqh">/</td>
    <td class="tg-baqh">%</td>
    <td class="tg-baqh">^</td>
  </tr>
  <tr>
    <td class="tg-baqh">&amp;</td>
    <td class="tg-baqh">|</td>
    <td class="tg-baqh">~</td>
    <td class="tg-baqh">!</td>
    <td class="tg-baqh">,</td>
    <td class="tg-baqh">=</td>
  </tr>
  <tr>
    <td class="tg-baqh">&lt;</td>
    <td class="tg-baqh">&gt;</td>
    <td class="tg-baqh">&lt;=</td>
    <td class="tg-baqh">&gt;=</td>
    <td class="tg-baqh">++</td>
    <td class="tg-baqh">--</td>
  </tr>
  <tr>
    <td class="tg-baqh">&lt;&lt;</td>
    <td class="tg-baqh">&gt;&gt;</td>
    <td class="tg-baqh">==</td>
    <td class="tg-baqh">!=</td>
    <td class="tg-baqh">&amp;&amp;</td>
    <td class="tg-baqh">||</td>
  </tr>
  <tr>
    <td class="tg-baqh">+=</td>
    <td class="tg-baqh">-=</td>
    <td class="tg-baqh">/=</td>
    <td class="tg-baqh">%=</td>
    <td class="tg-baqh">^=</td>
    <td class="tg-baqh">&amp;=</td>
  </tr>
  <tr>
    <td class="tg-baqh">|=</td>
    <td class="tg-baqh">*=</td>
    <td class="tg-baqh">&lt;&lt;=</td>
    <td class="tg-baqh">&gt;&gt;=</td>
    <td class="tg-baqh">[]</td>
    <td class="tg-baqh">()</td>
  </tr>
  <tr>
    <td class="tg-baqh">-&gt;</td>
    <td class="tg-baqh">-&gt;*</td>
    <td class="tg-baqh">new</td>
    <td class="tg-baqh">new[]</td>
    <td class="tg-baqh">delete</td>
    <td class="tg-baqh">delete[]</td>
  </tr>
  <tr>
    <td class="tg-1wig" colspan="6"><b>不能被重载的运算符</b></td>
  </tr>
  <tr>
    <td class="tg-baqh" colspan="2">::</td>
    <td class="tg-baqh">.*</td>
    <td class="tg-baqh">.</td>
    <td class="tg-baqh" colspan="2">?:</td>
  </tr>
</tbody>
</table>
</li>
<li><p><strong>我们只能重载已有的运算符，而无权发明新的运算符号。</strong></p>
</li>
<li><p>有四个符号（<code>+</code>、<code>-</code>、<code>*</code>、<code>&amp;</code>）既是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量我们可以推断到底定义的是哪种运算符。</p>
</li>
<li><p><strong>对于一个重载的运算符来说，其优先级和结合律与对应的内置运算符保持一致。</strong> 不考虑运算对象类型的话，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x == y + z;</span><br></pre></td></tr></table></figure>
<p>永远等价于 <code>x == (y + z);</code>。</p>
</li>
<li><p>通常情况下，我们将运算符作用于类型正确的实参，从而以这种间接方式“调用”重载的运算符函数。然而，<strong>我们也能像调用普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个非成员运算符函数的等价调用</span></span><br><span class="line">data1 + data2;           <span class="comment">// 普通的表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2); <span class="comment">// 等价的函数调用</span></span><br></pre></td></tr></table></figure>
<p><strong>我们像调用其他成员函数一样显式地调用成员运算符函数。具体做法是，首先指定运行函数的对象（或指针）的名字，然后使用点运算符（或箭头运算符）访问希望调用的函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">data1 += data2;          <span class="comment">// 基于“调用”的表达式</span></span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2); <span class="comment">// 对成员运算符函数的等价调用</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为使用重载的运算符本质上是一次函数调用，所以这些关于运算对象求值顺序的规则无法应用到重载的运算符上。特别是，逻辑与运算符、逻辑或运算符和逗号运算符的运算对象求值顺序规则无法保留下来。除此之外，<strong><code>&amp;&amp;</code> 和 <code>||</code> 运算符的重载版本也无法保留内置运算符的短路求值属性，两个运算对象总是会被求值</strong>。</p>
<p>因为上述运算符的重载版本无法保留求值顺序和/或短路求值属性，因此不建议重载它们。当代码使用了这些运算符的重载版本时，用户可能会突然发现他们一直习惯的求值规则不再适用了。</p>
</li>
<li><p>还有一个原因使得我们一般不重载逗号运算符和取地址运算符：C++ 语言已经定义了这两种运算符用于类类型对象时的特殊含义，这一点与大多数运算符都不相同。因为这两种运算符已经有了内置的含义，所以一般来说它们不应该被重载，否则它们的行为将异于常态，从而导致类的用户无法适应。</p>
<blockquote>
<p><strong>Best Practices：通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。</strong></p>
</blockquote>
</li>
<li><p>赋值运算符的行为与复合版本的类似：赋值之后，左侧运算对象和右侧运算对象的值相等，并且<strong>运算符应该返回它左侧运算对象的一个引用</strong>。重载的赋值运算应该继承而非违背其内置版本的含义。</p>
</li>
<li><p>下面的准则有助于我们在将运算符定义为成员函数还是普通的非成员函数做出抉择：</p>
<ul>
<li>赋值（<code>=</code>）、下标（<code>[]</code>）、调用（<code>()</code>）和成员访问箭头（<code>-&gt;</code>）运算符必须是成员。</li>
<li>复合赋值运算符一般来说应该是成员，但并非必须，这一点与赋值运算符略有不同。</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员。</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符等，因此它们通常应该是普通的非成员函数。</li>
</ul>
</li>
<li><p><strong>如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。当我们把运算符定义成成员函数时，它的左侧运算对象必须是运算符所属类的一个对象。</strong> 例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"world"</span>;</span><br><span class="line"><span class="built_in">string</span> t = s + <span class="string">"!"</span>;  <span class="comment">// 正确：我们能把一个 const char* 加到一个 string 对象中</span></span><br><span class="line"><span class="built_in">string</span> u = <span class="string">"hi"</span> + s; <span class="comment">// 如果 + 是 string 的成员，则产生错误</span></span><br></pre></td></tr></table></figure>
<p>如果 <code>operator+</code> 是 <code>string</code> 类的成员，则上面的第一个加法等价于 <code>s.operator+(&quot;!&quot;)</code>。同样的，<code>&quot;hi&quot; + s</code> 等价于 <code>&quot;hi&quot;.operator+(s)</code>。显然 <code>&quot;hi&quot;</code> 的类型是 <code>const char*</code>，这是一种内置类型，根本就没有成员函数。</p>
<p>因为 <code>string</code> 将 <code>+</code> 定义成了普通的非成员函数，所以 <code>&quot;hi&quot; + s</code> 等价于 <code>operator+(&quot;hi&quot;, s)</code>。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少有一个运算对象是类类型，并且两个运算对象都能准确无误地转换成 <code>string</code>。</p>
</li>
</ol>
<h1 id="14-2-输入和输出运算符" class="heading-control"><a href="#14-2-输入和输出运算符" class="headerlink" title="14.2 输入和输出运算符"></a>14.2 输入和输出运算符<a class="heading-anchor" href="#14-2-输入和输出运算符" aria-hidden="true"></a></h1><h2 id="14-2-1-重载输出运算符-lt-lt" class="heading-control"><a href="#14-2-1-重载输出运算符-lt-lt" class="headerlink" title="14.2.1 重载输出运算符 &lt;&lt;"></a>14.2.1 重载输出运算符 &lt;&lt;<a class="heading-anchor" href="#14-2-1-重载输出运算符-lt-lt" aria-hidden="true"></a></h2><ol>
<li><p>通常情况下，输出运算符的第一个形参是一个非常量 <code>ostream</code> 对象的引用。之所以 <code>ostream</code> 是非常量是因为向流写入内容会改变其状态；而该形参是引用是因为我们无法直接复制一个 <code>ostream</code> 对象。第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参；而之所以该形参可以是常量是因为（通常情况下）打印对象不会改变对象的内容。为了与其他输出运算符保持一致，<code>operator&lt;&lt;</code> 一般要返回它的 <code>ostream</code> 形参。</p>
</li>
<li><blockquote>
<p><strong>Best Practices：</strong> 通常，输出运算符应该主要负责打印对象的内容而非控制格式，输出运算符不应该打印换行符。</p>
</blockquote>
</li>
<li><p><strong>与 <code>iostream</code> 标准库兼容的输入输出运算符必须是普通的非成员函数，而不能是类的成员函数。</strong> 否则，它们的左侧运算对象将是我们的类的一个对象。</p>
</li>
<li><p><strong>IO 运算符通常需要读写类的非公有数据成员，所以 IO 运算符一般被声明为友元。</strong></p>
</li>
</ol>
<h2 id="14-2-2-重载输入运算符-gt-gt" class="heading-control"><a href="#14-2-2-重载输入运算符-gt-gt" class="headerlink" title="14.2.2 重载输入运算符 &gt;&gt;"></a>14.2.2 重载输入运算符 &gt;&gt;<a class="heading-anchor" href="#14-2-2-重载输入运算符-gt-gt" aria-hidden="true"></a></h2><ol>
<li><p>通常情况下，输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入到的（非常量）对象的引用。该运算符通常会返回某个给定流的引用。第二个形参之所以必须是个非常量是因为输入运算符本身的目的就是将数据读入到这个对象中。</p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 输入运算符必须处理输入可能失败的情况，而输出运算符不需要。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>Best Practices：</strong> 当读取操作发生错误时，输入运算符应该负责从错误中恢复。</p>
</blockquote>
</li>
</ol>
<h1 id="14-3-算术和关系运算符" class="heading-control"><a href="#14-3-算术和关系运算符" class="headerlink" title="14.3 算术和关系运算符"></a>14.3 算术和关系运算符<a class="heading-anchor" href="#14-3-算术和关系运算符" aria-hidden="true"></a></h1><ol>
<li><p>通常情况下，我们把算术和关系运算符定义成非成员函数以允许对左侧或右侧的运算对象进行转换。因为这些运算符一般不需要改变运算对象的状态，所以形参都是常量的引用。</p>
</li>
<li><p><strong>算术运算符通常会计算它的两个运算对象并得到一个新值，这个值有别于任意一个运算对象，常常位于一个局部变量之内，操作完成后返回该局部变量的副本作为其结果。</strong> 如果类定义了算术运算符，则它一般也会定义一个对应的复合赋值运算符。此时，最有效的方式是使用复合赋值来定义算术运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设两个对象指向同一本书</span></span><br><span class="line">Sales_data <span class="keyword">operator</span>+(<span class="keyword">const</span> Sales_data &amp;lhs, <span class="keyword">const</span> Sales_data &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Sales_data sum = lhs; <span class="comment">// 把 lhs 的数据成员拷贝给 sum</span></span><br><span class="line">    sum += rhs;           <span class="comment">// 将 rhs 加到 sum 中</span></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Tip：</strong> 如果类同时定义了算术运算符和相关的复合赋值运算符，则通常情况下应该使用复合赋值来实现算术运算符。</p>
</blockquote>
</li>
</ol>
<h2 id="14-3-1-相等运算符" class="heading-control"><a href="#14-3-1-相等运算符" class="headerlink" title="14.3.1 相等运算符"></a>14.3.1 相等运算符<a class="heading-anchor" href="#14-3-1-相等运算符" aria-hidden="true"></a></h2><ol>
<li><ul>
<li>如果一个类含有判断两个对象是否相等的操作，则它显然应该把函数定义成 <code>operator==</code> 而非一个普通的命名函数：因为用户肯定希望能使用 <code>==</code> 比较对象，所以提供了 <code>==</code> 就意味着用户无须再费时费力地学习并记忆一个全新的函数名字。此外，类定义了 <code>==</code> 运算符之后也更容易使用标准库容器和算法。</li>
<li>如果类定义了 <code>operator==</code>，则该运算符应该能判断一组给定的对象中是否含有重复数据。</li>
<li>通常情况下，相等运算符应该具有传递性，换句话说，如果 <code>a == b</code> 和 <code>b == c</code> 都为真，则 <code>a == c</code> 也应该为真。</li>
<li>如果类定义了 <code>operator==</code>，则这个类也应该定义 <code>operator!=</code>。对于用户来说，当他们能使用 <code>==</code> 时肯定也希望能使用 <code>!=</code>，反之亦然。</li>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个，这意味着其中一个运算符应该负责实际比较对象的工作，而另一个运算符则只是调用那个真正工作的运算符。</li>
</ul>
<p><br></p>
<blockquote>
<p><strong>Best Practices：</strong> 如果某个类在逻辑上有相等性的含义，则该类应该定义 <code>operator==</code>，这样做可以使得用户更容易使用标准库算法来处理这个类。</p>
</blockquote>
</li>
</ol>
<h2 id="14-3-2-关系运算符" class="heading-control"><a href="#14-3-2-关系运算符" class="headerlink" title="14.3.2 关系运算符"></a>14.3.2 关系运算符<a class="heading-anchor" href="#14-3-2-关系运算符" aria-hidden="true"></a></h2><ol>
<li>定义了相等运算符的类也常常（但不总是）包含关系运算符。特别是，因为关联容器和一些算法要用到小于运算符，所以定义 <code>operator&lt;</code> 会比较有用。</li>
<li><blockquote>
<p><strong>Best Practices：</strong> 如果存在唯一一种逻辑可靠的 <code>&lt;</code> 定义，则应该考虑为这个类定义 <code>&lt;</code> 运算符。如果类同时还包含 <code>==</code>，则当且仅当 <code>&lt;</code> 的定义和 <code>==</code> 产生的结果一致时才定义 <code>&lt;</code> 运算符。</p>
</blockquote>
</li>
</ol>
<h1 id="14-4-赋值运算符" class="heading-control"><a href="#14-4-赋值运算符" class="headerlink" title="14.4 赋值运算符"></a>14.4 赋值运算符<a class="heading-anchor" href="#14-4-赋值运算符" aria-hidden="true"></a></h1><ol>
<li><p>和拷贝赋值及移动赋值运算符一样，其他重载的赋值运算符也必须先释放当前内存空间，再创建一片新空间。（移动赋值运算符并没有创建新空间，而是接管了右侧运算对象的资源——博主注）</p>
</li>
<li><p><strong>我们可以重载赋值运算符。不论形参的类型是什么，赋值运算符都必须定义为成员函数。</strong></p>
</li>
<li><p>复合赋值运算符不非得是类的成员，不过我们还是倾向于把包括复合赋值在内的所有赋值运算都定义在类的内部。为了与内置类型的复合赋值保持一致，类中的复合赋值运算符也要返回其左侧运算对象的引用。</p>
<blockquote>
<p><strong>Best Practices：赋值运算符必须定义成类的成员，复合赋值运算符通常情况下也应该这样做。这两类运算符都应该返回左侧运算对象的引用。</strong></p>
</blockquote>
</li>
</ol>
<h1 id="14-5-下标运算符" class="heading-control"><a href="#14-5-下标运算符" class="headerlink" title="14.5 下标运算符"></a>14.5 下标运算符<a class="heading-anchor" href="#14-5-下标运算符" aria-hidden="true"></a></h1><ol>
<li><blockquote>
<p><strong>Note：下标运算符必须是成员函数。</strong></p>
</blockquote>
</li>
<li><p>为了与下标的原始定义兼容，下标运算符通常以所访问元素的引用作为返回值，这样做的好处是下标可以出现在赋值运算符的任意一端。进一步，<strong>我们最好同时定义下标运算符的常量版本和非常量版本，当作用于一个常量对象时，下标运算符返回常量引用以确保我们不会给返回的对象赋值</strong>。</p>
<blockquote>
<p><strong>Best Practices：如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用。</strong></p>
</blockquote>
<p>举个例子，我们按照如下形式定义 <code>StrVec</code> 的下标运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> elements[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *elements; <span class="comment">// 指向数组首元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这两个下标运算符的用法类似于 <code>vector</code> 或者数组中的下标。因为下标运算符返回的是元素的引用，所以当 <code>StrVec</code> 是非常量时，我们可以给元素赋值；而当我们对常量对象取下标时，不能为其赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设 svec 是一个 StrVec 对象</span></span><br><span class="line"><span class="keyword">const</span> StrVec cvec = svec; <span class="comment">// 把 svec 的元素拷贝到 cvec 中</span></span><br><span class="line"><span class="comment">// 如果 svec 中含有元素，对第一个元素运行 string 的 empty 函数</span></span><br><span class="line"><span class="keyword">if</span> (svec.size() &amp;&amp; svec[<span class="number">0</span>].empty())</span><br><span class="line">&#123;</span><br><span class="line">    svec[<span class="number">0</span>] = <span class="string">"zero"</span>; <span class="comment">// 正确：下标运算符返回 string 的引用</span></span><br><span class="line">    cvec[<span class="number">0</span>] = <span class="string">"Zip"</span>;  <span class="comment">// 错误：对 cvec 取下标返回的是常量引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过区分成员函数是否是 <code>const</code> 的，我们可以对其进行重载。因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用 <code>const</code> 成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。</strong>——博主注，<a href="https://blog.shipengx.com/archives/53fe514.html">《C++ Primer - 第 7 章 类》</a>第 41 条。</p>
</li>
</ol>
<h1 id="14-6-递增和递减运算符" class="heading-control"><a href="#14-6-递增和递减运算符" class="headerlink" title="14.6 递增和递减运算符"></a>14.6 递增和递减运算符<a class="heading-anchor" href="#14-6-递增和递减运算符" aria-hidden="true"></a></h1><ol>
<li>C++ 语言并不要求递增和递减运算符必须是类的成员，但是因为它们改变的正好是所操作对象的状态，所以建议将其设定为成员函数。</li>
<li><blockquote>
<p><strong>Best Practices：定义递增和递减运算符的类应该同时定义前置版本和后置版本。这些运算符通常应该被定义成类的成员。</strong></p>
</blockquote>
</li>
<li><blockquote>
<p><strong>Best Practices：为了与内置版本保持一致，前置运算符应该返回递增或递减后对象的引用。</strong></p>
</blockquote>
</li>
<li><p>要想同时定义前置和后置运算符，必须首先解决一个问题，即普通的重载形式无法区分这两种情况。前置和后置版本使用的是同一个符号，意味着其重载版本所用的名字将是相同的，并且运算对象的数量和类型也相同。</p>
<p><strong>为了解决这个问题，后置版本接受一个额外的（不被使用）<code>int</code> 类型的形参。当我们使用后置运算符时，编译器为这个形参提供一个值为 0 的实参。尽管从语法上来说后置函数可以使用这个额外的形参，但是在实际过程中通常不会这么做。这个形参的唯一作用就是区分前置版本和后置版本的函数，而不是真的要在实现后置版本时参与运算。</strong></p>
</li>
<li><blockquote>
<p><strong>Best Practices：为了与内置版本保持一致，后置运算符应该返回对象的原值（递增或递减之前的值），返回的形式是一个值而非引用。</strong></p>
</blockquote>
</li>
<li><p>对于后置版本来说，在递增对象之前需要首先记录对象的状态：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后置版本：递增/递减对象的值但是返回原值</span></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处无须检查有效性，调用前置递增运算时才需要检查</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>; <span class="comment">// 记录当前的值</span></span><br><span class="line">    ++*<span class="keyword">this</span>;                <span class="comment">// 向前移动一个元素，前置 ++ 需要检查递增的有效性</span></span><br><span class="line">    <span class="keyword">return</span> ret;             <span class="comment">// 返回之前记录的状态</span></span><br><span class="line">&#125;</span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处无须检查有效性，调用前置递减运算时才需要检查</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>; <span class="comment">// 记录当前的值</span></span><br><span class="line">    --*<span class="keyword">this</span>;                <span class="comment">// 向后移动一个元素，前置 -- 需要检查递减的有效性</span></span><br><span class="line">    <span class="keyword">return</span> ret;             <span class="comment">// 返回之前记录的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：</strong> 因为我们不会用到 <code>int</code> 形参，所以无须为其命名。</p>
</blockquote>
</li>
<li><p>如果我们想通过函数调用的方式调用后置版本，则必须为它的整型参数传递一个值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>; <span class="comment">// p 指向 a1 中的 vector</span></span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);  <span class="comment">// 调用后置版本的 operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();   <span class="comment">// 调用前置版本的 operator++</span></span><br></pre></td></tr></table></figure>
<p>尽管传入的值通常会被运算符函数忽略，但却必不可少，因为编译器只有通过它才能知道应该使用后置版本。</p>
</li>
</ol>
<h1 id="14-7-成员访问运算符" class="heading-control"><a href="#14-7-成员访问运算符" class="headerlink" title="14.7 成员访问运算符"></a>14.7 成员访问运算符<a class="heading-anchor" href="#14-7-成员访问运算符" aria-hidden="true"></a></h1><ol>
<li><blockquote>
<p><strong>Note：</strong> 箭头运算符必须是类的成员。解引用运算符通常也是类的成员，尽管并非必须如此。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>Note：</strong> 重载的箭头运算符必须返回类的指针或者自定义了箭头运算符的某个类的对象。</p>
</blockquote>
</li>
</ol>
<h1 id="14-8-函数调用运算符" class="heading-control"><a href="#14-8-函数调用运算符" class="headerlink" title="14.8 函数调用运算符"></a>14.8 函数调用运算符<a class="heading-anchor" href="#14-8-函数调用运算符" aria-hidden="true"></a></h1><ol>
<li><p>如果类重载了函数调用运算符，则我们可以像使用函数一样使用该类的对象。</p>
<p>举个简单的例子，下面这个名为 <code>absInt</code> 的 <code>struct</code> 含有一个调用运算符，该运算符负责返回其参数的绝对值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类只定义了一种操作：函数调用运算符，它负责接受一个 <code>int</code> 类型的实参，然后返回该实参的绝对值。</p>
<p>我们使用调用运算符的方式是令一个 <code>absInt</code> 对象作用于一个实参列表，这一过程看起来非常像调用函数的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line">absInt absObj;      <span class="comment">// 含有函数调用运算符的对象</span></span><br><span class="line"><span class="keyword">int</span> ui = absObj(i); <span class="comment">// 将 i 传递给 absObj.operator()</span></span><br></pre></td></tr></table></figure>
<p>即使 <code>absObj</code> 只是一个对象而非函数，我们也能“调用”该对象。<strong>调用对象实际上是在运行重载的调用运算符。</strong> 在此例中，该运算符接受一个 <code>int</code> 值并返回其绝对值。</p>
</li>
<li><blockquote>
<p><strong>Note：函数调用运算符必须是成员函数。一个类可以定义多个不同版本的调用运算符，相互之间应该在参数数量或类型上有所区别。</strong></p>
</blockquote>
</li>
<li><p>如果类定义了调用运算符，则该类的对象称作<strong>函数对象</strong>（function object）。因为可以调用这种对象，所以我们说这些对象的“行为像函数一样”。</p>
</li>
<li><p>和其他类一样，函数对象类除了 <code>operator()</code> 之外也可以包含其他成员。函数对象类通常含有一些数据成员，这些成员被用于定制调用运算符中的操作。</p>
</li>
<li><p><strong>函数对象常常作为泛型算法的实参。</strong> 例如，可以使用标准库 <code>for_each</code> 算法和我们自己的 <code>PrintString</code> 类来打印容器的内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">for_each(vs.begin(), vs.end(), PrintString(<span class="built_in">cerr</span>, <span class="string">'\n'</span>));</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="14-8-1-lambda-是函数对象" class="heading-control"><a href="#14-8-1-lambda-是函数对象" class="headerlink" title="14.8.1 lambda 是函数对象"></a>14.8.1 lambda 是函数对象<a class="heading-anchor" href="#14-8-1-lambda-是函数对象" aria-hidden="true"></a></h2><ol>
<li><p>当我们编写了一个 <code>lambda</code> 后，编译器将该表达式翻译成一个未命名类的未命名对象，在 <code>lambda</code> 表达式产生的类中含有一个重载的函数调用运算符，例如，对于我们传递给 <code>stable_sort</code> 作为其最后一个实参的 <code>lambda</code> 表达式来说：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据单词的长度对其进行排序，对于长度相同的单词按照字母表顺序排序</span></span><br><span class="line">stable_sort(words.begin(), words.end(),</span><br><span class="line">            [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;a, <span class="keyword">const</span> <span class="built_in">string</span> &amp;b)</span><br><span class="line">            &#123; <span class="keyword">return</span> a.size() &lt; b.size(); &#125;);</span><br></pre></td></tr></table></figure>
<p>其行为类似于下面这个类的一个未命名对象</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShorterString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.size() &lt; s2.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>产生的类只有一个函数调用运算符成员，它负责接受两个 <code>string</code> 并比较它们的长度，它的形参列表和函数体与 <code>lambda</code> 表达式完全一样。默认情况下 <code>lambda</code> 不能改变它捕获的变量。因此在默认情况下，由 <code>lambda</code> 产生的类当中的函数调用运算符是一个 <code>const</code> 成员函数。如果 <code>lambda</code> 被声明为可变的，则调用运算符就不是 <code>const</code> 的了。</p>
<p>用这个类替代 <code>lambda</code> 表达式后，我们可以重写并重新调用 <code>stable_sort</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">stable_sort(words.begin(), words.end(), ShorterString());</span><br></pre></td></tr></table></figure>
<p>第三个实参是新构建的 <code>ShorterString</code> 对象，当 <code>stable_sort</code> 内部的代码每次比较两个 <code>string</code> 时就会“调用”这一对象，此时该对象将调用运算符的函数体，判断第一个 <code>string</code> 的大小小于第二个时返回 <code>true</code>。</p>
</li>
<li><p><strong>当一个 <code>lambda</code> 表达式通过引用捕获变量时，将由程序负责确保 <code>lambda</code> 执行时引用所引的对象确实存在。因此，编译器可以直接使用该引用而无须在 <code>lambda</code> 产生的类中将其存储为数据成员。</strong></p>
</li>
<li><p><strong>通过值捕获的变量被拷贝到 <code>lambda</code> 中。因此，这种 <code>lambda</code> 产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，令其使用捕获的变量的值来初始化数据成员。</strong></p>
</li>
<li><p><strong><code>lambda</code> 表达式产生的类不含默认构造函数、赋值运算符及默认析构函数；它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定。</strong></p>
</li>
</ol>
<h2 id="14-8-2-标准库定义的函数对象" class="heading-control"><a href="#14-8-2-标准库定义的函数对象" class="headerlink" title="14.8.2 标准库定义的函数对象"></a>14.8.2 标准库定义的函数对象<a class="heading-anchor" href="#14-8-2-标准库定义的函数对象" aria-hidden="true"></a></h2><ol>
<li><p>标准库定义了一组表示算术运算符、关系运算符和逻辑运算符的类，每个类分别定义了一个执行命名操作的调用运算符。例如，<code>plus</code> 类定义了一个函数调用运算符用于对一对运算对象执行 <code>+</code> 的操作；<code>modulus</code> 类定义了一个调用运算符执行二元的 <code>%</code> 操作；<code>equal_to</code> 类执行 <code>==</code>，等等。</p>
<p>这些类都被定义成模板的形式，我们可以为其指定具体的应用类型，这里的类型即调用运算符的形参类型。例如，<code>plus&lt;string&gt;</code> 令 <code>string</code> 加法运算符作用于 <code>string</code> 对象；<code>plus&lt;int&gt;</code> 的运算对象是 <code>int</code>；<code>plus&lt;Sales_data&gt;</code> 对 <code>Sales_data</code> 对象执行加法运算，以此类推。</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial,    sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial,    sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;   vertical-align:top}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;   vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="3"><center>标准库函数对象</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <th class="tg-7btt">算术</th>
    <th class="tg-7btt">关系</th>
    <th class="tg-7btt">逻辑</th>
  </tr>
  <tr>
    <td class="tg-0pky">plus&lt;Type&gt;</td>
    <td class="tg-0pky">equal_to&lt;Type&gt;</td>
    <td class="tg-0pky">logical_and&lt;Type&gt;</td>
  </tr>
  <tr>
    <td class="tg-0pky">minus&lt;Type&gt;</td>
    <td class="tg-0pky">not_equal_to&lt;Type&gt;</td>
    <td class="tg-0pky">logical_or&lt;Type&gt;</td>
  </tr>
  <tr>
    <td class="tg-0pky">multiplies&lt;Type&gt;</td>
    <td class="tg-0pky">greater&lt;Type&gt;</td>
    <td class="tg-0pky">logical_not&lt;Type&gt;</td>
  </tr>
  <tr>
    <td class="tg-0pky">divides&lt;Type&gt;</td>
    <td class="tg-0pky">greater_equal&lt;Type&gt;</td>
    <td class="tg-0pky" rowspan="3"></td>
  </tr>
  <tr>
    <td class="tg-c3ow">modulus&lt;Type&gt;</td>
    <td class="tg-0pky">less&lt;Type&gt;</td>
  </tr>
  <tr>
    <td class="tg-c3ow">negate&lt;Type&gt;</td>
    <td class="tg-0pky">less_equal&lt;Type&gt;</td>
  </tr>      
</tbody>
</table>
</li>
<li><p>表示运算符的函数对象类常用来替换算法中的默认运算符。如我们所知，在默认情况下排序算法使用 <code>operator&lt;</code> 将序列按照升序排列。如果要执行降序排列的话，我们可以传入一个 <code>greater</code> 类型的对象。该类将产生一个调用运算符并负责执行待排序类型的大于运算。例如，如果 <code>svec</code> 是一个 <code>vector&lt;string&gt;</code>，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">sort(svec.begin(), svec.end(), greater&lt;<span class="built_in">string</span>&gt;());</span><br></pre></td></tr></table></figure>
<p>则上面的语句将按照降序对 <code>svec</code> 进行排序。第三个实参是 <code>greater&lt;string&gt;</code> 类型的一个未命名的对象，因此当 <code>sort</code> 比较元素时，不再是使用默认的 <code>&lt;</code> 运算符，而是调用给定的 <code>greater</code> 函数对象。该对象负责在 <code>string</code> 元素之间执行 <code>&gt;</code> 比较运算。</p>
<p>需要特别注意的是，<strong>标准库规定其函数对象对于指针同样适用</strong>。我们之前曾经介绍过比较两个无关指针将产生未定义的行为，然而我们可能会希望通过比较指针的内存地址来 <code>sort</code> 指针的 <code>vector</code>。直接这么做将产生未定义的行为，因此我们可以使用一个标准库函数对象来实现该目的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span> *&gt; nameTable; <span class="comment">// 指针的 vector</span></span><br><span class="line"><span class="comment">//错误：nameTable 中的指针彼此之间没有关系，所以 &lt; 将产生未定义的行为</span></span><br><span class="line">sort(nameTable.begin(), nameTable.end(),</span><br><span class="line">     [](<span class="built_in">string</span> *a, <span class="built_in">string</span> *b)</span><br><span class="line">     &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line"><span class="comment">// 正确：标准库规定指针的 less 是定义良好的</span></span><br><span class="line">sort(nameTable.begin(), nameTable.end(), less&lt;<span class="built_in">string</span> *&gt;());</span><br></pre></td></tr></table></figure>
<p><strong>关联容器使用 <code>less&lt;key_type&gt;</code> 对元素排序，因此我们可以定义一个指针的 <code>set</code> 或者在 <code>map</code> 中使用指针作为关键值而无须直接声明 <code>less</code>。</strong></p>
</li>
</ol>
<h2 id="14-8-3-可调用对象与-function" class="heading-control"><a href="#14-8-3-可调用对象与-function" class="headerlink" title="14.8.3 可调用对象与 function"></a>14.8.3 可调用对象与 function<a class="heading-anchor" href="#14-8-3-可调用对象与-function" aria-hidden="true"></a></h2><ol>
<li><p><strong>C++ 语言中有几种可调用的对象：函数、函数指针、<code>lambda</code> 表达式、<code>bind</code> 创建的对象以及重载了函数调用运算符的类。</strong></p>
</li>
<li><p>和其他对象一样，可调用的对象也有类型。例如，每个 <code>lambda</code> 有它自己唯一的（未命名）类类型；函数及函数指针的类型则由其返回值类型和实参类型决定，等等。</p>
<p>然而，两个不同类型的可调用对象却可能共享同一种<strong>调用形式</strong>（call signature）。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
<p>是一个函数类型，它接受两个 <code>int</code>、返回一个 <code>int</code>。</p>
</li>
<li><p>对于几个可调用对象共享同一种调用形式的情况，有时我们会希望把它们看成具有相同的类型。例如，考虑下列不同类型的可调用对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; returni + j; &#125;</span><br><span class="line"><span class="comment">// lambda，其产生一个未命名的函数对象类</span></span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span><br><span class="line">&#123; <span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"><span class="comment">// 函数对象类</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divide</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> denominator / divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这些可调用对象分别对其参数执行了不同的算术运算，尽管它们的类型各不相同，但是共享同一种调用形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数表</strong>（function table）用于存储指向可调用对象的“指针”。当程序需要执行某个特定的操作时，从表中查找该调用的函数。</p>
<p>在 C++ 语言中，函数表很容易通过 <code>map</code> 来实现。对于此例来说，我们使用一个表示运算符符号的 <code>string</code> 对象作为关键字；使用实现运算符的函数作为值。当我们需要求给定运算符的值时，先通过运算符索引 <code>map</code>，然后调用找到的那个元素。</p>
<p>假定我们的所有函数都相互独立，并且只处理关于 <code>int</code> 的二元运算，则 <code>map</code> 可以定义成如下的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 构建从运算符到函数指针的映射关系，其中函数接受两个 int、返回一个 int</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span> (*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; binops;</span><br></pre></td></tr></table></figure>
<p>我们可以按照下面的形式将 <code>add</code> 的指针添加到 <code>binops</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：add 是一个指向正确类型函数的指针</span></span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, add&#125;); <span class="comment">// &#123;"+", add&#125; 是一个 pair</span></span><br></pre></td></tr></table></figure>
<p>但是我们不能将 <code>mod</code> 或者 <code>divide</code> 存入 <code>binops</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">binops.insert(&#123;<span class="string">"%"</span>, mod&#125;); <span class="comment">// 错误：mod 不是一个函数指针</span></span><br></pre></td></tr></table></figure>
<p>问题在于 <code>mod</code> 是个 <code>lambda</code> 表达式，而每个 <code>lambda</code> 有它自己的类类型，该类型与存储在 <code>binops</code> 中的值的类型不匹配。</p>
</li>
<li><p>可以使用一个名为 <code>function</code> 的新的标准库类型解决上述问题，<code>function</code> 定义在 <code>functional</code> 头文件中：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;   vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;   vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>function 的操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">function&lt;T&gt; f;</td>
    <td class="tg-0pky">f 是一个用来存储可调用对象的空 function，这些可调用对象的调用形式应该与函数类型 T 相同（即 T 是 retType(args)）</td>
  </tr>
  <tr>
    <td class="tg-0pky">function&lt;T&gt; f(nullptr);</td>
    <td class="tg-0pky">显式地构造一个空 function</td>
  </tr>
  <tr>
    <td class="tg-0lax">function&lt;T&gt; f(obj);</td>
    <td class="tg-0lax">在 f 中存储可调用对象 obj 的副本</td>
  </tr>
  <tr>
    <td class="tg-0pky">f</td>
    <td class="tg-0pky">将 f 作为条件：当 f 含有一个可调用对象时为真；否则为假</td>
  </tr>
  <tr>
    <td class="tg-0pky">f(args)</td>
    <td class="tg-0pky">调用 f 中的对象，参数是 args</td>
  </tr>
  <tr>
    <th class="tg-fymr" colspan="2">定义为 function&lt;T&gt; 的成员的类型</th>
  </tr>
  <tr>
    <td class="tg-0pky">result type</td>
    <td class="tg-0pky">该 function 类型的可调用对象返回的类型</td>
  </tr>
  <tr>
    <td class="tg-0lax">argument_type</td>
    <td class="tg-cly1" rowspan="3">当 T 有一个或两个实参时定义的类型。如果 T 只有一个实参，则 argument_type 是该类型的同义词；如果 T 有两个实参，则    first_argument_type 和 second_argument_type 分别代表两个实参的类型</td>
  </tr>
  <tr>
    <td class="tg-0lax">first_argument_type</td>
  </tr>
  <tr>
    <td class="tg-0lax">second_argument_type</td>
  </tr>
</tbody>
</table>
</li>
<li><p><code>function</code> 是一个模板，和我们使用过的其他模板一样，当创建一个具体的 <code>function</code> 类型时我们必须提供额外的信息。在此例中，所谓额外的信息是指该 <code>function</code> 类型能够表示的对象的调用形式。参考其他模板，我们在一对尖括号内指定类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;</span><br></pre></td></tr></table></figure>
<p>在这里我们声明了一个 <code>function</code> 类型，它可以表示接受两个 <code>int</code>、返回一个 <code>int</code> 的可调用对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;             <span class="comment">// 函数指针</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide();        <span class="comment">// 函数对象类的对象</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) <span class="comment">// lambda</span></span><br><span class="line">                             &#123; <span class="keyword">return</span> i * j; &#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f1(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印 6</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f2(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印 2</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f3(<span class="number">4</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 打印 8</span></span><br></pre></td></tr></table></figure>
<p>使用这个 <code>function</code> 类型我们可以重新定义 <code>map</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 列举了可调用对象与二元运算符对应关系的表格</span></span><br><span class="line"><span class="comment">// 所有可调用对象都必须接受两个 int、返回一个 int</span></span><br><span class="line"><span class="comment">// 其中的元素可以是函数指针、函数对象或者 lambda</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br></pre></td></tr></table></figure>
<p>我们能把所有可调用对象，包括函数指针、<code>lambda</code> 或者函数对象在内，都添加到这个 <code>map</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops = &#123;</span><br><span class="line">    &#123;<span class="string">"+"</span>, add&#125;,                                <span class="comment">// 函数指针</span></span><br><span class="line">    &#123;<span class="string">"-"</span>, <span class="built_in">std</span>::minus&lt;<span class="keyword">int</span>&gt;()&#125;,                  <span class="comment">// 标准库函数对象</span></span><br><span class="line">    &#123;<span class="string">"/"</span>, divide()&#125;,                           <span class="comment">// 用户定义的函数对象</span></span><br><span class="line">    &#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i * j; &#125;&#125;, <span class="comment">// 未命名的 lambda</span></span><br><span class="line">    &#123;<span class="string">"8"</span>, mod&#125;&#125;;                               <span class="comment">// 命名了的 lambda 对象</span></span><br></pre></td></tr></table></figure>
<p>一如往常，<strong>当我们索引 <code>map</code> 时将得到关联值的一个引用</strong>。如果我们索引 <code>binops</code>，将得到 <code>function</code> 对象的引用。<strong><code>function</code> 类型重载了调用运算符，该运算符接受它自己的实参然后将其传递给存好的可调用对象</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">binops[<span class="string">"+"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用 add(10, 5)</span></span><br><span class="line">binops[<span class="string">"-"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 使用 minus&lt;int&gt; 对象的调用运算符</span></span><br><span class="line">binops[<span class="string">"/"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 使用 divide 对象的调用运算符</span></span><br><span class="line">binops[<span class="string">"*"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用 lambda 函数对象</span></span><br><span class="line">binops[<span class="string">"%"</span>](<span class="number">10</span>, <span class="number">5</span>); <span class="comment">// 调用 lambda 函数对象</span></span><br></pre></td></tr></table></figure>
<p>我们依次调用了 <code>binops</code> 中存储的每个操作。在第一个调用中，我们获得的元素存放着一个指向 <code>add</code> 函数的指针，因此调用 <code>binops[&quot;+&quot;](10, 5)</code> 实际上是使用该指针调用 <code>add</code>，并传入 10 和 5。在接下来的调用中，<code>binops[&quot;-&quot;]</code> 返回一个存放着 <code>std::minus&lt;int&gt;</code> 类型对象的 <code>function</code>，我们将执行该对象的调用运算符。</p>
</li>
<li><p>我们不能（直接）将重载函数的名字存入 <code>function</code> 类型的对象中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales data &amp;, <span class="keyword">const</span> Sales data &amp;)</span></span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, add&#125;); <span class="comment">// 错误：哪个 add？</span></span><br></pre></td></tr></table></figure>
<p>解决上述二义性问题的一条途径是存储函数指针而非函数的名字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add; <span class="comment">// 指针所指的 add 是接受两个 int 的版本</span></span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, fp&#125;);  <span class="comment">// 正确：fp 指向一个正确的 add 版本</span></span><br></pre></td></tr></table></figure>
<p>同样，我们也能使用 <code>lambda</code> 来消除二义性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：使用 lambda 来指定我们希望使用的 add 版本</span></span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, [](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123; <span class="keyword">return</span> add(a, b); &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p><code>lambda</code> 内部的函数调用传入了两个 <code>int</code>，因此该调用只能匹配接受两个 <code>int</code> 的 <code>add</code> 版本，而这也正是执行 <code>lambda</code> 时真正调用的函数。</p>
</li>
</ol>
<h1 id="14-9-重载、类型转换与运算符" class="heading-control"><a href="#14-9-重载、类型转换与运算符" class="headerlink" title="14.9 重载、类型转换与运算符"></a>14.9 重载、类型转换与运算符<a class="heading-anchor" href="#14-9-重载、类型转换与运算符" aria-hidden="true"></a></h1><ol>
<li>转换构造函数和类型转换运算符共同定义了<strong>类类型转换</strong>（class-type conversions），这样的转换有时也被称作<strong>用户定义的类型转换</strong>（user-defined conversions）。</li>
</ol>
<h2 id="14-9-1-类型转换运算符" class="heading-control"><a href="#14-9-1-类型转换运算符" class="headerlink" title="14.9.1 类型转换运算符"></a>14.9.1 类型转换运算符<a class="heading-anchor" href="#14-9-1-类型转换运算符" aria-hidden="true"></a></h2><ol>
<li><p>转换构造函数和类型转换运算符共同定义了<strong>类类型转换</strong>（class-type conversions），这样的转换有时也被称作<strong>用户定义的类型转换</strong>（user-defined conversions）。</p>
</li>
<li><p><strong>类型转换运算符</strong>（conversion operator）是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中 <code>type</code> 表示某种类型。类型转换运算符可以面向任意类型（除了 <code>void</code> 之外）进行定义，只要该类型能作为函数的返回类型。因此，我们<strong>不允许转换成数组或者函数类型，但允许转换成指针（包括数组指针及函数指针）或者引用类型</strong>。</p>
<p><strong>类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，因此，类型转换运算符一般被定义成 <code>const</code> 成员。</strong></p>
<blockquote>
<p><strong>Note：一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表也必须为空。类型转换函数通常应该是 <code>const</code>。</strong></p>
</blockquote>
</li>
<li><p>举个例子，我们定义一个比较简单的类，令其表示 0 到 255 之间的一个整数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"Bad SmallInt value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们的 <code>SmallInt</code> 类既定义了向类类型的转换，也定义了从类类型向其他类型的转换。其中，构造函数将算术类型的值转换成 <code>smallInt</code> 对象，而类型转换运算符将 <code>SmallInt</code> 对象转换成 <code>int</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>; <span class="comment">// 首先将 4 隐式地转换成 SmallInt，然后调用 SmallInt::operator=</span></span><br><span class="line">si + <span class="number">3</span>; <span class="comment">// 首先将 si 隐式地转换成 int，然后执行整数的加法</span></span><br></pre></td></tr></table></figure>
<p><strong>尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。</strong> 因此，我们可以将任何算术类型传递给 <code>SmallInt</code> 的构造函数。类似的，我们也能使用类型转换运算符将一个 <code>SmallInt</code> 对象转换成 <code>int</code>，然后再将所得的 <code>int</code> 转换成任何其他算术类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内置类型转换将 double 实参转换成 int</span></span><br><span class="line">SmallInt si = <span class="number">3.14</span>; <span class="comment">// 调用 SmallInt(int) 构造函数</span></span><br><span class="line"><span class="comment">// SmallInt 的类型转换运算符将 si 转换成 int</span></span><br><span class="line">si + <span class="number">3.14</span>;          <span class="comment">// 内置类型转换将所得的 int 继续转换成 double</span></span><br></pre></td></tr></table></figure>
<p>因为类型转换运算符是隐式执行的，所以无法给这些函数传递实参，当然也就不能在类型转换运算符的定义中使用任何形参。同时，尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(SmallInt &amp;)</span></span>; <span class="comment">// 错误：不是成员函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;             <span class="comment">// 错误：指定了返回类型</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">(<span class="keyword">int</span> = <span class="number">0</span>)</span> <span class="keyword">const</span></span>;          <span class="comment">// 错误：参数列表不为空</span></span><br><span class="line">    <span class="keyword">operator</span> <span class="keyword">int</span> *() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="number">42</span>; &#125; <span class="comment">// 错误：42 不是一个指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于类来说，定义向 <code>bool</code> 的类型转换还是比较普遍的现象。</p>
</li>
<li><p>C++11 新标准引入了<strong>显式的类型转换运算符</strong>（explicit conversion operator）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 编译器不会自动执行这一类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>和显式的构造函数一样，编译器（通常）也不会将一个显式的类型转换运算符用于隐式类型转换</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;          <span class="comment">// 正确：SmallInt 的构造函数不是显式的</span></span><br><span class="line">si + <span class="number">3</span>;                   <span class="comment">// 错误：此处需要隐式的类型转换，但类的运算符是显式的</span></span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>; <span class="comment">// 正确：显式地请求类型转换</span></span><br></pre></td></tr></table></figure>
<p><strong>当类型转换运算符是显式的时，我们也能执行类型转换，不过必须通过显式的强制类型转换才可以。</strong></p>
<p>该规定存在一个例外，即<strong>如果表达式被用作条件，则编译器会将显式的类型转换自动应用于它。换句话说，当表达式出现在下列位置时，显式的类型转换将被隐式地执行</strong>：</p>
<ul>
<li><code>if</code>、<code>while</code> 及 <code>do</code> 语句的条件部分</li>
<li><code>for</code> 语句头的条件表达式</li>
<li>逻辑非运算符（<code>!</code>）、逻辑或运算符（<code>||</code>）、逻辑与运算符（<code>&amp;&amp;</code>）的运算对象</li>
<li>条件运算符（<code>? :</code>）的条件表达式。</li>
</ul>
</li>
<li><p><strong>无论我们什么时候在条件中使用流对象，都会使用为 IO 类型定义的 <code>operator bool</code>。</strong> 例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; value)</span><br></pre></td></tr></table></figure>
<p><code>while</code> 语句的条件执行输入运算符，它负责将数据读入到 <code>value</code> 并返回 <code>cin</code>。为了对条件求值，<code>cin</code> 被 <code>istream operator bool</code> 类型转换函数隐式地执行了转换。如果 <code>cin</code> 的条件状态是 <code>good</code>，则该函数返回为真；否则该函数返回为假。</p>
</li>
<li><blockquote>
<p><strong>Best Practices：</strong> 向 <code>bool</code> 的类型转换通常用在条件部分，因此 <code>operator bool</code> 一般定义成 <code>explicit</code> 的。</p>
</blockquote>
</li>
</ol>
<h2 id="14-9-2-避免有二义性的类型转换" class="heading-control"><a href="#14-9-2-避免有二义性的类型转换" class="headerlink" title="14.9.2 避免有二义性的类型转换"></a>14.9.2 避免有二义性的类型转换<a class="heading-anchor" href="#14-9-2-避免有二义性的类型转换" aria-hidden="true"></a></h2><ol>
<li><p>在两种情况下可能产生多重转换路径。第一种情况是两个类提供相同的类型转换：例如，当 A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个转换目标是 A 类的类型转换运算符时，我们就说它们提供了相同的类型转换。</p>
<p>第二种情况是类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。最典型的例子是算术运算符，对某个给定的类来说，最好只定义最多一个与算术类型有关的转换规则。</p>
<blockquote>
<p><strong>WARNING：</strong> 通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及两个以上转换源或转换目标是算术类型的转换。</p>
</blockquote>
</li>
<li><p>在下面的例子中，我们定义了两种将 <code>B</code> 转换成 <code>A</code> 的方法：一种使用 <code>B</code> 的类型转换运算符、另一种使用 <code>A</code> 的以 <code>B</code> 为参数的构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最好不要在两个类之间构建相同的类型转换</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">const</span> B &amp;); <span class="comment">// 把一个 B 转换成 A</span></span><br><span class="line">    <span class="comment">// 其他数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 也是把一个 B 转换成 A</span></span><br><span class="line">    <span class="comment">// 其他数据成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="keyword">const</span> A &amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a = f(b); <span class="comment">// 二义性错误：含义是 f(B::operator A())</span></span><br><span class="line">            <span class="comment">// 还是 f(A::A(const B &amp;))?</span></span><br></pre></td></tr></table></figure>
<p>因为同时存在两种由 <code>B</code> 获得 <code>A</code> 的方法，所以造成编译器无法判断应该运行哪个类型转换，也就是说，对 <code>f</code> 的调用存在二义性。该调用可以使用以 <code>B</code> 为参数的 <code>A</code> 的构造函数，也可以使用 <code>B</code> 当中把 <code>B</code> 转换成 <code>A</code> 的类型转换运算符。因为这两个函数效果相当、难分伯仲，所以该调用将产生错误。</p>
<p>如果我们确实想执行上述的调用，就不得不显式地调用类型转换运算符或者转换构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">A a1 = f(b.<span class="keyword">operator</span> A()); <span class="comment">// 正确：使用 B 的类型转换运算符</span></span><br><span class="line">A a2 = f(A(b));           <span class="comment">// 正确：使用 A 的构造函数</span></span><br></pre></td></tr></table></figure>
<p>值得注意的是，我们无法使用强制类型转换来解决二义性问题，因为强制类型转换本身也面临二义性。</p>
</li>
<li><p>另外如果类定义了一组类型转换，它们的转换源（或者转换目标）类型本身可以通过其他类型转换联系在一起，则同样会产生二义性的问题。最简单也是最困扰我们的例子就是类当中定义了多个参数都是算术类型的构造函数，或者转换目标都是算术类型的类型转换运算符。</p>
<p>例如，在下面的类中包含两个转换构造函数，它们的参数是两种不同的算术类型；同时还包含两个类型转换运算符，它们的转换目标也恰好是两种不同的算术类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    A(<span class="keyword">int</span> = <span class="number">0</span>); <span class="comment">// 最好不要创建两个转换源都是算术类型的类型转换</span></span><br><span class="line">    A(<span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 最好不要创建两个转换对象都是算术类型的类型转换</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line">A a;</span><br><span class="line">f2(a); <span class="comment">// 二义性错误：含义是 f(A::operator int())</span></span><br><span class="line">       <span class="comment">// 还是 f(A::operator double())？</span></span><br><span class="line"><span class="keyword">long</span> lg;</span><br><span class="line"><span class="function">A <span class="title">a2</span><span class="params">(lg)</span></span>; <span class="comment">// 二义性错误：含义是 A::A(int) 还是 A::A(double)？</span></span><br></pre></td></tr></table></figure>
<p>在对 <code>f2</code> 的调用中，哪个类型转换都无法精确匹配 <code>long double</code>。然而这两个类型转换都可以使用，只要后面再执行一次生成 <code>long double</code> 的标准类型转换即可。因此，在上面的两个类型转换中哪个都不比另一个更好，调用将产生二义性。</p>
<p>当我们试图用 <code>long</code> 初始化 <code>a2</code> 时也遇到了同样问题，哪个构造函数都无法精确匹配 <code>long</code> 类型。它们在使用构造函数前都要求先将实参进行类型转换：</p>
<ul>
<li>先执行 <code>long</code> 到 <code>double</code> 的标准类型转换，再执行 <code>A(double)</code></li>
<li>先执行 <code>long</code> 到 <code>int</code> 的标准类型转换，再执行 <code>A(int)</code></li>
</ul>
<p><br></p>
<p>编译器没办法区分这两种转换序列的好坏，因此该调用将产生二义性。</p>
<p>调用 <code>f2</code> 及初始化 <code>a2</code> 的过程之所以会产生二义性，根本原因是它们所需的标准类型转换级别一致。当我们使用用户定义的类型转换时，如果转换过程包含标准类型转换，则标准类型转换的级别将决定编译器选择最佳匹配的过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">short s = <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 把 short 提升成 int 优于把 short 转换成 double</span></span><br><span class="line"><span class="function">A <span class="title">a3</span><span class="params">(s)</span></span>; <span class="comment">// 使用 A::A(int)</span></span><br></pre></td></tr></table></figure>
<p>在此例中，<strong>把 <code>short</code> 提升成 <code>int</code> 的操作要优于把 <code>short</code> 转换成 <code>double</code> 的操作</strong>，因此编译器将使用 <code>A::A(int)</code> 构造函数构造 <code>a3</code>，其中实参是 <code>s</code>（提升后）的值。</p>
<blockquote>
<p><strong>Note：</strong> 当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。</p>
</blockquote>
</li>
<li><p>除了显式地向 <code>bool</code> 类型的转换之外，我们应该尽量避免定义类型转换函数并尽可能地限制那些“显然正确”的非显式构造函数。</p>
</li>
<li><p>当我们调用重载的函数时，从多个类型转换中进行选择将变得更加复杂。如果两个或多个类型转换都提供了同一种可行匹配，则这些类型转换一样好。</p>
<p>举个例子，当几个重载函数的参数分属不同的类类型时，如果这些类恰好定义了同样的转换构造函数，则二义性问题将进一步提升：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    C(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">// 其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    D(<span class="keyword">int</span>);</span><br><span class="line">    <span class="comment">// 其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> C &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">(<span class="keyword">const</span> D &amp;)</span></span>;</span><br><span class="line">manip(<span class="number">10</span>); <span class="comment">// 二义性错误：含义是 manip(C(10)) 还是 manip(D(10))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当调用重载函数时，如果两个（或多个）用户定义的类型转换都提供了可行匹配，则我们认为这些类型转换一样好。在这个过程中，我们不会考虑任何可能出现的标准类型转换的级别。只有当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出现的标准类型转换。</p>
<p>例如当我们调用 <code>manip</code> 时，即使其中一个类定义了需要对实参进行标准类型转换的构造函数，这次调用仍然会具有二义性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">E</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    E(<span class="keyword">double</span>);</span><br><span class="line">    <span class="comment">// 其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> C &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip2</span><span class="params">(<span class="keyword">const</span> E &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 二义性错误：两个不同的用户定义的类型转换都能用在此处</span></span><br><span class="line">manip2(<span class="number">10</span>); <span class="comment">// 含义是 manip2(C(10)) 还是 manip2(E(double(10)))</span></span><br></pre></td></tr></table></figure>
<p>在此例中，<code>C</code> 有一个转换源为 <code>int</code> 的类型转换，<code>E</code> 有一个转换源为 <code>double</code> 的类型转换。对于 <code>manip2(10)</code> 来说，两个 <code>manip2</code> 函数都是可行的：</p>
<ul>
<li><code>manip2(const C &amp;)</code> 是可行的，因为 <code>C</code> 有一个接受 <code>int</code> 的转换构造函数，该构造函数与实参精确匹配。</li>
<li><code>manip2(const E &amp;)</code> 是可行的，因为 <code>E</code> 有一个接受 <code>double</code> 的转换构造函数，而且为了使用该函数我们可以利用标准类型转换把 <code>int</code> 转换成所需的类型。</li>
</ul>
<p><br></p>
<p>因为调用重载函数所请求的用户定义的类型转换不止一个且彼此不同，所以该调用具有二义性。<strong>即使其中一个调用需要额外的标准类型转换而另一个调用能精确匹配，编译器也会将该调用标示为错误。</strong></p>
<blockquote>
<p><strong>Note：</strong> 在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性。</p>
</blockquote>
</li>
</ol>
<h2 id="14-9-3-函数匹配与重载运算符" class="heading-control"><a href="#14-9-3-函数匹配与重载运算符" class="headerlink" title="14.9.3 函数匹配与重载运算符"></a>14.9.3 函数匹配与重载运算符<a class="heading-anchor" href="#14-9-3-函数匹配与重载运算符" aria-hidden="true"></a></h2><ol>
<li><p>重载的运算符也是重载的函数。</p>
</li>
<li><p>和普通函数调用不同，我们不能通过调用的形式来区分当前调用的是成员函数还是非成员函数。</p>
<p>当我们使用重载运算符作用于类类型的运算对象时，候选函数中包含该运算符的普通非成员版本和内置版本。除此之外，如果左侧运算对象是类类型，则定义在该类中的运算符的重载版本也包含在候选函数内。</p>
<p>当我们调用一个命名的函数时，具有该名字的成员函数和非成员函数不会彼此重载，这是因为我们用来调用命名函数的语法形式对于成员函数和非成员函数来说是不相同的。当我们通过类类型的对象（或者该对象的指针及引用）进行函数调用时，只考虑该类的成员函数。而当我们在表达式中使用重载的运算符时，无法判断正在使用的是成员函数还是非成员函数，因此二者都应该在考虑的范围内。</p>
<blockquote>
<p><strong>Note：</strong> 表达式中运算符的候选函数集既应该包括成员函数，也应该包括非成员函数。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>WARNING：</strong> 如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。</p>
</blockquote>
</li>
</ol>
<h1 id="小结" class="heading-control"><a href="#小结" class="headerlink" title="小结"></a>小结<a class="heading-anchor" href="#小结" aria-hidden="true"></a></h1><ol>
<li><p>一个重载的运算符必须是某个类的成员或者至少拥有一个类类型的运算对象。重载运算符的运算对象数量、结合律、优先级与对应的用于内置类型的运算符完全一致。当运算符被定义为类的成员时，类对象的隐式 <code>this</code> 指针绑定到第一个运算对象。赋值、下标、函数调用和箭头运算符必须作为类的成员。</p>
</li>
<li><p>如果类重载了函数调用运算符 <code>operator()</code>，则该类的对象被称作“函数对象”。这样的对象常用在标准函数中。<code>lambda</code> 表达式是一种简便的定义函数对象类的方式。</p>
</li>
<li><p>在类中可以定义转换源或转换目的是该类型本身的类型转换，这样的类型转换将自动执行。只接受单独一个实参的非显式构造函数定义了从实参类型到类类型的类型转换；而非显式的类型转换运算符则定义了从类类型到其他类型的转换。</p>
</li>
</ol>
<h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%AC%AC%2014%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8.png" alt="第 14 章术语表"></p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 1 章 开始</title>
    <url>/archives/3fc34abb.html</url>
    <content><![CDATA[<ol>
<li><p>每个 C++ 程序都包含一个或多个函数（function），其中一个必须命名为 <code>main</code>。</p>
</li>
<li><p><code>main</code> 函数的返回类型必须为 <code>int</code>，即整数类型。</p>
</li>
<li><p>在大多数系统中，<code>main</code> 的返回值被用来指示状态。返回值 0 表明成功，非 0 的返回值的含义由系统定义，通常用来指示错误类型。</p>
</li>
<li><p>对于源文件（source file）的命名，不同编译器使用不同的后缀命名约定，最常见的包括 <code>.cc</code> <code>.cxx</code> <code>.cpp</code> <code>.cp</code> <code>.c</code> 等。</p>
</li>
<li><p>在 UNIX 和 Windows 系统中，执行完一个程序后，都可以通过 <code>echo</code> 命令获得其返回值。在 UNIX 系统中，通过如下命令获得状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> $?</span><br></pre></td></tr></table></figure>
<p>在 Windows 系统中查看状态可键入：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> %ERRORLEVEL%</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器通常都包含一些选项，能对有问题的程序结构发出警告。我们习惯在 GNU 编译器中使用 <code>-Wall</code> 选项，在微软编译器中使用 <code>/W4</code>。</p>
</li>
<li><p><code>iostream</code> 库包含两个基础类型 <code>istream</code> 和 <code>ostream</code>，分别表示输入流和输出流。一个流就是一个字符序列，是从 IO 设备读出或写入 IO 设备的。术语“流”（stream）想要表达的是，随着时间的推移，字符是顺序生成或消耗的。</p>
</li>
<li><p>标准输入输出对象：<code>cin</code> <code>cout</code> <code>cerr</code> <code>clog</code>。</p>
</li>
<li><p>输出运算符 <code>&lt;&lt;</code> 接受两个运算对象：左侧的运算对象必须是一个 <code>ostream</code> 对象，右侧的运算对象是要打印的值。此运算符将给定的值写到给定的 <code>ostream</code> 对象中。输出运算符的计算结果就是其左侧运算对象。即，计算结果就是我们写入给定值的那个 ostream 对象。</p>
</li>
<li><p><code>endl</code> 被称为操纵符（manipulator）。写入 <code>endl</code> 的效果是结束当前行，并将与设备关联的缓冲区（buffer）中的内容刷到设备中。缓冲刷新操作可以保证到目前为止程序所产生的所有输出都真正写入输出流中，而不是仅停留在内存中等待写入流。</p>
</li>
<li><p>标准库定义的所有名字都在命名空间 <code>std</code> 中。</p>
</li>
<li><p>输入运算符 <code>&gt;&gt;</code> 与输出运算符类似，它接受一个 <code>istream</code> 作为其左侧运算对象，接受一个对象作为其右侧运算对象。它从给定的 <code>istream</code> 读入数据，并存入给定对象中。与输出运算符类似，输入运算符返回其左侧运算对象作为其计算结果。</p>
</li>
<li><p>界定符对形式的注释是以 <code>/*</code> 开始，以 <code>*/</code> 结束的。因此，一个注释不能嵌套在另一个注释之内。</p>
</li>
<li><p>下列哪些语句是合法的？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"/*"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*/"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="comment">/* "*/</span> <span class="string">" */;</span></span><br><span class="line"><span class="string">std::cout &lt;&lt; /* "</span>*/ <span class="string">" /* "</span> <span class="comment">/*" */</span>;</span><br></pre></td></tr></table></figure>
<p>语句 1、2、4 是合法的，分别输出 <code>/*</code> <code>*/</code> <code>/*</code>。</p>
</li>
<li><p>语句块（block），就是用花括号包围的零条或多条语句的序列。语句块也是语句的一种，在任何要求使用语句的地方都可以使用语句块。</p>
</li>
<li><p>每个 <code>for</code> 语句都包含两部分：循环头和循环体。循环头控制循环体的执行次数，它由三部分组成：初始化语句（init-statement）、循环条件（condition）和表达式（expression）。初始化语句定义的变量仅在 <code>for</code> 循环内部存在，在循环结束之后不能使用。初始化语句只在 <code>for</code> 循环入口处执行一次，循环体每次执行前都会先检查循环条件，表达式在 <code>for</code> 循环体之后执行。</p>
</li>
<li><p>观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val)</span><br><span class="line">    sum += val;</span><br></pre></td></tr></table></figure>
<p>该代码片段的数据读取操作是在 <code>while</code> 的循环条件中完成的，<code>while</code> 循环条件的求值就是执行表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val</span><br></pre></td></tr></table></figure>
<p>此表达式从标准输入读取下一个数，保存在 val 中。输入运算符返回其左侧运算对象，在本例中是 <code>std::cin</code>。因此，此循环条件实际上检测的是 <code>std::cin</code>。当使用一个 <code>istream</code> 对象作为条件时，其效果是检测流的状态。如果流是有效的，即流未遇到错误，那么检测成功。当遇到文件结束符（end-of-file），或遇到一个无效输入时（例如读入的值不是一个整数），<code>istream</code> 对象的状态会变为无效。处于无效状态的 <code>istream</code> 对象会使条件变为假。因此，上述代码片段中，<code>while</code> 循环会一直执行直至遇到文件结束符（或输入错误）（最简单的方法是完成数字的输入后随便输入一个符号然后回车———博主注）。</p>
</li>
<li><p>将如下代码片段编译为可执行程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; val)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"haha"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The number you input is "</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sum += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The sum of numbers you input is "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>执行编译后的可执行程序，并输入序列 <code>1 2 5 6 8 12 2? 3 5</code> 后回车，得到如下输出，思考程序执行流程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">haha</span><br><span class="line">The number you input is 2</span><br><span class="line">haha</span><br><span class="line">The number you input is 6</span><br><span class="line">haha</span><br><span class="line">The number you input is 12</span><br><span class="line">The number you input is 0</span><br><span class="line">The sum of numbers you input is 20</span><br></pre></td></tr></table></figure>
</li>
<li><p>标准库头文件通常不带后缀，编译器一般不关心头文件的格式。</p>
</li>
<li><p>每个类实际上都定义了一个新的类型，其类型名就是类名。</p>
</li>
<li><p>包含来自标准库的头文件时，应该用尖括号 <code>&lt; &gt;</code> 包围头文件，对于不属于标准库的头文件，则用双引号 <code>&quot; &quot;</code> 包围。</p>
</li>
<li><p>大多数操作系统支持文件重定向，这种机制允许我们将标准输入和标准输出与命名文件关联起来：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">addItems&lt;infile &gt;outfile</span><br></pre></td></tr></table></figure>
<p>假定程序已经编译为名为 addItems.exe 的可执行文件（在 UNIX 中是 addItems），则上述命令会从一个名为 infile 的文件读取数据，并将输出结果写入到一个名为 outfile 的文件中，两个文件都位于当前目录中。</p>
</li>
<li><p>成员函数（member function）是定义为类的一部分的函数，有时也被称为方法（method）。</p>
</li>
<li><p>点运算符（.）只能用于类类型的对象。其左侧运算对象必须是一个类类型的对象，右侧运算对象必须是该类型的一个成员名，运算结果为右侧运算对象指定的成员。当用点运算符访问一个成员函数时，通常是想调用该函数。使用调用运算符（<code>()</code>）来调用一个函数，调用运算符是一对圆括号，里面放置实参（argument）列表（可能为空）。</p>
</li>
<li><p><strong>缓冲区（buffer）</strong> 一个存储区域，用于保存数据。IO 设施通常将输入（或输出）数据保存在一个缓冲区中，读写缓冲区的动作与程序中的动作是无关的。可以显式地刷新输出缓冲，以便强制将缓冲区中的数据写入输出设备。默认情况下，读 cin 会刷新 cout；程序非正常终止时也会刷新 cout。</p>
</li>
<li><p><strong>cerr</strong> 一个 <code>ostream</code> 对象，关联到标准错误，通常写入到与标准输出相同的设备。默认情况下，写到 <code>cerr</code> 的数据是不缓冲的。<code>cerr</code> 通常用于输出错误信息或其它不属于程序正常逻辑的输出内容。</p>
</li>
<li><p><strong>clog</strong> 一个 <code>ostream</code> 对象，关联到标准错误。默认情况下，写到 <code>clog</code> 的数据是被缓冲的。<code>clog</code> 通常用于报告程序的执行信息，存入一个日志文件中。</p>
</li>
<li><p><strong>未初始化的变量（uninitialized variable）</strong> 未赋予初值的变量。类类型的变量如果未指定初值，则按类定义指定的方式进行初始化。定义在函数内部的内置类型变量默认是不初始化的，除非有显式的初始化语句。试图使用一个未初始化变量的值是错误的。未初始化变量是 bug 的常见成因。</p>
</li>
<li><p><strong>&gt;&gt;运算符（&gt;&gt;operator）输入运算符</strong> 从左侧运算对象所指定的输入流读取数据，存入右侧运算对象中：<code>cin &gt;&gt; i</code> 表示从标准输入读取下一个值，存入 i 中。输入运算符可以连接：<code>cin &gt;&gt; i &gt;&gt; j</code> 表示先读取一个值存入 i，再读取一个值存入 j。</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 15 章 面向对象程序设计</title>
    <url>/archives/9b53416f.html</url>
    <content><![CDATA[<h1 id="15-1-OOP：概述" class="heading-control"><a href="#15-1-OOP：概述" class="headerlink" title="15.1 OOP：概述"></a>15.1 OOP：概述<a class="heading-anchor" href="#15-1-OOP：概述" aria-hidden="true"></a></h1><ol>
<li><p><strong>面向对象程序设计</strong>（object-oriented programming）的核心思想是数据抽象（封装）、继承和动态绑定（多态）。</p>
</li>
<li><p>在 C++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成<strong>虚函数</strong>（virtual function）。</p>
</li>
<li><p>派生类必须通过使用<strong>类派生列表</strong>（class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：<strong>首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有访问说明符</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote <span class="comment">// Bulk_quote 继承了 Quote</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::size t)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>派生类必须在其内部对所有重新定义的虚函数进行声明。</strong> 派生类可以在这样的函数之前加上 <code>virtua1</code> 关键字，但是并不是非得这么做。C++11 新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表之后增加一个 <code>override</code> 关键字。</p>
</li>
<li><p>通过使用<strong>动态绑定</strong>（dynamic binding），我们能用同一段代码分别处理 <code>Quote</code> 和 <code>Bulk_quote</code> 的对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 计算并打印销售给定数量的某种书籍所得的费用</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream &amp;os,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ostream &amp;os, <span class="keyword">const</span> Quote &amp;item, <span class="keyword">size_t</span> n)</span><br><span class="line">    <span class="comment">// 根据传入 item 形参的对象类型调用 Quote:：net_price</span></span><br><span class="line">    <span class="comment">// 或者 Bulk_quote::net_price</span></span><br><span class="line">    <span class="keyword">double</span> ret = item.net price(n);</span><br><span class="line">    os &lt;&lt; <span class="string">"ISBN: "</span> &lt;&lt; item.isbn() <span class="comment">// 调用 Quote:isbn</span></span><br><span class="line">       &lt;&lt; <span class="string">" # sold: "</span> &lt;&lt; n &lt;&lt; <span class="string">"total due: "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 <code>print_total</code> 的 <code>item</code> 形参是基类 <code>Quote</code> 的一个引用，实际传入 <code>print_total</code> 的对象类型将决定到底执行 <code>net_price</code> 的哪个版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// basic 的类型是 Quote；bulk 的类型是 Bulk_quote</span></span><br><span class="line">print_total(<span class="built_in">cout</span>, basic, <span class="number">20</span>); <span class="comment">// 调用 Quote 的 net_price</span></span><br><span class="line">print_total(<span class="built_in">cout</span>, bulk, <span class="number">20</span>);  <span class="comment">// 调用 Bulk_quote 的 net_price</span></span><br></pre></td></tr></table></figure>
<p>函数的运行版本由实参决定，即在运行时选择函数的版本，所以动态绑定有时又被称为<strong>运行时绑定</strong>（run-time binding）。</p>
<blockquote>
<p>Note：在 C++ 语言中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。</p>
</blockquote>
</li>
</ol>
<h1 id="15-2-定义基类和派生类" class="heading-control"><a href="#15-2-定义基类和派生类" class="headerlink" title="15.2 定义基类和派生类"></a>15.2 定义基类和派生类<a class="heading-anchor" href="#15-2-定义基类和派生类" aria-hidden="true"></a></h1><h2 id="15-2-1-定义基类" class="heading-control"><a href="#15-2-1-定义基类" class="headerlink" title="15.2.1 定义基类"></a>15.2.1 定义基类<a class="heading-anchor" href="#15-2-1-定义基类" aria-hidden="true"></a></h2><ol>
<li><blockquote>
<p>Note：基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作也是如此。</p>
</blockquote>
</li>
<li><p>派生类可以继承其基类的成员，然而当遇到如 <code>net_price</code> 这样与类型相关的操作时，派生类必须对其重新定义。换句话说，派生类需要对这些操作提供自己的新定义以<strong>覆盖</strong>（<code>override</code>）从基类继承而来的旧定义。</p>
</li>
<li><p>在 C++ 语言中，基类必须将它的两种成员函数区分开来：</p>
<ul>
<li>基类希望其派生类进行覆盖的函数</li>
<li>基类希望派生类直接继承而不要改变的函数<br><br></li>
</ul>
<p>对于前者，基类通常将其定义为<strong>虚函数</strong>（<code>virtual</code>）。<strong>当我们使用指针或引用调用虚函数时，该调用将被动态绑定。根据引用或指针所绑定的对象类型不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。</strong></p>
</li>
<li><p>基类通过在其成员函数的声明语句之前加上关键字 <code>virtua1</code> 使得该函数执行动态级定。<strong>任何构造函数之外的非静态函数都可以是虚函数。关键字 virtual 只能出现在类内部的声明语句之前而不能用于类外部的函数定义。如果基类把一个函数声明成虚函数，则该函数在派生类中隐式地也是虚函数。</strong></p>
</li>
<li><p><strong>成员函数如果没被声明为虚函数，则其解析过程发生在编译时而非运行时。</strong></p>
</li>
<li><p>派生类可以继承定义在基类中的成员，但是派生类的成员函数不一定有权访问从基类继承而来的成员。和其他使用基类的代码一样，派生类能访问公有成员，而不能访问私有成员。不过在某些时候基类中还有这样一种成员，基类希望它的派生类有权访问该成员，同时禁止其他用户访问。我们用受保护的（<code>protected</code>）访问运算符说明这样的成员。</p>
</li>
</ol>
<h2 id="15-2-2-定义派生类" class="heading-control"><a href="#15-2-2-定义派生类" class="headerlink" title="15.2.2 定义派生类"></a>15.2.2 定义派生类<a class="heading-anchor" href="#15-2-2-定义派生类" aria-hidden="true"></a></h2><ol>
<li><p>派生类必须通过使用<strong>类派生列表</strong>（class derivation list）明确指出它是从哪个（哪些）基类继承而来的。类派生列表的形式是：首先是一个冒号，后面紧跟以逗号分隔的基类列表，其中每个基类前面可以有以下三种访问说明符中的一个：<code>public</code>、<code>protected</code> 或者 <code>private</code>。</p>
</li>
<li><p>派生类必须将其继承而来的成员函数中需要覆盖的那些重新声明。</p>
</li>
<li><p>如果一个派生是公有的，则基类的公有成员也是派生类接口的组成部分。此外，我们<strong>能将公有派生类型的对象绑定到基类的引用或指针上</strong>。</p>
<blockquote>
<p>之我见：为什么强调公有派生？因为如果是保护派生或私有派生，那么即使将派生对象绑定到基类引用或指针上，派生对象内部的所有内容对外部都将不可见。</p>
</blockquote>
</li>
<li><p>大多数类都只继承自一个类，这种形式的继承被称作“单继承”。</p>
</li>
<li><p>派生类经常（但不总是）覆盖它继承的虚函数。如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似于其他的普通成员，派生类会直接继承其在基类中的版本。</p>
</li>
<li><p>派生类可以在它覆盖的函数前使用 <code>virtual</code> 关键字，但不是非得这么做。C++11 新标准允许派生类显式地注明它使用某个成员函数覆盖了它继承的虚函数。具体做法是在形参列表后面、或者在 <code>const</code> 成员函数的 <code>const</code> 关键字后面、或者在<strong>引用成员函数</strong>的<strong>引用限定符</strong>后面添加一个关键字 <code>override</code>。</p>
</li>
<li><p>一个派生类对象包含多个组成部分：</p>
<ul>
<li>一个含有派生类自己定义的（非静态）成员的子对象</li>
<li>一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个<br><br></li>
</ul>
<p>C++ 标准并没有明确规定派生类的对象在内存中如何分布，因此，在一个对象中，继承自基类的部分和派生类自定义的部分不一定是连续存储的。</p>
</li>
<li><p>因为在派生类对象中含有与其基类对应的组成部分，所以我们<strong>能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象中的基类部分上</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Quote item;       <span class="comment">// 基类对象</span></span><br><span class="line">Bulk_quote bulk;  <span class="comment">// 派生类对象</span></span><br><span class="line">Quote *p = &amp;item; <span class="comment">// p 指向 Quote 对象</span></span><br><span class="line">p = &amp;bulk;        <span class="comment">// p 指向 bulk 的 Quote 部分</span></span><br><span class="line">Quote &amp;r = bulk;  <span class="comment">// r 绑定到 bulk 的 Quote 部分</span></span><br></pre></td></tr></table></figure>
<p>这种转换通常称为<strong>派生类到基类的</strong>（derived-to-base）类型转换。和其他类型转换一样，<strong>编译器会隐式地执行派生类到基类的转换</strong>。这种隐式特性意味着我们可以把派生类对象或者派生类对象的引用用在需要基类引用的地方：同样的，我们也可以把派生类对象的指针用在需要基类指针的地方。</p>
<blockquote>
<p>Note：在派生类对象中含有与其基类对应的组成部分，这一事实是继承的关键所在。</p>
</blockquote>
</li>
<li><p>尽管在派生类对象中含有从基类继承而来的成员，但是派生类并不能直接初始化这些成员。和其他创建了基类对象的代码一样，派生类也必须使用基类的构造函数来初始化它的基类部分。</p>
</li>
<li><p>派生类对象的基类部分与派生类对象自己的数据成员都是在构造函数的初始化阶段执行初始化操作的。类似于我们初始化成员的过程，<strong>派生类构造函数同样是通过构造函数初始化列表来将实参传递给基类构造函数的</strong>。</p>
</li>
<li><p><strong>除非我们特别指出，否则派生类对象的基类部分会像数据成员一样执行默认初始化。</strong> 如果想使用其他的基类构造函数，我们需要以类名加圆括号内的实参列表的形式为构造函数提供初始值。这些实参将帮助编译器决定到底应该选用哪个构造函数来初始化派生类对象的基类部分。</p>
<blockquote>
<p>Note：首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员。</p>
</blockquote>
</li>
<li><p>派生类可以访问基类的公有成员和受保护成员。</p>
</li>
<li><p>派生类的作用域嵌套在基类的作用域之内。因此，对于派生类的一个成员来说，它使用派生类成员的方式与使用基类成员的方式没什么不同。</p>
</li>
<li><p>关键概念：遵循基类的接口。必须明确一点：每个类负责定义各自的接口。要想与类的对象交互必须使用该类的接口，即使这个对象是派生类的基类部分也是如此。</p>
<p>因此，派生类对象不能直接初始化基类的成员。尽管从语法上来说我们可以在派生类构造函数体内给它的公有或受保护的基类成员赋值，但是最好不要这么做。和使用基类的其他场合一样，派生类应该遵循基类的接口，并且通过调用基类的构造函数来初始化那些从基类中继承而来的成员。</p>
</li>
<li><p><strong>如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义。不论从基类中派生出来多少个派生类，对于每个静态成员来说都只存在唯一的实例。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">statmem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Derived &amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>静态成员遵循通用的访问控制规则，如果基类中的成员是 <code>private</code> 的，则派生类无权访问它。假设某静态成员是可访问的，则我们既能通过基类使用它也能通过派生类使用它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Derived::f</span><span class="params">(<span class="keyword">const</span> Derived &amp;derived_obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Base::statmem;      <span class="comment">// 正确：Base 定义了statmem</span></span><br><span class="line">    Derived::statmem(); <span class="comment">// 正确：Derived 继承了 statmem</span></span><br><span class="line">    <span class="comment">// 正确：派生类的对象能访问基类的静态成员</span></span><br><span class="line">    derived_obj.statmem(); <span class="comment">// 通过 Derived 对象访问</span></span><br><span class="line">    statmem();             <span class="comment">// 通过 this 对象访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>派生类的声明与其他类差别不大，声明中包含类名但是不包含它的派生列表。一条声明语句的目的是令程序知晓某个名字的存在以及该名字表示一个什么样的实体，如一个类、一个函数或一个变量等。派生列表以及与定义有关的其他细节必须与类的主体一起出现。如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明。</p>
</li>
<li><p><strong>一个类不能派生它本身。</strong> 一个类是基类，同时它也可以是一个派生类。</p>
</li>
<li><p>每个类都会继承<strong>直接基类</strong>（direct base）的所有成员。对于一个最终的派生类来说，它会继承其直接基类的成员；该直接基类的成员又含有其基类的成员；依此类推直至继承链的顶端。因此，<strong>最终的派生类将包含它的直接基类的子对象以及每个间接基类（indirect base）的子对象</strong>。</p>
</li>
<li><p><strong>C++11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 <code>final</code>。</strong></p>
<blockquote>
<p>之我见：当于给类做了“绝育手术”，被 <code>final</code> 修饰的类“后继无类”。</p>
</blockquote>
</li>
</ol>
<h2 id="15-2-3-类型转换与继承" class="heading-control"><a href="#15-2-3-类型转换与继承" class="headerlink" title="15.2.3 类型转换与继承"></a>15.2.3 类型转换与继承<a class="heading-anchor" href="#15-2-3-类型转换与继承" aria-hidden="true"></a></h2><ol>
<li><blockquote>
<p>WARNING：理解基类和派生类之间的类型转换是理解 C++ 语言面向对象编程的关键所在。</p>
</blockquote>
</li>
<li><p>通常情况下，如果我们想把引用或指针绑定到一个对象上，则引用或指针的类型应与对象的类型一致，或者对象的类型含有一个可接受的 <code>const</code> 类型转换规则。存在继承关系的类是一个重要的例外：我们<strong>可以将基类的指针或引用绑定到派生类对象上</strong>。例如，我们可以用 <code>Quote&amp;</code> 指向一个 <code>Bulk_quote</code> 对象，也可以把一个 <code>Bulk_quote</code> 对象的地址赋给一个 <code>Quote*</code>。</p>
</li>
<li><p>可以将基类的指针或引用绑定到派生类对象上有一层极为重要的含义：当使用基类的引用（或指针）时，实际上我们并不清楚该引用（或指针）所绑定对象的真实类型。该对象可能是基类的对象，也可能是派生类的对象。</p>
</li>
<li><blockquote>
<p>Note：和内置指针一样，智能指针类也支持派生类向基类的类型转换，这意味着我们可以将一个派生类对象的指针存储在一个基类的智能指针内。</p>
</blockquote>
</li>
<li><p>当我们使用存在继承关系的类型时，必须将一个变量或其他表达式的静态类型（static type）与该表达式表示对象的动态类型（dynamic type）区分开来。<strong>表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知。</strong></p>
</li>
<li><p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致。</p>
<blockquote>
<p>Note：基类的指针或引用的静态类型可能与其动态类型不一致。</p>
</blockquote>
</li>
<li><p><strong>不存在从基类向派生类的隐式类型转换。</strong> 之所以存在派生类向基类的类型转换是因为每个派生类对象都包含一个基类部分，而基类的引用或指针可以绑定到该基类部分上。一个基类的对象既可以以独立的形式存在，也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，则它只含有基类定义的成员，而不含有派生类定义的成员。</p>
<p>因为一个基类的对象可能是派生类对象的一部分，也可能不是，所以不存在从基类向派生类的自动类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Quote base;</span><br><span class="line">Bulk_quote *bulkP = &amp;base;  <span class="comment">// 错误：不能将基类转换成派生类</span></span><br><span class="line">Bulk_quote &amp;bulkRef = base; <span class="comment">// 错误：不能将基类转换成派生类</span></span><br></pre></td></tr></table></figure>
<p>如果上述赋值是合法的，则我们有可能会使用 <code>bulkP</code> 或 <code>bulkRef</code> 访问 <code>base</code> 中本不存在的成员。</p>
<p>除此之外还有一种情况显得有点特别，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bulk quote bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;      <span class="comment">// 正确：动态类型是 Bulk_quote</span></span><br><span class="line">Bulk_quote *bulkP = itemP; <span class="comment">// 错误：不能将基类转换成派生类</span></span><br></pre></td></tr></table></figure>
<p>编译器在编译时无法确定某个特定的转换在运行时是否安全，这是因为编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果在基类中含有一个或多个虚函数，我们可以使用 <code>dynamic_cast</code> 请求一个类型转换，该转换的安全检查将在运行时执行。同样，如果我们已知某个基类向派生类的转换是安全的，则我们可以使用 <code>static_cast</code>来强制覆盖掉编译器的检查工作。</p>
</li>
<li><p><strong>派生类向基类的自动类型转换只对指针或引用类型有效</strong>，在派生类类型和基类类型之间不存在这样的转换。</p>
</li>
<li><p>当我们初始化或赋值一个类类型的对象时，实际上是在调用某个函数。当执行初始化时，我们调用构造函数；而当执行赋值操作时，我们调用赋值运算符。这些成员通常都包含一个参数，该参数的类型是类类型的 <code>const</code> 版本的引用。</p>
</li>
<li><p>当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员。类似的，如果我们将一个派生类对象赋值给一个基类对象，则实际运行的赋值运算符也是基类中定义的那个，该运算符同样只能处理基类自己的成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bulk_quote bulk;  <span class="comment">// 派生类对象</span></span><br><span class="line"><span class="function">Quote <span class="title">item</span><span class="params">(bulk)</span></span>; <span class="comment">// 使用 Quote::Quote(const Quote&amp;) 构造函数</span></span><br><span class="line">item = bulk;      <span class="comment">// 调用 Quote::operator=(const Quotes)</span></span><br></pre></td></tr></table></figure>
<p>当构造 <code>item</code> 时，运行 <code>Quote</code> 的拷贝构造函数。该函数只能处理 <code>bookNo</code> 和 <code>price</code> 两个成员，它负责拷贝 <code>bulk</code> 中 <code>Quote</code> 部分的成员，同时忽略掉 <code>bulk</code> 中 <code>Bulk_quote</code> 部分的成员。类似的，对于将 <code>bulk</code> 赋值给 <code>item</code> 的操作来说，只有 <code>bulk</code> 中 <code>Quote</code> 部分的成员被赋值给 <code>item</code>，其余部分被<strong>切掉</strong>（sliced down）了。</p>
<blockquote>
<p>WARNING：当我们用一个派生类对象为一个基类对象初始化或赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉。</p>
</blockquote>
</li>
<li><p>要想理解在具有继承关系的类之间发生的类型转换，有三点非常重要：</p>
<ul>
<li>从派生类向基类的类型转换只对指针或引用类型有效</li>
<li>基类向派生类不存在隐式类型转换</li>
<li>和任何其他成员一样，派生类向基类的类型转换也可能会由于访问受限而变得不可行</li>
</ul>
<p>尽管自动类型转换只对指针或引用类型有效，但是继承体系中的大多数类仍然（显式或隐式地）定义了拷贝控制成员。因此，我们通常能够将一个派生类对象拷贝、移动或赋值给一个基类对象。不过需要注意的是，这种操作只处理派生类对象的基类部分。</p>
</li>
</ol>
<h1 id="15-3-虚函数" class="heading-control"><a href="#15-3-虚函数" class="headerlink" title="15.3 虚函数"></a>15.3 虚函数<a class="heading-anchor" href="#15-3-虚函数" aria-hidden="true"></a></h1><ol>
<li><p>当我们使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。因为我们直到运行时才能知道到底调用了哪个版本的虚函数，所以所有虚函数都必须有定义。通常情况下，如果我们不使用某个函数，则无须为该函数提供定义。但是我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。（纯虚函数是个例外）</p>
</li>
<li><p>当某个虚函数通过指针或引用调用时，编译器产生的代码直到运行时才能确定应该调用哪个版本的函数。被调用的函数是与绑定到指针或引用上的对象的动态类型相匹配的那一个。</p>
</li>
<li><p><strong>动态绑定只有当我们通过指针或引用调用虚函数时才会发生。</strong> 当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。</p>
</li>
<li><p>关键概念：C++ 的多态性。OOP 的核心思想是多态性（polymorphism）。我们把具有继承关系的多个类型称为多态类型，因为我们能使用这些类型的“多种形式”而无须在意它们的差异。<strong>引用或指针的静态类型与动态类型不同这一事实正是 C++ 语言支持多态性的根本所在。</strong></p>
<p>当我们使用基类的引用或指针调用基类中定义的一个函数时，我们并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类的对象也可能是一个派生类的对象。如果该函数是虚函数，则直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针所绑定的对象的真实类型。</p>
<p>另一方面，对非虚函数的调用在编译时进行绑定。类似的，通过对象进行的函数（虚函数或非虚函数）调用也在编译时绑定。对象的类型是确定不变的，我们无论如何都不可能令对象的动态类型与静态类型不一致。因此，通过对象进行的函数调用将在编译时绑定到该对象所属类中的函数版本上。</p>
<blockquote>
<p>当且仅当对通过指针或引用调用虚函数时，才会在运行时解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同。</p>
</blockquote>
</li>
<li><p>当我们在派生类中覆盖了某个虚函数时，可以再一次使用 <code>virtual</code> 关键字指出该函数的性质。然而这么做并非必须，因为<strong>一旦某个函数被声明成虚函数，则在所有派生类中它都是虚函数</strong>。一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与被它覆盖的基类函数完全一致。</p>
</li>
<li><p>派生类中虚函数的返回类型也必须与基类函数匹配。该规则存在一个例外，<strong>当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果 <code>D</code> 由 <code>B</code> 派生得到，则基类的虚函数可以返回 <code>B*</code> 而派生类的对应函数可以返回 <code>D*</code>，只不过这样的返回类型要求从 <code>D</code> 到 <code>B</code> 的类型转换是可访问的</strong>。（可参考 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25vcm1hbl9pcnNhL2FydGljbGUvZGV0YWlscy8xMDI4NzMwNjU=" title="https://blog.csdn.net/norman_irsa/article/details/102873065">CSDN 博客<i class="fa fa-external-link"></i></span>——博主注）</p>
<blockquote>
<p>Note：基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参必须与派生类中的形参严格匹配。</p>
</blockquote>
</li>
<li><p>派生类如果定义了一个函数与基类中虚函数的名字相同但是形参列表不同，这仍然是合法的行为。编译器将认为新定义的这个函数与基类中原有的函数是相互独立的。这时，派生类的函数并没有覆盖掉基类中的版本。就实际的编程习惯而言，这种声明往往意味着发生了错误，因为我们可能原本希望派生类能覆盖掉基类中的虚函数，但是一不小心把形参列表弄错了。</p>
</li>
<li><p>派生类中的成员函数被 <code>override</code> 修饰后，会强迫编译器检查该成员函数是否能够重写基类中的同名虚函数，因此，一个最佳实践是，<strong>派生类中的虚函数都应用 <code>override</code> 修饰</strong>。如果我们使用 <code>override</code> 标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fl</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fl</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>; <span class="comment">// 正确：f1 与基类中的 f1 匹配</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>;       <span class="comment">// 错误：B 没有形如 f2(int) 的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">// 错误：f3 不是虚函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">()</span> <span class="keyword">override</span></span>;          <span class="comment">// 错误：B 没有名为 f4 的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>只有虚函数才能被覆盖。</strong></p>
</li>
<li><p>还能把某个函数指定为 <code>final</code>，如果我们已经把函数定义成 <code>final</code> 了，则之后任何尝试覆盖该函数的操作都将引发错误（用于终止继承链中某个虚函数的虚周期——博主注）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 从 B 继承 f2() 和 f3()，覆盖 f1(int)</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fl</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">final</span></span>; <span class="comment">// 不允许后续的其他类覆盖 f1(int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;          <span class="comment">// 正确：覆盖从间接基类 B 继承而来的 f2</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>; <span class="comment">// 错误：D2 已经将 f1 声明成 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>final</code> 和 <code>override</code> 说明符出现在形参列表（包括任何 <code>const</code> 或引用修饰符）以及尾置返回类型之后。</p>
<blockquote>
<p>之我见：<code>override</code> 描述的是对上的关系，final 描述的是对下的关系。</p>
</blockquote>
</li>
<li><p>和其他函数一样，<strong>虚函数也可以拥有默认实参</strong>。<strong>如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定。</strong></p>
<p>换句话说，<strong>如果我们通过基类的引用或指针调用函数，则使用基类中定义的默认实参，即使实际运行的是派生类中的函数版本也是如此</strong>。此时，传入派生类函数的将是基类函数定义的默认实参。如果派生类函数依赖不同的实参，则程序结果将与我们的预期不符。</p>
<blockquote>
<p>Best Practices：如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。</p>
</blockquote>
</li>
<li><p>在某些情况下，我们希望对虚函数的调用不要进行动态绑定，而是强迫其执行虚函数的某个特定版本。使用作用域运算符可以实现这一目的，例如下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 强行调用基类中定义的函数版本而不管 baseP 的动态类型到底是什么</span></span><br><span class="line"><span class="keyword">double</span> undiscounted = baseP-&gt;Quote::net_price(<span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<p>该代码强行调用 <code>Quote</code> 的 <code>net_price</code> 函数，而不管 <code>basep</code> 实际指向的对象类型到底是什么。该调用将在编译时完成解析。</p>
<blockquote>
<p>Note：通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。</p>
</blockquote>
<p>什么时候我们需要回避虚函数的默认机制呢？通常是当一个派生类的虚函数调用它覆盖的基类的虚函数版本时。在此情况下，基类的版本通常完成继承层次中所有类型都要做的共同任务，而派生类中定义的版本需要执行一些与派生类本身密切相关的操作。</p>
<blockquote>
<p>WARNING：如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归。</p>
</blockquote>
</li>
</ol>
<h1 id="15-4-抽象基类" class="heading-control"><a href="#15-4-抽象基类" class="headerlink" title="15.4 抽象基类"></a>15.4 抽象基类<a class="heading-anchor" href="#15-4-抽象基类" aria-hidden="true"></a></h1><ol>
<li><p>一个<strong>纯虚</strong>（pure virtual）函数无须定义。我们通过在函数体的位置（即在声明语句的分号之前）书写 <code>=0</code> 就可以将一个虚函数说明为纯虚函数。其中，<strong><code>=0</code> 只能出现在类内部的虚函数声明语句处</strong>。也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。也就是说，我们不能在类的内部为一个 <code>=0</code> 的函数提供函数体。</p>
</li>
<li><p>含有（或者未经覆盖直接继承）纯虚函数的类是<strong>抽象基类</strong>（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。<strong>我们不能（直接）创建一个抽象基类的对象。</strong></p>
</li>
<li><p><strong>抽象基类的派生类必须给出自己的接口实现，否则它们仍将是抽象基类。</strong></p>
</li>
<li><p>派生类的构造函数只初始化它的直接基类。</p>
</li>
</ol>
<h1 id="15-5-访问控制与继承" class="heading-control"><a href="#15-5-访问控制与继承" class="headerlink" title="15.5 访问控制与继承"></a>15.5 访问控制与继承<a class="heading-anchor" href="#15-5-访问控制与继承" aria-hidden="true"></a></h1><ol>
<li><p>一个类使用 <code>protected</code> 关键字来声明那些它希望与派生类分享但是不想被其他公共访问使用的成员。<code>protected</code> 说明符可以看做是 <code>public</code> 和 <code>private</code> 中和后的产物：</p>
<ul>
<li>和私有成员类似，受保护的成员对于类的用户来说是不可访问的</li>
<li>和公有成员类似，<strong>受保护的成员对于派生类的成员和友元来说是可访问的</strong></li>
<li>派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。派生类对于一个基类对象中的受保护成员没有任何访问特权<br><br></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem; <span class="comment">// protected 成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sneaky</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;)</span></span>; <span class="comment">// 能访问 Sneaky::prot mem</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;)</span></span>;   <span class="comment">// 不能访问 Base::prot mem</span></span><br><span class="line">    <span class="keyword">int</span> j;                         <span class="comment">// j 默认是 private</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 正确：c1obber 能访问 Sneaky 对象的 private 和 protected 成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Sneaky &amp;s)</span> </span>&#123; s.j = s.prot_mem = <span class="number">0</span>; &#125;</span><br><span class="line"><span class="comment">// 错误：clobber 不能访问 Base 的 protected 成员</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clobber</span><span class="params">(Base &amp;b)</span> </span>&#123; b.prot_mem = <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员；对于普通的基类对象中的成员不具有特殊的访问权限。</strong></p>
<blockquote>
<p>某个类的友元（包括友元类和友元函数）有权访问这个类的私有和受保护成员。</p>
</blockquote>
</li>
<li><p>某个类对其继承而来的成员的访问权限受到两个因素影响：</p>
<ul>
<li>一是在基类中该成员的访问说明符</li>
<li>二是在派生类的派生列表中的访问说明符<br><br></li>
</ul>
<p><strong>派生访问说明符对于派生类的成员（及友元）能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。派生访问说明符的目的是控制派生类用户（包括派生类的派生类在内）对于基类成员的访问权限。</strong></p>
<blockquote>
<p>之我见：派生类对基类成员的访问权限只取决于基类中该成员的访问说明符；派生访问说明符只决定了派生类中继承自基类的成员的受访问权限，该权限为：</p>
<script type="math/tex; mode=display">
\textbf{high}(基类成员访问说明符, 派生访问说明符)</script><p>例如，基类成员访问说明符为 <code>protected</code>，派生访问说明符为 <code>private</code>，则派生类可以访问继承而来的基类受保护成员，但这些继承而来的基类受保护成员在派生类中的受访问权限为：</p>
<script type="math/tex; mode=display">
\textbf{high}(protected, private) = private</script><p>因此派生类实例及派生类的派生类都无权访问。</p>
</blockquote>
</li>
<li><p>派生类向基类的转换是否可访问由使用该转换的代码决定，同时派生类的派生访问说明符也会有影响。假定 <code>D</code> 继承自 <code>B</code>：</p>
<ul>
<li>只有当 <code>D</code> <strong>公有地</strong>继承 <code>B</code> 时，用户代码才能使用派生类向基类的转换；如果 <code>D</code> 继承 <code>B</code> 的方式是受保护的或者私有的，则用户代码不能使用该转换</li>
<li>不论 <code>D</code> 以什么方式继承 <code>B</code>，<code>D</code> 的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的</li>
<li>如果 <code>D</code> 继承 <code>B</code> 的方式是公有的或者受保护的，则 <code>D</code> 的派生类的成员和友元可以使用 <code>D</code> 向 <code>B</code> 的类型转换；反之，如果 <code>D</code> 继承 <code>B</code> 的方式是私有的，则不能使用<br><br></li>
</ul>
<blockquote>
<p>Tip：对于代码中的某个给定节点来说，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的；反之则不行。</p>
</blockquote>
</li>
<li><blockquote>
<p>关键概念：类的设计与受保护的成员。不考虑继承的话，我们可以认为一个类有两种不同的用户：普通用户和类的实现者。其中，普通用户编写的代码使用类的对象，这部分代码只能访问类的公有（接口）成员；实现者则负责编写类的成员和友元的代码，成员和友元既能访问类的公有部分，也能访问类的私有（实现）部分。</p>
<p>如果进一步考虑继承的话就会出现第三种用户，即派生类。基类把它希望派生类能够使用的部分声明成受保护的。普通用户不能访问受保护的成员，而派生类及其友元仍旧不能访问私有成员。</p>
<p>和其他类一样，基类应该将其接口成员声明为公有的；同时将属于其实现的部分分成两组：一组可供派生类访问，另一组只能由基类及基类的友元访问。对于前者应该声明为受保护的，这样派生类就能在实现自己的功能时使用基类的这些操作和数据；对于后者应该声明为私有的。</p>
</blockquote>
</li>
<li><p><strong>就像友元关系不能传递一样，友元关系同样也不能继承。基类的友元在访问派生类成员时不具有特殊性，类似的，派生类的友元也不能随意访问基类的成员</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 添加 friend 声明，其他成员与之前的版本一致</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span> <span class="comment">// Pal 在访问 Base 的派生类时不具有特殊性</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(Base b)</span> </span>&#123; <span class="keyword">return</span> b.prot_mem; &#125; <span class="comment">// 正确：Pal 是 Base 的友元</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.j; &#125;     <span class="comment">// 错误：Pa1 不是 Sneaky 的友元</span></span><br><span class="line">    <span class="comment">// 对基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">(Sneaky s)</span> </span>&#123; <span class="keyword">return</span> s.prot_mem; &#125; <span class="comment">// 正确：Pal 是 Base 的友元</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之我见：一个基类的友元可以访问派生类对象中继承自基类的成员。某个类的友元类的基类或派生类对这个类并不具有特殊访问权限。</p>
<p>Note：不能继承友元关系；每个类负责控制各自成员的访问权限。</p>
</blockquote>
</li>
<li><p>有时我们需要改变派生类继承的某个名字的访问级别，通过使用 <code>using</code> 声明可以达到这一目的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::sizet <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base <span class="comment">// 注意：private 继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 保持对象尺寸相关的成员的访问级别</span></span><br><span class="line">    <span class="keyword">using</span> Base::size;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过在类的内部使用 <code>using</code> 声明语句，我们可以将该类的直接或间接基类中的任何可访问成员（例如，非私有成员）标记出来。<code>using</code> 声明语句中名字的访问权限由该 <code>using</code> 声明语句之前的访问说明符来决定。也就是说，如果一条 <code>using</code> 声明语句出现在类的 <code>private</code> 部分，则该名字只能被类的成员和友元访问；如果 <code>using</code> 声明语句位于 <code>public</code> 部分，则类的所有用户都能访问它；如果 <code>using</code> 声明语句位于 <code>protected</code> 部分，则该名字对于成员、友元和派生类是可访问的。</p>
<blockquote>
<p>派生类只能为那些它可以访问的名字提供 <code>using</code> 声明。</p>
</blockquote>
</li>
<li><p>使用 <code>struct</code> 和 <code>class</code> 关键字定义的类具有不同的默认访问说明符。类似的，默认派生运算符也由定义派生类所用的关键字来决定。<strong>默认情况下，使用 <code>class</code> 关键字定义的派生类是私有继承的；而使用 <code>struct</code> 关键字定义的派生类是公有继承的</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> Base <span class="comment">// 默认 public 继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> Base <span class="comment">// 默认 private 继承</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 <code>struct</code> 关键字和 <code>class</code> 关键字定义的类之间唯一的差别就是默认成员访问说明符及默认派生访问说明符。</p>
<blockquote>
<p>一个私有派生的类最好显式地将 <code>private</code> 声明出来，而不要仅仅依赖于默认的设置。显式声明的好处是可以令私有继承关系清晰明了，不至于产生误会。</p>
</blockquote>
</li>
<li><blockquote>
<p>之我见：对于私有继承得到的派生类，派生类的派生类的成员或友元不能执行向间接基类的类型转换。</p>
</blockquote>
</li>
</ol>
<h1 id="15-6-继承中的类作用域" class="heading-control"><a href="#15-6-继承中的类作用域" class="headerlink" title="15.6 继承中的类作用域"></a>15.6 继承中的类作用域<a class="heading-anchor" href="#15-6-继承中的类作用域" aria-hidden="true"></a></h1><ol>
<li><p>当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。所以派生类才能像使用自己的成员一样使用基类的成员。</p>
</li>
<li><p>一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用哪些成员仍然是由静态类型决定的。</p>
</li>
<li><p>和其他作用域一样，<strong>派生类也能重用定义在其直接基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字</strong>，但可以通过作用域运算符来使用一个被隐藏的基类成员。</p>
<blockquote>
<p>Best Practices：除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>关键概念：名字查找与继承</strong><br>理解函数调用的解析过程对于理解 C++ 的继承至关重要，假定我们调用 <code>p-&gt;mem()</code>（或者 <code>obj.mem()</code>），则依次执行以下 4 个步骤：</p>
<ul>
<li>首先确定 <code>p</code>（或 <code>obj</code>）的静态类型。因为我们调用的是一个成员，所以该类型必然是类类型</li>
<li>在 <code>p</code>（或 <code>obj</code>）的静态类型对应的类中查找 <code>mem</code>。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错（从当前的静态类型开始向继承链的上游查找——博主注）</li>
<li>一旦找到了 <code>mem</code>，就进行常规的类型检查以确认对于当前找到的 <code>mem</code>，本次调用是否合法（找到了就不再继续往上找了——博主注）</li>
<li>假设调用合法，则编译器将根据调用的是否是虚函数而产生不同的代码：<ul>
<li>如果 <code>mem</code> 是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行该虚函数的哪个版本，依据是对象的动态类型</li>
<li>反之，如果 <code>mem</code> 不是虚函数或者我们是通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用（这意味着，将基类指针或引用绑定到派生类对象上，并通过该指针或引用调用一个基类和派生类中都存在的同名同参非虚函数，则基类中的版本将隐藏派生类中的版本——博主注）</li>
</ul>
</li>
</ul>
</blockquote>
</li>
<li><p>声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，<strong>定义派生类中的函数也不会重载其基类中的成员。和其他作用域一样，如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏掉</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived</span> :</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">memfcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 隐藏基类的 memfcn</span></span><br><span class="line">&#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Base b;</span><br><span class="line">b.memfcn();       <span class="comment">// 调用 Base::memfcn</span></span><br><span class="line">d.memfcn(<span class="number">10</span>);     <span class="comment">// 调用 Derived::memfcn</span></span><br><span class="line">d.memfcn();       <span class="comment">// 错误：参数列表为空的 memfcn 被隐藏了</span></span><br><span class="line">d.Base::memfcn(); <span class="comment">// 正确：调用 Base::memfcn</span></span><br></pre></td></tr></table></figure>
<p>为了解析 <code>d.memfcn();</code> 这条调用语句，编译器首先在 <code>Derived</code> 中查找名字 <code>memfcn</code>；因为 <code>Derived</code> 确实定义了一个名为 <code>memfcn</code> 的成员，所以查找过程终止。<strong>一旦名字找到，编译器就不再继续查找了。</strong><code>Derived</code> 中的 <code>memfcn</code> 版本需要一个 <code>int</code> 实参，而当前的调用语句无法提供任何实参，所以该调用语句是错误的。</p>
</li>
<li><p>现在可以理解为什么基类与派生类中的虚函数必须有相同的形参列表了。<strong>假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 隐藏基类的 fcn，这个 fcn 不是虚函数</span></span><br><span class="line">    <span class="comment">// D1 继承了 Base::fcn() 的定义</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>;      <span class="comment">// 形参列表与 Base 中的 fcn 不一致</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>; <span class="comment">// 是一个新的虚函数，在 Base 中不存在</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> D1</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 是一个非虚函数，隐藏了 D1::fcn(int)</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fcn</span><span class="params">()</span></span>;    <span class="comment">// 覆盖了 Base 的虚函数 fcn</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;    <span class="comment">// 覆盖了 D1 的虚函数 f2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>D1</code> 的 <code>fcn</code> 将隐藏 <code>Base</code> 的 <code>fcn</code>。此时拥有了两个名为 <code>fcn</code> 的函数：一个是 <code>D1</code> 从 <code>Base</code> 继承而来的虚函数 <code>fcn</code>；另一个是 <code>D1</code> 自己定义的接受一个 <code>int</code> 参数的非虚函数 <code>fcn</code>。</p>
<p>观察下面的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base bobj;</span><br><span class="line">D1 d1obj;</span><br><span class="line">D2 d2obj;</span><br><span class="line"></span><br><span class="line">Base *bp1 = &amp;bobj, *bp2 = &amp;d1obj, *bp3 = &amp;d2obj;</span><br><span class="line">bp1-&gt;fcn(); <span class="comment">// 虚调用，将在运行时调用 Base::fcn</span></span><br><span class="line">bp2-&gt;fcn(); <span class="comment">// 虚调用，将在运行时调用 Base::fcn</span></span><br><span class="line">bp3-&gt;fcn(); <span class="comment">// 虚调用，将在运行时调用 D2::fcn</span></span><br><span class="line"></span><br><span class="line">D1 *d1p = &amp;d1obj;</span><br><span class="line">D2 *d2p = &amp;d2obj;</span><br><span class="line">bp2-&gt;f2(); <span class="comment">// 错误：Base 没有名为 f2 的成员</span></span><br><span class="line">d1p-&gt;f2(); <span class="comment">// 虚调用，将在运行时调用 D1::f2()</span></span><br><span class="line">d2p-&gt;f2(); <span class="comment">// 虚调用，将在运行时调用 D2::f2()</span></span><br></pre></td></tr></table></figure>
<p>再观察下面的示例，在每条调用语句中，指针都指向了 <code>D2</code> 类型的对象，但是<strong>由于我们调用的是非虚函数，所以不会发生动态绑定。实际调用的函数版本由指针的静态类型决定</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base *p1 = &amp;d2obj;</span><br><span class="line">D1 *p2 = &amp;d2obj;</span><br><span class="line">D2 *p3 = &amp;d2obj;</span><br><span class="line">p1-&gt;fcn(<span class="number">42</span>); <span class="comment">// 错误：Base 中没有接受一个 int 的 fcn</span></span><br><span class="line">p2-&gt;fcn(<span class="number">42</span>); <span class="comment">// 静态绑定，调用 D1::fcn(int)</span></span><br><span class="line">p3-&gt;fcn(<span class="number">42</span>); <span class="comment">// 静态绑定，调用 D2::fcn(int)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和其他函数一样，成员函数无论是否是虚函数都能被重载。派生类可以覆盖重载函数的 0 个或多个实例。如果派生类希望所有的重载版本对于它来说都是可见的，那么它就需要覆盖所有的版本，或者一个也不覆盖。</p>
<p>有时一个类仅需覆盖重载集合中的一些而非全部函数，一种好的解决方案是为重载的成员提供一条 <code>using</code> 声明语句，这样我们就无须覆盖基类中的每一个重载版本了。<code>using</code> 声明语句指定一个名字而不指定形参列表，所以<strong>一条基类成员函数的 <code>using</code> 声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无须为继承而来的其他函数重新定义</strong>。</p>
<p>类内 <code>using</code> 声明的一般规则同样适用于重载函数的名字；<strong>基类函数的每个实例在派生类中都必须是可访问的。对派生类没有重新定义的重载版本的访问实际上是对 <code>using</code> 声明点的访问</strong>。</p>
</li>
</ol>
<h1 id="15-7-构造函数与拷贝控制" class="heading-control"><a href="#15-7-构造函数与拷贝控制" class="headerlink" title="15.7 构造函数与拷贝控制"></a>15.7 构造函数与拷贝控制<a class="heading-anchor" href="#15-7-构造函数与拷贝控制" aria-hidden="true"></a></h1><ol>
<li>如果一个类（基类或派生类）没有定义拷贝控制操作，则编译器将为它合成一个版本。当然，这个合成的版本也可以定义成被删除的函数（使用 <code>delete</code> 关键字，被删除的函数将不能再被调用——博主注）。</li>
</ol>
<h2 id="15-7-1-虚析构函数" class="heading-control"><a href="#15-7-1-虚析构函数" class="headerlink" title="15.7.1 虚析构函数"></a>15.7.1 虚析构函数<a class="heading-anchor" href="#15-7-1-虚析构函数" aria-hidden="true"></a></h2><ol>
<li><p>继承关系对基类拷贝控制最直接的影响是<strong>基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了</strong>（与《Effective C++》第三版条款 07“为多态基类声明 <code>virtual</code> 析构函数”相对应——博主注）。当我们 <code>delete</code> 一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。例如，如果我们 <code>delete</code> 一个 <code>Quote*</code> 类型的指针，则该指针有可能实际指向了一个 <code>Bulk_quote</code> 类型的对象。如果这样的话，编译器就必须清楚它应该执行的是 <code>Bulk_quote</code> 的析构函数。和其他函数一样，我们<strong>通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>; <span class="comment">// 动态绑定析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>和其他虚函数一样，<strong>析构函数的虚属性也会被继承</strong>。因此，无论 <code>Quote</code> 的派生类使用合成的析构函数还是定义自己的析构函数，都将是虚析构函数。<strong>只要基类的析构函数是虚函数，就能确保当我们 <code>delete</code> 基类指针时将运行正确的析构函数版本</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Quote *itemP = <span class="keyword">new</span> Quote; <span class="comment">// 静态类型与动态类型一致</span></span><br><span class="line"><span class="keyword">delete</span> itemP;             <span class="comment">// 调用 Quote 的析构函数</span></span><br><span class="line">itemP = <span class="keyword">new</span> Bulk_quote;   <span class="comment">// 静态类型与动态类型不一致</span></span><br><span class="line"><span class="keyword">delete</span> itemP;             <span class="comment">// 调用 Bulk_quote 的析构函数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>WARNING：如果基类的析构函数不是虚函数，则 <code>delete</code> 一个指向派生类对象的基类指针将产生未定义的行为。</p>
</blockquote>
</li>
<li><p>如果一个类定义了析构函数，即使它通过 <code>=default</code> 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。</p>
</li>
</ol>
<h2 id="15-7-2-合成拷贝控制与继承" class="heading-control"><a href="#15-7-2-合成拷贝控制与继承" class="headerlink" title="15.7.2 合成拷贝控制与继承"></a>15.7.2 合成拷贝控制与继承<a class="heading-anchor" href="#15-7-2-合成拷贝控制与继承" aria-hidden="true"></a></h2><ol>
<li><p>基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。此外，这些合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。</p>
</li>
<li><p>无论基类成员是合成的版本（如 <code>Quote</code> 继承体系的例子）还是自定义的版本都没有太大影响。唯一的要求是相应的成员应该可访问并且不是一个被删除的函数。</p>
</li>
<li><p>合成的析构函数体是空的，其隐式的析构部分负责销毁类的成员。<strong>对于派生类的析构函数来说，它除了销毁派生类自己的成员外，还负责销毁派生类的直接基类；该直接基类又销毁它自己的直接基类，以此类推直至继承链的顶端。</strong></p>
</li>
<li><p><strong>某些定义基类的方式可能导致有的派生类成员成为被删除的函数</strong>：</p>
<ul>
<li>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作</li>
<li>如果在基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和接贝构造函数将是被删除的，因为编译器无法销毁派生类对象的基类部分</li>
<li>编译器将不会合成一个删除掉的移动操作。当我们使用 <code>=default</code> 请求一个移动操作时，如果基类中的对应操作是删除的或不可访问的，那么派生类中该函数将是被删除的，原因是派生类对象的基类部分不可移动。同样，如果基类的析构函数是删除的或不可访问的，则派生类的移动构造函数也将是被删除的<br><br></li>
</ul>
</li>
<li><p>大多数基类都会定义一个虚析构函数。因此在默认情况下，基类通常不含有合成的移动操作，而且在它的派生类中也没有合成的移动操作。</p>
<p>因为基类缺少移动操作会阻止派生类拥有自己的合成移动操作，所以当我们确实需要执行移动操作时应该首先在基类中进行定义。我们的 <code>Quote</code> 可以使用合成的版本，不过前提是 <code>Quote</code> 必须显式地定义这些成员。一旦 <code>Quote</code> 定义了自己的移动操作，那么它必须同时显式地定义拷贝操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;                         <span class="comment">// 对成员依次进行默认初始化</span></span><br><span class="line">    Quote(<span class="keyword">const</span> Quote &amp;) = <span class="keyword">default</span>;            <span class="comment">// 对成员依次拷贝</span></span><br><span class="line">    Quote(Quote &amp;&amp;) = <span class="keyword">default</span>;                 <span class="comment">// 对成员依次拷贝</span></span><br><span class="line">    Quote &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Quote &amp;) = <span class="keyword">default</span>; <span class="comment">// 拷贝赋值</span></span><br><span class="line">    Quote &amp;<span class="keyword">operator</span>=(Quote &amp;&amp;) = <span class="keyword">default</span>;      <span class="comment">// 移动赋值</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除非 <code>Quote</code> 的派生类中含有排斥移动的成员，否则它将自动获得合成的移动操作。</p>
</li>
</ol>
<h2 id="15-7-3-派生类的拷贝控制成员" class="heading-control"><a href="#15-7-3-派生类的拷贝控制成员" class="headerlink" title="15.7.3 派生类的拷贝控制成员"></a>15.7.3 派生类的拷贝控制成员<a class="heading-anchor" href="#15-7-3-派生类的拷贝控制成员" aria-hidden="true"></a></h2><ol>
<li><p>派生类构造函数在其初始化阶段中不但要初始化派生类自己的成员，还负责初始化派生类对象的基类部分。因此，派生类的拷贝和移动构造函数在拷贝和移动自有成员的同时，也要拷贝和移动基类部分的成员。类似的，派生类赋值运算符也必须为其基类部分的成员赋值。</p>
<p>和构造函数及赋值运算符不同的是，<strong>析构函数只负责销毁派生类自己分配的资源。如前所述，对象的成员是被隐式销毁的；类似的，派生类对象的基类部分也是自动销毁的</strong>。</p>
<blockquote>
<p>WARNING：当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。</p>
</blockquote>
</li>
<li><p><strong>当为派生类定义拷贝或移动构造函数时，我们通常使用对应的基类构造函数初始化对象的基类部分</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 默认情况下，基类的默认构造函数初始化对象的基类部分</span></span><br><span class="line">    <span class="comment">// 要想使用拷贝或移动构造函数，我们必须在构造函数初始值列表中</span></span><br><span class="line">    <span class="comment">// 显式地调用该构造函数</span></span><br><span class="line">    D(<span class="keyword">const</span> D &amp;d) : Base(d) <span class="comment">// 拷贝基类成员</span></span><br><span class="line">    <span class="comment">/* D 的成员的初始值*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">    D(D &amp;&amp;d) : Base(<span class="built_in">std</span>::move(d)) <span class="comment">// 移动基类成员</span></span><br><span class="line">    <span class="comment">/* D 的成员的初始值*/</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* ... */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Base</code> 的拷贝构造函数负责将 <code>d</code> 的基类部分拷贝给要创建的对象。假如我们没有提供基类的初始值的话：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// D 的这个拷贝构造函数很可能是不正确的定义</span></span><br><span class="line"><span class="comment">// 基类部分被默认初始化，而非拷贝</span></span><br><span class="line">D(<span class="keyword">const</span> D &amp;d) <span class="comment">/* 成员初始值，但是没有提供基类初始值 */</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WARNING：在默认情况下，基类默认构造函数初始化派生类对象的基类部分。<strong>如果我们想拷贝（或移动）基类部分，则必须在派生类的构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。</strong></p>
</blockquote>
</li>
<li><p>与拷贝和移动构造函数一样，<strong>派生类的赋值运算符也必须显式地为其基类部分赋值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Base::operator=(const Base&amp;) 不会被自动调用</span></span><br><span class="line">D &amp;D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs); <span class="comment">// 为基类部分赋值</span></span><br><span class="line">    <span class="comment">// 按照过去的方式为派生类的成员赋值</span></span><br><span class="line">    <span class="comment">// 酌情处理自赋值及释放已有资源等情况</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在析构函数体执行完成后，对象的成员会被隐式销毁。类似的，对象的基类部分也是隐式销毁的。因此，和构造函数及赋值运算符不同的是，派生类析构函数只负责销毁由派生类自己分配的资源</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Base::~Base 被自动调用执行</span></span><br><span class="line">    ~D()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* 该处由用户定义清除派生类成员的操作 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>对象销毁的顺序正好与其创建的顺序相反：派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。</strong></p>
<blockquote>
<p>如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。</p>
</blockquote>
</li>
</ol>
<h2 id="15-7-4-继承的构造函数" class="heading-control"><a href="#15-7-4-继承的构造函数" class="headerlink" title="15.7.4 继承的构造函数"></a>15.7.4 继承的构造函数<a class="heading-anchor" href="#15-7-4-继承的构造函数" aria-hidden="true"></a></h2><ol>
<li><p><strong>一个类只初始化它的直接基类，出于同样的原因，一个类也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。</strong> 如果派生类没有直接定义这些构造函数，则编译器将为派生类合成它们。派生类继承基类构造函数的方式是提供一条注明了（直接）基类名的 <code>using</code> 声明语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Disc_quote::Disc_quote; <span class="comment">// 继承 Disc_quote 的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通常情况下，<code>using</code> 声明语句只是令某个名字在当前作用域内可见。而<strong>当作用于构造函数时，<code>using</code> 声明语句将令编译器产生代码</strong>。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。换句话说，对于基类的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数。</p>
</li>
<li><p>和普通成员的 <code>using</code> 声明不一样，<strong>一个构造函数的 <code>using</code> 声明不会改变该构造函数的访问级别</strong>。例如，<strong>不管 <code>using</code> 声明出现在哪儿，基类的私有构造函数在派生类中还是一个私有构造函数；受保护的构造函数和公有构造函数也是同样的规则</strong>。</p>
<p><strong>一个 <code>using</code> 声明语句不能指定 <code>explicit</code> 或 <code>constexpr</code>。如果基类的构造函数是 <code>explicit</code> 或者 <code>constexpr</code>，则继承的构造函数也拥有相同的属性。</strong></p>
</li>
<li><p><strong>当一个基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。</strong> 例如，如果基类有一个接受两个形参的构造函数，其中第二个形参含有默认实参，则派生类将获得两个构造函数：一个构造函数接受两个形参（没有默认实参），另一个构造函数只接受一个形参，它对应于基类中最左侧的没有默认值的那个形参。</p>
</li>
<li><p>如果基类含有几个构造函数，则除了两个例外情况，大多数时候派生类会继承所有这些构造函数。</p>
<ul>
<li>第一个例外是<strong>派生类可以继承一部分构造函数，而为其他构造函数定义自己的版本。如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数</strong></li>
<li>第二个例外是<strong>默认、拷贝和移动构造函数不会被继承</strong>。这些构造函数按照正常规则被合成。继承的构造函数不会被作为用户定义的构造函数来使用，因此，如果一个类只含有继承的构造函数，则它也将拥有一个合成的默认构造函数</li>
</ul>
</li>
</ol>
<h1 id="15-8-容器与继承" class="heading-control"><a href="#15-8-容器与继承" class="headerlink" title="15.8 容器与继承"></a>15.8 容器与继承<a class="heading-anchor" href="#15-8-容器与继承" aria-hidden="true"></a></h1><ol>
<li><blockquote>
<p>WARNING：当派生类对象被赋值给基类对象时，其中的派生类部分将被“切掉”，因此容器和存在继承关系的类型无法兼容。</p>
</blockquote>
</li>
<li><p>当我们希望在容器中存放具有继承关系的对象时，我们实际上存放的通常是基类的指针（更好的选择是智能指针。和往常一样，这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; basket;</span><br><span class="line">basket.push_back(make_shared&lt;Quote&gt;(<span class="string">"0-201-82470-1"</span>, <span class="number">50</span>));</span><br><span class="line">basket.push_back(make_shared&lt;Bulk_quote&gt;(<span class="string">"0-201-54848-8"</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">.25</span>));</span><br><span class="line"><span class="comment">// 调用 Quote 定义的版本；打印 562.5，即在 15*&amp;50 中扣除掉折扣金额</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; basket.back()-&gt;net_price(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>正如我们可以将一个派生类的普通指针转换成基类指针一样，我们也<strong>能把一个派生类的智能指针转换成基类的智能指针</strong>。</p>
</li>
</ol>
<h2 id="15-8-1-编写-Basket-类" class="heading-control"><a href="#15-8-1-编写-Basket-类" class="headerlink" title="15.8.1 编写 Basket 类"></a>15.8.1 编写 Basket 类<a class="heading-anchor" href="#15-8-1-编写-Basket-类" aria-hidden="true"></a></h2><ol>
<li><p>对于容器的 <code>upper_bound</code> 函数来说，它返回的是容器的一个迭代器，该迭代器指向容器中所有与 <code>upper_bound</code> 输入值相等的元素中最后一个元素的下一位置。</p>
</li>
<li><p>如果父类虚函数返回的是内建数据类型，那么派生类虚函数的返回类型要与父类严格一致；如果父类虚函数返回的是某个父类（可以是自身也可以是其它的类，这里我们称之为 <code>Base</code>）的指针或引用，那么派生类虚函数的返回类型可以是 <code>Base</code> 类的派生类的指针或引用。（博主注）</p>
</li>
</ol>
<h1 id="15-9-文本查询程序再探" class="heading-control"><a href="#15-9-文本查询程序再探" class="headerlink" title="15.9 文本查询程序再探"></a>15.9 文本查询程序再探<a class="heading-anchor" href="#15-9-文本查询程序再探" aria-hidden="true"></a></h1><h2 id="15-9-1-面向对象的解决方案" class="heading-control"><a href="#15-9-1-面向对象的解决方案" class="headerlink" title="15.9.1 面向对象的解决方案"></a>15.9.1 面向对象的解决方案<a class="heading-anchor" href="#15-9-1-面向对象的解决方案" aria-hidden="true"></a></h2><ol>
<li><p>当我们令一个类公有地继承另一个类时，派生类应当反映与基类的“是一种（IsA）”关系。在设计良好的类体系当中，公有派生类的对象应该可以用在任何需要基类对象的地方。</p>
<p>类型之间的另一种常见关系是“有一个（HasA）”关系，具有这种关系的类暗含成员的意思。</p>
</li>
</ol>
<h1 id="小结" class="heading-control"><a href="#小结" class="headerlink" title="小结"></a>小结<a class="heading-anchor" href="#小结" aria-hidden="true"></a></h1><ol>
<li><p>动态绑定使得我们可以忽略类型之间的差异，其机理是<strong>在运行时根据对象的动态类型来选择运行函数的哪个版本</strong>。</p>
</li>
<li><p><strong>在 C++ 语言中，动态绑定只作用于虚函数，并且需要通过指针或引用调用。</strong></p>
</li>
<li><p><strong>在派生类对象中包含有与它的每个基类对应的子对象。</strong>因为所有派生类对象都含有基类部分，所以我们能将派生类的引用或指针转换为一个可访问的基类引用或指针。</p>
</li>
<li><p><strong>当执行派生类的构造、拷贝、移动和赋值操作时，首先构造、拷贝、移动和赋值其中的基类部分，然后才轮到派生类部分。析构函数的执行顺序则正好相反，首先销毁派生类，接下来执行基类子对象的析构函数。</strong></p>
</li>
<li><p><strong>基类通常都应该定义一个虚析构函数</strong>，即使基类根本不需要析构函数也最好这么做。<strong>将基类的析构函数定义成虚函数的原因是为了确保当我们删除一个基类指针，而该指针实际指向一个派生类对象时，程序也能正确运行</strong>（防止内存泄漏——博主注）。</p>
</li>
</ol>
<h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><ol>
<li><p><strong>动态绑定</strong>（dynamic binding）直到运行时才确定到底执行函数的哪个版本。在 C++ 语言中，动态绑定的意思是在运行时根据引用或指针所绑定对象的实际类型来选择执行虚函数的某一个版本。</p>
</li>
<li><p><strong>动态类型</strong>（dynamic type）对象在运行时的类型。引用所引对象或者指针所指对象的动态类型可能与该引用或指针的静态类型不同。基类的指针或引用可以指向一个派生类对象。在这样的情况中，静态类型是基类的引用（或指针），而动态类型是派生类的引用（或指针）。</p>
</li>
<li><p><strong>多态性</strong>（polymorphism）当用于面向对象编程的范畴时，多态性的含义是指程序能通过引用或指针的动态类型获取类型特定行为的能力。</p>
</li>
<li><p><strong>私有继承</strong>（private inheritance）在私有继承中，基类的公有成员和受保护成员是派生类的私有成员。</p>
</li>
<li><p><strong>纯虚函数</strong>（pure virtual）在类的内部声明虚函数时，在分号之前使用了<code>=0</code>。一个纯虚函数不需要（但是可以）被定义。含有纯虚函数的类是抽象基类。如果派生类没有对继承而来的纯虚函数定义自己的版本，则该派生类也是抽象的。</p>
</li>
<li><p><strong>运行时绑定</strong>（run-time binding）与动态绑定等价。</p>
</li>
<li><p><strong>切掉</strong>（sliced down）当我们用一个派生类对象初始化基类对象或者为基类对象赋值时发生的情况。对象的派生类部分将被“切掉”，只剩下基类部分赋值给基类对象。</p>
</li>
<li><p><strong>静态类型</strong>（static type）对象被定义的类型或表达式产生的类型。静态类型在编译时是已知的。</p>
</li>
<li><p><strong>虚函数</strong>（virtual function）用于定义类型特定行为的成员函数。通过引用或指针对虚函数的调用直到运行时才被解析，依据是引用或指针所绑定对象的类型。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 13 章 拷贝控制</title>
    <url>/archives/2eb22c6f.html</url>
    <content><![CDATA[<ol>
<li><p><strong>拷贝构造函数</strong>（copy constructor）、<strong>拷贝赋值运算符</strong>（copy-assignment operator）、<strong>移动构造函数</strong>（move constructor）、<strong>移动赋值运算符</strong>（move-assignment operator）和<strong>析构函数</strong>（destructor）。</p>
</li>
<li><p>拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。我们称这些操作为<strong>拷贝控制操作</strong>（copy control）。</p>
</li>
<li><p><strong>如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。</strong></p>
</li>
</ol>
<h1 id="13-1-拷贝、赋值与销毁" class="heading-control"><a href="#13-1-拷贝、赋值与销毁" class="headerlink" title="13.1 拷贝、赋值与销毁"></a>13.1 拷贝、赋值与销毁<a class="heading-anchor" href="#13-1-拷贝、赋值与销毁" aria-hidden="true"></a></h1><h2 id="13-1-1-拷贝构造函数" class="heading-control"><a href="#13-1-1-拷贝构造函数" class="headerlink" title="13.1.1 拷贝构造函数"></a>13.1.1 拷贝构造函数<a class="heading-anchor" href="#13-1-1-拷贝构造函数" aria-hidden="true"></a></h2><ol>
<li><p>如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo();            <span class="comment">// 默认构造函数</span></span><br><span class="line">    Foo(<span class="keyword">const</span> Foo &amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>拷贝构造函数的第一个参数必须是一个引用类型。虽然我们可以定义一个接受非 <code>const</code> 引用的拷贝构造函数，但此参数几乎总是一个 <code>const</code> 的引用。拷贝构造函数在几种情况下都会被隐式地使用。因此，<strong>拷贝构造函数通常不应该是 <code>explicit</code> 的</strong>。</p>
</li>
<li><p><strong>如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。</strong></p>
</li>
<li><p>对某些类来说，<strong>合成拷贝构造函数</strong>（synthesized copy constructor）用来阻止我们拷贝该类类型的对象。<strong>而一般情况，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非 <code>static</code> 成员拷贝到正在创建的对象中。</strong></p>
</li>
<li><p>每个成员的类型决定了它如何拷贝：<strong>对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。虽然我们不能直接拷贝一个数组，但合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素是类类型，则使用元素的拷贝构造函数来进行拷贝。</strong></p>
</li>
<li><p>当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当我们使用<strong>拷贝初始化</strong>（copy initialization）时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。</p>
</li>
<li><p><strong>拷贝初始化通常使用拷贝构造函数来完成。如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。</strong></p>
</li>
<li><p><strong>拷贝初始化不仅在我们用 <code>=</code> 定义变量时会发生，在下列情况下也会发生：</strong></p>
<ul>
<li><strong>将一个对象作为实参传递给一个非引用类型的形参</strong></li>
<li><strong>从一个返回类型为非引用类型的函数返回一个对象</strong></li>
<li><strong>用花括号列表初始化一个数组中的元素或一个聚合类中的成员</strong></li>
</ul>
</li>
<li><p>某些类类型还会对它们所分配的对象使用拷贝初始化。例如，<strong>当我们初始化标准库容器或是调用其 <code>insert</code> 或 <code>push</code> 成员时，容器会对其元素进行拷贝初始化。与之相对，用 <code>emplace</code> 成员创建的元素都进行直接初始化。</strong></p>
</li>
<li><p><strong>在函数调用过程中，具有非引用类型的参数要进行拷贝初始化，类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。</strong></p>
</li>
<li><p>拷贝构造函数被用来初始化非引用类类型参数，这一特性解释了为什么拷贝构造函数自己的参数必须是引用类型。如果其参数不是引用类型，则调用永远也不会成功——为了调用拷贝构造函数，我们必须拷贝它的实参，但为了拷贝实参，我们又需要调用拷贝构造函数，如此无限循环。</p>
</li>
<li><p>如果我们使用的初始化值要求通过一个 <code>explicit</code> 的构造函数来进行类型转换，那么使用拷贝初始化还是直接初始化就不是无关紧要的了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 正确：直接初始化</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = <span class="number">10</span>; <span class="comment">// 错误：接受大小参数的构造函数是 explicit 的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;)</span></span>; <span class="comment">// f 的参数进行拷贝初始化</span></span><br><span class="line">f(<span class="number">10</span>);               <span class="comment">// 错误：不能用一个 explicit 的构造函数拷贝一个实参</span></span><br><span class="line">f(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>));  <span class="comment">// 正确：从一个 int 直接构造一个临时 vector</span></span><br></pre></td></tr></table></figure>
<p>直接初始化 v1 是合法的，但看起来与之等价的拷贝初始化 v2 则是错误的，因为 <strong><code>vector</code> 的接受单一大小参数的构造函数是 <code>explicit</code> 的</strong>。出于同样的原因，当传递一个实参或从函数返回一个值时，我们不能隐式使用一个 <code>explicit</code> 构造函数。如果我们希望使用一个 <code>explicit</code> 构造函数，就必须显式地使用，像此代码中最后一行那样。</p>
</li>
<li><p><strong>在拷贝初始化过程中，编译器可以（但不是必须）跳过拷贝/移动构造函数，直接创建对象。</strong> 即，编译器被允许将下面的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> null_book = <span class="string">"9-999-99999-9"</span>; <span class="comment">// 拷贝初始化</span></span><br></pre></td></tr></table></figure>
<p>改写为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">null_book</span><span class="params">(<span class="string">"9-999-99999-9"</span>)</span></span>;  <span class="comment">// 编译器略过了拷贝构造函数</span></span><br></pre></td></tr></table></figure>
<p>但是，即使编译器略过了拷贝/移动构造函数，但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的（例如，不能是 <code>private</code> 的）。</p>
</li>
<li><p><strong>练习 13.4：</strong> 假定 Point 是一个类类型，它有一个 <code>public</code> 的拷贝构造函数，指出下面程序片段中哪些地方使用了拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Point global;</span><br><span class="line"><span class="function">Point <span class="title">foo_bar</span><span class="params">(Point arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Point local = arg, *heap = <span class="keyword">new</span> Point(global);</span><br><span class="line">    *heap = local;</span><br><span class="line">    Point pa[<span class="number">4</span>] = &#123;local, *heap&#125;;</span><br><span class="line">    <span class="keyword">return</span> *heap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1：<code>foo_bar</code> 的形参为传值形式，传入实参时会发生拷贝构造生成临时对象 <code>arg</code><br>2：<code>local</code> 通过临时对象 <code>arg</code> 拷贝构造生成<br>3：<code>head</code> 指向的内存初始时通过全局对象 <code>global</code> 拷贝构造生成<br>4：<code>pa</code> 数组的 <code>[0]</code> 元素通过局部对象 <code>loacal</code> 拷贝构造生成<br>5：<code>pa</code> 数组的 <code>[1]</code> 元素通过 <code>head</code> 指向的内存上的内容拷贝构造生成<br>6：<code>foo_bar</code> 返回的临时匿名对象通过 <code>head</code> 指向的内存上的内容拷贝构造生成</p>
</li>
<li><p><strong>练习 13.5：</strong> 给定下面的类框架，编写一个拷贝构造函数，拷贝所有成员。你的构造函数应该动态分配一个新的 <code>string</code>，并将对象拷贝到 ps 指向的位置，而不是 ps 本身的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>())</span><br><span class="line">        : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>答：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HasPtr(<span class="keyword">const</span> HasPtr &amp;param) : ps(<span class="keyword">new</span> <span class="built_in">string</span>(*(param.ps))), i(param.i) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="13-1-2-拷贝赋值运算符" class="heading-control"><a href="#13-1-2-拷贝赋值运算符" class="headerlink" title="13.1.2 拷贝赋值运算符"></a>13.1.2 拷贝赋值运算符<a class="heading-anchor" href="#13-1-2-拷贝赋值运算符" aria-hidden="true"></a></h2><ol>
<li><p><strong>与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。</strong></p>
</li>
<li><p><strong>重载运算符本质上是函数</strong>，其名字由 <code>operator</code> 关键字后接表示要定义的运算符的符号组成。因此，赋值运算符就是一个名为 <code>operator=</code> 的函数。<strong>类似于任何其他函数，运算符函数也有一个返回类型和一个参数列表。</strong></p>
</li>
<li><p>重载运算符的参数表示运算符的运算对象。<strong>某些运算符，包括赋值运算符，必须定义为成员函数。如果一个运算符是一个成员函数，其左侧运算对象就绑定到隐式的 <code>this</code> 参数。</strong> 对于一个二元运算符，例如赋值运算符，其右侧运算对象作为显式参数传递。</p>
</li>
<li><p>拷贝赋值运算符接受一个与其所在类相同类型的参数，为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。另外值得注意的是，标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。</p>
<blockquote>
<p><strong>Best Practices：</strong> 赋值运算符通常应该返回一个指向其左侧运算对象的引用。</p>
</blockquote>
</li>
<li><p>与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个<strong>合成拷贝赋值运算符</strong>（synthesized copy-assignment operator）。类似拷贝构造函数，对于某些类，合成拷贝赋值运算符用来禁止该类型对象的赋值。如果拷贝赋值运算符并非出于此目的，它会将右侧运算对象的每个非 <code>static</code> 成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。<strong>合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。</strong></p>
</li>
<li><p><strong>练习 13.8：</strong> 为 13.1.1 节练习 13.5 中的 <code>HasPtr</code> 类编写赋值运算符。类似拷贝构造函数，你的赋值运算符应该将对象拷贝到 ps 指向的位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">HasPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;param)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> tmp = <span class="keyword">new</span> <span class="built_in">string</span>(*(param.ps));</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = tmp;</span><br><span class="line">    i = param.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="13-1-3-析构函数" class="heading-control"><a href="#13-1-3-析构函数" class="headerlink" title="13.1.3 析构函数"></a>13.1.3 析构函数<a class="heading-anchor" href="#13-1-3-析构函数" aria-hidden="true"></a></h2><ol>
<li><p>构造函数初始化对象的非 <code>static</code> 数据成员，还可能做一些其他工作；<strong>析构函数释放对象使用的资源，并销毁对象的非 <code>static</code> 数据成员。析构函数是类的一个成员函数，名字由波浪号接类名构成。它没有返回值，也不接受参数。</strong> 由于析构函数不接受参数，因此它不能被重载。对一个给定类，只会有唯一一个析构函数。</p>
</li>
<li><p><strong>如同构造函数有一个初始化部分和一个函数体，析构函数也有一个函数体和一个析构部分。在一个构造函数中，成员的初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。</strong></p>
</li>
<li><p>通常，析构函数释放对象在生存期分配的所有资源。<strong>在一个析构函数中，不存在类似构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。</strong> 成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。</p>
<blockquote>
<p><strong>Note：</strong> 隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象。</p>
</blockquote>
<p>与普通指针不同，智能指针是类类型，所以具有析构函数。因此，与普通指针不同，智能指针成员在析构阶段会被自动销毁。</p>
</li>
<li><p>无论何时一个对象被销毁，就会自动调用其析构函数：</p>
<ul>
<li>变量在离开其作用域时被销毁。</li>
<li>当一个对象被销毁时，其成员被销毁。</li>
<li>容器（无论是标准库容器还是数组）被销毁时，其元素被销毁。</li>
<li>对于动态分配的对象，当对指向它的指针应用 <code>delete</code> 运算符时被销毁。</li>
<li>对于临时对象，当创建它的完整表达式结束时被销毁。</li>
</ul>
<p><br></p>
<p>由于析构函数自动运行，我们的程序可以按需要分配资源，而（通常）无须担心何时释放这些资源。</p>
<blockquote>
<p><strong>Note：</strong> 当指向一个对象的引用或指针离开作用域时，析构函数不会执行。</p>
</blockquote>
</li>
<li><p>当一个类未定义自己的析构函数时，编译器会为它定义一个<strong>合成析构函数</strong>（synthesized destructor）。类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型的对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。</p>
</li>
<li><p>认识到析构函数体自身并不直接销毁成员是非常重要的。<strong>成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。</strong></p>
</li>
<li><p><strong>练习 13.12：</strong> 在下面的代码片段中会发生几次析构函数调用？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">fcn</span><span class="params">(<span class="keyword">const</span> Sales_data *trans, Sales_data accum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Sales_data item1(*trans), item2(accum);</span><br><span class="line">    <span class="keyword">return</span> item1.isbn() != item2.isbn();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：3 次。item1、item2 和 accum。函数形参里，accum 传值使用，会拷贝构造一个同名临时对象，离开函数前该临时对象被析构。</p>
</li>
</ol>
<h2 id="13-1-4-三-五法则" class="heading-control"><a href="#13-1-4-三-五法则" class="headerlink" title="13.1.4 三/五法则"></a>13.1.4 三/五法则<a class="heading-anchor" href="#13-1-4-三-五法则" aria-hidden="true"></a></h2><ol>
<li><p>当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。<strong>如果这个类需要一个析构函数，我们几乎可以肯定它也需要一个接贝构造函数和一个拷贝赋值运算符。</strong></p>
<blockquote>
<p><strong>Tip： 如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。</strong> （因为类中可能有指针成员，拷贝构造或拷贝赋值时需要进行深拷贝——博主注）</p>
</blockquote>
</li>
<li><p>如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然——如果一个类需要一个拷贝赋值运算符，几亚可以肯定它也需要一个拷贝构造函数。然而，<strong>无论是需要拷贝构造函数还是需要拷贝赋值运算符都不必然意味着也需要析构函数</strong>。</p>
</li>
<li><p><strong>练习 13.14：</strong> 假定 numbered 是一个类，它有一个默认构造函数，能为每个对象生成一个唯一的序号，保存在名为 mysn 的数据成员中。假定 numbered 使用合成的拷贝控制成员，并给定如下函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(numbered s)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; s.mysn &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>则下面代码输出什么内容？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">numbered a, b = a, c = b;</span><br><span class="line">f(a);</span><br><span class="line">f(b);</span><br><span class="line">f(c);</span><br></pre></td></tr></table></figure>
<p>答：输出 3 个相同的值（a 的序号）。</p>
</li>
<li><p><strong>练习 13.15：</strong> 假定 numbered 定义了一个拷贝构造函数，能生成一个新的序号。这会改变上一题中调用的输出结果吗？如果会改变，为什么？新的输出结果是什么？</p>
<p>答：会改变，a 默认构造，b 使用 a 拷贝构造，c 使用 b 拷贝构造，3 次对 f 的调用又会发生 3 次拷贝构造（构造临时对象 s），每次拷贝构造的对象都将得到一个新序号，因此会输出三个新序号。</p>
</li>
<li><p><strong>练习 13.16：</strong> 如果 f 中的参数是 <code>const numbered&amp;</code>，将会怎样？这会改变输出结果吗？如果会改变，为什么？新的输出结果是什么？</p>
<p>答：会改变，分别输出 a、b、c 的序号，调用 f 时不再拷贝构造临时对象。</p>
</li>
</ol>
<h2 id="13-1-5-使用-default" class="heading-control"><a href="#13-1-5-使用-default" class="headerlink" title="13.1.5 使用 =default"></a>13.1.5 使用 =default<a class="heading-anchor" href="#13-1-5-使用-default" aria-hidden="true"></a></h2><ol>
<li><p>可以通过将拷贝控制成员定义为 <code>=default</code> 来显式地要求编译器生成合成的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 拷贝控制成员；使用 default</span></span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> Sales_data &amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;);</span><br><span class="line">    ~Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="comment">// 其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Sales_data &amp;Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data &amp;) = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<p><strong>当我们在类内用 <code>=default</code> 修饰成员的声明时，合成的函数将隐式地声明为内联的（就像任何其他类内声明的成员函数一样）。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用 <code>=default</code>，就像对拷贝赋值运算符所做的那样。</strong></p>
<blockquote>
<p><strong>Note：</strong> 我们只能对具有合成版本的成员函数使用 <code>=default</code>（即，默认构造函数或拷贝控制成员）。</p>
</blockquote>
</li>
</ol>
<h2 id="13-1-6-阻止拷贝" class="heading-control"><a href="#13-1-6-阻止拷贝" class="headerlink" title="13.1.6 阻止拷贝"></a>13.1.6 阻止拷贝<a class="heading-anchor" href="#13-1-6-阻止拷贝" aria-hidden="true"></a></h2><ol>
<li><blockquote>
<p><strong>Best Practices：</strong> 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。</p>
</blockquote>
</li>
<li><p>在新标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为<strong>删除的函数</strong>（deleted function）来阻止拷贝。删除的函数是这样一种函数：我们虽然声明了它们，但不能以任何方式使用它们。在函数的参数列表后面加上 <code>=delete</code> 来指出我们希望将它定义为删除的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NoCopy() = <span class="keyword">default</span>;                         <span class="comment">// 使用合成的默认构造函数</span></span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>;            <span class="comment">// 阻止拷贝</span></span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy &amp;) = <span class="keyword">delete</span>; <span class="comment">// 阻止赋值</span></span><br><span class="line">    ~NoCopy() = <span class="keyword">default</span>;                        <span class="comment">// 使用合成的析构函数</span></span><br><span class="line">    <span class="comment">// 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>=delete</code> 通知编译器，我们不希望定义这些成员。</p>
</li>
<li><p><strong>与 <code>=default</code> 不同，<code>=delete</code> 必须出现在函数第一次声明的时候</strong>，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，因此 <code>=default</code> 直到编译器生成代码时才需要。而另一方面，编译器需要知道一个函数是删除的，以便禁止试图使用它的操作。<strong>与 <code>=default</code> 的另一个不同之处是，我们可以对任何函数指定 <code>=delete</code>（我们只能对编译器可以合成的默认构造函数或拷贝控制成员使用 <code>=default</code>）。</strong> 虽然删除函数的主要用途是禁止拷贝控制成员，但当我们希望引导函数匹配过程时，删除函数有时也是有用的。</p>
</li>
<li><p><strong>值得注意的是，我们不能删除析构函数。</strong> 如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器将不允许定义该类型的变量或创建该类的临时对象。而且，如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。因为如果一个成员的析构函数是删除的，则该成员无法被销毁。而如果一个成员无法被销毁，则对象整体也就无法被销毁了。</p>
</li>
<li><p>对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoDtor</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    NoDtor() = <span class="keyword">default</span>; <span class="comment">// 使用合成默认构造函数</span></span><br><span class="line">    ~NoDtor() = <span class="keyword">delete</span>; <span class="comment">// 我们不能销毁 NoDtor 类型的对象</span></span><br><span class="line">&#125;;</span><br><span class="line">NoDtor nd;                <span class="comment">// 错误：NoDtor 的析构函数是删除的</span></span><br><span class="line">NoDtor *p = <span class="keyword">new</span> NoDtor(); <span class="comment">// 正确：但我们不能 delete p</span></span><br><span class="line"><span class="keyword">delete</span> p;                 <span class="comment">// 错误：NoDtor 的析构函数是删除的</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>WARNING：</strong> 对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型动态分配对象的指针。</p>
</blockquote>
</li>
<li><p>如前所述，如果我们未定义拷贝控制成员，编译器会为我们定义合成的版本。类似的，如果一个类未定义构造函数，编译器会为其合成一个默认构造函数。对某些类来说，编译器将这些合成的成员定义为删除的函数：</p>
<ul>
<li>如果类的某个成员的析构函数是删除的或不可访问的（例如，是 <code>private</code> 的），则类的合成析构函数被定义为删除的。</li>
<li>如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的。</li>
<li>如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个 <code>const</code> 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。</li>
<li>如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个 <code>const</code> 成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。</li>
</ul>
<p><br></p>
<p>本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的，这看起来可能有些奇怪。其原因是，如果没有这条规则，我们可能会创建出无法销毁的对象。对于具有引用成员或无法默认构造的 <code>const</code> 成员的类，编译器不会为其合成默认构造函数，这应该不奇怪。同样不出人意料的规则是：如果一个类有 <code>const</code> 成员，则它不能使用合成的拷贝赋值运算符。毕竟，此运算符试图赋值所有成员，而将一个新值赋予一个 <code>const</code> 对象是不可能的。虽然我们可以将一个新值赋予一个引用成员，但这样做改变的是引用指向的对象的值，而不是引用本身。如果为这样的类合成拷贝赋值运算符，则赋值后，左侧运算对象仍然指向与赋值前一样的对象，而不会与右侧运算对象指向相同的对象。由于这种行为看起来并不是我们所期望的，因此对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。</p>
<blockquote>
<p><strong>Note：</strong> 本质上，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。</p>
</blockquote>
</li>
<li><p>在 C++11 新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为 <code>private</code> 的来阻止拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrivateCopy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 无访问说明符；接下来的成员默认为 private 的</span></span><br><span class="line">    <span class="comment">// 拷贝控制成员是 private 的，因此普通用户代码无法访问</span></span><br><span class="line">    PrivateCopy(<span class="keyword">const</span> PrivateCopy &amp;);</span><br><span class="line">    PrivateCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> PrivateCopy &amp;);</span><br><span class="line">    <span class="comment">// 其他成员</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    PrivateCopy() = <span class="keyword">default</span>; <span class="comment">// 使用合成的默认构造函数</span></span><br><span class="line">    ~PrivateCopy();          <span class="comment">// 用户可以定义此类型的对象，但无法拷贝它们</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于析构函数是 <code>public</code> 的，用户可以定义 <code>PrivateCopy</code> 类型的对象。但是，由于拷贝构造函数和拷贝赋值运算符是 <code>private</code> 的，用户代码将不能拷贝这个类型的对象。但是，友元和成员函数仍旧可以拷贝对象。为了阻止友元和成员函数进行拷贝，我们将这些拷贝控制成员声明为 <code>private</code> 的，但并不定义它们。</p>
</li>
<li><p><strong>声明但不定义一个成员函数是合法的。</strong> 试图访问一个未定义的成员将导致一个链接时错误。通过声明（但不定义）<code>private</code> 的拷贝构造函数，我们可以预先阻止任何拷贝该类型对象的企图：试图拷贝对象的用户代码将在编译阶段被标记为错误；成员函数或友元函数中的拷贝操作将会导致链接时错误。</p>
<blockquote>
<p><strong>Best Practices：</strong> 希望阻止拷贝的类应该使用 <code>=delete</code> 来定义它们自己的拷贝构造函数和拷贝赋值运算符，而不应该将它们声明为 <code>private</code> 的。</p>
</blockquote>
</li>
</ol>
<h1 id="13-2-拷贝控制和资源管理" class="heading-control"><a href="#13-2-拷贝控制和资源管理" class="headerlink" title="13.2 拷贝控制和资源管理"></a>13.2 拷贝控制和资源管理<a class="heading-anchor" href="#13-2-拷贝控制和资源管理" aria-hidden="true"></a></h1><ol>
<li><p>一旦一个类需要析构函数，那么它几乎肯定也需要一个拷贝构造函数和一个拷贝赋值运算符。</p>
</li>
<li><p><code>IO</code> 类型和 <code>unique_ptr</code> 不允许拷贝或赋值，因此它们的行为既不像值也不像指针。</p>
</li>
</ol>
<h2 id="13-2-1-行为像值的类" class="heading-control"><a href="#13-2-1-行为像值的类" class="headerlink" title="13.2.1 行为像值的类"></a>13.2.1 行为像值的类<a class="heading-anchor" href="#13-2-1-行为像值的类" aria-hidden="true"></a></h2><ol>
<li><p>赋值运算符通常组合了析构函数和构造函数的操作。</p>
</li>
<li><p>当你编写一个赋值运算符时，一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中。当拷贝完成后，销毁左侧运算对象的现有成员就是安全的了。一旦左侧运算对象的资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员中了。</p>
</li>
<li><p><strong>为了说明防范自赋值操作的重要性，考虑如果赋值运算符如下编写将会发生什么：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这样编写赋值运算符是错误的!</span></span><br><span class="line">HasPtr &amp;HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">delete</span> ps; <span class="comment">// 释放对象指向的 string</span></span><br><span class="line">    <span class="comment">// 如果 rhs 和 *this 是同一个对象，我们就将从已释放的内存中拷贝数据!</span></span><br><span class="line">    ps = <span class="keyword">new</span> <span class="built_in">string</span>(*(rhs.ps));</span><br><span class="line">    i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 rhs 和本对象是同一个对象，<code>delete ps</code> 会释放 <code>*this</code> 和 rhs 指向的 <code>string</code>。接下来，当我们在 <code>new</code> 表达式中试图拷贝 <code>*(rhs.ps)</code> 时，就会访问一个指向无效内存的指针，其行为和结果是未定义的。</p>
</li>
<li><blockquote>
<p><strong>WARNING：对于一个赋值运算符来说，正确工作是非常重要的，即使是将一个对象赋予它自身，也要能正确工作。一个好的方法是在销毁左侧运算对象资源之前拷贝右侧运算对象。</strong></p>
</blockquote>
</li>
</ol>
<h2 id="13-2-2-定义行为像指针的类" class="heading-control"><a href="#13-2-2-定义行为像指针的类" class="headerlink" title="13.2.2 定义行为像指针的类"></a>13.2.2 定义行为像指针的类<a class="heading-anchor" href="#13-2-2-定义行为像指针的类" aria-hidden="true"></a></h2><ol>
<li><p>令一个类展现类似指针的行为的最好方法是使用 <code>shared_ptr</code> 来管理类中的资源。拷贝（或赋值）一个 <code>shared_ptr</code> 会拷贝（赋值）<code>shared_ptr</code> 所指向的指针。<code>shared_ptr</code> 类自己记录有多少用户共享它所指向的对象。当没有用户使用对象时，<code>shared_ptr</code> 类负责释放资源。</p>
</li>
<li><p>引用计数的工作方式如下：</p>
<ul>
<li>除了初始化对象外，每个构造函数（拷贝构造函数除外）还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态，因此将计数器初始化为 1。</li>
<li>拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享的计数器，指出给定对象的状态又被一个新用户所共享。</li>
<li>析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为 0，则析构函数释放状态。</li>
<li>拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为 0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。</li>
</ul>
</li>
<li><p>通过使用引用计数，我们就可以编写类指针的 <code>HasPtr</code> 版本了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数分配新的 string 和新的计数器，将计数器置为 1</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s = <span class="built_in">std</span>::<span class="built_in">string</span>())</span><br><span class="line">        : ps(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="keyword">size_t</span>(<span class="number">1</span>)) &#123;&#125;</span><br><span class="line">    <span class="comment">// 拷贝构造函数拷贝所有三个数据成员，并递增计数器</span></span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;p) : ps(p.ps), i(p.i), use(p.use) &#123; ++*use; &#125;</span><br><span class="line">    HasPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;);</span><br><span class="line">    ~HasPtr();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> *use; <span class="comment">// 用来记录有多少个对象共享 *ps 的成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HasPtr::~HasPtr()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) <span class="comment">// 如果引用计数变为 0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ps;  <span class="comment">// 释放 string 内存</span></span><br><span class="line">        <span class="keyword">delete</span> use; <span class="comment">// 释放计数器内存</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HasPtr &amp;HasPtr::<span class="keyword">operator</span>=(<span class="keyword">const</span> HasPtr &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    ++*rhs.use;      <span class="comment">// 递增右侧运算对象的引用计数</span></span><br><span class="line">    <span class="keyword">if</span> (--*use == <span class="number">0</span>) <span class="comment">// 然后递减本对象的引用计数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> ps;  <span class="comment">// 如果没有其他用户</span></span><br><span class="line">        <span class="keyword">delete</span> use; <span class="comment">// 释放本对象分配的成员</span></span><br><span class="line">    &#125;</span><br><span class="line">    ps = rhs.ps; <span class="comment">// 将数据从 rhs 拷贝到本对象</span></span><br><span class="line">    i = rhs.i;</span><br><span class="line">    use = rhs.use;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回本对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="13-3-交换操作" class="heading-control"><a href="#13-3-交换操作" class="headerlink" title="13.3 交换操作"></a>13.3 交换操作<a class="heading-anchor" href="#13-3-交换操作" aria-hidden="true"></a></h1><ol>
<li><p>除了定义拷贝控制成员，管理资源的类通常还定义一个名为 <code>swap</code> 的函数。</p>
</li>
<li><p>如果一个类定义了自己的 <code>swap</code>，那么算法将使用类自定义版本。</p>
</li>
<li><p>为了交换两个对象我们需要进行一次拷贝和两次赋值。</p>
</li>
<li><p>可以在我们的类上定义一个自己版本的 <code>swap</code> 来重载 <code>swap</code> 的默认行为。<code>swap</code> 的典型实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;, HasPtr &amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 其他成员定义，与此前一样</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr &amp;lhs, HasPtr &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.ps, rhs.ps); <span class="comment">// 交换指针，而不是 string 数据</span></span><br><span class="line">    swap(lhs.i, rhs.i);   <span class="comment">// 交换 int 成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们首先将 <code>swap</code> 定义为 <code>friend</code>，以便能访问 <code>HasPtr</code> 的（<code>private</code> 的）数据成员。由于 <code>swap</code> 的存在就是为了优化代码，我们将其声明为 <code>inline</code> 函数。</p>
<blockquote>
<p><strong>Note：</strong> 与拷贝控制成员不同，<code>swap</code> 并不是必要的。但是，对于分配了资源的类，定义 <code>swap</code> 可能是一种很重要的优化手段。</p>
</blockquote>
<p>在本例中，数据成员是内置类型的，而内置类型是没有特定版本的 <code>swap</code> 的，所以在本例中，对 <code>swap</code> 的调用会调用标准库 <code>std::swap</code>。但是，如果一个类的成员有自己类型特定的 <code>swap</code> 函数，调用 <code>std::swap</code> 就是错误的了。</p>
</li>
<li><p>定义 <code>swap</code> 的类通常用 <code>swap</code> 来定义它们的赋值运算符。这些运算符使用了一种名为<strong>拷贝并交换</strong>（copy and swap）（《Effective C++》中提到过——博主注）的技术。<strong>这种技术将左侧运算对象与右侧运算对象的一个副本进行交换</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注意 rhs 是按值传递的，意味着 HasPtr 的拷贝构造函数</span></span><br><span class="line"><span class="comment">// 将右侧运算对象中的 string 拷贝到 rhs</span></span><br><span class="line">HasPtr &amp;HasPtr::<span class="keyword">operator</span>=(HasPtr rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 交换左侧运算对象和局部变量 rhs 的内容</span></span><br><span class="line">    swap(*<span class="keyword">this</span>, rhs); <span class="comment">// rhs 现在指向本对象曾经使用的内存</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;     <span class="comment">// rhs 被销毁，从而 delete 了 rhs 中的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个版本的赋值运算符中，参数并不是一个引用，我们将右侧运算对象以传值方式传递给了赋值运算符。因此，<code>rhs</code> 是右侧运算对象的一个副本。参数传递时拷贝 <code>HasPtr</code> 的操作会分配该对象的 <code>string</code> 的一个新副本。在赋值运算符的函数体中，我们调用 <code>swap</code> 来交换 <code>rhs</code> 和 <code>*this</code> 中的数据成员。这个调用将左侧运算对象中原来保存的指针存入 <code>rhs</code> 中，并将 <code>rhs</code> 中原来的指针存入 <code>*this</code> 中。因此，在 <code>swap</code> 调用之后，<code>*this</code> 中的指针成员将指向新分配的 <code>string</code>——右侧运算对象中 <code>string</code> 的一个副本。当赋值运算符结束时，<code>rhs</code> 被销毁，<code>HasPtr</code> 的析构函数将执行。此析构函数 <code>delete rhs</code> 现在指向的内存，即，释放掉左侧运算对象中原来的内存。这个技术的有趣之处是它自动处理了自赋值情况且天然就是异常安全的。它通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确，这与我们在原来的赋值运算符中使用的方法是一致的。它保证异常安全的方法也与原来的赋值运算符实现一样。代码中唯一可能抛出异常的是拷贝构造函数中的 <code>new</code> 表达式。如果真发生了异常，它也会在我们改变左侧运算对象之前发生。</p>
<blockquote>
<p><strong>Tip：使用拷贝和交换的赋值运算符自动就是异常安全的，且能正确处理自赋值。</strong></p>
</blockquote>
</li>
</ol>
<h1 id="13-4-拷贝控制示例" class="heading-control"><a href="#13-4-拷贝控制示例" class="headerlink" title="13.4 拷贝控制示例"></a>13.4 拷贝控制示例<a class="heading-anchor" href="#13-4-拷贝控制示例" aria-hidden="true"></a></h1><ol>
<li><blockquote>
<p><strong>Best Practices：拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作。这种情况下，公共的工作应该放在 <code>private</code> 的工具函数中完成。</strong></p>
</blockquote>
</li>
<li><p>带有一个默认参数的构造函数会被当做默认构造函数。</p>
</li>
</ol>
<h1 id="13-5-动态内存管理类" class="heading-control"><a href="#13-5-动态内存管理类" class="headerlink" title="13.5 动态内存管理类"></a>13.5 动态内存管理类<a class="heading-anchor" href="#13-5-动态内存管理类" aria-hidden="true"></a></h1><ol>
<li><p><code>vector</code> 类将其元素保存在连续内存中。为了获得可接受的性能，<code>vector</code> 预先分配足够的内存来保存可能需要的更多元素。<code>vector</code> 的每个添加元素的成员函数会检查是否有空间容纳更多的元素。如果有，成员函数会在下一个可用位置构造一个对象。如果没有可用空间，<code>vector</code> 就会重新分配空间：它获得新的空间，将已有元素移动到新空间中，释放旧空间，并添加新元素。</p>
</li>
<li><p><code>allocator</code> 分配的内存是未构造的，我们将在需要添加新元素时用 <code>allocator</code> 的 <code>construct</code> 成员在原始内存中创建对象。类似的，当我们需要删除一个元素时，我们将使用 <code>destroy</code> 成员来销毁元素。</p>
</li>
<li><p><strong>当我们用 <code>allocator</code> 分配内存时，必须记住内存是未构造的。为了使用此原始内存，我们必须调用 <code>construct</code>，在此内存中构造一个对象。传递给 <code>construct</code> 的第一个参数必须是一个指针，指向调用 <code>allocate</code> 所分配的未构造的内存空间。剩余参数确定用哪个构造函数来构造对象。</strong></p>
</li>
<li><p><strong>移动构造函数通常是将资源从给定对象“移动”而不是拷贝到正在创建的对象。而且我们知道标准库保证“移后源”（moved-from）string 仍然保持一个有效的、可析构的状态。</strong></p>
</li>
<li><p><code>move</code> 标准库函数定义在 <code>utility</code> 头文件中。我们通常不为 <code>move</code> 提供一个 <code>using</code> 声明。当我们使用 <code>move</code> 时，直接调用 <code>std::move</code> 而不是 <code>move</code>。</p>
</li>
</ol>
<h1 id="13-6-对象移动" class="heading-control"><a href="#13-6-对象移动" class="headerlink" title="13.6 对象移动"></a>13.6 对象移动<a class="heading-anchor" href="#13-6-对象移动" aria-hidden="true"></a></h1><ol>
<li><p>新标准的一个最主要的特性是可以移动而非拷贝对象的能力。很多情况下都会发生对象拷贝。在其中某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。</p>
</li>
<li><p>使用移动而不是拷贝的另一个原因源于 <code>IO</code> 类或 <code>unique_ptr</code> 这样的类。这些类都包含不能被共享的资源（如指针或 <code>IO</code> 缓冲）。因此，这些类型的对象不能拷贝但可以移动。</p>
</li>
<li><p>在旧 C++ 标准中，没有直接的方法移动对象。因此，即使不必拷贝对象的情况下，我们也不得不拷贝。如果对象较大，或者是对象本身要求分配内存空间（如 <code>string</code>），进行不必要的拷贝代价非常高。类似的，在旧版本的标准库中，容器中所保存的类必须是可拷贝的。但在新标准中，我们可以用容器保存不可拷贝的类型，只要它们能被移动即可。</p>
<blockquote>
<p><strong>Note：</strong> 标准库容器、<code>string</code> 和 <code>shared_ptr</code> 类既支持移动也支持拷贝。<code>IO</code> 类和 <code>unique_ptr</code> 类可以移动但不能拷贝。</p>
</blockquote>
</li>
</ol>
<h2 id="13-6-1-右值引用" class="heading-control"><a href="#13-6-1-右值引用" class="headerlink" title="13.6.1 右值引用"></a>13.6.1 右值引用<a class="heading-anchor" href="#13-6-1-右值引用" aria-hidden="true"></a></h2><ol>
<li><p>为了支持移动操作，新标准引入了一种新的引用类型——<strong>右值引用</strong>（rvalue reference）。所谓右值引用就是必须绑定到右值的引用。我们通过 <code>&amp;&amp;</code> 而不是 <code>&amp;</code> 来获得右值引用。如我们将要看到的，<strong>右值引用有一个重要的性质——只能绑定到一个将要销毁的对象</strong>。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。</p>
</li>
<li><p>左值和右值是表达式的属性，一些表达式生成或要求左值，而另外一些则生成或要求右值。<strong>一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。</strong></p>
</li>
<li><p>类似任何引用，一个右值引用也不过是某个对象的另一个名字而已。如我们所知，对于常规引用（为了与右值引用区分开来，我们可以称之为<strong>左值引用</strong>（lvalue reference）），我们不能将其绑定到要求转换的表达式、字面常量或是返回右值的表达式。右值引用有着完全相反的绑定特性：我们可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r = i;             <span class="comment">// 正确：r 引用 i</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr = i;           <span class="comment">// 错误：不能将一个右值引用绑定到一个左值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = i * <span class="number">42</span>;       <span class="comment">// 错误：i * 42 是一个右值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = i * <span class="number">42</span>; <span class="comment">// 正确：我们可以将一个 const 的引用绑定到一个右值上</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = i * <span class="number">42</span>;     <span class="comment">// 正确：将 rr2 绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>
<p><strong>返回左值引用的函数，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。我们可以将一个左值引用绑定到这类表达式的结果上。返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将一个左值引用绑定到这类表达式上，但我们可以将一个 <code>const</code> 的左值引用或者一个右值引用绑定到这类表达式上。</strong></p>
</li>
<li><p><strong>左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。</strong></p>
</li>
<li><p>由于右值引用只能绑定到临时对象，我们得知</p>
<ul>
<li>所引用的对象将要被销毁</li>
<li>该对象没有其他用户</li>
</ul>
<p><br></p>
<p>这两个特性意味着：使用右值引用的代码可以自由地接管所引用的对象的资源。</p>
<blockquote>
<p><strong>Note：右值引用指向将要被销毁的对象。因此，我们可以从绑定到右值引用的对象“窃取”状态。</strong></p>
</blockquote>
</li>
<li><p>变量可以看作只有一个运算对象而没有运算符的表达式，类似其他任何表达式，<strong>变量表达式也有左值/右值属性。变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上</strong>，这有些令人惊讶：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr1 = <span class="number">42</span>;  <span class="comment">// 正确：字面常量是右值</span></span><br><span class="line"><span class="keyword">int</span> &amp;&amp;rr2 = rr1; <span class="comment">// 错误：表达式 rr1 是左值!</span></span><br></pre></td></tr></table></figure>
<p>其实有了右值表示临时对象这一观察结果，变量是左值这一特性并不令人惊讶。毕竟，<strong>变量是持久的，直至离开作用域时才被销毁</strong>。</p>
<blockquote>
<p><strong>Note：变量是左值，因此我们不能将一个右值引用直接绑定到一个变量上，即使这个变量是右值引用类型也不行。</strong></p>
<p>之我见：能被赋值的都是左值，但左值不一定都能被赋值，例如右值引用。左值指的是持久值，右值指的是临时值。</p>
</blockquote>
</li>
<li><p>虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。<strong>我们还可以通过调用一个名为 <code>move</code> 的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件 <code>utility</code> 中。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> &amp;&amp;rr3 = <span class="built_in">std</span>::move(rr1); <span class="comment">// ok</span></span><br></pre></td></tr></table></figure>
<p><code>move</code> 调用告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。我们必须认识到，调用 <code>move</code> 就意味着承诺：除了对 rr1 赋值或销毁它外，我们将不再使用它。<strong>在调用 <code>move</code> 之后，我们不能对移后源对象的值做任何假设。</strong></p>
<blockquote>
<p><strong>Note：我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值。</strong></p>
</blockquote>
</li>
<li><p>与大多数标准库名字的使用不同，对 <code>move</code> 我们不提供 <code>using</code> 声明。我们直接调用 <code>std::move</code> 而不是 <code>move</code>。</p>
<blockquote>
<p><strong>WARNING：</strong> 使用 <code>move</code> 的代码应该使用 <code>std::move</code> 而不是 <code>move</code>。这样做可以避免潜在的名字冲突。</p>
</blockquote>
</li>
</ol>
<h2 id="13-6-2-移动构造函数和移动赋值运算符" class="heading-control"><a href="#13-6-2-移动构造函数和移动赋值运算符" class="headerlink" title="13.6.2 移动构造函数和移动赋值运算符"></a>13.6.2 移动构造函数和移动赋值运算符<a class="heading-anchor" href="#13-6-2-移动构造函数和移动赋值运算符" aria-hidden="true"></a></h2><ol>
<li><p>类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。<strong>除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。</strong></p>
</li>
<li><p>我们为 <code>StrVec</code> 类定义移动构造函数，<code>elements</code>、<code>first_free</code> 和 <code>cap</code> 是 <code>StrVec</code> 类中的三个指针成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec::StrVec(StrVec &amp;&amp;s) <span class="keyword">noexcept</span> <span class="comment">// 移动操作不应抛出任何异常</span></span><br><span class="line">    <span class="comment">// 成员初始化器接管 s 中的资源</span></span><br><span class="line">    : elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 令 s 进入这样的状态——对其运行析构函数是安全的</span></span><br><span class="line">    s.elements = s.first_free = s.cap = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>由于移动操作“窃取”资源，它通常不分配任何资源。因此，移动操作通常不会抛出任何异常。</strong> 当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。我们将看到，除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。</p>
<p>一种通知标准库的方法是在我们的构造函数中指明 <code>noexcept</code>。<code>noexcept</code>是新标准引入的承诺一个函数不抛出异常的一种方法。我们在一个函数的参数列表后指定 <code>noexcept</code>。在一个构造函数中，<code>noexcept</code> 出现在参数列表和初始化列表开始的冒号之间。<strong>我们必须在类头文件的声明中和定义中（如果定义在类外的话）都指定 <code>noexcept</code>。</strong></p>
<blockquote>
<p><strong>Note：不抛出异常的移动构造函数和移动赋值运算符必须标记为 <code>noexcept</code>。</strong></p>
</blockquote>
</li>
<li><p>我们需要指出一个移动操作不抛出异常，这是因为两个相互关联的事实：首先，虽然移动操作通常不抛出异常，但抛出异常也是允许的；其次，标准库容器能对异常发生时其自身的行为提供保障。例如，<code>vector</code> 保证，如果我们调用 <code>push_back</code> 时发生异常，<code>vector</code> 目身不会发生改变。</p>
</li>
<li><p>对一个 <code>vector</code> 调用 <code>push_back</code> 可能要求为 <code>vector</code> 重新分配内存空间。当重新分配 <code>vector</code> 的内存时，<code>vector</code> 将元素从旧空间移动到新内存中。</p>
</li>
<li><p>如我们刚刚看到的那样，移动一个对象通常会改变它的值。如果重新分配过程使用了移动构造函数，且在移动了部分而不是全部元素后抛出了一个异常，就会产生问题。旧空间中的移动源元素已经被改变了，而新空间中未构造的元素可能尚不存在。在此情况下，<code>vector</code> 将不能满足自身保持不变的要求。</p>
<p>另一方面，如果 <code>vector</code> 使用了拷贝构造函数且发生了异常，它可以很容易地满足要求。在此情况下，当在新内存中构造元素时，旧元素保持不变。如果此时发生了异常，<code>vector</code> 可以释放新分配的（但还未成功构造的）内存并返回。<code>vector</code> 原有的元素仍然存在。</p>
<p>为了避免这种潜在问题，除非 <code>vector</code> 知道元素类型的移动构造函数不会抛出异常，否则在重新分配内存的过程中，它就必须使用拷贝构造函数而不是移动构造函数。如果希望在 <code>vector</code> 重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。我们通过将移动构造函数（及移动赋值运算符）标记为 <code>noexcept</code> 来做到这一点。</p>
</li>
<li><p><strong>移动赋值运算符执行与析构函数和移动构造函数相同的工作。</strong> 与移动构造函数一样，如果我们的移动赋值运算符不抛出任何异常，我们就应该将它标记为 <code>noexcept</code>。类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec &amp;StrVec::<span class="keyword">operator</span>=(StrVec &amp;&amp;rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接检测自赋值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>();                  <span class="comment">// 释放已有元素</span></span><br><span class="line">        elements = rhs.elements; <span class="comment">// 从 rhs 接管资源</span></span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        <span class="comment">// 将 rhs 置于可析构状态</span></span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们费心地去检查自赋值情况看起来有些奇怪。毕竟，移动赋值运算符需要右侧运算对象的一个右值。我们进行检查的原因是此右值可能是 <code>move</code> 调用的返回结果。与其他任何赋值运算符一样，关键点是<strong>我们不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源（可能是相同的资源）</strong>。</p>
</li>
<li><p>从一个对象移动数据并不会销毁此对象，但有时在移动操作完成后，源对象会被销毁。因此，当我们编写一个移动操作时，必须确保移后源对象进入一个可析构的状态。</p>
<p>除了将移后源对象置为析构安全的状态之外，移动操作还必须保证对象仍然是有效的。一般来说，对象有效就是指可以安全地为其赋予新值或者可以安全地使用而不依赖其当前值。另一方面，移动操作对移后源对象中留下的值没有任何要求。因此，我们的程序不应该依赖于移后源对象中的数据。</p>
<blockquote>
<p><strong>WARNING：</strong> 在移动操作之后，移后源对象必须保持有效的、可析构的状态，但是用户不能对其值进行任何假设。</p>
</blockquote>
</li>
<li><p>与处理拷贝构造函数和拷贝赋值运算符一样，编译器也会合成移动构造函数和移动赋值运算符。但是，合成移动操作的条件与合成拷贝操作的条件大不相同。</p>
<p>与拷贝操作不同，编译器根本不会为某些类合成移动操作。特别是，<strong>如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了</strong>。因此，某些类就没有移动构造函数或移动赋值运算符。<strong>如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来代替移动操作。</strong></p>
<p><strong>只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 <code>static</code> 数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符。</strong> 编译器可以移动内置类型的成员。如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器会为 X 和 hasX 合成移动操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;         <span class="comment">// 内置类型可以移动</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s; <span class="comment">// string 定义了自己的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    X mem; <span class="comment">// X 有合成的移动操作</span></span><br><span class="line">&#125;;</span><br><span class="line">X x, x2 = <span class="built_in">std</span>::move(x);       <span class="comment">// 使用合成的移动构造函数</span></span><br><span class="line">hasX hx, hx2 = <span class="built_in">std</span>::move(hx); <span class="comment">// 使用合成的移动构造函数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：只有当一个类没有定义任何自己版本的拷贝控制成员，且它的所有数据成员都能移动构造或移动赋值时，编译器才会为它合成移动构造函数或移动赋值运算符。</strong></p>
</blockquote>
</li>
<li><p><strong>与拷贝操作不同，移动操作永远不会隐式定义为删除的函数。但是，如果我们显式地要求编译器生成 <code>=default</code> 的移动操作，且编编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。</strong> 除了一个重要例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则：</p>
<ul>
<li>与拷贝构造函数不同，移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数，或者是有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符的情况类似。</li>
<li>如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的。</li>
<li>类似拷贝构造函数，如果类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。</li>
<li>类似拷贝赋值运算符，如果有类成员是 <code>const</code> 的或是引用，则类的移动赋值运算符被定义为删除的。</li>
</ul>
<p><br></p>
<p>例如，假定 Y 是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定 Y 是一个类，它定义了自己的拷贝构造函数但未定义自己的移动构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasY</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    hasY() = <span class="keyword">default</span>;</span><br><span class="line">    hasY(hasY &amp;&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Y mem; <span class="comment">// hasY 将有一个删除的移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">hasY hy, hy2 = <span class="built_in">std</span>::move(hy); <span class="comment">// 错误：移动构造函数是删除的</span></span><br></pre></td></tr></table></figure>
<p>编译器可以拷贝类型为 Y 的对象，但不能移动它们。类 <code>hasY</code> 显式地要求一个移动构造函数，但编译器无法为其生成。因此，<code>hasY</code> 会有一个删除的移动构造函数。如果 <code>hasY</code> 忽略了移动构造函数的声明，则编译器根本不能为它合成一个。如果移动操作可能被定义为删除的函数，编译器就不会合成它们。</p>
<p>移动操作和合成的拷贝控制成员间还有最后一个相互作用关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。<strong>如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。</strong></p>
<blockquote>
<p><strong>Note：定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的。</strong></p>
</blockquote>
</li>
<li><p>如果一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪个构造函数。赋值操作的情况类似。</p>
</li>
<li><p>如果一个类有一个拷贝构造函数但未定义移动构造函数，会发生什么呢？在此情况下，编译器不会合成移动构造函数，这意味着此类将有拷贝构造函数但不会有移动构造函数。<strong>如果一个类没有移动构造函数，函数匹配规则保证该类型的对象会被拷贝，即使我们试图通过调用 <code>move</code> 来移动它们时也是如此：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo() = <span class="keyword">default</span>;</span><br><span class="line">    Foo(<span class="keyword">const</span> Foo &amp;); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="comment">// 其他成员定义，但 Foo 未定义移动构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line">Foo x;</span><br><span class="line"><span class="function">Foo <span class="title">y</span><span class="params">(x)</span></span>;            <span class="comment">// 拷贝构造函数；x 是一个左值</span></span><br><span class="line"><span class="function">Foo <span class="title">z</span><span class="params">(<span class="built_in">std</span>::move(x))</span></span>; <span class="comment">// 拷贝构造函数，因为未定义移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>在对 z 进行初始化时，我们调用了 <code>move(x)</code>，它返回一个绑定到 x 的 <code>Foo&amp;&amp;</code>。<code>Foo</code> 的拷贝构造函数是可行的，因为我们可以将一个 <code>Foo&amp;&amp;</code> 转换为一个 <code>const Foo&amp;</code>。因此，z 的初始化将使用 <code>Foo</code> 的拷贝构造函数。（<strong>一个右值引用可以转换为 <code>const</code> 左值引用</strong>——博主注）</p>
<p>值得注意的是，<strong>用拷贝构造函数代替移动构造函数几乎肯定是安全的（赋值运算符的情况类似）</strong>。一般情况下，拷贝构造函数满足对应的移动构造函数的要求：它会拷贝给定对象，并将原对象置于有效状态。实际上，拷贝构造函数甚至都不会改变原对象的值。</p>
<blockquote>
<p><strong>Note：如果一个类有一个可用的拷贝构造函数而没有移动构造函数，则其对象是通过拷贝构造函数来“移动”的。拷贝赋值运算符和移动赋值运算符的情况类似。</strong></p>
</blockquote>
</li>
<li><p>新标准库中定义了一种<strong>移动迭代器</strong>（move iterator）适配器。<strong>一个移动迭代器通过改变给定迭代器的解引用运算符的行为来适配此迭代器。一般来说，一个迭代器的解引用运算符返回一个指向元素的左值。与其他迭代器不同，移动迭代器的解引用运算符生成一个右值引用。</strong></p>
<p>我们通过调用标准库的 <code>make_move_iterator</code> 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。</p>
<p>原迭代器的所有其他操作在移动迭代器中都照常工作。由于移动迭代器支持正常的迭代器操作，我们可以将一对移动迭代器传递给算法。特别是，可以将移动迭代器传递给 <code>uninitialized_copy</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配大小两倍于当前规模的内存空间</span></span><br><span class="line">    <span class="keyword">auto</span> newcapacity = size() ? <span class="number">2</span> * size() : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = alloc.allocate(newcapacity);</span><br><span class="line">    <span class="comment">// 移动元素</span></span><br><span class="line">    <span class="keyword">auto</span> last = uninitialized_copy(make_move_iterator(begin()),</span><br><span class="line">                                   make_move_iterator(end()),</span><br><span class="line">                                   first);</span><br><span class="line">    <span class="built_in">free</span>();           <span class="comment">// 释放旧空间</span></span><br><span class="line">    elements = first; <span class="comment">// 更新指针</span></span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong><code>uninitialized_copy</code> 对输入序列中的每个元素调用 <code>construct</code> 来将元素“拷贝”到目的位置。此算法使用迭代器的解引用运算符从输入序列中提取元素。由于我们传递给它的是移动迭代器，因此解引用运算符生成的是一个右值引用，这意味着 <code>construct</code> 将使用移动构造函数来构造元素。</strong></p>
<p>值得注意的是，标准库不保证哪些算法适用移动迭代器，哪些不适用。由于移动一个对象可能销毁掉原对象，因此你只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。</p>
</li>
<li><blockquote>
<p><strong>建议：不要随意使用移动操作。</strong> 由于一个移后源对象具有不确定的状态，对其调用 <code>std::move</code> 是危险的。当我们调用 <code>move</code> 时，必须绝对确认移后源对象没有其他用户。</p>
<p>通过在类代码中小心地使用 <code>move</code>，可以大幅度提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。</p>
<p><strong>Best Practice：</strong> 在移动构造函数和移动赋值运算符这些类实现代码之外的地方，只有当你确信需要进行移动操作且移动操作是安全的，才可以使用 <code>std::move</code>。</p>
</blockquote>
</li>
<li><p><strong>练习 13.51：</strong> 虽然 <code>unique_ptr</code> 不能拷贝，但我们在 12.1.5 节（第 418 页）中编写了一个 <code>clone</code> 函数，它以值方式返回一个 <code>unique_ptr</code>。解释为什么函数是合法的，以及为什么它能正确工作。</p>
<p>答：<strong>不能拷贝 <code>unique_ptr</code> 的规则有一个例外：我们可以拷贝或赋值一个将要被销毁的 <code>unique_ptr</code>。最常见的例子就是从函数返回一个 <code>unique_ptr</code></strong>。</p>
</li>
</ol>
<h2 id="13-6-3-右值引用和成员函数" class="heading-control"><a href="#13-6-3-右值引用和成员函数" class="headerlink" title="13.6.3 右值引用和成员函数"></a>13.6.3 右值引用和成员函数<a class="heading-anchor" href="#13-6-3-右值引用和成员函数" aria-hidden="true"></a></h2><ol>
<li><p>定义了 <code>push_back</code> 的标准库容器提供两个版本：一个版本有一个右值引用参数，而另一个版本有一个 <code>const</code> 左值引用。假定 X 是元素类型，那么这些容器就会定义以下两个 <code>push_back</code> 版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X &amp;)</span></span>; <span class="comment">// 拷贝：绑定到任意类型的 X</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X &amp;&amp;)</span></span>;      <span class="comment">// 移动：只能绑定到类型 X 的可修改的右值</span></span><br></pre></td></tr></table></figure>
<p>我们可以将能转换为类型 X 的任何对象传递给第一个版本的 <code>push_back</code>。此版本从其参数拷贝数据。对于第二个版本，我们只可以传递给它非 <code>const</code> 的右值。此版本对于非 <code>const</code> 的右值是精确匹配（也是更好的匹配）的，因此当我们传递一个可修改的右值时，编译器会选择运行这个版本。此版本会从其参数窃取数据。</p>
<p>一般来说，我们不需要为函数操作定义接受一个 <code>const X&amp;&amp;</code> 或是一个（普通的）<code>X&amp;</code> 参数的版本。当我们希望从实参“窃取”数据时，通常传递一个右值引用。为了达到这一目的，实参不能是 <code>const</code> 的。类似的，从一个对象进行拷贝的操作不应该改变该对象。因此，通常不需要定义一个接受一个（普通的）<code>X&amp;</code> 参数的版本。</p>
<blockquote>
<p><strong>Note：</strong> 区分移动和拷贝的重载函数通常有一个版本接受一个 const T&amp;，而另一个版本接受一个 T&amp;。</p>
</blockquote>
<p>作为一个更具体的例子，我们将为 <code>StrVec</code> 类定义另一个版本的 <code>push_back</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>; <span class="comment">// 拷贝元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;&amp;)</span></span>;      <span class="comment">// 移动元素</span></span><br><span class="line">    <span class="comment">// 其他成员的定义，如前</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chk_n_alloc(); <span class="comment">// 确保有空间容纳新元素</span></span><br><span class="line">    <span class="comment">// 在 first_free 指向的元素中构造 s 的一个副本</span></span><br><span class="line">    alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="built_in">string</span> &amp;&amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chk_n_alloc(); <span class="comment">// 如果需要的话为 StrVec 重新分配内存</span></span><br><span class="line">    alloc.construct(first_free++, <span class="built_in">std</span>::move(s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个成员几乎是相同的。差别在于右值引用版本调用 <code>move</code> 来将其参数传递给 <code>construct</code>。如前所述，<code>construct</code> 函数使用其第二个和随后的实参的类型来确定使用哪个构造函数。由于 <code>move</code> 返回一个右值引用，传递给 <code>construct</code> 的实参类型是 <code>string&amp;&amp;</code>。因此，会使用 <code>string</code> 的移动构造函数来构造新元素。当我们调用 <code>push_back</code> 时，实参类型决定了新元素是拷贝还是移动到容器中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">StrVec vec; <span class="comment">// 空 StrVec</span></span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"some string or another"</span>;</span><br><span class="line">vec.push_back(s);      <span class="comment">// 调用 push_back(const string&amp;)</span></span><br><span class="line">vec.push_back(<span class="string">"done"</span>); <span class="comment">// 调用 push_back(string&amp;&amp;)</span></span><br></pre></td></tr></table></figure>
<p>这些调用的差别在于实参是一个左值还是一个右值（从”done”创建的临时 <code>string</code>），具体调用哪个版本据此来决定。</p>
</li>
<li><p>我们指出 <code>this</code> 的左值/右值属性的方式与定义 <code>const</code> 成员函数相同，即，在参数列表后放置一个<strong>引用限定符</strong>（reference qualifier）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Foo &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;) &amp;; <span class="comment">// 只能向可修改的左值赋值</span></span><br><span class="line">    <span class="comment">// Foo 的其他参数</span></span><br><span class="line">&#125;;</span><br><span class="line">Foo &amp;Foo::<span class="keyword">operator</span>=(<span class="keyword">const</span> Foo &amp;rhs) &amp;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行将 rhs 赋予本对象所需的工作</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>引用限定符可以是 <code>&amp;</code> 或 <code>&amp;&amp;</code>，分别指出 <code>this</code> 可以指向一个左值或右值。<strong>类似 <code>const</code> 限定符，引用限定符只能用于（非 <code>static</code>）成员函数，且必须同时出现在函数的声明和定义中。</strong></p>
<p><strong>对于 <code>&amp;</code> 限定的函数，我们只能将它用于左值；对于 <code>&amp;&amp;</code> 限定的函数，只能用于右值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Foo &amp;<span class="title">retFoo</span><span class="params">()</span></span>; <span class="comment">// 返回一个引用；retFoo 调用是一个左值</span></span><br><span class="line"><span class="function">Foo <span class="title">retVal</span><span class="params">()</span></span>;  <span class="comment">// 返回一个值；retVal 调用是一个右值</span></span><br><span class="line">Foo i, j;      <span class="comment">// i 和 j 是左值</span></span><br><span class="line">i = j;         <span class="comment">// 正确：i 是左值</span></span><br><span class="line">retFoo() = j;  <span class="comment">// 正确：retFoo() 返回一个左值</span></span><br><span class="line">retVal() = j;  <span class="comment">// 错误：retVal() 返回一个右值</span></span><br><span class="line">i = retVal();  <span class="comment">// 正确：我们可以将一个右值作为赋值操作的右侧运算对象</span></span><br></pre></td></tr></table></figure>
<p><strong>一个函数可以同时用 <code>const</code> 和引用限定。在此情况下，引用限定符必须跟随在 <code>const</code> 限定符之后</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">someMem</span><span class="params">()</span> &amp; <span class="keyword">const</span></span>;     <span class="comment">// 错误：const 限定符必须在前</span></span><br><span class="line">    <span class="function">Foo <span class="title">anotherMem</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;  <span class="comment">// 正确：const 限定符在前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>就像一个成员函数可以根据是否有 <code>const</code> 来区分其重载版本一样，引用限定符也可以区分重载版本。而且，我们可以综合引用限定符和 <code>const</code> 来区分一个成员函数的重载版本。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;&amp;</span>;      <span class="comment">// 可用于可改变的右值</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>; <span class="comment">// 可用于任何类型的 Foo</span></span><br><span class="line">    <span class="comment">// Foo 的其他成员的定义</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 本对象为右值，因此可以原址排序</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    sort(data.begin(), data.end());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 本对象是 const 或是一个左值，哪种情况我们都不能对其进行原址排序</span></span><br><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;                         <span class="comment">// 拷贝一个副本</span></span><br><span class="line">    sort(ret.data.begin(), ret.data.end()); <span class="comment">// 排序副本</span></span><br><span class="line">    <span class="keyword">return</span> ret;                             <span class="comment">// 返回副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们对一个右值执行 <code>sorted</code> 时，它可以安全地直接对 <code>data</code> 成员进行排序。<strong>对象是一个右值，意味着没有其他用户，因此我们可以改变对象。</strong> 当对一个 <code>const</code> 右值或一个左值执行 <code>sorted</code> 时，我们不能改变对象，因此就需要在排序前拷贝 <code>data</code>。</p>
<p>编译器会根据调用 <code>sorted</code> 的对象的左值/右值属性来确定使用哪个 <code>sorted</code> 版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">retVal().sorted(); <span class="comment">// retVal() 是一个右值，调用 Foo::sorted() &amp;&amp;</span></span><br><span class="line">retFoo().sorted(); <span class="comment">// retFoo() 是一个左值，调用 Foo::sorted() const &amp;</span></span><br></pre></td></tr></table></figure>
<p>当我们定义 <code>const</code> 成员函数时，可以定义两个版本，唯一的差别是一个版本有 <code>const</code> 限定而另一个没有。引用限定的函数则不一样。<strong>如果我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> &amp;</span>;</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">()</span> <span class="keyword">const</span></span>; <span class="comment">// 错误：必须加上引用限定符</span></span><br><span class="line">    <span class="comment">// Comp 是函数类型的类型别名</span></span><br><span class="line">    <span class="comment">// 此函数类型可以用来比较 int 值</span></span><br><span class="line">    <span class="keyword">using</span> Comp = <span class="keyword">bool</span>(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;);</span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(Comp *)</span></span>;       <span class="comment">// 正确：不同的参数列表</span></span><br><span class="line">    <span class="function">Foo <span class="title">sorted</span><span class="params">(Comp *)</span> <span class="keyword">const</span></span>; <span class="comment">// 正确：两个版本都没有引用限定符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>本例中声明了一个没有参数的 <code>const</code> 版本的 <code>sorted</code>，此声明是错误的。因为 <code>Foo</code> 类中还有一个无参的 <code>sorted</code> 版本，它有一个引用限定符，因此 <code>const</code> 版本也必须有引用限定符。另一方面，接受一个比较操作指针的 <code>sorted</code> 版本是没问题的，因为两个函数都没有引用限定符。</p>
<blockquote>
<p><strong>Note：如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。</strong></p>
</blockquote>
</li>
<li><p><strong>练习 13.56：</strong> 如果 <code>sorted</code> 定义如下，会发生什么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Foo <span class="title">ret</span><span class="params">(*<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret.sorted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：由于 <code>ret</code> 是左值，所以会无限递归调用左值版本的 <code>sorted</code> 方法 <code>Foo Foo::sorted() const &amp;</code>。</p>
</li>
<li><p><strong>练习 13.57：</strong> 如果 <code>sorted</code> 定义如下，会发生什么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Foo <span class="title">Foo::sorted</span><span class="params">()</span> <span class="keyword">const</span> &amp; </span>&#123; <span class="keyword">return</span> Foo(*<span class="keyword">this</span>).sorted(); &#125;</span><br></pre></td></tr></table></figure>
<p>答：使用 <code>*this</code> 拷贝构造一个 <code>Foo</code> 临时对象（右值），对该临时对象调用右值版本的 <code>sorted</code> 方法 <code>Foo Foo::sorted() &amp;&amp;</code> 并返回。</p>
</li>
</ol>
<h1 id="小结" class="heading-control"><a href="#小结" class="headerlink" title="小结"></a>小结<a class="heading-anchor" href="#小结" aria-hidden="true"></a></h1><ol>
<li><p>移动构造函数和移动赋值运算符接受一个（通常是非 <code>const</code> 的）右值引用；而拷贝版本则接受一个（通常是 <code>const</code> 的）普通左值引用。</p>
</li>
<li><p>如果一个类未声明这些操作，编译器会自动为其生成。<strong>如果这些操作未定义成删除的，它们会逐成员初始化、移动、赋值或销毁对象：合成的操作依次处理每个非 <code>static</code> 数据成员，根据成员类型确定如何移动、拷贝、赋值或销毁它。</strong></p>
</li>
<li><p>分配了内存或其他资源的类几乎总是需要定义拷贝控制成员来管理分配的资源。如果一个类需要析构函数，则它几乎肯定也需要定义移动和拷贝构造函数及移动和拷贝赋值运算符。</p>
</li>
</ol>
<h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%AC%AC%2013%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%881%EF%BC%89.png" alt="第 13 章术语表（1）"></p>
<p><img data-src="https://image.shipengx.com/%E7%AC%AC%2013%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%882%EF%BC%89.png" alt="第 13 章术语表（2）"></p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 5 章 语句</title>
    <url>/archives/c7171333.html</url>
    <content><![CDATA[<ol>
<li><p>一个表达式，末尾加上分号就变成了<strong>表达式语句</strong>（expression statement）。表达式语句的作用是执行表达式并丢弃掉求值结果。最简单的语句是<strong>空语句</strong>（null statement），空语句中只含有一个单独的分号。如果在程序的某个地方，语法上需要一条语句但是逻辑上不需要，此时应该使用空语句。一种常见的情况是，当循环的全部工作在条件部分就可以完成时，我们通常会用到空语句。例如，我们想读取输入流的内容直到遇到一个特定的值为止，除此之外什么事情也不做：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重复读入数据直至到达文件末尾或某次输入的值等于 sought</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s &amp;&amp; s != sought)</span><br><span class="line">    ;  <span class="comment">// 空语句</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用空语句时应该加上注释，从而令读这段代码的人知道该语句是有意省略。</p>
</blockquote>
<p>下面的片段包含两条语句：表达式语句和空语句。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ival = v1 + v2;;  <span class="comment">// 正确：第二个分号表示一条多余的空语句</span></span><br></pre></td></tr></table></figure>
<p>多余的空语句一般来说是无害的，但是如果在 <code>if</code>或者 <code>while</code> 的条件后面跟了一个额外的分号就可能完全改变我们的初衷。例如，下面的代码将无休止地循环下去：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 出现了糟糕的情况：额外的分号，循环体是那条空语句</span></span><br><span class="line"><span class="keyword">while</span> (iter != svec.end()) ;  <span class="comment">// while 循环体是那条空语句</span></span><br><span class="line">    ++iter;                   <span class="comment">// 递增运算不属于循环的一部分</span></span><br></pre></td></tr></table></figure>
<p>虽然从形式上来看执行递增运算的语句前面有缩进，但它并不是循环的一部分。循环条件后面跟着的分号构成了一条空语句，它才是真正的循环体。</p>
<blockquote>
<p>多余的空语句并非总是无害的。</p>
</blockquote>
</li>
<li><p><strong>复合语句</strong>（compound statement）是指用花括号括起来的（可能为空的）语句和声明的序列，复合语句也被称作<strong>块</strong>（block）。<strong>一个块就是一个作用域，在块中引入的名字只能在块内部以及嵌套在块中的子块里访问。</strong> 通常，名字在有限的区域内可见，该区域从名字定义处开始，到名字所在的（最内层）块的结尾为止。所谓空块，是指内部没有任何语句的一对花括号。空块的作用等价于空语句，空语句显然没有空块更加直白。</p>
</li>
<li><p>定义在控制结构当中的变量只在相应语句的内部可见，一旦语句结束，变量也就超出其作用范围了，如果其他代码也需要访问控制变量，则变量必须定义在语句的外部。</p>
</li>
<li><p>C++ 为解决<strong>悬垂 <code>else</code></strong>（dangling else）问题，规定 <code>else</code> 与离它最近的尚未匹配的 <code>if</code> 匹配，从而消除了程序的二义性。</p>
</li>
<li><p><code>switch</code> 语句首先对括号里的表达式求值，该表达式紧跟在关键字 <code>switch</code> 的后面，可以是一个初始化的变量声明。表达式的值转换成整数类型，然后与每个 <code>case</code> 标签的值比较。</p>
</li>
<li><p><code>case</code> 关键字和它对应的值一起被称为 <strong><code>case</code> 标签</strong>（case label）。<code>case</code> 标签必须是整型常量表达式。任何两个 <code>case</code> 标签的值不能相同，否则就会引发错误。另外，<code>default</code> 也是一种特殊的 <code>case</code> 标签。</p>
</li>
<li><p><strong>如果某个 <code>case</code> 标签匹配成功，将从该标签开始往后顺序执行所有 <code>case</code> 分支，除非程序显式地中断了这一过程，否则直到 <code>switch</code> 的结尾处才会停下来。</strong>要想避免执行后续 <code>case</code> 分支的代码，我们必须显式地告诉编译器终止执行过程。大多数情况下，在下一个 <code>case</code> 标签之前应该有一条 <code>break</code> 语句。每个 <code>case</code> 标签只能对应一个值，但是有时候我们希望两个或更多个值共享同一组操作。此时，我们就故意省略掉 <code>break</code> 语句，使得程序能够连续执行若干个 <code>case</code> 标签。例如，我们想统计所有元音字母出现的总次数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> vowelCnt = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 出现了 a、e、i、o 或 u 中的任意一个都会将 vowelCnt 的值加 1</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'o'</span>:</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        ++vowelCnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码片段中 <code>switch</code> 语句还可以写成下面这种较为简洁的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (ch)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'a'</span>: <span class="keyword">case</span> <span class="string">'e'</span>: <span class="keyword">case</span> <span class="string">'i'</span>: <span class="keyword">case</span> <span class="string">'o'</span>: <span class="keyword">case</span> <span class="string">'u'</span>:</span><br><span class="line">        ++vowelCnt;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一般不要省略 <code>case</code> 分支最后的 <code>break</code> 语句。如果没写 <code>break</code> 语句，最好加一段注释说清楚程序的逻辑。尽管 <code>switch</code> 语句不是非得在最后一个标签后面写上<code>break</code>，但是为了安全起见，最好这么做。因为这样的话，即使以后再增加新的 <code>case</code> 分支，也不用再在前面补充 <code>break</code> 语句了。</p>
</blockquote>
</li>
<li><p>如果没有任何一个 <code>case</code> 标签能匹配上 <code>switch</code> 表达式的值，程序将执行紧跟在 <strong><code>default</code>标签</strong>（default label）后面的语句。</p>
<blockquote>
<p>即使不准备在 <code>default</code> 标签下做任何工作，定义一个 <code>default</code> 标签也是有用的。其目的在于告诉程序的读者，我们已经考虑到了默认的情况，只是目前什么也没做。</p>
</blockquote>
</li>
<li><p>如果在某处一个带有初值的变量位于作用域之外，在另一处该变量位于作用域之内，则从前一处跳转到后一处的行为是非法行为。<strong>C++ 语言规定，不允许跨过变量的初始化语句直接跳转到该变量作用域内的另一个位置。如果需要为某个 <code>case</code> 分支定义并初始化一个变量，我们应该把变量定义在块内，从而确保后面的所有 <code>case</code> 标签都在变量的作用域之外。</strong></p>
</li>
<li><p>在 <strong><code>while</code> 语句</strong>（while statement）中，定义在 <code>while</code> 条件部分或者 <code>while</code> 循环体内的变量每次选代都经历从创建到销毁的过程。</p>
</li>
<li><p><strong><code>for</code> 语句</strong>中对循环控制变量的修改发生在每次循环迭代之后。</p>
</li>
<li><p><code>for</code> 语句头中定义的对象只在 <code>for</code> 循环体内可见。</p>
</li>
<li><p>和其他的声明一样，<code>for</code> 语句的 init_statement 也可以定义多个对象。但是 init_statement 只能有一条声明语句，因此，所有变量的基础类型必须相同。举个例子，我们用下面的循环把 <code>vector</code> 的元素拷贝一份添加到原来的元素后面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录 v 的大小，当到达原来的最后一个元素后结束循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(v.size()) i = <span class="number">0</span>, sz = v.size(); i != sz; ++i)</span><br><span class="line">    v.push_back(v[i]);</span><br></pre></td></tr></table></figure>
<p>在这个循环中，我们在 init_statement 里同时定义了索引 i 和循环控制变量 sz。</p>
</li>
<li><p><code>for</code> 语句头能省略掉 <code>init_statement</code>、<code>condition</code> 和 <code>expression</code> 中的任何一个（或者全部），省略掉 expression 时，就要求条件部分或者循环体必须改变迭代变量的值。</p>
</li>
<li><p><strong>范围 <code>for</code> 语句</strong>（range for statement）的语法形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>expression 表示的必须是一个序列，比如用花括号括起来的初始值列表、数组或者 <code>vector</code> 或 <code>string</code> 等类型的对象，这些类型的共同特点时拥有能返回迭代器 <code>begin</code> 和 <code>end</code> 成员。declaration 定义一个变量，序列中的每个元素都得能转换成该变量的类型，确保类型相容最简单的办法是使用 <code>auto</code> 类型说明符，这个关键字可以令编译器帮助我们指定合适的类型。<strong>如果需要对序列中的元素执行写操作，循环变量必须声明成引用类型。</strong> 每次迭代都会重新定义循环控制变量，并将其初始化成序列中的下一个值，之后才会执行 statement。</p>
</li>
<li><p>不能通过范围 <code>for</code> 语句增加 <code>vector</code> 对象（或者其他容器）的元素，因为在范围 <code>for</code> 语句中，预存了 <code>end()</code> 的值。一旦在序列中添加（删除）元素，<code>end</code> 函数的值就可能变得无效了。</p>
</li>
<li><p><code>do while</code>语句应该在括号包围起来的条件后面用一个分号表示语句结束。</p>
</li>
<li><p><strong><code>break</code> 语句</strong>（break statement）负责终止离它最近的 <code>while</code>、<code>do while</code>、<code>for</code> 或 <code>switch</code> 语句，并从这些语句之后的第一条语句开始继续执行。<strong><code>break</code> 语句只能出现在迭代语句或者 <code>switch</code> 语句内部（包括嵌套在此类循环里的语句或块的内部）。</strong><code>break</code> 语句的作用范围仅限于最近的循环或者 <code>switch</code>。</p>
</li>
<li><p><strong><code>continue</code> 语句</strong>（continue statement）终止最近的循环中的当前迭代并立即开始下一次迭代。<code>continue</code> 语句只能出现在 <code>for</code>、<code>while</code> 和 <code>do while</code> 循环的内部，或者嵌套在此类循环里的语句或块的内部。<strong>和 <code>break</code> 语句类似的是，出现在嵌套循环中的 <code>continue</code> 语句也仅作用于离它最近的循环。和 <code>break</code> 语句不同的是，只有当 <code>switch</code> 语句嵌套在迭代语句内部时，才能在 <code>switch</code> 里使用 <code>continue</code>。</strong><code>continue</code> 语句中断当前的迭代，但是仍然继续执行循环。<strong>对于 <code>while</code> 或者 <code>do while</code> 语句来说，继续判断条件的值；对于传统的 <code>for</code> 循环来说，继续执行 <code>for</code> 语句头的 <code>expression</code>；而对于范围 <code>for</code> 语句来说，则是用序列中的下一个元素初始化循环控制变量。</strong></p>
</li>
<li><p><strong><code>goto</code> 语句</strong>（goto statement）的作用是从 <code>goto</code> 语句无条件跳转到<strong>同一函数</strong>内的另一条语句。</p>
</li>
<li><p><code>goto</code> 语句的语法形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">goto</span> label;</span><br></pre></td></tr></table></figure>
<p>其中，label 是用于标识一条语句的标示符。<strong>带标签语句</strong>（labeled statement）是一种特殊的语句，在它之前有一个标示符以及一个冒号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">end: <span class="keyword">return</span>;  <span class="comment">// 带标签语句，可以作为 goto 的目标</span></span><br></pre></td></tr></table></figure>
<p><strong>标签标示符独立于变量或其他标示符的名字，因此，标签标示符可以和程序中其他实体的标示符使用同一个名字而不会相互干扰。</strong><code>goto</code> 语句和控制权转向的那条带标签的语句必须位于同一个函数之内。<strong>和 <code>switch</code> 语句类似，<code>goto</code> 语句也不能将程序的控制权从变量的作用域之外转移到作用域之内</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">    <span class="keyword">int</span> ix = <span class="number">10</span>;  <span class="comment">// 错误：goto 语句绕过了一个带初始化的变量定义</span></span><br><span class="line">end:</span><br><span class="line">    <span class="comment">// 错误：此处的代码需要使用 ix，但是 goto 语句绕过了它的声明</span></span><br><span class="line">    ix = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p>向后跳过一个已经执行的定义是合法的。跳回到变量定义之前意味着系统将销毁该变量，然后重新创建它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向后跳过一个带初始化的变量定义是合法的</span></span><br><span class="line">begin:</span><br><span class="line">    <span class="keyword">int</span> sz = get_size();</span><br><span class="line">    <span class="keyword">if</span> (sz &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">goto</span> begin;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，<code>goto</code> 语句执行后将销毁 sz。因为跳回到 begin 的动作跨过了 sz 的定义语句，所以 sz 将重新定义并初始化。</p>
</li>
<li><p>在 C++ 语言中，异常处理包括：</p>
<ul>
<li><strong><code>throw</code> 表达式</strong>（throw expression），异常检测部分使用 <code>throw</code> 表达式来表示它遇到了无法处理的问题。我们说 <code>throw</code> <strong>引发</strong>（raise）了异常。</li>
<li><strong><code>try</code> 语句块</strong>（try block），异常处理部分使用 <code>try</code> 语句块处理异常。<code>try</code> 语句块以关键字 <code>try</code> 开始，并以一个或多个 <strong><code>catch</code> 子句</strong>（catch clause）结束。<code>try</code> 语句块中代码抛出的异常通常会被某个 <code>catch</code> 子句处理。因为<code>catch</code>子句“处理”异常，所以它们也被称作<strong>异常处理代码</strong>（exception handler）。</li>
<li>一套<strong>异常类</strong>（exception class），用于在 <code>throw</code> 表达式和相关的 <code>catch</code> 子句之间传递异常的具体信息。<br><br></li>
</ul>
</li>
<li><p>程序的异常检测部分使用 <code>throw</code> 表达式引发一个异常。<code>throw</code> 表达式包含关键字 <code>throw</code> 和紧随其后的一个表达式，其中表达式的类型就是抛出的异常类型。<code>throw</code> 表达式后面通常紧跟一个分号，从而构成一条表达式语句。</p>
</li>
<li><p>类型 <code>runtime_error</code> 是标准库异常类型的一种，定义在 <code>stdexcept</code> 头文件中。必须初始化<code>runtime_error</code> 的对象，方式是给它提供一个 <code>string</code> 对象或者一个 C 风格的字符串，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> runtime_error(<span class="string">"Data must refer to same ISBN"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>try</code> 语句块的通用语法形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">    program-statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (exception-declaration)</span><br><span class="line">&#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (exception-declaration)</span><br><span class="line">&#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>跟在 <code>try</code> 块之后的是一个或多个 <code>catch</code> 子句。<code>catch</code> 子句包括三部分：关键字 <code>catch</code>、括号内一个（可能未命名的）对象的声明（称作<strong>异常声明</strong>，exception declaration）以及一个块。当选中了某个 <code>catch</code> 子句处理异常之后，执行与之对应的块。<code>catch</code> 一旦完成，程序跳转到 <code>try</code> 语句块最后一个 <code>catch</code> 子句之后的那条语句继续执行。<strong><code>try</code> 语句块内声明的变量在外部无法访问，特别是在 <code>catch</code> 子句内也无法访问。</strong></p>
</li>
<li><p>每个标准库异常类都定义了名为 <code>what</code> 的成员函数，这些函数没有参数，返回值是 C 风格字符串（即 <code>const char*</code>）。其中，<code>runtime_error</code> 的 <code>what</code> 成员返回的是初始化一个具体对象时所用的 <code>string</code> 对象的副本。</p>
</li>
<li><p>寻找处理代码的过程与函数调用链刚好相反。当异常被抛出时，首先搜索抛出该异常的函数。如果没找到匹配的 <code>catch</code> 子句，终止该函数，并在调用该函数的函数中继续寻找。如果还是没有找到匹配的 <code>catch</code> 子句，这个新的函数也被终止，继续搜索调用它的函数。以此类推，沿着程序的执行路径逐层回退，直到找到适当类型的 <code>catch</code> 子句为止。如果最终还是没能找到任何匹配的 <code>catch</code> 子句，程序转到名为 <strong><code>terminate</code></strong> 的标准库函数。该函数的行为与系统有关，一般情况下，执行该函数将导致程序非正常退出。对于那些没有任何 <code>try</code> 语句块定义的异常，也按照类似的方式处理：毕竟，没有 <code>try</code> 语句块也就意味着没有匹配的 <code>catch</code> 子句。如果一段程序没有 <code>try</code> 语句块且发生了异常，系统会调用 <code>terminate</code> 函数并终止当前程序的执行。</p>
</li>
<li><p>C++ 标准库定义了一组类，用于报告标准库函数遇到的问题，它们分别定义在 4 个头文件中：</p>
<ul>
<li><code>exception</code> 头文件定义了最通用的异常类 <code>exception</code>。它只报告异常的发生，不提供任何额外信息。</li>
<li><code>stdexcept</code> 头文件定义了几种常用的异常类，如下表所示。</li>
<li><code>new</code> 头文件定义了 <code>bad_alloc</code> 异常类型。</li>
<li><code>type_info</code> 头文件定义了 <code>bad_cast</code> 异常类型。<br><br></li>
</ul>
<table>
<tbody>
<tr>
    <td colspan="2"><b><center>&lt;stdexcept&gt;定义的异常类</center></b></td>
</tr>
<tr>
    <td>exception</td>
    <td>最常见的问题</td>
</tr>
<tr>
    <td>runtime_error</td>
    <td>只有在运行时才能检测出的问题</td>
</tr>
<tr>
    <td>range_error</td>
    <td>运行时错误：生成的结果超出了有意义的值域范围</td>
</tr>
<tr>
    <td>overflow_error</td>
    <td>运行时错误：计算上溢</td>
</tr>
<tr>
    <td>underflow_error</td>
    <td>运行时错误：计算下溢</td>
</tr>
<tr>
    <td>logic_error</td>
    <td>程序逻辑错误</td>
</tr>
<tr>
    <td>domain_error</td>
    <td>逻辑错误：参数对应的结果值不存在</td>
</tr>
<tr>
    <td>invalid_argument</td>
    <td>逻辑错误：无效参数</td>
</tr>
<tr>
    <td>length_error</td>
    <td>逻辑错误：试图创建一个超出该类型最大长度的对象</td>
</tr>
<tr>
    <td>out_of_range</td>
    <td>逻辑错误：使用一个超出有效范围的值</td>
</tr>
</tbody>
</table>
</li>
<li><p>标准库异常类只定义了几种运算，包括创建或接贝异常类型的对象，以及为异常类型的对象赋值。只能以默认初始化的方式初始化 <code>exception</code>、<code>bad_alloc</code> 和 <code>bad_cast</code> 对象，不允许为这些对象提供初始值。其他异常类型的行为则恰好相反：应该使用 <code>string</code> 对象或者 C 风格字符串初始化这些类型的对象，但是不允许使用默认初始化的方式。当创建此类对象时，必须提供初始值，该初始值含有错误相关的信息。异常类型只定义了一个名为 <code>what</code> 的成员函数，该函数没有任何参数，返回值是一个指向 C 风格字符串的 <code>const char*</code>。该字符串的目的是提供关于异常的一些文本信息。<code>what</code> 函数返回的 C 风格字符串的内容与异常对象的类型有关。如果异常类型有一个字符串初始值，则 <code>what</code> 返回该字符串。对于其他无初始值的异常类型来说，<code>what</code> 返回的内容由编译器决定。</p>
</li>
<li><p>编写一段程序，从标准输入读取两个整数，当第二个数是 0 时抛出异常，使用 <code>try</code> 语句块捕获异常，<code>catch</code> 子句为用户输出一条提示信息，询问是否输入新数并重新执行 <code>try</code> 语句块的内容。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a, b;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::invalid_argument <span class="title">err</span><span class="params">(<span class="string">"Wrong input for the 2nd argument!"</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == b)</span><br><span class="line">            <span class="keyword">throw</span> err;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"a/b = "</span> &lt;&lt; a / b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::invalid_argument &amp;e)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; e.what() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Try again? Enter y or n"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">char</span> c;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">cin</span> || <span class="string">'n'</span> == c)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 2 章 变量和基本类型</title>
    <url>/archives/e005f4cb.html</url>
    <content><![CDATA[<ol>
<li><p>一些语言，如 Smalltalk 和 Python 等，在程序运行时检查数据类型；与之相反，C++ 是一种<strong>静态数据类型语言</strong>，它的类型检查发生在编译时。因此，编译器必须知道程序中每一个变量对应的数据类型。</p>
</li>
<li><p>C++ 标准规定的各种算数类型数据尺寸的最小值：</p>
<table>
<thead>
<tr>
    <td><b>类型</b></td>
    <td><b>含义</b></td>
    <td><b>最小尺寸</b></td>
</tr>
</thead>
<tbody>
<tr>
    <td>bool</td>
    <td>布尔类型</td>
    <td>未定义</td>
</tr>
<tr>
    <td>char</td>
    <td>字符</td>
    <td>8位</td>
</tr>
<tr>
    <td>wchar_t</td>
    <td>宽字符</td>
    <td>16位</td>
</tr>
<tr>
    <td>char16_t</td>
    <td>Unicode字符</td>
    <td>16位</td>
</tr>
<tr>
    <td>char32_t</td>
    <td>Unicode字符</td>
    <td>32位</td>
</tr>
<tr>
    <td>short</td>
    <td>短整型</td>
    <td>16位</td>
</tr>
<tr>
    <td>int</td>
    <td>整型</td>
    <td>16位</td>
</tr>
<tr>
    <td>long</td>
    <td>长整型</td>
    <td>32位</td>
</tr>
<tr>
    <td>long long</td>
    <td>长整型</td>
    <td>64位</td>
</tr>
<tr>
    <td>float</td>
    <td>单精度浮点数</td>
    <td>6位有效数字</td>
</tr>
<tr>
    <td>double</td>
    <td>双精度浮点数</td>
    <td>10位有效数字</td>
</tr>
<tr>
    <td>long double</td>
    <td>扩展精度浮点数</td>
    <td>10位有效数字</td>
</tr>
</tbody>
</table>
</li>
<li><p>一个 <code>char</code> 的大小和一个机器字节一样。</p>
</li>
<li><p>C++ 语言规定一个 <code>int</code> 至少和一个 <code>short</code> 一样大，一个 <code>long</code> 至少和一个 <code>int</code> 一样大，一个 <code>long long</code> 至少和一个 <code>long</code> 一样大。其中，数据类型 <code>long long</code> 是在 C++11 中新定义的。</p>
</li>
<li><p>计算机以比特序列存储数据，每个比特非 0 即 1。大多数计算机以 2 的整数次幂个比特作为块来处理内存，可寻址的最小内存块称为“字节（byte）”，存储的基本单元称为“字（word）”，它通常由几个字节组成。在 C++语言中，一个字节要至少能容纳机器基本字符集中的字符。大多数机器的字节由 8 比特构成，字则由 32 或 64 比特构成，也就是 4 或 8 字节。大多数计算机将内存中的每个字节与一个数字（被称为“地址（address）”）关联起来。</p>
</li>
<li><p>浮点型可表示单精度、双精度和扩展精度值。C++ 标准指定了一个浮点数有效位数的最小值，然而大多数编译器都实现了更高的精度。通常，<code>float</code> 以 1 个字（32 比特）来表示，<code>doub1e</code> 以 2 个字（64 比特）来表示，<code>long double</code> 以 3 或 4 个字（96 或 128 比特）来表示。一般来说，类型 <code>float</code> 和 <code>double</code> 分别有 7 和 16 个有效位；类型 <code>long doub1e</code> 则常常被用于有特殊浮点需求的硬件，它的具体实现不同，精度也各不相同。</p>
</li>
<li><p>与其他整型不同，字符型被分为了三种：<code>char</code>、<code>signed char</code> 和 <code>unsigned char</code>。特别需要注意的是：类型 <code>char</code> 和类型 <code>signed char</code> 并不一样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和无符号的。类型 <code>char</code> 实际上会表现为上述两种形式中的一种，具体是哪种由编译器决定。无符号类型中所有比特都用来存储值，例如，8 比特的 <code>unsigned char</code> 可以表示 0 至 255 区间内的值。C++标准并没有规定带符号类型应如何表示，但是约定了在表示范围内正值和负值的量应该平衡。因此，8 比特的 <code>signed char</code> 理论上应该可以表示-127 至 127 区间内的值，大多数现代计算机将实际的表示范围定为-128 至 127。</p>
</li>
<li><p>在算术表达式中不要使用 <code>char</code> 或 <code>bool</code>，只有在存放字符或布尔值时才使用它们。因为<strong>类型 <code>char</code> 在一些机器上是有符号的，而在另一些机器上又是无符号的</strong>，所以如果使用 <code>char</code> 进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定它的类型是 <code>signed char</code> 或者 <code>unsigned char</code>。</p>
</li>
<li><p>执行浮点数运算选用 <code>double</code>，因为 <code>float</code> 通常精度不够而且双精度浮点数和单精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单精度还快。<code>long double</code> 提供的精度在一般情况下是没有必要的，况且它带来的运行时消耗也不容忽视。</p>
</li>
<li><p>观察下述代码，<code>c</code> 值为多少：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> c = <span class="number">-9</span>;</span><br></pre></td></tr></table></figure>
<p>首先，要清楚数据在计算机中以“补码”进行存储这一客观事实；其次，还要看机器的<strong>大小端模式</strong>：对于小端模式，为 247；对于大端模式，为 255。</p>
</li>
<li><p>类型所能表示的值的范围决定了转换的过程：</p>
<ul>
<li>当把一个浮点数赋给整数类型时，进行了近似处理。结果值将仅保留浮点数中小数点之前的部分；</li>
<li>当把一个整数值赋给浮点类型时，小数部分记为 0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失；</li>
<li><strong>当赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。</strong>例如，8 比特大小的 <code>unsigned char</code> 可以表示 0 至 255 区间内的值，如果我们赋了一个区间以外的值，则实际的结果是该值对 256 取模后所得的余数。因此，把-1 赋给 8 比特大小的 <code>unsigned char</code> 所得的结果是 255；</li>
<li>当赋给带符号类型一个超出它表示范围的值时，结果是未定义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成垃圾数据。<br><br></li>
</ul>
</li>
<li><p><strong>当一个算术表达式中既有无符号数又有 <code>int</code> 值时，那个 <code>int</code> 值就会转换成无符号数。</strong>把 <code>int</code> 转换成无符号数的过程和把 <code>int</code> 直接赋给无符号变量等效。观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i + i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出-84</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u + i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 如果int占32位，输出4294967264</span></span><br></pre></td></tr></table></figure>
<p>在第一个输出表达式里，两个（负）整数相加并得到了期望的结果。在第二个输出表达式里，相加前首先把整数-42 转换成无符号数。<strong>把负数转换成无符号数类似于直接给无符号数赋一个负值，结果等于这个负数加上无符号数的模。</strong><br>当从无符号数中减去一个值时，不管这个值是不是无符号数，我们都必须确保结果不能是一个负值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> u1 = <span class="number">42</span>, u2 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u1 - u2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 输出32</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u2 - u1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 结果是取模后的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>无符号数不会小于 0 这一事实同样关系到循环的写法，下述代码片段存在死循环的 bug：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> u = <span class="number">10</span>; u &gt;= <span class="number">0</span>; --u)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>当 u 等于 0 时迭代输出 0，然后继续执行 <code>for</code> 语句里的表达式。表达式- -u 从 u 当中减去 1，得到的结果-1 并不满足无符号数的要求，此时像所有表示范围之外的其他数字一样，-1 被自动地转换成一个合法的无符号数。假设 <code>int</code> 类型占 32 位，则当 u 等于 0 时，- -u 的结果将会是 4294967295，即$-1 + 2^{32}$。</p>
</li>
<li><p><strong>切勿混用带符号类型和无符号类型</strong>。如果表达式里既有带符号类型又有无符号类型，当带符号类型取值为负时会出现异常结果，这是因为带符号数会自动地转换成无符号数。例如，在一个形如 a*b 的式子中，如果 a=-1，b=1，而且 a 和 b 都是 <code>int</code>，则表达式的值显然为-1。然而，如果 a 是<code>int</code>，而 b 是 <code>unsigned</code>，则结果须视在当前机器上 <code>int</code> 所占位数而定。当 <code>int</code> 占 32 位时，结果是 4294967295。</p>
</li>
<li><p>可以将整数型字面值写作十进制数、八进制数或十六进制数的形式。以 0 开头的整数代表八进制数，以 0x 或 0X 开头的代表十六进制数。例如，能用下面的任意一种形式来表示数值 20：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20 &#x2F;*十进制*&#x2F;    024 &#x2F;*八进制*&#x2F;    0x14 &#x2F;*十六进制*&#x2F;</span><br></pre></td></tr></table></figure>
<p>默认情况下，十进制字面值是带符号数，八进制和十六进制字面值既可能是带符号的也可能是无符号的。十进制字面值的类型是 <code>int</code>、<code>long</code> 和 <code>long long</code> 中尺寸最小的那个（例如，三者当中最小是 <code>int</code>），当然前提是这种类型要能容纳下当前的值。八进制和十六进制字面值的类型是能容纳其数值的<code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code> 和 <code>unsigned long long</code> 中的尺寸最小者。如果一个字面值连与之关联的最大的数据类型都放不下，将产生错误。类型 <code>short</code> 没有对应的字面值。</p>
</li>
<li><p>默认的，浮点型字面值是 <code>double</code> 类型。</p>
</li>
<li><p>字符串字面值的类型实际上是由常量字符构成的数组（array），编译器在每个字符串的结尾处添加一个空字符（’\0’），因此，字符串字面值的实际长度要比它的内容多 1。例如，字面值’A’表示的就是单独的字符 A，而字符串”A”则代表了一个字符的数组，该数组包含两个字符：一个是字母 A、另一个是空字符。</p>
</li>
<li><p>泛化的转义序列，其形式是\x 后紧跟 1 个或多个十六进制数字，或者\后紧跟 1 个、2 个或 3 个八进制数字，其中数字部分表示的是字符对应的数值。<strong>如果反斜线\后面跟着的八进制数字超过 3 个，只有前 3 个数字与\构成转义序列。</strong>例如，”\1234”表示 2 个字符，即八进制数 123 对应的字符以及字符 4。相反，\x 要用到后面跟着的所有数字，例如，”\x1234”表示一个 16 位的字符，该字符由这 4 个十六进制数所对应的比特唯一确定。因为大多数机器的 <code>char</code> 型数据占 8 位，所以上面这个例子可能会报错。</p>
</li>
<li><p>通过添加如下表所列的前缀或后缀，可以改变整型、浮点型和字符型字面值的默认类型：</p>
<table>
<thead>
<tr>
    <td colspan="4"><b>字符和字符串字面值</b></td>
</tr>
</thead>
<tbody>
<tr>
    <td><b>前缀</b></td>
    <td><b>含义</b></td>
    <td colspan="2"><b>类型</b></td>
</tr>
<tr>
    <td>u</td>
    <td>Unicode 16字符</td>
    <td colspan="2">char16_t</td>
</tr>
<tr>
    <td>U</td>
    <td>Unicode 32字符</td>
    <td colspan="2">char32_t</td>
</tr>
<tr>
    <td>L</td>
    <td>宽字符</td>
    <td colspan="2">wchar_t</td>
</tr>
<tr>
    <td>u8</td>
    <td>UTF-8（仅用于字符串字面常量）</td>
    <td colspan="2">char</td>
</tr>
<tr>
    <td colspan="2"><b>整型字面值</b></td>
    <td colspan="2"><b>浮点型字面值</b></td>
</tr>
<tr>
    <td><b>后缀</b></td>
    <td><b>最小匹配类型</b></td>
    <td><b>后缀</b></td>
    <td><b>类型</b></td>
</tr>
<tr>
    <td>u 或 U</td>
    <td>unsigned</td>
    <td>f 或F</td>
    <td>float</td>
</tr>
<tr>
    <td>l 或 L</td>
    <td>long</td>
    <td>l或L</td>
    <td>long double</td>
</tr>
<tr>
    <td>ll或LL</td>
    <td>long long</td>
    <td></td>
    <td></td>
</tr>
</tbody>
</table>

<p>示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="string">L'a'</span>      <span class="comment">// 宽字符型字面值，类型是wchar_t</span></span><br><span class="line"><span class="string">u8"hi！"</span>  <span class="comment">// utf-8字符串字面值（utf-8用8位编码一个Unicode字符）</span></span><br><span class="line"><span class="number">42U</span>LL     <span class="comment">// 无符号整型字面值，类型是unsigned 1ong 1ong</span></span><br><span class="line"><span class="number">1E-3</span>F     <span class="comment">// 单精度浮点型字面值，类型是float</span></span><br><span class="line"><span class="number">3.14159L</span>  <span class="comment">// 扩展精度浮点型字面值，类型是1ong double</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在 C++ 语言中，初始化和赋值是两个完全不同的操作。初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而以一个新值来替代。</p>
</li>
<li><p>要想定义一个名为 units sold 的 <code>int</code> 变量并初始化为 0，以下的 4 条语句都可以做到这一点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> units sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> units sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>作为 C++11 新标准的一部分，用花括号来初始化变量得到了全面应用，这种初始化的形式被称为<strong>列表初始化</strong>。现在，无论是初始化对象还是某些时候为对象赋新值，都可以使用这样一组由花括号括起来的初始值了。<strong>当用于内置类型的变量时，这种初始化形式有一个重要特点：如果我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错</strong>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> double1d = <span class="number">3.1415926536</span>;</span><br><span class="line"><span class="keyword">int</span> a&#123;<span class="number">1</span>d&#125;, b = &#123;<span class="number">1</span>d&#125;;  <span class="comment">// 错误：转换未执行，因为存在丢失信息的危险</span></span><br><span class="line">int c(1d), d = 1d;    // 正确：转换执行，且确实丢失了部分值</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。<strong>定义于任何函数体之外的变量（全局变量）被初始化为 0。</strong>定义在函数体内部的内置类型变量（局部变量）将不被初始化（uninitialized）。一个未被初始化的内置类型变量的值是未定义的，如果试图拷贝或以其他形式访问此类值将引发错误。定义于函数体内的内置类型的对象如果没有初始化，则其值未定义。类的对象如果没有显式地初始化，则其值由类确定。</p>
</li>
<li><p>绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一个合适的默认值。<strong><code>string</code> 类规定如果没有指定初值则生成一个空串。</strong>一些类要求每个对象都显式初始化，此时如果创建了一个该类的对象而未对其做明确的初始化操作，将引发错误。</p>
</li>
<li><p>下列变量的初值分别是什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> global_str;     <span class="comment">// 空串</span></span><br><span class="line"><span class="keyword">int</span> global_int;             <span class="comment">// 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local_int;          <span class="comment">// 未知</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> local_str;  <span class="comment">// 空串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为了允许把程序拆分成多个逻辑部分来编写，C++语言支持<strong>分离式编译</strong>（separate compilation）机制，该机制允许将程序分割为若干个文件，每个文件可被独立编译。为了支持分离式编译，C++ 语言将声明和定义区分开来。<strong>声明（declaration）使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明。而定义（definition）负责创建与名字关联的实体。</strong>变量声明规定了变量的类型和名字，在这一点上定义与之相同。但是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。如果想声明一个变量而非定义它，就在变量名前添加关键字 <code>extern</code>，而且不要显式地初始化变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;  <span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">int</span> j;         <span class="comment">// 变量定义</span></span><br></pre></td></tr></table></figure>
<p><strong>任何包含了显式初始化的声明即成为定义。</strong>我们能给由 <code>extern</code> 关键字标记的变量赋一个初始值，但是这么做也就抵消了 <code>extern</code> 的作用。<code>extern</code> 语句如果包含初始值就不再是声明，而变成定义了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> pi = <span class="number">3.1416</span>;  <span class="comment">// 变量定义</span></span><br></pre></td></tr></table></figure>
<p><strong>在函数体内部，如果试图初始化一个由 <code>extern</code> 关键字标记的变量，将引发错误。</strong></p>
</li>
<li><p><strong>变量能且只能被定义一次，但是可以被多次声明。</strong>变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却绝对不能重复定义。指出下面的语句是声明还是定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ix = <span class="number">1024</span>;  <span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">int</span> iy;                <span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> iz;         <span class="comment">// 声明</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++ 是一种<strong>静态类型</strong>（statically typed）语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为<strong>类型检查</strong>（type checking）。</p>
</li>
<li><p>用户自定义的标识中不能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定义在函数体外的标识符不能以下画线开头。</p>
</li>
<li><p><strong>作用域</strong>（scope）是程序的一部分，在其中名字有其特定的含义。C++ 语言中大多数作用域都以花括号分隔。<strong>同一个名字在不同的作用域中可能指向不同的实体。名字的有效区域始于名字的声明语句，以声明语句所在的作用域末端为结束。</strong><code>main</code> 拥有全局作用域（global scope）。一旦声明之后，全局作用域内的名字在整个程序的范围内都可使用。作用域能彼此包含，被包含（或者说被嵌套）的作用域称为<strong>内层作用域</strong>（inner scope），包含着别的作用域的作用域称为外层作用域（outer scope）。作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访问该名字。同时，<strong>允许在内层作用域中重新定义外层作用域已有的名字。</strong>观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> reused = <span class="number">42</span>;  <span class="comment">// 全局变量reused</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; reused &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 使用全局变量reused，输出42</span></span><br><span class="line">    <span class="keyword">int</span> reused = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; reused &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    <span class="comment">// 使用局部变量reused，输出0</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ::reused &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 显示访问全局变量reused，输出42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局作用域本身并没有名字，所以当作用域操作符的左侧为空时，向全局作用域发出请求获取作用域操作符右侧名字对应的变量。<strong>如果函数有可能用到某全局变量，则不宜再定义一个同名的局部变量。</strong></p>
</li>
<li><p><strong>引用</strong>（reference）为对象起了另外一个名字，引用类型引用（refers to）另外一种类型。通过将声明符写成 <code>&amp;d</code> 的形式来定义引用类型，其中 d 是声明的变量名。一般在初始化变量时，初始值会被拷贝到新建的对象中。然而定义引用时，程序把引用和它的初始值<strong>绑定</strong>（bind）在一起，而不是将初始值拷贝给引用。<strong>一旦初始化完成，引用将和它的初始值对象一直绑定在一起。因为无法令引用重新绑定到另外一个对象，因此引用必须初始化。</strong></p>
</li>
<li><p>引用并非对象，相反的，它只是为一个已经存在的对象所起的另外一个名字。定义了一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的。为引用赋值，实际上是把值赋给了与引用绑定的对象。获取引用的值，实际上是获取了与引用绑定的对象的值。同理，以引用作为初始值，实际上是以与引用绑定的对象作为初始值。因为引用本身不是一个对象，所以不能定义引用的引用。</p>
</li>
<li><p>除去两种例外情况（后面将会介绍），引用的类型都要和与之绑定的对象严格匹配。而且，引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</p>
</li>
<li><p>下面的语句哪些合法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r1 = i;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">0</span>, &amp;r2 = d;</span><br><span class="line"></span><br><span class="line">r2 = <span class="number">3.14159</span>;  <span class="comment">// a</span></span><br><span class="line">r2 = r1;       <span class="comment">// b</span></span><br><span class="line">i = r2;        <span class="comment">// c</span></span><br><span class="line">r1 = d;        <span class="comment">// d</span></span><br></pre></td></tr></table></figure>
<p>四条语句均合法，但编译器会提示语句 c 和语句 d 存在数据丢失风险。</p>
</li>
<li><p>指针与引用相比有很多不同点：</p>
<ul>
<li>指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以先后指向几个不同的对象；</li>
<li>指针无须在定义时赋初值。和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。<br><br></li>
</ul>
</li>
<li><p><strong>引用不是对象，没有实际地址，所以不能定义指向引用的指针。</strong>除去两种例外情况（后面将会介绍），所有指针的类型都要和它所指向的对象严格匹配。在声明语句中指针的类型实际上被用于指定它所指向对象的类型，所以二者必须匹配。如果指针指向了一个其他类型的对象，对该对象的操作将发生错误。</p>
</li>
<li><p>对指针解引用会得出所指的对象，因此如果给解引用的结果赋值，实际上也就是给指针所指的对象赋值。解引用操作仅适用于那些确实指向了某个对象的有效指针。</p>
</li>
<li><p><strong>空指针</strong>（null pointer）不指向任何对象，在试图使用一个指针之前代码可以首先检查它是否为空。以下列出几个生成空指针的方法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;  <span class="comment">// 需要首先#include cstdlib</span></span><br></pre></td></tr></table></figure>
<p>得到空指针最直接的办法就是用字面值 <code>nullptr</code> 来初始化指针，这也是 C++11 新标准新引入的一种方法。<code>nullptr</code> 是一种特殊类型的字面值，它可以被转换成任意其他的指针类型。过去的程序还会用到一个名为 <code>NULL</code> 的<strong>预处理变量</strong>（preprocessor variable）来给指针赋值，这个变量在头文件 cstdlib 中定义，它的值就是 0。预处理变量不属于命名空间 <code>std</code>，它由预处理器负责管理，因此我们可以直接使用预处理变量而无须在前面加上 <code>std::</code>。当用到一个预处理变量时，预处理器会自动地将它替换为实际值，因此用 <code>NULL</code> 初始化指针和用 0 初始化指针是一样的。在新标准下，现在的 C++程序最好使用 <code>nullptr</code>，同时尽量避免使用 <code>NULL</code>。</p>
</li>
<li><p>建议初始化所有的指针，并且在可能的情况下，尽量等定义了对象之后再定义指向它的指针。如果实在不清楚指针应该指向何处，就把它初始化为 <code>nullptr</code> 或者 0。</p>
</li>
<li><p>一旦定义了引用，就无法令其再绑定到另外的对象，之后每次使用这个引用都是访问它最初绑定的那个对象。</p>
</li>
<li><p><code>void*</code> 是一种特殊的指针类型，可用于存放任意对象的地址。</p>
</li>
<li><p>引用本身不是一个对象，因此不能定义指向引用的指针。但指针是对象，所以存在对指针的引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;       <span class="comment">// p是一个int型指针</span></span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;  <span class="comment">// r是一个对指针p的引用</span></span><br><span class="line">r = &amp;i;       <span class="comment">// r引用了一个指针，因此给r赋值&amp;i就是令p指向i</span></span><br><span class="line">*r = <span class="number">0</span>;       <span class="comment">// 解引用r得到i，也就是p指向的对象，将i的值改为0</span></span><br></pre></td></tr></table></figure>
<p>要理解 r 的类型到底是什么，最简单的办法是<strong>从右向左阅读</strong>r 的定义。离变量名最近的符号（此例中是 <code>&amp;r</code> 的符号 &amp;）对变量的类型有最直接的影响，因此 r 是一个引用。声明符的其余部分用以确定 r 引用的类型是什么，此例中的符号*说明 r 引用的是一个指针。最后，声明的基本数据类型部分指出 r 引用的是一个 <code>int</code> 指针。</p>
</li>
<li><p><strong><code>const</code> 对象一旦创建后其值就不能再改变，所以 <code>const</code> 对象必须初始化。</strong> 一如既往，初始值可以是任意复杂的表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = get_size();  <span class="comment">// 正确：运行时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> j = <span class="number">42</span>;          <span class="comment">// 正确：编译时初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> k;               <span class="comment">// 错误：k是一个未经初始化的常量</span></span><br></pre></td></tr></table></figure>
<p>只能在 <code>const</code> 类型的对象上执行不改变其内容的操作。例如，<code>const int</code> 和普通的 <code>int</code> 一样都能参与算术运算，也都能转换成一个布尔值，等等。在不改变 <code>const</code> 对象的操作中还有一种是初始化，<strong>如果利用一个对象去初始化另外一个对象，则它们是不是 <code>const</code> 都无关紧要</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br><span class="line"><span class="keyword">int</span> j = ci;</span><br></pre></td></tr></table></figure>
<p>尽管 ci 是整型常量，但无论如何 ci 中的值还是一个整型数。ci 的常量特征仅仅在执行改变 ci 的操作时才会发挥作用。当用 ci 去初始化时，根本无须在意 ci 是不是一个常量。拷贝一个对象的值并不会改变它，一旦拷贝完成，新的对象就和原来的对象没什么关系了。</p>
</li>
<li><p>默认情况下，<code>const</code> 对象被设定为仅在文件内有效。当多个文件中出现了同名的 <code>const</code> 变量时，其实等同于在不同文件中分别定义了独立的变量。<br>某些时候有这样一种 <code>const</code> 变量，它的初始值不是一个常量表达式，但又确实有必要在文件间共享。这种情况下，我们不希望编译器为每个文件分别生成独立的变量。相反，我们想让这类 <code>const</code> 对象像其他（非常量）对象一样工作，也就是说，只在一个文件中定义 <code>const</code>，而在其他多个文件中声明并使用它。解决的办法是，对于 <code>const</code> 变量不管是声明还是定义都添加 <code>extern</code> 关键字，这样只需定义一次就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// file1.cc定义并初始化了一个常量，该常量能被其他文件访问</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize = fcn();</span><br><span class="line"><span class="comment">// file 1.h头文件</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> bufSize;  <span class="comment">// 与file 1.cc中定义的bufSize是同一个</span></span><br></pre></td></tr></table></figure>
<p><strong>如果想在多个文件之间共享 <code>const</code> 对象，必须在变量的定义之前添加 <code>extern</code> 关键字。</strong></p>
</li>
<li><p>可以把引用绑定到 <code>const</code> 对象上，就像绑定到其他对象上一样，我们称之为<strong>对常量的引用</strong>（reference to const）。<strong>与普通引用不同的是，对常量的引用不能被用作修改它所绑定的对象。</strong></p>
</li>
<li><p>常引用常用于函数传参，有两个优点：节省资源开销和确保传入数据安全（不可更改）。<strong>常量引用可以绑定非常量对象，但不允许通过常量引用去修改所引用的非常量对象的值。</strong>例如，对于形参为常量引用的函数，我们传入的往往是非常量；<strong>普通引用（非常量引用）不能绑定常量对象</strong>。</p>
</li>
<li><p>前文曾提到，引用的类型必须与其所引用对象的类型一致，但是有两个例外。第一种例外情况就是<strong>在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。</strong> 尤其，<strong>允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;       <span class="comment">// 允许将const int&amp;绑定到一个普通int对象上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;      <span class="comment">// 正确：r2是一个常量引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;  <span class="comment">// 正确：r3是一个常量引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>;        <span class="comment">// 错误：r4是一个普通的非常量引用</span></span><br></pre></td></tr></table></figure>
<p>要想理解这种例外情况的原因，最简单的办法是弄清楚当一个常量引用被绑定到另外一种类型上时到底发生了什么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ri = dval;</span><br></pre></td></tr></table></figure>
<p>此处 ri 引用了一个 <code>int</code> 型的数。对 ri 的操作应该是整数运算，但 dval 却是一个双精度浮点数而非整数。因此为了确保让 ri 绑定一个整数，编译器把上述代码变成了如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> temp = dval;  <span class="comment">// 由双精度浮点数生成一个临时的整型常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ri = temp;   <span class="comment">// 让ri绑定这个临时量</span></span><br></pre></td></tr></table></figure>
<p>在这种情况下，ri 绑定了一个<strong>临时量</strong>（temporary）对象。<strong>所谓临时量对象就是当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。</strong>常常把临时量对象简称为临时量。</p>
</li>
<li><p><strong>对 <code>const</code> 的引用可能引用一个并非 <code>const</code> 的对象。</strong>必须认识到，<strong>常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是一个常量未作限定。因为对象也可能是个非常量，所以允许通过其他途径改变它的值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;rl = i;        <span class="comment">// 引用ri绑定对象i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; r2 = i;  <span class="comment">// r2也绑定对象i，但是不允许通过r2修改i的值</span></span><br><span class="line">r1 = <span class="number">0</span>;             <span class="comment">// r1并非常量引用，i的值修改为0</span></span><br><span class="line">r2 = <span class="number">0</span>;             <span class="comment">// 错误：r2是一个常量引用</span></span><br></pre></td></tr></table></figure>
<p>r2 绑定（非常量）整数 i 是合法的行为。然而，不允许通过 r2 修改 i 的值。尽管如此，i 的值仍然允许通过其他途径修改，既可以直接给 i 赋值，也可以通过像 r1 一样绑定到 i 的其他引用来修改。</p>
</li>
<li><p><strong>指向常量的指针</strong>（pointer to const）不能用于改变其所指对象的值。<strong>要想存放常量对象的地址，只能使用指向常量的指针</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;    <span class="comment">// pi是个常量，它的值不能改变</span></span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;         <span class="comment">// 错误：ptr是一个普通指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;  <span class="comment">// 正确：cptr可以指向一个双精度常量</span></span><br><span class="line">*cptr = <span class="number">42</span>;                <span class="comment">// 错误：不能给*cptr赋值</span></span><br></pre></td></tr></table></figure>
<p>前文曾提到，指针的类型必须与其所指对象的类型一致，但是有两个例外。第二种例外情况是<strong>允许令一个指向常量的指针指向一个非常量对象</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;  <span class="comment">// dval是一个双精度浮点数，它的值可以改变</span></span><br><span class="line">cptr = &amp;dval;        <span class="comment">// 正确：但是不能通过cptr改变dval的值</span></span><br></pre></td></tr></table></figure>
<p>和常量引用一样，指向常量的指针也没有规定其所指的对象必须是一个常量。<strong>所谓指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定那个对象的值不能通过其他途径改变。所谓指向常量的指针或引用，不过是指针或引用“自以为是”罢了，它们觉得自己指向了常量，所以自觉地不去改变所指对象的值。</strong></p>
</li>
<li><p><strong>要区分开常量指针、指向常量的指针和常量引用这些概念。</strong></p>
</li>
<li><p><strong>常量指针</strong>（const pointer）必须初始化（因为常量指针本身是一个常量），而且一旦初始化完成，则它的值（也就是存放在指针中的那个地址）就不能再改变了。把*放在 <code>const</code> 关键字之前用以说明指针是一个常量，这样的书写形式隐含着一层意味，即不变的是指针本身的值而非指向的那个值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> errNumb = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;errNumb;   <span class="comment">// curErr将一直指向errNumb</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;  <span class="comment">// pip是一个指向常量对象的常量指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>指针本身是一个常量并不意味着不能通过指针修改其所指对象的值，能否这样做完全依赖于所指对象的类型。</strong></p>
</li>
<li><p>下面的哪些初始化是合法的？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;         <span class="comment">// 错误：非常量引用的初始值必须为左值</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p2 = &amp;i2;        <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">-1</span>, &amp;r = <span class="number">0</span>;   <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = &amp;i2;  <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p1 = &amp;i2;        <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;<span class="keyword">const</span> r2;        <span class="comment">// 错误：r2是一个引用，定义时必须初始化，且第二个const没必要</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i2 = i, &amp;r = i;   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的定义哪些是合法的？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i, *<span class="keyword">const</span> cp;       <span class="comment">// 错误：常量和引用都必须初始化</span></span><br><span class="line"><span class="keyword">int</span> *p1, *<span class="keyword">const</span> p2;     <span class="comment">// 错误：常量和引用都必须初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ic, &amp;r = ic;  <span class="comment">// 错误：常量和引用都必须初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3;    <span class="comment">// 错误：常量和引用都必须初始化</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p;           <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用名词<strong>顶层 <code>const</code></strong>（top-level const）表示指针本身是个常量，而用名词<strong>底层 <code>const</code></strong>（low-level const）表示指针所指的对象是一个常量。更一般的，顶层 <code>const</code> 可以表示任意的对象是常量，这一点对任何数据类型都适用，如算术类型、类、指针等。底层 <code>const</code> 则与指针和引用等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层 <code>const</code> 也可以是底层 <code>const</code>，这一点和其他类型相比区别明显：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p1 = &amp;i;        <span class="comment">// 不能改变p1的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">42</span>;         <span class="comment">// 不能改变ci的值，这是一个顶层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p2 = &amp;ci；      <span class="comment">// 允许改变p2的值，这是一个底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *<span class="keyword">const</span> p3 = p2;  <span class="comment">// 靠右的const是顶层const，靠左的是底层const</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = ci;         <span class="comment">// 用于声明引用的const都是底层const</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当执行对象的拷贝操作时，拷入和搭出的对象必须县有相同的底层 <code>const</code> 资格，或者两个对象的数据类型必须能够转换。</strong>一般来说，非常量可以转换成常量，反之则不行。接上例中的代码，观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = p3;        <span class="comment">// 错误：p3包含底层const的定义，而p没有</span></span><br><span class="line">p2 = p3;            <span class="comment">// 正确：p2和p3都是底层const</span></span><br><span class="line">p2 = &amp;i;            <span class="comment">// 正确：int*能转换成const int*</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = ci;        <span class="comment">// 错误：普通的int&amp;不能绑定到int常量上</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = i;  <span class="comment">// 正确：const int&amp;可以绑定到一个普通int上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>常量表达式</strong>（const expression）是指<strong>值不会改变并且在编译过程就能得到计算结果</strong>的表达式。显然，字面值属于常量表达式，用常量表达式初始化的 <code>const</code> 对象也是常量表达式。一个对象（或表达式）是不是常量表达式由它的数据类型和初始值共同决定，例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_files = <span class="number">20</span>;         <span class="comment">// max_files是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> limit = max files + <span class="number">1</span>;  <span class="comment">// limit是常量表达式</span></span><br><span class="line"><span class="keyword">int</span> staff_size = <span class="number">27</span>;              <span class="comment">// staff_size不是常量表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_size();        <span class="comment">// sz不是常量表达式</span></span><br></pre></td></tr></table></figure>
<p>尽管 staff_size 的初始值是个字面值常量，但由于它的数据类型只是一个普通 <code>int</code> 而非 <code>const int</code>，所以它不属于常量表达式。另一方面，尽管 sz 本身是一个常量，但它的具体值<strong>直到运行时才能获取到</strong>，所以也不是常量表达式。</p>
</li>
<li><p>C++11 新标准规定，允许将变量声明为 <strong><code>constexpr</code></strong> 类型以便由编译器来验证变量的值是否是一个常量表达式。声明为 <code>constexpr</code> 的变量一定是一个常量，而且必须用常量表达式初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> sz = size();  <span class="comment">// 中有当size是一个constexpr函数时才是一条正确的声明语句</span></span><br></pre></td></tr></table></figure>
<p>尽管不能使用普通函数作为 <code>constexpr</code> 变量的初始值，但 C++标准允许定义一种特殊的 <code>constexpr</code> 函数。这种函数应该足够简单以使得编译时就可以计算其结果，这样就能用 <code>constexpr</code> 函数去初始化 <code>constexpr</code> 变量了。一般来说，如果你认定变量是一个常量表达式，那就把它声明成 <code>constexpr</code> 类型。</p>
</li>
<li><p>常量表达式的值需要在编译时就得到计算，因此对声明 <code>constexpr</code> 时用到的类型必须有所限制。因为这些类型一般比较简单，值也显而易见、容易得到，就把它们称为“字面值类型”（literal type）。<strong>算术类型、引用和指针都属于字面值类型。自定义类、IO 库、<code>string</code> 类型则不属于字面值类型，也就不能被定义成 <code>constexpr</code>。</strong>尽管指针和引用都能定义成 <code>constexpr</code>，但它们的初始值却受到严格限制。<strong>一个 <code>constexpr</code> 指针的初始值必须是 nullptr 或者 0，或者是存储于某个固定地址中的对象。</strong>函数体内定义的变量一般来说并非存放在固定地址中，因此 <code>constexpr</code> 指针不能指向这样的变量。相反的，定义于所有函数体之外的对象其地址固定不变，能用来初始化 <code>constexpr</code> 指针。</p>
</li>
<li><p><strong>在 <code>constexpr</code> 声明中如果定义了一个指针，限定符 <code>constexpr</code> 仅对指针有效，与指针所指的对象无关</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;      <span class="comment">// p是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;  <span class="comment">// q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<p>p 和 q 的类型相差甚远，p 是一个指向常量的指针，而 q 是一个常量指针，其中的关键在于 <strong><code>constexpr</code> 把它所定义的对象置为了顶层 <code>const</code>。与其他常量指针类似，<code>constexpr</code> 指针既可以指向常量也可以指向一个非常量</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *np = <span class="literal">nullptr</span>;  <span class="comment">// np是一个指向整数的常量指针，其值为空</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> i = <span class="number">42</span>;         <span class="comment">// i的类型是整型常量</span></span><br><span class="line"><span class="comment">// i和j都必须定义在函数体之外</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;  <span class="comment">// p是常量指针，指向整型常量i constexpr</span></span><br><span class="line"><span class="keyword">int</span> *pl = &amp;j;                 <span class="comment">// p1是常量指针，指向整数j</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> null = <span class="number">0</span>, *p = null;  <span class="comment">// 错误：int类型的值不能用于初始化int *类型的值</span></span><br><span class="line"><span class="keyword">int</span> null = <span class="number">0</span>, *p = <span class="number">0</span>;     <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类型别名</strong>（type alias）是一个名字。有两种方法可用于定义类型别名。传统的方法是使用关键字 <strong><code>typedef</code></strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;    <span class="comment">// wages是double的同义词</span></span><br><span class="line"><span class="keyword">typedef</span> wages base, *p;  <span class="comment">// base是double的同义词，p是double*的同义词</span></span><br></pre></td></tr></table></figure>
<p>新标准规定了一种新的方法，使用<strong>别名声明</strong>（alias declaration）来定义类型的别名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> SI = Sales item;  <span class="comment">// SI是Sales item的同义词</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果某个类型别名指代的是复合类型或常量，那么把它用到声明语句里就会产生意想不到的后果。例如下面的声明语句用到了类型 pstring，它实际上是类型 <code>char*</code> 的别名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>;  <span class="comment">// cstr是指向char的常量指针</span></span><br><span class="line"><span class="keyword">const</span> pstring *ps;       <span class="comment">// ps是一个指针，它的对象是指向char的常量指针</span></span><br></pre></td></tr></table></figure>
<p>上述两条声明语句的基本数据类型都是 <code>const pstring</code>，和过去一样，<strong><code>const</code> 是对给定类型的修饰</strong>。<strong>pstring 实际上是指向 <code>char</code> 的指针，因此，<code>const pstring</code> 就是指向 <code>char</code> 的常量指针，而非指向常量字符的指针。</strong> 遇到一条使用了类型别名的声明语句时，人们往往会错误地尝试把类型别名替换成它本来的样子，以理解该语句的含义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>;  <span class="comment">// 是对const pstring cstr的错误理解</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>auto</code></strong> 类型说明符，用它就能让编译器替我们去分析表达式所属的类型。<code>auto</code> 让编译器通过初始值来推算变量的类型。显然，<strong><code>auto</code> 定义的变量必须有初始值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由va11和va12相加的结果可以推断出item的类型</span></span><br><span class="line"><span class="keyword">auto</span> item = val1 + val2;  <span class="comment">// item初始化为val1和va12相加的结果</span></span><br></pre></td></tr></table></figure>
<p>此处编译器将根据 va11 和 va12 相加的结果来推断 item 的类型。</p>
</li>
<li><p>使用 <code>auto</code> 也能在一条语句中声明多个变量。因为<strong>一条声明语句只能有一个基本数据类型</strong>，所以该语句中所有变量的初始基本数据类型都必须一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">0</span>, *p = &amp;i;     <span class="comment">// 正确：i是整数、p是整型指针</span></span><br><span class="line"><span class="keyword">auto</span> sz = <span class="number">0</span>, pi = <span class="number">3.14</span>;  <span class="comment">// 错误：sz和pi的类型不一致</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器推断出来的 <code>auto</code> 类型有时候和初始值的类型并不完全一样，编译器会适当地改变结果类型使其更符合初始化规则。首先，正如我们所熟知的，使用引用其实是使用引用的对象，特别是当引用被用作初始值时，真正参与初始化的其实是引用对象的值。此时编译器以引用对象的类型作为 <code>auto</code> 的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r;  <span class="comment">// a是一个整数（r是i的别名，而i是一个整数）</span></span><br></pre></td></tr></table></figure>
<p>其次，<strong><code>auto</code> 一般会忽略掉顶层 <code>const</code>，同时底层 <code>const</code> 则会保留下来</strong>，比如当初始值是一个指向常量的指针时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;   <span class="comment">// b是一个整数（ci的顶层const特性被忽略掉了）</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;   <span class="comment">// c是一个整数（cr是ci的别名，ci本身是一个顶层const）</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;   <span class="comment">// d是一个整型指针（整数的地址就是指向整数的指针）</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;  <span class="comment">// e是一个指向整数常量的指针（对常量对象取地址是一种底层const）</span></span><br></pre></td></tr></table></figure>
<p><strong>如果希望推断出的 <code>auto</code> 类型是一个顶层 <code>const</code>，需要明确指出</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">// ci的推演类型是int，f是const int</span></span><br></pre></td></tr></table></figure>
<p>还可以将引用的类型设为 <code>auto</code>，此时原来的初始化规则仍然适用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> &amp;g = ci;        <span class="comment">// g是一个整型常量引用，绑定到ci</span></span><br><span class="line"><span class="keyword">auto</span> &amp;h = <span class="number">42</span>;        <span class="comment">// 错误：不能为非常量引用绑定字面值</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">42</span>;  <span class="comment">// 正确：可以为常量引用绑定字面值</span></span><br></pre></td></tr></table></figure>
<p><strong>设置一个类型为 <code>auto</code> 的引用时，初始值中的顶层常量属性仍然保留。</strong>和往常一样，如果我们给初始值绑定一个引用，则此时的常量就不是顶层常量了。<strong>要在一条语句中定义多个变量，切记，符号 <code>&amp;</code> 和 <code>*</code> 只从属于某个声明符，而非基本数据类型的一部分，因此初始值必须是同一种类型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> k = ci, &amp;l = i;     <span class="comment">// k是整数，l是整型引用</span></span><br><span class="line"><span class="keyword">auto</span> &amp;m = ci, *p = &amp;ci;  <span class="comment">// m是对整型常量的引用，p是指向整型常量的指针</span></span><br><span class="line"><span class="comment">// 错误：i的类型是int而&amp;ci的类型是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;n = i, *p2 = &amp;ci;</span><br></pre></td></tr></table></figure>
<p><strong>常量引用可以绑定到非常量，普通引用只能绑定到非常量；指向常量的指针可以指向非常量，普通指针只能指向非常量。所谓的“常量引用”和“指向常量的指针”限制的只是引用和指针的行为。</strong></p>
</li>
<li><p>判断下列定义推断出的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">auto</span> j = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;k = i;</span><br><span class="line"><span class="keyword">auto</span> *p = &amp;i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> j2 = i, &amp;k2 = i;</span><br></pre></td></tr></table></figure>
<p>j 是个整型变量，k 是个对整型常量的引用，p 是个指向整型常量的指针，j2 是个整型常量，k2 是个对整型常量的引用。</p>
</li>
<li><p>C++11 新标准引入了第二种类型说明符 <code>decltype</code>，它的作用是选择并返回操作数的数据类型。<strong>在此过程中，编译器分析表达式并得到它的类型，却不实际计算表达式的值。</strong></p>
</li>
<li><p><code>decltype</code> 处理顶层 <code>const</code> 和引用的方式与 <code>auto</code> 有些许不同。<strong>如果 <code>decltype</code> 使用的表达式是一个变量，则 <code>decltype</code> 返回该变量的类型（包括顶层 <code>const</code> 和引用在内）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>;  <span class="comment">// x的类型是const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x;  <span class="comment">// y的类型是const int&amp;，y绑定到变量x</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) z;      <span class="comment">// 错误：z是一个引用，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>因为 cj 是一个引用，<code>decltype(cj)</code> 的结果就是引用类型，因此作为引用的 z 必须被初始化。<strong>需要指出的是，引用从来都作为其所指对象的同义词出现，只有用在 <code>decltype</code> 处是一个例外。</strong></p>
</li>
<li><p><strong>如果 <code>decltype</code> 使用的表达式不是一个变量，则 <code>decltype</code> 返回表达式结果对应的类型。有些表达式将向 <code>decltype</code> 返回一个引用类型。一般来说当这种情况发生时，意味着该表达式的结果对象能作为一条赋值语句的左值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decltype的结果可以是引用类型</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;  <span class="comment">// 正确：加法的结果是int，因此b是一个（未初始化的）int</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c;     <span class="comment">// 错误：c是int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure>
<p>因为 r 是一个引用，因此 <code>decltype(r)</code> 的结果是引用类型。如果想让结果类型是 r 所指的类型，可以把 r 作为表达式的一部分，如 r+0，显然这个表达式的结果将是一个具体值而非一个引用。另一方面，<strong>如果表达式的内容是解引用操作，则 <code>decltype</code> 将得到引用类型。正如我们所熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值。因此，<code>decltype(*p)</code> 的结果类型就是 <code>int&amp;</code>，而非 <code>int</code>。</strong><code>decltype</code> 和 <code>auto</code> 的另一处重要区别是，<code>decltype</code> 的结果类型与表达式形式密切相关。有一种情况需要特别注意：对于 <code>decltype</code> 所用的表达式来说，如果变量名加上了一对括号，则得到的类型与不加括号时会有不同。<strong>如果 <code>decltype</code> 使用的是一个不加括号的变量，则得到的结果就是该变量的类型；如果给变量加上了一层或多层括号，编译器就会把它当成是一个表达式。变量是一种可以作为赋值语句左值的特殊表达式，所以这样的 <code>decltype</code> 就会得到引用类型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// decltype的表达式如果是加上了括号的变量，结果将是引用</span></span><br><span class="line"><span class="keyword">decltype</span>((i)) d;  <span class="comment">// 错误：d是int&amp;，必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(i) e;    <span class="comment">// 正确：e是一个（未初始化的）int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>切记：<strong><code>decltype((variable))</code>（注意是双层括号）的结果永远是引用，而 <code>decltype(variable)</code> 结果只有当 variable 本身就是一个引用时才是引用。</strong></p>
</li>
<li><p>请指出每一个变量的类型以及程序结束时它们各自的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>((b)) d = a;</span><br><span class="line">++c;</span><br><span class="line">++d;</span><br></pre></td></tr></table></figure>
<p>a：整型变量，4；b：整型变量，4；c：整型变量，4；d：对整型变量的引用，4。</p>
</li>
<li><p><strong>赋值是会产生引用的一类典型表达式，引用的类型就是左值的类型。</strong>也就是说，如果 i 是 <code>int</code>，则表达式 i=x 的类型是 <code>int&amp;</code>。根据这一特点，指出下面代码中每一个变量的类型和值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>, b = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">decltype</span>(a) c = a;</span><br><span class="line"><span class="keyword">decltype</span>(a = b) d = a;</span><br></pre></td></tr></table></figure>
<p>a：整型变量，3；b：整型变量，4；c：整型变量，3；d：对整型变量的引用，3。</p>
</li>
<li><p>类体右侧的表示结束的花括号后必须写一个分号，这是因为类体后面可以紧跟变量名以示对该类型对象的定义，所以分号必不可少。</p>
</li>
<li><p>类的数据成员定义了类的对象的具体内容，每个对象有自己的一份数据成员拷贝。修改一个对象的数据成员，不会影响其他的对象。</p>
</li>
<li><p>C++11 新标准规定，可以为数据成员提供一个<strong>类内初始值</strong>（in-class initializer）。创建对象时，类内初始值将用于初始化数据成员。没有初始值的成员将被默认初始化。</p>
</li>
<li><p>类内初始值的限制：或者放在花括号里，或者放在等号右边，记住不能使用圆括号。</p>
</li>
<li><p>头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。</p>
</li>
<li><p>确保头文件多次包含仍能安全工作的常用技术是<strong>预处理器</strong>（preprocesor），预处理器是在编译之前执行的一段程序，可以部分地改变我们所写的程序。<code>#include</code>，当预处理器看到 <code>#include</code> 标记时就会用指定的头文件的内容代替 <code>#include</code>。C++ 程序还会用到的一项预处理功能是<strong>头文件保护符</strong>（header guard），头文件保护符依赖于预处理变量。预处理变量有两种状态：已定义和未定义。<code>#define</code> 指令把一个名字设定为预处理变量，另外两个指令则分别检查某个指定的预处理变量是否已经定义：<code>#ifdef</code> 当且仅当变量已定义时为真，<code>#ifndef</code> 当且仅当变量未定义时为真。一旦检查结果为真，则执行后续操作直至遇到 <code>#endif</code> 指令为止。预处理变量无视 C++语言中关于作用域的规则。</p>
</li>
<li><p><strong>常量指针（const pointer）</strong>是一种指针，它的值永不改变。</p>
</li>
<li><p><strong>常量引用（const reference）</strong>是一种习惯叫法，含义是指向常量的引用。</p>
</li>
<li><p><strong>常量表达式（const expression）</strong>能在编译时计算并获取结果的表达式。</p>
</li>
<li><p><strong>constexpr</strong>是一种函数，用于代表一条常量表达式。</p>
</li>
<li><p><strong>数据成员（data member）</strong>组成对象的数据元素，类的每个对象都有类的数据成员的一份拷贝。数据成员可以在类内部声明的同时初始化。</p>
</li>
<li><p><strong>声明符（declarator）</strong>是声明的一部分，包括被定义的名字和类型修饰符，其中类型修饰符可以有也可以没有。</p>
</li>
<li><p><strong>默认初始化（default initialization）</strong>当对象未被显式地赋予初始值时执行的初始化行为。由类本身负责执行的类对象的初始化行为。全局作用域的内置类型对象初始化为 0；局部作用域的对象未被初始化即拥有未定义的值。</p>
</li>
<li><p><strong>标识符（identifier）</strong>组成名字的字符序列，标识符对大小写敏感。</p>
</li>
<li><p><strong>列表初始化（list initialization）</strong>利用花括号把一个或多个初始值放在一起的初始化形式。</p>
</li>
<li><p><strong>底层 const（low-level const）</strong>一个不属于顶层的 <code>const</code>，类型如果由底层常量定义，则不能被忽略。</p>
</li>
<li><p><strong>空指针（null pointer）</strong>值为 0 的指针，空指针合法但是不指向任何对象。<code>nullptr</code> 是表示空指针的字面值常量。</p>
</li>
<li><p><strong>指针（pointer）</strong>是一个对象，存放着某个对象的地址，或者某个对象存储区域之后的下一地址，或者 0。</p>
</li>
<li><p><strong>指向常量的指针（pointer to const）</strong>是一个指针，存放着某个常量对象或非常量对象的地址。指向常量的指针不能用来改变它所指对象的值。</p>
</li>
<li><p><strong>对常量的引用（reference to const）</strong>是一一个引用，不能用来改变它所绑定对象的值。对常量的引用可以绑定常量对象，或者非常量对象，或者表达式的结果。</p>
</li>
<li><p><strong>顶层 const（top-level const）</strong>是一个 <code>const</code>，规定某对象的值不能改变。</p>
</li>
<li><p><strong>void*</strong> 可以指向任意非常量的指针类型，不能执行解引用操作。</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Git版本库管理最佳实践——以创建新分支加入某个项目为例</title>
    <url>/archives/586b7559.html</url>
    <content><![CDATA[<h1 id="1-背景" class="heading-control"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景<a class="heading-anchor" href="#1-背景" aria-hidden="true"></a></h1><blockquote>
<p>公司项目存放于GitLab服务器，想要加入该项目贡献代码</p>
</blockquote>
<h1 id="2-最佳实践" class="heading-control"><a href="#2-最佳实践" class="headerlink" title="2 最佳实践"></a>2 最佳实践<a class="heading-anchor" href="#2-最佳实践" aria-hidden="true"></a></h1><h2 id="2-1-添加SSH公钥至GitLab服务器" class="heading-control"><a href="#2-1-添加SSH公钥至GitLab服务器" class="headerlink" title="2.1 添加SSH公钥至GitLab服务器"></a>2.1 添加SSH公钥至GitLab服务器<a class="heading-anchor" href="#2-1-添加SSH公钥至GitLab服务器" aria-hidden="true"></a></h2><ul>
<li>生成SSH公钥<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -C “your email address”</span><br></pre></td></tr></table></figure></li>
<li>添加公钥至GitLab服务器（不再赘述）</li>
</ul>
<h2 id="2-2-配置git全局（或工程）用户名和邮箱" class="heading-control"><a href="#2-2-配置git全局（或工程）用户名和邮箱" class="headerlink" title="2.2 配置git全局（或工程）用户名和邮箱"></a>2.2 配置git全局（或工程）用户名和邮箱<a class="heading-anchor" href="#2-2-配置git全局（或工程）用户名和邮箱" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name “your user name”</span><br><span class="line">git config --global user.email “your email address”</span><br></pre></td></tr></table></figure>
<h2 id="2-3-克隆仓库、创建个人分支、提交代码" class="heading-control"><a href="#2-3-克隆仓库、创建个人分支、提交代码" class="headerlink" title="2.3 克隆仓库、创建个人分支、提交代码"></a>2.3 克隆仓库、创建个人分支、提交代码<a class="heading-anchor" href="#2-3-克隆仓库、创建个人分支、提交代码" aria-hidden="true"></a></h2><p>克隆仓库，切换到将要merge进去的目标分支，在该分支下创建个人分支，在新建的个人分支下进行文件修改，将个人分支push到远程仓库并建立追踪关系（push后加—set-upstream参数）：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repo_addr</span><br><span class="line"><span class="built_in">cd</span> repo_dir</span><br><span class="line">git checkout target_repo_branch_to_merge</span><br><span class="line">git checkout -b branch_name</span><br><span class="line"><span class="comment"># 进行文件修改</span></span><br><span class="line">git add --all</span><br><span class="line">git commit -m “Your commit content.”</span><br><span class="line">git push --<span class="built_in">set</span>-upstream origin branch_name  <span class="comment"># 成功push过一次后可以简化为git push</span></span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-将个人分支merge到目标分支、打好tag" class="heading-control"><a href="#2-4-将个人分支merge到目标分支、打好tag" class="headerlink" title="2.4 将个人分支merge到目标分支、打好tag"></a>2.4 将个人分支merge到目标分支、打好tag<a class="heading-anchor" href="#2-4-将个人分支merge到目标分支、打好tag" aria-hidden="true"></a></h2><p>Web界面操作即可。</p>
<h1 id="3-一些说明" class="heading-control"><a href="#3-一些说明" class="headerlink" title="3 一些说明"></a>3 一些说明<a class="heading-anchor" href="#3-一些说明" aria-hidden="true"></a></h1><p>执行完<code>git clone</code>后，将拉取远程仓库的所有分支、各分支上的修改、tag等全部内容，并将在本地的克隆仓库中创建master分支（自动与远程仓库的master分支相关联，远程仓库别名缺省为origin），在创建个人分支前，务必先<code>git checkout</code>到将要merged到的分支（示例中为develop），然后再进行分支创建操作，否则在GitLab服务器上进行merge操作时，可能会发生冲突与逆向merge（develop分支merge到了个人分支）。原因：</p>
<blockquote>
<p>初次完成仓库克隆时，所在分支为master分支，此时若立即创建个人分支将是基于master分支创建的，而master分支与将要merge的分支很有可能是不同的，后续将做过修改的个人分支向develop分支进行merge时大概率会出现问题。当然，即使这样做了，也可能在进行merge操作时发生冲突与逆向merge（从develop分支创建个人分支后，修改文件期间有人向develop分支push了新的提交）。</p>
</blockquote>
<hr>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 4 章 表达式</title>
    <url>/archives/dc74a592.html</url>
    <content><![CDATA[<ol>
<li><p>字面值和变量是最简单的<strong>表达式</strong>（expression），其结果就是字面值和变量的值。</p>
</li>
<li><p>函数调用也是一种特殊的运算符，它对运算对象的数量没有限制。</p>
</li>
<li><p>对于含有多个运算符的复杂表达式来说，要想理解它的含义首先要理解运算符的优先级（precedence）、结合律（associativity）以及运算对象的求值顺序（order of evaluation）。</p>
</li>
<li><p>类型转换中，小整数类型（如 <code>bool</code>、<code>char</code>、<code>short</code> 等）通常会被<strong>提升</strong>（promoted）成较大的整数类型，主要是 <code>int</code>。</p>
</li>
<li><p>为已存在的运算符赋予另外一层含义，被称之为<strong>重载运算符</strong>（overloaded operator）。我们使用重载运算符时，其包括运算对象的类型和返回值的类型，都是由该运算符定义的；但是运算对象的个数、运算符的优先级和结合律都是无法改变的。</p>
</li>
<li><p>C++ 的表达式要不然是<strong>右值</strong>，要不然就是<strong>左值</strong>：左值可以位于赋值语句的左侧，右值则不能。一个左值表达式的求值结果是一个对象或者一个函数，然而以常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象。此外，虽然某些表达式的求值结果是对象，但它们是右值而非左值。可以做一个简单的归纳：<strong>当一个对象被用作右值的时候，用的是对象的值（内容）；当对象被用作左值的时候，用的是对象的身份（在内存中的位置）</strong>。</p>
</li>
<li><p>在需要右值的地方可以用左值来代替，但是不能把右值当成左值（也就是位置）使用。当一个左值被当成右值使用时，实际使用的是它的内容（值）。</p>
<ul>
<li>赋值运算符需要一个（非常量）左值作为其左侧运算对象，得到的结果也仍然是一个左值。</li>
<li>取地址符作用于一个左值运算对象，返回一个指向该运算对象的指针，这个指针是一个右值。</li>
<li>内置解引用运算符、下标运算符、迭代器解引用运算符、<code>string</code> 和 <code>vector</code> 的下标运算符的求值结果都是左值。</li>
<li>内置类型和迭代器的递增递减运算符作用于左值运算对象，其前置版本所得的结果也是左值。<br><br></li>
</ul>
</li>
<li><p>使用关键字 <code>decltype</code> 的时候，左值和右值也有所不同。如果表达式的求值结果是左值，<code>decltype</code> 作用于该表达式（不是变量）得到一个引用类型。举个例子，假定 p 的类型是 <code>int*</code>，因为解引用运算符生成左值，所以 <code>decltype(*p)</code> 的结果是 <code>int&amp;</code>。另一方面，因为取地址运算符生成右值，所以 <code>decltype(&amp;p)</code> 的结果是 <code>int**</code>，也就是说，结果是一个指向整型指针的指针。</p>
</li>
<li><p>优先级规定了运算对象的组合方式，但是没有说明运算对象按照什么顺序求值。在大多数情况下，不会明确指定求值的顺序。对于如下的表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i= f1() * f2();</span><br></pre></td></tr></table></figure>
<p>我们知道 f1 和 f2 一定会在执行乘法之前被调用，因为毕竟相乘的是这两个函数的返回值。但是我们无法知道到底 f1 在 f2 之前调用还是 f2 在 f1 之前调用。<strong>对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一个对象，将会引发错误并产生未定义的行为。</strong>举个简单的例子，<code>&lt;&lt;</code> 运算符没有明确规定何时以及如何对运算对象求值，因此下面的输出表达式是未定义的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; ++i &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 未定义的</span></span><br></pre></td></tr></table></figure>
<p>因为程序是未定义的，所以我们无法推断它的行为。编译器可能先求 ++i 的值再求 i 的值，此时输出结果是 <code>1 1</code>；也可能先求 i 的值再求 ++i 的值，输出结果是 <code>0 1</code>：甚至编译器还可能做完全不同的操作。因为此表达式的行为不可预知，因此不论编译器生成什么样的代码程序都是错误的。vscode 中输出结果为 <code>1 1</code>。有 4 种运算符明确规定了运算对象的求值顺序，第一种是<strong>逻辑与（&amp;&amp;）运算符，它规定先求左侧运算对象的值，只有当左侧运算对象的值为真时才继续求右侧运算对象的值</strong>。另外三种分别是逻辑或（ll）运算符、条件（?:）运算符和逗号（,）运算符。</p>
</li>
<li><p>以下两条经验准则对书写复合表达式有益：<br>(1) 拿不准的时候最好用括号来强制让表达式的组合关系符合程序逻辑的要求;<br>(2) 如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。第 2 条规则有一个重要例外，当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时该规则无效。例如，<strong>在表达式 <code>*++iter</code> 中，递增运算符改变 <code>iter</code> 的值，<code>iter</code>（已经改变）的值又是解引用运算符的运算对象。此时（或类似的情况下），求值的顺序不会成为问题，因为递增运算（即改变运算对象的子表达式）必须先求值，然后才轮到解引用运算。</strong></p>
</li>
<li><p>算术运算符的运算对象和求值结果都是右值。在表达式求值之前，小整数类型的运算对象被提升成较大的整数类型，所有运算对象最终会转换成同一类型。当一元正号运算符作用于一个指针或者算术值时，返回运算对象值的一个（提升后的）副本。一元负号运算符对运算对象值取负后，返回其（提升后的）副本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">bool</span> b2 = -b;  <span class="comment">// b2 是 true</span></span><br></pre></td></tr></table></figure>
<p><strong>布尔值不应该参与运算。</strong>对大多数运算符来说，布尔类型的运算对象将被提升为 <code>int</code> 类型。如上所示，布尔变量 b 的值为真，参与运算时将被提升成整数值 1，对它求负后的结果是 -1。将 -1 再转换回布尔值并将其作为 b2 的初始值，显然这个初始值不等于 0，转换成布尔值后应该为 1。所以，b2 的值是真！</p>
</li>
<li><p>假设某个机器的 <code>short</code> 类型占 16 位，则最大的 <code>short</code> 数值是 32767。在这样一台机器上，下面的复合赋值语句将产生溢出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">short short_value = <span class="number">32767</span>;  <span class="comment">// 如果 short 类型占 16 位，则能表示的最大值是 32767</span></span><br><span class="line">short_value += <span class="number">1</span>;           <span class="comment">// 该计算导致溢出</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"short value: "</span> &lt;&lt; short_value &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>给 short_value 赋值的语句是未定义的，这是因为表示一个带符号数 32768 需要 17 位，但是 short 类型只有 16 位。很多系统在编译和运行时都不报溢出错误，像其他未定义的行为一样，溢出的结果是不可预知的。在我们的系统中，程序的输出结果是（vscode 中调试也是如此）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">short_value: -32768</span><br></pre></td></tr></table></figure>
<p>该值发生了“环绕（wrapped around”，符号位本来是 0，由于溢出被改成了 1，于是结果变成一个负值。在别的系统中也许会有其他结果，程序的行为可能不同甚至直接崩溃。</p>
</li>
<li><p>整数相除结果还是整数，也就是说，如果商含有小数部分，直接弃除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival1 = <span class="number">21</span> / <span class="number">6</span>;  <span class="comment">// ival1 是 3，结果进行了删节，余数被抛弃掉了</span></span><br><span class="line"><span class="keyword">int</span> ival2 = <span class="number">21</span> / <span class="number">7</span>;  <span class="comment">// ival2 是 3，没有余数，结果是整数值</span></span><br></pre></td></tr></table></figure>
<p>运算符 % 俗称“取余”或“取模”运算符，负责计算两个整数相除所得的余数，参与取余运算的运算对象必须是整数类型。</p>
</li>
<li><p>C++ 语言的早期版本允许结果为负值的商向上或向下取整，<strong>C++11 新标准则规定商一律向 0 取整（即直接切除小数部分）</strong>。</p>
</li>
<li><p>如果 m%n 不等于 0，则它的符号和 m 相同。C++ 语言的早期版本允许 m%n 的符号匹配 n 的符号，而且商向负无穷一侧取整，这一方式在新标准中已经被禁止使用了。除了 -m 导致溢出的特殊情况，其他时候 (-m)/n 和 m/(-n) 都等于 -(m/n)，<strong>m%(-n)等于 m%n，(-m)%n 等于-(m%n)</strong>。具体示例如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">21</span> % <span class="number">6</span>;      <span class="comment">/*结果是3*/</span></span><br><span class="line"><span class="number">21</span> % <span class="number">7</span>;      <span class="comment">/*结果是0*/</span></span><br><span class="line"><span class="number">-21</span> % <span class="number">-8</span>;    <span class="comment">/*结果是-5*/</span></span><br><span class="line"><span class="number">21</span> % <span class="number">-5</span>;     <span class="comment">/*结果是1*/</span></span><br><span class="line"><span class="number">21</span> / <span class="number">6</span>;      <span class="comment">/*结果是3*/</span></span><br><span class="line"><span class="number">21</span> / <span class="number">7</span>;      <span class="comment">/*结果是3*/</span></span><br><span class="line"><span class="number">-21</span> / <span class="number">-8</span>;    <span class="comment">/*结果是2*/</span></span><br><span class="line"><span class="number">21</span> /<span class="number">-5</span>;      <span class="comment">/*结果是-4*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>下列表达式的结果是什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">30</span> / <span class="number">3</span> * <span class="number">21</span> % <span class="number">5</span>;   <span class="comment">// 0</span></span><br><span class="line"><span class="number">-30</span> / <span class="number">3</span> * <span class="number">21</span> % <span class="number">4</span>;  <span class="comment">// -2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>逻辑运算符和关系运算符的返回值都是布尔类型，运算对象和求值结果都是右值。</p>
</li>
<li><p>逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值。这种策略称为<strong>短路求值</strong>（short-circuit evaluation）。</p>
<ul>
<li>对于逻辑与运算符来说，当且仅当左侧运算对象为真时才对右侧运算对象求值；</li>
<li>对于逻辑或运算符来说，当且仅当左侧运算对象为假时才对右侧运算对象求值。<br><br></li>
</ul>
</li>
<li><p>声明成引用类型可以避免对元素的拷贝。</p>
</li>
<li><p>关系运算符都满足左结合律：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; j &lt; k)  <span class="comment">// 若k大于1则为真！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>解释在下面的 if 语句中条件部分的判断过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="keyword">if</span> (cp &amp;&amp; *cp)</span><br></pre></td></tr></table></figure>
<p>先判断 cp 是否是空指针，再判断 cp 指向的是否是空字串。</p>
</li>
<li><p>赋值运算符的左侧运算对象必须是一个可修改的左值。</p>
</li>
<li><p>赋值运算的结果是它的左侧运算对象，并且是一个左值。相应的，结果的类型就是左侧运算对象的类型。如果赋值运算符的左右两个运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。</p>
</li>
<li><p>C++11 新标准允许使用花括号括起来的初始值列表作为赋值语句的右侧运算对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">k = (<span class="number">3.14</span>);                           <span class="comment">// 错误：窄化转换</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;                       <span class="comment">// 初始为空</span></span><br><span class="line">vi = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;  <span class="comment">// vi现在含有10个元素了，值从0到9</span></span><br></pre></td></tr></table></figure>
<p>如果左侧运算对象是内置类型，那么初始值列表最多只能包含一个值，而且该值即使转换的话其所占空间也不应该大于目标类型的空间。</p>
</li>
<li><p>无论左侧运算对象的类型是什么，初始值列表都可以为空。此时，编译器创建一个值初始化的临时量并将其赋给左侧运算对象。</p>
</li>
<li><p>赋值运算符满足右结合律，这一点与其他二元运算符不太一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, jval;</span><br><span class="line">ival = jval = <span class="number">0</span>;  <span class="comment">// 正确：都被赋值为0</span></span><br></pre></td></tr></table></figure>
<p>因为赋值运算符满足右结合律，所以靠右的赋值运算 <code>jval = 0</code> 作为靠左的赋值运算符的右侧运算对象。又因为赋值运算返回的是其左侧运算对象，所以靠右的赋值运算的结果（即 jval）被赋给了 ival。<br>对于多重赋值语句中的每一个对象，它的类型或者与右边对象的类型相同、或者可由右边对象的类型转换得到：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival, *pval;  <span class="comment">// ival的类型是int；pval是指向int的指针</span></span><br><span class="line">ival = pval = <span class="number">0</span>;  <span class="comment">// 错误：不能把指针的值赋给int</span></span><br></pre></td></tr></table></figure>
<p>vscode 下提示错误：不能将 <code>int *</code> 类型的值分配到 <code>int</code> 类型的实体。但是可以强制转换：<code>ival = int(pval = 0)</code>；此时，vscode 下提示警告：从 <code>int *</code> 到 <code>int</code> 的指针截断。</p>
</li>
<li><p>因为赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分通常应该加上括号。任意一种复合运算符都完全等价于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = a op b;</span><br></pre></td></tr></table></figure>
<p>唯一的区别是左侧运算对象的求值次数：<strong>使用复合运算符只求值一次，使用普通的运算符则求值两次。</strong> 这两次包括：一次是作为右边子表达式的一部分求值，另一次是作为赋值运算的左侧运算对象求值。其实在很多地方，这种区别除了对程序性能有些许影响外几乎可以忽略不计。</p>
</li>
<li><p>递增运算符和递减运算符必须作用于左值运算对象。前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回。后置版本需要将原始值存储下来以便于返回这个未修改的内容。如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。对于整数和指针类型来说，编译器可能对这种额外的工作进行一定的优化；但是对于相对复杂的迭代器类型，这种额外的工作就消耗巨大了。</p>
</li>
<li><p>如果我们想在一条复合表达式中既将变量加 1 或减 1 又能使用它原来的值，这时就可以使用递增和递减运算符的后置版本。使用后置的递增运算符来控制循环输出一个 <code>vector</code> 对象内容直至遇到（但不包括）第一个负值为止：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pbeg = v.begin();</span><br><span class="line"><span class="comment">// 输出元素直至遇到第一个负值为止</span></span><br><span class="line"><span class="keyword">while</span> (pbeg != v.end() &amp;&amp; *beg &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *pbeg++ &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出当前值并将 pbeg 向前移动一个元素</span></span><br></pre></td></tr></table></figure>
<p><strong>后置递增运算符的优先级高于解引用运算符</strong>，因此 <code>*pbeg++</code> 等价于 <code>*(pbeg++)</code>。pbeg++ 把 pbeg 的值加 1，然后返回 pbeg 的初始值的副本作为其求值结果，此时解引用运算符的运算对象是 pbeg 未增加之前的值。</p>
</li>
<li><p>观察下面的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该循环的行为是未定义的！</span></span><br><span class="line"><span class="keyword">while</span> (beg != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*beg))</span><br><span class="line">    *beg = <span class="built_in">toupper</span>(*beg++);  <span class="comment">// 错误：该赋值语句未定义</span></span><br></pre></td></tr></table></figure>
<p>上述代码将产生未定义的行为。问题在于：赋值运算符左右两端的运算对象都用到了 beg，并且右侧的运算对象还改变了 beg 的值，所以该赋值语句是未定义的。编译器可能按照下面的任意一种思路处理该表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*beg = <span class="built_in">toupper</span>(*beg);        <span class="comment">// 如果先求左侧的值</span></span><br><span class="line">*(beg + <span class="number">1</span>) = <span class="built_in">toupper</span>(*beg);  <span class="comment">// 如果先求右侧的值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>点运算符获取类对象的一个成员，箭头运算符与点运算符有关，表达式 <code>ptr -&gt; mem</code> 等价于 <code>(*ptr).mem</code>。<strong>解引用运算符的优先级低于点运算符</strong>，所以执行解引用运算的子表达式两端必须加上括号。<strong>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。</strong> 点运算符分成两种情况：如果成员所属的对象是左值，那么结果是左值；反之，如果成员所属的对象是右值，那么结果是右值。</p>
</li>
<li><p>假设 iter 的类型是 <code>vector&lt;string&gt;::iterator</code>，下述表达式哪些不合法，合法表达式的含义是什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">*iter++;          <span class="comment">// 正确</span></span><br><span class="line">(*iter)++;        <span class="comment">// 正确</span></span><br><span class="line">*iter.empty();    <span class="comment">// 错误</span></span><br><span class="line">iter-&gt;empty();    <span class="comment">// 正确</span></span><br><span class="line">++*iter;          <span class="comment">// 正确</span></span><br><span class="line">iter++-&gt;empty();  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>要区分开 <code>*iter++</code> 与 <code>(*iter)++</code>：前者的解引用运算符作用于 iter 初始值的副本，后置递增运算符作用域 iter；后者的解引用运算符作用于 iter 本身，后置递增运算符作用于 iter 解引用后的值。</p>
</li>
<li><p>条件运算符（?:）允许我们把简单的 if-else 逻辑嵌入到单个表达式当中，条件运算符按照如下形式使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cond ? expr1 : expr2;</span><br></pre></td></tr></table></figure>
<p>其中 cond 是判断条件的表达式，而 expr1 和 expr2 是两个类型相同或可能转换为某个公共类型的表达式。<br>当条件运算符的两个表达式都是左值或者能转换成同一种左值类型时，运算的结果是左值；否则运算的结果是右值。</p>
</li>
<li><p>允许在条件运算符的内部嵌套另外一个条件运算符。也就是说，条件表达式可以作为另外一个条件运算符的 cond 或 expr。举个例子，使用一对嵌套的条件运算符可以将成绩分成三档：优秀（high pass）、合格（pass）和不合格（fail）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">finalgrade = (grade &gt; <span class="number">90</span>) ? <span class="string">"high pass"</span></span><br><span class="line">                          : (grade &lt; <span class="number">60</span>) ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;</span><br></pre></td></tr></table></figure>
<p><strong>条件运算符满足右结合律</strong>，意味着运算对象（一般）按照从右向左的顺序组合。因此在上面的代码中，靠右边的条件运算（比较成绩是否小于 60）构成了靠左边的条件运算的 <code>:</code> 分支。</p>
</li>
<li><p>观察下面的输出语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; ((grade &lt; <span class="number">60</span>) ? <span class="string">"fail"</span> : <span class="string">"pass"</span>);  <span class="comment">// 输出 pass 或者 fail</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (grade &lt; <span class="number">60</span>) ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;    <span class="comment">// 输出 1 或者 0！</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; grade &lt; <span class="number">60</span> ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;      <span class="comment">// 错误：试图比较 cout 和 60</span></span><br></pre></td></tr></table></figure>
<p>在第二条表达式中，grade 和 60 的比较结果是&lt;&lt;运算符的运算对象，因此如果 grade &lt; 60 为真输出 1，否则输出 0。<strong><code>&lt;&lt;</code> 运算符的返回值是 <code>cout</code></strong>，接下来 <code>cout</code> 作为条件运算符的条件。也就是说，第二条表达式等价于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; (grade &lt; <span class="number">60</span>);    <span class="comment">// 输出1或者0</span></span><br><span class="line"><span class="built_in">cout</span> ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;  <span class="comment">// 根据cout的值是true还是false产生对应的字面值</span></span><br></pre></td></tr></table></figure>
<p>因为第三条表达式等价于下面的语句，所以它是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; grade;  <span class="comment">// 小于运算符的优先级低于移位运算符，所以先输出 grade</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">60</span> ? <span class="string">"fail"</span> : <span class="string">"pass"</span>;  <span class="comment">// 然后比较 cout 和 60！</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>因为运算符的优先级问题，下面这条表达式无法通过编译。请指出问题在哪里，应该如何修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"word"</span>;</span><br><span class="line"><span class="built_in">string</span> p1 = s + s[s.size() - <span class="number">1</span>] == <span class="string">'s'</span> ? <span class="string">""</span> : <span class="string">"s"</span>;</span><br></pre></td></tr></table></figure>
<p>算数运算符优先级高于关系运算符，因此先计算 <code>s + s[s.size() - 1]</code>，返回结果是一个 <code>string</code> 对象，无法与字符字面值常量 <code>s</code> 进行相等性比较，程序应改为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> p1 = s + (s[s.size() - <span class="number">1</span>] == <span class="string">'s'</span> ? <span class="string">""</span> : <span class="string">"s"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>位运算符作用于整数类型的运算对象，并把运算对象看成是二进制位的集合。一种名为 <code>bitset</code> 的标准库类型也可以表示任意大小的二进制位集合，所以位运算符同样能用于 <code>bitset</code> 类型。</p>
</li>
<li><p>一般来说，如果运算对象是“小整型”，则它的值会被自动提升成较大的整数类型。运算对象可以是带符号的，也可以是无符号的。如果运算对象是带符号的且它的值为负，那么位运算符如何处理运算对象的“符号位”依赖于机器。而且，此时的左移操作可能会改变符号位的值，因此是一种未定义的行为。</p>
</li>
<li><p>移位运算符首先令左侧运算对象的内容按照右侧运算对象的要求移动指定位数，然后将经过移动的（可能还进行了提升）左侧运算对象的拷贝作为求值结果。其中，右侧的运算对象一定不能为负，而且值必须严格小于结果的位数，否则就会产生未定义的行为。二进制位或者向左移（&lt;&lt;）或者向右移（&gt;&gt;），移出边界之外的位就被舍弃掉了。</p>
</li>
<li><p>左移运算符（&lt;&lt;）在右侧插入值为 0 的二进制位。右移运算符（&gt;&gt;）的行为则依赖于其左侧运算对象的类型：如果该运算对象是无符号类型，在左侧插入值为 0 的二进制位；如果该运算对象是带符号类型，在左侧插入符号位的副本或值为 0 的二进制位，如何选择要视具体环境而定。</p>
</li>
<li><p>对于<strong>位与运算符</strong>（&amp;）来说，如果两个运算对象的对应位置都是 1 则运算结果中该位为 1，否则为 0。对于<strong>位或运算符</strong>（|）来说，如果两个运算对象的对应位置至少有一个为 1 则运算结果中该位为 1，否则为 0。对于<strong>位异或运算符</strong>（^）来说，如果两个运算对象的对应位置有且只有一个为 1 则运算结果中该位为 1，否则为 0。</p>
</li>
<li><p>移位运算符（又叫 IO 运算符）满足左结合律。<strong>移位运算符的优先级不高不低，介于中间：比算术运算符的优先级低，但比关系运算符、赋值运算符和条件运算符的优先级高。</strong></p>
</li>
<li><p><code>sizeof</code> 运算符返回一条表达式或一个类型名字所占的字节数。<code>sizeof</code> 运算符满足右结合律，其所得的值是一个 <code>size_t</code> 类型的常量表达式。运算符的运算对象有两种形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">sizeof</span>(type)</span><br><span class="line"><span class="keyword">sizeof</span> expr</span><br></pre></td></tr></table></figure>
<p>在第二种形式中，<code>sizeof</code> 并不实际计算其运算对象的值。</p>
</li>
<li><p>关于 <code>sizeof *p</code>。首先，因为 <code>sizeof</code> 满足右结合律并且与 <code>*</code> 运算符的优先级一样，所以表达式按照从右向左的顺序组合。也就是说，它等价于 <code>sizeof(*p)</code>。其次，因为 <code>sizeof</code> 不会实际求运算对象的值，所以即使 p 是一个无效（即未初始化）的指针也不会有什么影响。<strong>在 <code>sizeof</code> 的运算对象中解引用一个无效指针仍然是一种安全的行为，因为指针实际上并没有被真正使用。</strong><code>sizeof</code> 不需要真的解引用指针也能知道它所指对象的类型。C++11 新标准允许我们使用作用域运算符来获取类成员的大小。通常情况下只有通过类的对象才能访问到类的成员，但是 <strong><code>sizeof</code> 运算符无须我们提供一个县体的对象，因为要想知道类成员的大小无须真的获取该成员</strong>。</p>
</li>
<li><p><code>sizeof</code> 运算符的结果部分地依赖于其作用的类型：</p>
<ul>
<li>对 <code>char</code> 或者类型为 <code>char</code> 的表达式执行 <code>sizeof</code> 运算，结果得 1。</li>
<li>对引用类型执行 <code>sizeof</code> 运算得到被引用对象所占空间的大小。</li>
<li>对指针执行 <code>sizeof</code> 运算得到指针本身所占空间的大小。</li>
<li>对解引用指针执行 <code>sizeof</code> 运算得到指针指向的对象所占空间的大小，指针不需有效。</li>
<li>对数组执行 <code>sizeof</code> 运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次 <code>sizeof</code> 运算并将所得结果求和。注意，<strong><code>sizeof</code> 运算不会把数组转换成指针来处理</strong>。</li>
<li>对 <code>string</code> 对象或 <code>vector</code> 对象执行 <code>sizeof</code> 运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。<br><br></li>
</ul>
<p>因为执行 <code>sizeof</code> 运算能得到整个数组的大小，所以可以用数组的大小除以单个元素的大小得到数组中元素的个数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="keyword">sizeof</span>(ia) / <span class="keyword">sizeof</span>(*ia);</span><br><span class="line"><span class="keyword">int</span> arr2[sz];  <span class="comment">// 正确：sizeof 返回一个常量表达式</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>sizeof</code> 的返回值是一个常量表达式，所以我们可以用 <code>sizeof</code> 的结果声明数组的维度。</p>
</li>
<li><p>观察下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">3.541</span> + <span class="number">3</span>;  <span class="comment">// 编译器可能会警告该运算损失了精度</span></span><br></pre></td></tr></table></figure>
<p>算数类型之间的隐式转换被设计得尽可能避免损失精度。很多时候，<strong>如果表达式中既有整数类型的运算对象也有浮点数类型的运算对象，整型会转换成浮点型</strong>。在上面的例子中，3 转换成 <code>double</code> 类型，然后执行浮点数加法，所得结果的类型是 <code>double</code>。在初始化过程中，因为<strong>被初始化的对象的类型无法改变</strong>，所以初始值被转换成该对象的类型。仍以这个例子说明，加法运算得到的 <code>double</code> 类型的结果转换成 <code>int</code> 类型的值，这个值被用来初始化 ival。由 <code>double</code> 向 <code>int</code> 转换时忽略掉了小数部分，上面的表达式中，数值 6 被赋给了 ival。</p>
</li>
<li><p>何时发生隐式类型转换：</p>
<ul>
<li>在大多数表达式中，比 <code>int</code> 类型小的整型值首先提升为较大的整数类型；</li>
<li>在条件中，非布尔值转换成布尔类型；</li>
<li>初始化过程中，初始值转换成变量的类型；在赋值语句中，右侧运算对象转换成左侧运算对象的类型；</li>
<li>如果算术运算或关系运算的运算对象有多种类型，需要转换成同一种类型；</li>
<li>函数调用时也会发生类型转换。<br><br></li>
</ul>
</li>
<li><p><strong>算术转换</strong>的规则定义了一套类型转换的层次，其中运算符的运算对象将转换成最宽的类型。例如，如果一个运算对象的类型是 <code>long double</code>，那么不论另外一个运算对象的类型是什么都会转换成 <code>long double</code>。还有一种更普遍的情况，当表达式中既有浮点类型也有整数类型时，整数值将转换成相应的浮点类型。</p>
</li>
<li><p><strong>整型提升</strong>（integral promotion）负责把小整数类型转换成较大的整数类型。对于 <code>bool</code>、<code>char</code>、<code>signed char</code>、<code>unsigned char</code>、<code>short</code> 和 <code>unsigned short</code>等 类型来说，只要它们所有可能的值都能存在<code>int</code>里，它们就会提升成 <code>int</code> 类型；否则，提升成 <code>unsigned int</code> 类型。就如我们所熟知的，布尔值 false 提升成 0、true 提升成 1。较大的 <code>char</code> 类型（<code>wchar_t</code>、<code>char16_t</code>、<code>char32_t</code>）提升成 <code>int</code>、<code>unsigned int</code>、<code>long</code>、<code>unsigned long</code>、<code>long long</code> 和 <code>unsigned long long</code> 中最小的一种类型，前提是转换后的类型要能容纳原类型所有可能的值。</p>
</li>
<li><p>如果某个运算符的运算对象类型不一致，这些运算对象将转换成同一种类型。但是如果某个运算对象的类型是无符号类型，那么转换的结果就要依赖于机器中各个整数类型的相对大小了。像往常一样，首先执行整型提升。如果结果的类型匹配，无须进行进一步的转换。如果两个（提升后的）运算对象的类型要么都是带符号的、要么都是无符号的，则小类型的运算对象转换成较大的类型。<strong>如果一个运算对象是无符号类型，另外一个运算对象是带符号类型，而且其中的无符号类型不小于带符号类型，那么带符号的运算对象转换成无符号的。</strong>例如，假设两个类型分别是 <code>unsigned int</code> 和 <code>int</code>，则<code>int</code>类型的运算对象转换成 <code>unsigned int</code> 类型。需要注意的是，如果 <code>int</code> 型的值恰好为负值，可能得到意想不到的结果。剩下的一种情况是带符号类型大于无符号类型，此时转换的结果依赖于机器。如果无符号类型的所有值都能存在该带符号类型中，则无符号类型的运算对象转换成带符号类型。如果不能，那么带符号类型的运算对象转换成无符号类型。例如，如果两个运算对象的类型分别是<code>long</code>和 <code>unsigned int</code>，并且 <code>int</code> 和 <code>long</code> 的大小相同，则 <code>long</code> 类型的运算对象转换成<code>unsigned int</code> 类型；如果 <code>long</code> 类型占用的空间比 <code>int</code> 更多，则 <code>unsigned int</code> 类型的运算对象转换成 <code>long</code> 类型。</p>
</li>
<li><p>其它隐式类型转换：</p>
<ul>
<li><strong>数组转换成指针</strong>。在大多数用到数组的表达式中，数组自动转换成指向数组首元素的指针。当数组被用作 <code>decltype</code> 关键字的参数，或者作为取地址符（&amp;）、<code>sizeof</code> 及 <code>typeid</code> 等运算符的运算对象时，上述转换不会发生。同样的，如果用一个引用来初始化数组，上述转换也不会发生。当在表达式中使用函数类型时会发生类似的指针转换；</li>
<li><strong>指针的转换</strong>。C++还规定了几种其他的指针转换方式，包括常量整数值 0 或者字面值<code>nullptr</code> 能转换成任意指针类型；指向任意非常量的指针能转换成 <code>void*</code>；指向任意对象的指针能转换成 <code>const void*</code>；</li>
<li><strong>转换成布尔类型</strong>。存在一种从算术类型或指针类型向布尔类型自动转换的机制。如果指针或算术类型的值为 0，转换结果是 false；否则转换结果是 true；</li>
<li><p><strong>转换成常量</strong>。允许将指向非常量类型的指针转换成指向相应的常量类型的指针，对于引用也是这样。也就是说，<strong>如果 T 是一种类型，我们就能将指向 T 的指针或引用分别转换成指向<code>const T</code> 的指针或引用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;j = i;   <span class="comment">// 非常量转换成 const int 的引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = &amp;i;  <span class="comment">// 非常量的地址转换成 const 的地址</span></span><br><span class="line"><span class="keyword">int</span> &amp;r = j, *q = p; <span class="comment">// 错误：不允许 const 转换成非常量</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>类类型定义的转换</strong>。有下面的程序片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s; <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br></pre></td></tr></table></figure>
<p>IO 库定义了从 <code>istream</code> 向布尔值转换的规则，根据这一规则，<code>cin</code> 自动地转换成布尔值。所得的布尔值到底是什么由输入流的状态决定，<strong>如果最后一次读入成功，转换得到的布尔值是 true；相反，如果最后一次读入不成功，转换得到的布尔值是 false</strong>。</p>
</li>
</ul>
</li>
<li><p>现代 C++ 中有四种<strong>强制类型转换</strong>（cast）形式：<strong><code>static_cast</code></strong>、<strong><code>dynamic_cast</code></strong>、<strong><code>const_cast</code></strong> 和 <strong><code>reinterpret_cast</code></strong>。<code>dynamic_cast</code> 支持运行时类型识别。</p>
<ul>
<li><p><strong><code>static_cast</code></strong>。任何具有明确定义的类型转换，只要不包含底层 <code>const</code>，都可以使用 <code>static_cast</code>。当需要把一个较大的算术类型赋值给较小的类型时，<code>static_cast</code> 非常有用。此时，强制类型转换告诉程序的读者和编译器：我们知道并且不在乎潜在的精度损失。一般来说，如果编译器发现一个较大的算术类型试图赋值给较小的类型，就会给出警告信息；但是当我们执行了显式的类型转换后，警告信息就会被关闭了。<code>static_cast</code> 对于编译器无法自动执行的类型转换也非常有用。例如，我们可以使用<code>static_cast</code>找回存在于<code>void_</code> 指针中的值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* p = &amp;d; <span class="comment">// 正确：任何非常量对象的地址都能存入 void*</span></span><br><span class="line"><span class="comment">// 正确：将 void* 转换回初始的指针类型</span></span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>
<p>当我们把指针存放在 <code>void*</code> 中，并且使用 <code>static_cast</code> 将其强制转换回原来的类型时，应该确保指针的值保持不变。也就是说，强制转换的结果将与原始的地址值相等，因此我们必须确保转换后所得的类型就是指针所指的类型。类型一旦不符，将产生未定义的后果。即，<strong>从哪里来，回哪里去</strong>。</p>
</li>
<li><p><strong><code>const_cast</code></strong>。<code>const_cast</code> 只能改变运算对象的底层 <code>const</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">char</span> *p = <span class="keyword">const_cast</span>&lt;<span class="keyword">char</span>*&gt;(pc); <span class="comment">// 正确：但是通过 p 值是未定义的行为</span></span><br></pre></td></tr></table></figure>
<p>对于将常量对象转换成非常量对象的行为，我们一般称其为“去掉 <code>const</code> 性质（cast awaythe const）”。一旦我们去掉了某个对象的 <code>const</code> 性质，编译器就不再阻止我们对该对象进行写操作了。<strong>如果对象本身不是一个常量，使用强制类型转换获得写权限是合法的行为。然而如果对象是一个常量，再使用 <code>const_cast</code> 执行写操作就会产生未定义的后果。</strong> 只有 <code>const_cast</code> 能改变表达式的常量属性，使用其他形式的命名强制类型转换改变表达式的常量属性都将引发编译器错误。同样的，也不能用 <code>const_cast</code> 改变表达式的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp;</span><br><span class="line"><span class="comment">// 错误：static_cast 不能转换掉 const 性质</span></span><br><span class="line"><span class="keyword">char</span> *q = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(cp);</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="built_in">string</span>&gt;(cp); <span class="comment">// 正确：字符串字面值转换成 string 类型</span></span><br><span class="line"><span class="keyword">const_cast</span>&lt;<span class="built_in">string</span>&gt;(cp);  <span class="comment">// 错误：const_cast 只改变常量属性</span></span><br></pre></td></tr></table></figure>
<p><code>const_cast</code> 常常用于有函数重载的上下文中。</p>
</li>
<li><p><strong><code>reinterpret_cast</code></strong>。<code>reinterpret_cast</code> 通常为运算对象的位模式提供较低层次上的重新解释。在工程应用中编写 udp2lcm 程序时曾使用过这种强制类型转换。有如下代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line"><span class="keyword">char</span> *pc = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">char</span>*&gt;(ip);</span><br></pre></td></tr></table></figure>
<p>我们必须牢记 pc 所指的真实对象是一个 <code>int</code> 而非字符，如果把 pc 当成普通的字符指针使用就可能在运行时发生错误。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(pc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可能导致异常的运行时行为。使用 <code>reinterpret_cast</code> 是非常危险的，用 pc 初始化 str 的例子很好地证明了这一点。其中的关键问题是类型改变了，但编译器没有给出任何警告或者错误的提示信息。当我们用一个 <code>int</code> 的地址初始化 pc 时，由于显式地声称这种转换合法，所以编译器不会发出任何警告或错误信息。接下来再使用 pc 时就会认定它的值是 <code>char*</code> 类型，编译器没法知道它实际存放的是指向 <code>int</code> 的指针。最终的结果就是，在上面的例子中虽然用 pc 初始化 str 没什么实际意义，甚至还可能引发更糟糕的后果，但仅从语法上而言这种操作无可指摘。查找这类问题的原因非常困难，如果将 ip 强制转换成 pc 的语句和用 pc 初始化 <code>string</code> 对象的语句分属不同文件就更是如此。<br><br></p>
</li>
</ul>
</li>
<li><p>当我们在某处执行旧式的强制类型转换时，如果换成 <code>const_cast</code> 和 <code>static_cast</code> 也合法，则其行为与对应的命名转换一致。如果替换后不合法，则旧式强制类型转换执行与 <code>reinterpret_cast</code> 类似的功能。</p>
</li>
<li><p>用命名的强制类型转换改写下列旧式的转换语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">double</span> d;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *ps;</span><br><span class="line"><span class="keyword">char</span> *pc;</span><br><span class="line"><span class="keyword">void</span> *pv;</span><br><span class="line">pv = (<span class="keyword">void</span>*)ps;  <span class="comment">// (a)</span></span><br><span class="line">i = <span class="keyword">int</span>(*pc);    <span class="comment">// (b)</span></span><br><span class="line">pv = &amp;d;         <span class="comment">// (c)</span></span><br><span class="line">pc = (<span class="keyword">char</span>*)pv;  <span class="comment">// (d)</span></span><br></pre></td></tr></table></figure>
<p>对于语句（a），需要先使用 <code>const_cast</code> 去掉 ps 的底层 <code>const</code> 性质，然后再使用 <code>static_cast</code> 进行类型转换；其它语句直接使用 <code>static_cast</code> 进行类型转换即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pv = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(<span class="keyword">const_cast</span>&lt;<span class="built_in">string</span> *&gt;(ps));</span><br><span class="line">i = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(*pc);</span><br><span class="line">pv = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span> *&gt;(&amp;d);</span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(pv);</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键术语表：</p>
<ul>
<li><strong><code>const_cast</code></strong> 一种涉及 <code>const</code> 的强制类型转换。将底层 <code>const</code> 对象转换成对应的非常量类型，或者执行相反的转换。</li>
<li><strong><code>dynamic_cast</code></strong> 和继承及运行时类型识别一起使用。</li>
<li><strong>整型提升（integral promotion）</strong> 把一种较小的整数类型转换成与之最接近的较大整数类型的过程。不论是否真的需要，小整数类型（即 <code>short</code>、<code>char</code> 等）总是会得到提升。</li>
<li><strong>短路求值（short-circuit evaluation）</strong> 是一个专有名词，描述逻辑与运算符和逻辑或运算符的执行过程。如果根据运算符的第一个运算对象就能确定整个表达式的结果，求值终止，此时第二个运算对象将不会被求值。</li>
<li><strong>, 运算符（, operator）</strong> 逗号运算符，是一种从左向右求值的二元运算符。逗号运算符的结果是右侧运算对象的值，<strong>当且仅当右侧运算对象是左值时逗号运算符的结果是左值</strong>。</li>
<li><strong>++ 运算符（++ operator）</strong> 递增运算符。包括两种形式：前置版本和后置版本。<strong>前置递增运算符得到一个左值，它给运算符加 1 并得到运算对象改变后的值。后置递增运算符得到一个右值，它给运算符加 1 并得到运算对象原始的、未改变的值的副本。</strong>注意：即使迭代器没有定义+运算符，也会有++运算符。</li>
<li><strong>- - 运算符（- - operator）</strong> 递减运算符。包括两种形式：前置版本和后置版本。<strong>前置递减运算符得到一个左值，它从运算符减 1 并得到运算对象改变后的值。后置递减运算符得到一个右值，它从运算符减 1 并得到运算对象原始的、未改变的值的副本。</strong>注意：即使迭代器没有定义 - 运算符，也会有 - - 运算符。</li>
</ul>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 8 章 IO 库</title>
    <url>/archives/f6bc4afa.html</url>
    <content><![CDATA[<ol>
<li><p>继承机制使我们可以声明一个特定的类继承自另一个类。我们通常可以将一个派生类（继承类）对象当作其基类（所继承的类）对象来使用。类型 <code>ifstream</code> 和 <code>istringstream</code> 都继承自 <code>istream</code>。因此，我们可以像使用 <code>istream</code> 对象一样来使用 <code>ifstream</code> 和 <code>istringstream</code> 对象。也就是说，我们是如何使用 <code>cin</code> 的，就可以同样地使用这些类型的对象。例如，<strong>可以对一个 <code>ifstream</code> 或 <code>istringstream</code> 对象调用 <code>getline</code>，也可以使用 <code>&gt;&gt;</code> 从一个 <code>ifstream</code> 或 <code>istringstream</code> 对象中读取数据</strong>。类似的，类型 <code>ofstream</code> 和 <code>ostringstream</code> 都继承自 <code>ostream</code>。因此，我们是如何使用 <code>cout</code> 的，就可以同样地使用这些类型的对象。</p>
</li>
<li><p>不能拷贝或对 IO 对象赋值。<strong>由于不能拷贝 IO 对象，因此我们也不能将形参或返回类型设置为流类型。进行 IO 操作的函数通常以引用方式传递和返回流。读写一个 IO 对象会改变其状态，因此传递和返回的引用不能是 <code>const</code> 的。</strong></p>
</li>
<li><p>一个流一旦发生错误，其上后续的 IO 操作都会失败。只有当一个流处于无错状态时，我们才可以从它读取数据，向它写入数据。由于流可能处于错误状态，因此代码通常应该在使用一个流之前检查它是否处于良好状态。确定一个流对象的状态的最简单的方法是将它当作一个条件来使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    <span class="comment">// ok：读操作成功.....</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>操作 <code>good</code> 在所有错误位均未置位的情况下返回 true，而 <code>bad</code>、<code>fail</code> 和 <code>eof</code> 则在对应错误位被置位时返回 true。此外，在 <code>badbit</code> 被置位时，<code>fail</code> 也会返回 true。这意味着，<strong>使用 <code>good</code> 或 <code>fail</code> 是确定流的总体状态的正确方法。实际上，我们将流当作条件使用的代码就等价于<code>!fail()</code></strong>。</p>
</li>
<li><p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。导致缓冲刷新（即，数据真正写到输出设备或文件）的原因有很多：</p>
<ul>
<li>程序正常结束，作为 <code>main</code> 函数的 <code>return</code> 操作的一部分，缓冲刷新被执行。</li>
<li>缓冲区满时，需要刷新缓冲，而后新的数据才能继续写入缓冲区。</li>
<li>可以使用操纵符如 <code>endl</code> 来显式刷新缓冲区。</li>
<li>在每个输出操作之后，可以用操纵符 <code>unitbuf</code> 设置流的内部状态，来清空缓冲区。默认情况下，对 <code>cerr</code> 是设置 <code>unitbuf</code> 的，因此写到 <code>cerr</code> 的内容都是立即刷新的。</li>
<li>一个输出流可能被关联到另一个流。在这种情况下，当读写被关联的流时，关联到的流的缓冲区会被刷新。例如，<strong>默认情况下，<code>cin</code> 和 <code>cerr</code> 都关联到 <code>cout</code>。因此，读 <code>cin</code> 或写 <code>cerr</code> 都会导致 <code>cout</code> 的缓冲区被刷新</strong>。<br><br></li>
</ul>
</li>
<li><p>操纵符 <code>endl</code>，它完成换行并刷新缓冲区的工作。IO 库中还有两个类似的操纵符：<code>flush</code> 和 <code>ends</code>。<code>flush</code> 刷新缓冲区，但不输出任何额外的字符；<code>ends</code> 向缓冲区插入一个空字符，然后刷新缓冲区。</p>
</li>
<li><p>如果想在每次输出操作后都刷新缓冲区，我们可以使用 <code>unitbuf</code> 操纵符。它告诉流在接下来的每次写操作之后都进行一次 <code>flush</code> 操作。而 <code>nounitbuf</code> 操纵符则重置流，使其恢复使用正常的系统管理的缓冲区刷新机制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;  <span class="comment">// 所有输出操作后都会立即刷新缓冲区</span></span><br><span class="line"><span class="comment">// 任何输出都立即刷新，无缓冲</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;  <span class="comment">// 回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果程序异常终止，输出缓冲区是不会被刷新的。当一个程序崩溃后，它所输出的数据很可能停留在输出缓冲区中等待打印。</p>
</blockquote>
</li>
<li><p><strong>当一个输入流被关联到一个输出流时，任何试图从输入流读取数据的操作都会先刷新关联的输出流。</strong> 既可以将一个 <code>istream</code> 对象关联到另一个 <code>ostream</code>，也可以将一个 <code>ostream</code> 关联到另一个 <code>ostream</code>。每个流同时最多关联到一个流，但多个流可以同时关联到同一个 <code>ostream</code>。</p>
</li>
<li><p>头文件 <code>fstream</code> 定义了三个类型来支持文件 IO：<code>ifstream</code> 从一个给定文件读取数据，<code>ofstream</code> 向一个给定文件写入数据，以及 <code>fstream</code> 可以读写给定文件。</p>
</li>
<li><p>创建文件流对象时，我们可以提供文件名（可选的）。如果提供了一个文件名，则 <code>open</code> 会自动被调用。在新 C++ 标准中，文件名既可以是库类型 <code>string</code> 对象，也可以是 C 风格字符数组。</p>
</li>
<li><p>在要求使用基类型对象的地方，我们可以用继承类型的对象来替代。这意味着，接受一个 <code>iostream</code> 类型引用（或指针）参数的函数，可以用一个对应的 <code>fstream</code>（或 <code>sstream</code>）类型来调用。也就是说，如果有一个函数接受一个 <code>ostream&amp;</code> 参数，我们在调用这个函数时，可以传递给它一个 <code>ofstream</code> 对象，对 <code>istream&amp;</code> 和 <code>ifstream</code> 也是类似的。</p>
</li>
<li><p>如果我们定义了一个空文件流对象，可以随后调用 <code>open</code> 来将它与文件关联起来。如果调用 <code>open</code> 失败，<code>failbit</code> 会被置位。因为调用 <code>open</code> 可能失败，进行 <code>oppen</code> 是否成功的检测通常是一个好习惯。一旦一个文件流已经打开，它就保持与对应文件的关联。实际上，<strong>对一个已经打开的文件流调用 <code>open</code> 会失败，并会导致 <code>failbit</code> 被置位。随后的试图使用文件流的操作都会失败</strong>。为了将文件流关联到另外一个文件，必须首先关闭已经关联的文件。一旦文件成功关闭，我们可以打开新的文件。</p>
</li>
<li><p>当一个 <code>fstream</code> 对象离开其作用域时，与之关联的文件会自动关闭。</p>
</li>
<li><p>编写函数，以读模式打开一个文件，将其内容读入到一个 <code>string</code> 的 <code>vector</code> 中，将每一行作为一个独立的元素存于 <code>vector</code> 中，将每个单词作为一个独立的元素存储在另一个 <code>vector</code> 中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(<span class="string">"license.txt"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; vs_line, vs_word;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (input)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (getline(input, s))</span><br><span class="line">            vs_line.push_back(s);</span><br><span class="line"></span><br><span class="line">        input.clear();  <span class="comment">// 复位输入文件流状态为 true（输入文件流遇到文件尾状态会被置为 false）</span></span><br><span class="line">        input.seekg(<span class="number">0</span>); <span class="comment">// 返回输入文件流首位置</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (input &gt;&gt; s)</span><br><span class="line">            vs_word.push_back(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"Wrong input file stream."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output by line: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = vs_line.begin(); iter != vs_line.end(); ++iter)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Output by word: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">""</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = vs_word.begin(); iter != vs_word.end(); ++iter)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个流都有一个关联的<strong>文件模式</strong>（file mode）。如下表所示：</p>
<table>
<thead>
<tr>
    <th colspan="2"><center>文件模式</center></th>
</tr>
</thead>
<tbody>
<tr>
    <td>in</td>
    <td>以读方式打开</td>
</tr>
<tr>
    <td>out</td>
    <td>以写方式打开</td>
</tr>
<tr>
    <td>app</td>
    <td>每次写操作均定位到文件末尾</td>
</tr>
<tr>
    <td>ate</td>
    <td>打开文件后立即定位到文件末尾</td>
</tr>
<tr>
    <td>trunc</td>
    <td>截断文件</td>
</tr>
<tr>
    <td>binary</td>
    <td>以二进制方式进行 IO</td>
</tr>
</tbody>
</table>

<p>无论用哪种方式打开文件，我们都可以指定文件模式，调用 <code>open</code> 打开文件时可以，用一个文件名初始化流来隐式打开文件时也可以。指定文件模式有如下限制：</p>
<ul>
<li>只可以对 <code>ofstream</code> 或 <code>fstream</code> 对象设定 <code>out</code> 模式。</li>
<li>只可以对 <code>ifstream</code> 或 <code>fstream</code> 对象设定 <code>in</code> 模式。</li>
<li>只有当 <code>out</code> 也被设定时才可设定 <code>trunc</code> 模式。</li>
<li>只要 <code>trunc</code> 没被设定，就可以设定 <code>app</code> 模式。在 <code>app</code> 模式下，即使没有显式指定 <code>out</code> 模式，文件也总是以输出方式被打开。</li>
<li>默认情况下，即使我们没有指定 <code>trunc</code>，以 <code>out</code> 模式打开的文件也会被截断。为了保留以 <code>out</code> 模式打开的文件的内容，我们必须同时指定 <code>app</code> 模式，这样只会将数据追加写到文件末尾；或者同时指定 <code>in</code> 模式，即打开文件同时进行读写操作。</li>
<li><code>ate</code> 和 <code>binary</code> 模式可用于任何类型的文件流对象，且可以与其他任何文件模式组合使用。<br><br></li>
</ul>
<p>每个文件流类型都定义了一个默认的文件模式，当我们未指定文件模式时，就使用此默认模式。与 <code>ifstream</code> 关联的文件默认以 <code>in</code> 模式打开；与 <code>ofstream</code> 关联的文件默认以 <code>out</code> 模式打开；与 <code>fstream</code> 关联的文件默认以 <code>in</code> 和 <code>out</code> 模式打开。</p>
</li>
<li><p>默认情况下，当我们打开一个 <code>ofstream</code> 时，文件的内容会被丢弃。阻止一个 <code>ofstream</code> 清空给定文件内容的方法是同时指定 <code>app</code> 模式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在这几条语句中，file1 都被截断</span></span><br><span class="line"><span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">"file1"</span>)</span></span>;  <span class="comment">// 隐含以输出模式打开文件并截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out2</span><span class="params">(<span class="string">"file1"</span>, ofstream::out)</span></span>;  <span class="comment">// 隐含地截断文件</span></span><br><span class="line"><span class="function">ofstream <span class="title">out3</span><span class="params">(<span class="string">"file1"</span>, ofstream::out | ofstream::trunc)</span></span>;</span><br><span class="line"><span class="comment">// 为了保留文件内容，我们必须显式指定 app 模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app</span><span class="params">(<span class="string">"file2"</span>, ofstream::app)</span></span>;  <span class="comment">// 隐含为输出模式</span></span><br><span class="line"><span class="function">ofstream <span class="title">app2</span><span class="params">(<span class="string">"file2"</span>, ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WARNING：保留被 ofstream 打开的文件中已有数据的唯一方法是显式指定 app 或 in 模式。</p>
</blockquote>
</li>
<li><p><code>sstream</code> 头文件定义了三个类型来支持内存 IO，这些类型可以向 <code>string</code> 写入数据，从 <code>string</code> 读取数据，就像 <code>string</code> 是一个 IO 流一样。<code>istringstream</code> 从 <code>string</code> 读取数据，<code>ostringstream</code> 向 <code>string</code> 写入数据，而头文件 <code>stringstream</code> 既可从 <code>string</code> 读数据也可向 <code>string</code> 写数据。<code>stringstream</code> 特有的一些操作如下表所示：</p>
<table>
<thead>
<tr>
    <th colspan="2"><center>stringstream特有的操作</center></th>
</tr>
</thead>
<tbody>
<tr>
    <td>sstream strm;</td>
    <td>strm 是一个未绑定的 stringstream 对象。sstream 是头文件 sstream 中定义的一个类型</td>
</tr>
<tr>
    <td>sstream strm(s);</td>
    <td>strm 是一个 sstream 对象，保存 strings 的一个拷贝。此构造函数是 explicit 的</td>
</tr>
<tr>
    <td>strm.str()</td>
    <td>返回 strm 所保存的 string 的拷贝</td>
</tr>
<tr>
    <td>strm.str(s)</td>
    <td>将 string s 拷贝到 strm 中，返回 void</td>
</tr>
</tbody>
</table>
</li>
<li><p>每个 IO 对象都维护一组条件状态，用来指出此对象上是否可以进行 IO 操作。如果遇到了错误——例如<strong>在输入流上遇到了文件末尾，则对象的状态变为失效，所有后续输入操作都不能执行，直至错误被纠正</strong>。标准库提供了一组函数，用来设置和检测这些状态。</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Git版本库管理最佳实践——以跟踪仓库指定分支下的代码为例</title>
    <url>/archives/77718b2.html</url>
    <content><![CDATA[<h1 id="1-背景" class="heading-control"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景<a class="heading-anchor" href="#1-背景" aria-hidden="true"></a></h1><blockquote>
<p>在本地同步追踪某个远程仓库的某一分支（以develop分支为例）。</p>
</blockquote>
<h1 id="2-问题" class="heading-control"><a href="#2-问题" class="headerlink" title="2 问题"></a>2 问题<a class="heading-anchor" href="#2-问题" aria-hidden="true"></a></h1><p>起初先进行了如下操作：</p>
<ul>
<li>创建一个文件夹，初始化为git仓库：<code>git init</code></li>
<li>进行用户基本信息配置：<code>git config</code></li>
<li>创建本地仓库的develop分支：<code>git checkout -b</code></li>
<li>关联远程仓库git地址：<code>git remote add</code></li>
</ul>
<p>接下来，尝试通过<code>git branch --set-upstream-to</code>将本地仓库develop分支与远程仓库develop分支进行关联时报错：develop分支不存在。使用<code>git branch -r</code>发现远程仓库分支为空，其实使用<code>git branch -a</code>可以发现根本看不到任何分支。</p>
<h1 id="3-解决" class="heading-control"><a href="#3-解决" class="headerlink" title="3 解决"></a>3 解决<a class="heading-anchor" href="#3-解决" aria-hidden="true"></a></h1><p>因为仅仅是关联了远程仓库，本地仓库并未获取远程仓库的修改（包括分支信息），所以本地看不到远程仓库的分支，也就无法进行分支关联操作。以<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGVvZGF4aW4vcC84NTY5MDYxLmh0bWw=" title="https://www.cnblogs.com/leodaxin/p/8569061.html">参考1<i class="fa fa-external-link"></i></span>中的建议，在将本地仓库分支与远程仓库分支进行关联前，可先通过<code>git fetch origin</code>命令拉取远程仓库的修改，这样便可获取远程仓库分支信息，但还无法看到本地分支。最佳实践是使用<code>git pull origin develop</code>命令（前提是你必须知道想要将远程仓库的哪个分支并入本地分支），便可看到远程仓库的develop分支和本地仓库的develop分支（当前分支），进而可进行分支关联操作。</p>
<h1 id="4-结论" class="heading-control"><a href="#4-结论" class="headerlink" title="4 结论"></a>4 结论<a class="heading-anchor" href="#4-结论" aria-hidden="true"></a></h1><p>总结一下最佳实践：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">git checkout -b local_branch</span><br><span class="line">git remote add origin repo_addr</span><br><span class="line">git pull origin repo_branch</span><br><span class="line">git branch --<span class="built_in">set</span>-upstream-to=origin/repo_branch local_branch</span><br><span class="line">git fetch --all</span><br></pre></td></tr></table></figure>
<p>当然，直接使用<code>git clone</code>也是可以的（<strong>这才应该算是最佳实践！</strong>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> repo_addr</span><br><span class="line"><span class="built_in">cd</span> repo_dir</span><br><span class="line">git checkout target_repo_branch</span><br></pre></td></tr></table></figure>
<p><code>git checkout target_repo_branch</code>将自动在本地创建一个名为target_repo_branch的分支，并将其与远程仓库中的target_repo_branch分支进行关联。执行完<code>git clone</code>后，默认在本地仓库创建的是master分支，并将其与远程仓库的master分支进行关联，但通常情况下，maser分支仅用于版本释放，我们并不会直接向mater分支推送修改，而是在其它分支（如develop分支）完成开发与调试后，再通过<code>git merge</code>将分支上的工作并入master分支。</p>
<h1 id="5-参考" class="heading-control"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考<a class="heading-anchor" href="#5-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGVvZGF4aW4vcC84NTY5MDYxLmh0bWw=" title="https://www.cnblogs.com/leodaxin/p/8569061.html">Git branch -r 无法获取远程分支，ui可以看见分支但是git 命令无法查看解决方案<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 6 章 函数</title>
    <url>/archives/fb22e988.html</url>
    <content><![CDATA[<ol>
<li><p>我们通过<strong>调用运算符</strong>（call operator）来执行函数。调用运算符的形式是一对圆括号，它作用于一个表达式，该表达式是函数或者指向函数的指针；圆括号之内是一个用逗号隔开的实参（argument）列表，我们用实参初始化函数的形参。调用表达式的类型就是函数的返回类型。</p>
</li>
<li><p>函数的调用完成两项工作：一是用实参初始化函数对应的形参，二是将控制权转移给被调用函数。此时，<strong>主调函数</strong>（calling function）的执行被暂时中断，被调函数（called function）开始执行。</p>
</li>
<li><p>执行函数的第一步是（隐式地）定义并初始化它的形参，即创建与形参同名的匿名变量。</p>
</li>
<li><p>实参是形参的初始值。第一个实参初始化第一个形参，第二个实参初始化第二个形参，以此类推。尽管实参与形参存在对应关系，但是并没有规定实参的求值顺序。编译器能以任意可行的顺序对实参求值。</p>
</li>
<li><p><strong>函数的调用规定实参数量应与形参数量一致</strong>，所以形参一定会被初始化。</p>
</li>
<li><p>不能将 <code>const char*</code> 转换成 <code>int</code>。</p>
</li>
<li><p>形参名是可选的，但是由于我们无法使用未命名的形参，所以形参一般都应该有个名字。偶尔，函数确实有个别形参不会被用到，则此类形参通常不命名以表示在函数体内不会使用它。不管怎样，是否设置未命名的形参并不影响调用时提供的实参数量。<strong>即使某个形参不被函数使用，也必须为它提供一个实参。</strong></p>
</li>
<li><p>函数的返回类型不能是数组类型或函数类型，但可以是指向数组或函数的指针。</p>
</li>
<li><p>在 C++ 语言中，名字有作用域，对象有<strong>生命周期</strong>（lifetime）：</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见；</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间。<br><br></li>
</ul>
</li>
<li><p>形参和函数体内部定义的变量统称为<strong>局部变量</strong>（local variable）。它们对函数而言是“局部”的，仅在函数的作用域内可见，同时局部变量还会<strong>隐藏</strong>（hide）外层作用域中同名的其他所有声明。在所有函数体之外定义的对象存在于程序的整个执行过程中。此类对象在程序启动时被创建，直到程序结束才会销毁。</p>
</li>
<li><p>把只存在于块执行期间的对象称为<strong>自动对象</strong>（automatic object）。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。形参是一种自动对象。<strong>函数开始时为形参申请存储空间，因为形参定义在函数体作用域之内，所以一旦函数终止，形参也就被销毁。</strong> 内置类型的未初始化局部变量将产生未定义的值。</p>
</li>
<li><p><strong>局部静态对象</strong>（local static object）在程序的执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁，在此期间即使对象所在的函数结束执行也不会对它有影响。<strong>内置类型的局部静态变量初始化为 0。</strong></p>
</li>
<li><p>函数只能定义一次，但可以声明多次。如果一个函数永远也不会被我们用到，那么它可以只有声明没有定义。</p>
</li>
<li><p>函数声明也称作<strong>函数原型</strong>（function prototype）。</p>
<blockquote>
<p>含有函数声明的头文件应该被包含到定义函数的源文件中。</p>
</blockquote>
</li>
<li><p>大多数编译器提供了分离式编译每个文件的机制，这一过程通常会产生一个后缀名是 .obj（Windows）或 .o（UNIX）的文件，后缀名的含义是该文件包含对象代码（object code）。</p>
</li>
<li><p>每次调用函数时都会重新创建它的形参，并用传入的实参对形参进行初始化。形参初始化的机理与变量初始化一样。</p>
</li>
<li><p>形参的类型决定了形参和实参交互的方式。<strong>如果形参是引用类型，它将绑定到对应的实参上：否则，将实参的值拷贝后赋给形参。</strong> 当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>（passed by reference）或者函数被<strong>传引用调用</strong>（called by reference）。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>（passed by value）或者函数被<strong>传值调用</strong>（called by value）。</p>
</li>
<li><blockquote>
<p>最佳实践：熟悉 C 的程序员常常使用指针类型的形参访问函数外部的对象。<strong>在 C++ 语言中，建议使用引用类型的形参替代指针。</strong></p>
</blockquote>
</li>
<li><p>拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型（包括 IO 类型在内）根本就不支持拷贝操作。<strong>当某种类型不支持拷贝操作时，函数只能通过引用形参访问该类型的对象。</strong></p>
</li>
<li><blockquote>
<p>最佳实践： 如果函数无须改变引用形参的值，最好将其声明为常量引用。</p>
</blockquote>
</li>
<li><p><strong>值传递形参既可以传入左值，也可以传入右值。非常量引用的初始值只能是左值。</strong></p>
</li>
<li><p>当用实参初始化形参时会忽略掉顶层 <code>const</code>。换句话说，形参的顶层 <code>const</code> 被忽略掉了。<strong>当形参有顶层 <code>const</code> 时，传给它常量对象或者非常量对象都是可以的。</strong></p>
</li>
<li><p><strong>可以使用非常量初始化一个底层 <code>const</code> 对象，但是反过来不行；同时一个普通的引用必须用同类型的对象初始化。</strong> 观察下面的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *cp = &amp;i;   <span class="comment">// 正确：但是 cp 不能改变 i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r = i;     <span class="comment">// 正确：但是 r 不能改变 i</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;   <span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span> *p = cp;          <span class="comment">// 错误：p 的类型和 cp 的类型不匹配</span></span><br><span class="line"><span class="keyword">int</span> &amp;r3 = r;          <span class="comment">// 错误：r3 的类型和 r 的类型不匹配</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = <span class="number">42</span>;         <span class="comment">// 错误：不能用字面值初始化一个非常量引用，即非常量引用的初值只能是左值</span></span><br></pre></td></tr></table></figure>
<p>C++ 允许我们用字面值初始化常量引用，常量引用的常量属性已经限制了函数体内部对所传入实参的修改操作，所以用字面值初始化函数的常量引用形参并无大碍。</p>
</li>
<li><p>把函数不会改变的形参定义成（普通的）引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型：我们<strong>不能把 <code>const</code> 对象、字面值或者需要类型转换的对象传递给普通的引用形参</strong>。</p>
</li>
<li><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响，这两个性质分别是：</p>
<ul>
<li>不允许拷贝数组；</li>
<li><p>使用数组时（通常）会将其转换成指针。<br><strong>因为不能拷贝数组，所以我们无法以值传递的方式使用数组参数。因为数组会被转换成指针，所以当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针。</strong> 尽管不能以值传递的方式传递数组，但是我们可以把形参写成类似数组的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尽管形式不同，但这三个 print 函数是等价的</span></span><br><span class="line"><span class="comment">// 每个函数都有一个 const int* 类型的形参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[])</span></span>;    <span class="comment">// 可以看出来，函数的意图是作用于一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>[<span class="number">10</span>])</span></span>;  <span class="comment">// 这里的维度表示我们期望数组含有多少元素，实际不一定</span></span><br></pre></td></tr></table></figure>
<p>数组的大小对函数的调用没有影响。</p>
<blockquote>
<p>WARNING：和其他使用数组的代码一样，以数组作为形参的函数也必须确保使用数组时不会越界。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>管理指针形参有三种常用的技术：</p>
<ul>
<li><strong>使用标记指定数组长度</strong><br>管理数组实参的第一种方法是要求数组本身包含一个结束标记，使用这种方法的典型示例是 C 风格字符串。<strong>C 风格字符串存储在字符数组中，并且在最后一个字符后面跟着一个空字符。</strong>这种方法适用于那些有明显结束标记且该标记不会与普通数据混淆的情况，但是对于像 <code>int</code> 这样所有取值都是合法值的数据就不太有效了。</li>
<li><strong>使用标准库规范</strong><br>管理数组实参的第二种技术是传递指向数组首元素和尾后元素的指针，这种方法受到了标准库技术的启发。</li>
<li><strong>显式传递一个表示数组大小的形参。</strong><br><br></li>
</ul>
</li>
<li><p><strong>当函数不需要对数组元素执行写操作的时候，数组形参应该是指向 <code>const</code> 的指针。只有当函数确实要改变元素值的时候，才把形参定义成指向非常量的指针。</strong></p>
</li>
<li><p><strong>形参也可以是数组的引用。此时，引用形参绑定到对应的实参上，也就是绑定到数组上</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> elem : arr)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; elem &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&amp;arr</code> 两端的括号必不可少：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f(<span class="keyword">int</span> &amp;arr[<span class="number">10</span>])    <span class="comment">// 错误：将 arr 声明成了引用的数组</span></span><br><span class="line">f(<span class="keyword">int</span> (&amp;arr)[<span class="number">10</span>])  <span class="comment">// 正确：arr 是具有 10 个整数的整型数组的引用</span></span><br></pre></td></tr></table></figure>
<p>因为数组的大小是构成数组类型的一部分，所以只要不超过维度，在函数体内就可以放心地使用数组。但是，这一用法也无形中限制了 <code>print</code> 函数的可用性，我们只能将函数作用于大小为 10 的数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">inti=<span class="number">0</span>, j[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">print(&amp;i);  <span class="comment">// 错误：实参不是含有 10 个整数的数组</span></span><br><span class="line">print(j);   <span class="comment">// 错误：实参不是含有 10 个整数的数组</span></span><br><span class="line">print(k);   <span class="comment">// 正确：实参是含有 10 个整数的数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和所有数组一样，当将多维数组传递给函数时，真正传递的是指向数组首元素的指针。因为我们处理的是数组的数组，所以首元素本身就是一个数组，指针就是一个指向数组的指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// matrix 指向数组的首元素，该数组的元素是由 10 个整数构成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> (*matrix)[<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>再一次强调，*matrix 两端的括号必不可少：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *matrix[<span class="number">10</span>];    <span class="comment">// 10 个指针构成的数组</span></span><br><span class="line"><span class="keyword">int</span> (*matrix)[<span class="number">10</span>];  <span class="comment">// 指向含有 10 个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
<p>也可以使用数组的语法定义函数，此时编译器会一如既往地忽略掉第一个维度：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价定义</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> matrix[][<span class="number">10</span>], <span class="keyword">int</span> rowSize)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>matrix 的声明看起来是一个二维数组，实际上形参是指向含有 10 个整数的数组的指针。</p>
</li>
<li><p>有时我们需要给 <code>main</code> 传递实参，一种常见的情况是用户通过设置一组选项来确定函数所要执行的操作。例如，假定 <code>main</code> 函数位于可执行文件 prog 之内，我们可以向程序传递下面的选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prog-d-0 ofile data0</span><br></pre></td></tr></table></figure>
<p>这些命令行选项通过两个（可选的）形参传递给 <code>main</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>第二个形参 argv 是一个数组，它的元素是指向 C 风格字符串的指针；第一个形参 argc 表示数组中字符串的数量。因为第二个形参是数组，所以 <code>main</code> 函数也可以定义成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>其中 argv 指向 <code>char*</code>。<strong>当实参传给 <code>main</code> 函数之后，argv 的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次传递命令行提供的实参。最后一个指针之后的元素值保证为 0。</strong> 以上面提供的命令行为例，argc 应该等于 5，argv 应该包含如下的 C 风格字符串：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">argv[<span class="number">0</span>] = <span class="string">"prog"</span>;  <span class="comment">// 或者 argv[0] 也可以指向一个空字符串</span></span><br><span class="line">argv[<span class="number">1</span>] = <span class="string">"-d"</span>;</span><br><span class="line">argv[<span class="number">2</span>] = <span class="string">"-o"</span>;</span><br><span class="line">argv[<span class="number">3</span>] = <span class="string">"ofile"</span>;</span><br><span class="line">argv[<span class="number">4</span>] = <span class="string">"data0"</span>;</span><br><span class="line">argv[<span class="number">5</span>] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WARNING：当使用 argv 中的实参时，一定要记得可选的实参从 argv[1] 开始；argv[0] 保存程序的名字，而非用户输入。</p>
</blockquote>
</li>
<li><p>为了编写能处理不同数量实参的函数，C++11 新标准提供了两种主要的方法：</p>
<ul>
<li>如果所有的实参类型相同，可以传递一个名为 <code>initializer_list</code> 的标准库类型；</li>
<li>如果实参的类型不同，可以编写一种特殊的函数，也就是所谓的可变参数<strong>模板</strong>。<br><br></li>
</ul>
</li>
<li><p>C++ 还有一种特殊的形参类型（即省略符），可以用它传递可变数量的实参。不过需要注意的是，这种功能一般只用于与 C 函数交互的接口程序。</p>
</li>
<li><p>如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用 <strong><code>initializer_list</code></strong> 类型的形参。<code>initializer_list</code> 是一种标准库类型，用于表示某种特定类型的值的数组。<code>initializer_list</code> 类型定义在同名的头文件中，它提供的操作如下表所示：</p>
<table>
<tbody>
<tr>
    <td colspan="2"><b><center>initializer_list 提供的操作</center></b></td>
</tr>
<tr>
    <td>initializer_list&lt;T&gt; lst;</td>
    <td>默认初始化；T类型元素的空列表</td>
</tr>
<tr>
    <td>initializer_list lst{a, b, c...};</td>
    <td>lst 的元素数量和初始值一样多；lst 的元素是对应初始值的副本；列表中的<br>元素是 const</td>
</tr>
<tr>
    <td>lst2(lst)</td>
    <td rowspan="2">拷贝或赋值一个 initializer_list 对象不会拷贝列表中的元素；拷贝后，<br>原始列表和副本共享元素</td>
</tr>
<tr>
    <td>lst2 = lst</td>
</tr>
<tr>
    <td>lst.size()</td>
    <td>列表中的元素数量</td>
</tr>
<tr>
    <td>lst.begin()</td>
    <td>返回指向lst中首元素的指针</td>
</tr>
<tr>
    <td>lst.end()</td>
    <td>返回指向lst中尾元素下一位置的指针</td>
</tr>
</tbody>
</table>

<p><strong>和 <code>vector</code> 一样，<code>initializer_list</code> 也是一种模板类型。定义 <code>initializer_list</code> 对象时，必须说明列表中所含元素的类型。和 <code>vector</code> 不一样的是，<code>initializer_list</code> 对象中的元素永远是常量值，我们无法改变 <code>initializer_list</code> 对象中元素的值。如果想向 <code>initializer_list</code> 形参中传递一个值的序列，则必须把序列放在一对花括号内。因为 <code>initializer_list</code> 包含 <code>begin</code> 和 <code>end</code> 成员，所以我们可以使用 <code>范围for</code> 循环处理其中的元素。</strong></p>
</li>
<li><p>省略符形参是为了便于 C++ 程序访问某些特殊的 C 代码而设置的。这些代码使用了名为 varargs 的 C 标准库功能。通常，省略符形参不应用于其它目的。</p>
<blockquote>
<p>WARNING：省略符形参应该仅仅用于 C 和 C++ 通用的类型。特别应该注意的是，大多数类类型的对象在传递给省略符形参时都无法正确拷贝。</p>
</blockquote>
<p><strong>省略符形参只能出现在形参列表的最后一个位置</strong>，它的形式无外乎以下两种：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(parm_list, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure>
<p><strong>省略符形参所对应的实参无须类型检查。</strong> 在第一种形式中，形参声明后面的逗号是可选的。</p>
</li>
<li><p>在 <code>范围for</code> 循环中使用 <code>initializer_list</code> 对象时，应该将循环控制变量声明成引用类型吗？为什么？<br>答：引用类型的优势主要是可以直接操作所引用的对象，以及避免拷贝较为复杂的类类型对象和容器对象。因为 <code>initializer_list</code> 对象的元素永远是常量值，所以我们不可能通过设定引用类型来更改循环控制变量的内容。只有当 <code>initializer_list</code> 对象的元素类型是类类型或容器类型（比如 <code>string</code>）时，才有必要把 <code>范围for</code> 循环的控制变量设为引用类型。参考自 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JsdWVfY29mZmVlaS9qYXZhL2FydGljbGUvZGV0YWlscy84ODk3MTE1Nw==" title="https://blog.csdn.net/blue_coffeei/java/article/details/88971157">C++ Primer 学习笔记及作业答案之第六章<i class="fa fa-external-link"></i></span>。</p>
</li>
<li><p><code>return</code> 语句有两种形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">return</span> expression;</span><br></pre></td></tr></table></figure>
<p><strong>没有返回值的 <code>return</code> 语句只能用在返回类型是 <code>void</code> 的函数中。返回 <code>void</code> 的函数不要求非得有 <code>return</code> 语句，因为在这类函数的最后一句后面会隐式地执行 <code>return</code>。</strong><br>一个返回类型是 <code>void</code> 的函数也能使用 <code>return</code> 语句的第二种形式，不过此时 <code>return</code> 语句的 expresssion 必须是另一个返回 <code>void</code> 的函数。强行令 <code>void</code> 函数返回其他类型的表达式将产生编译错误。</p>
</li>
<li><p><code>return</code> 语句返回值的类型必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。</p>
</li>
<li><p>返回一个值的方式和初始化一一 个变量或形参的方式完全一样：<strong>返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果</strong>。<strong>如果函数返回引用，则该引用仅是它所引对象的一个别名。</strong></p>
</li>
<li><p>函数完成后，它所占用的存储空间也随之被释放掉。因此，<strong>函数终止意味着局部变量的引用将指向不再有效的内存区域，不应返回局部对象的引用或指针</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 严重错误：这个函数试图返回局部对象的引用</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> &amp;<span class="title">mainip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ret;</span><br><span class="line">    <span class="comment">// 以某种方式改变一下 ret</span></span><br><span class="line">    <span class="keyword">if</span> (!ret.empty())</span><br><span class="line">        <span class="keyword">return</span> ret;  <span class="comment">// 错误：返回局部对象的引用！</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Empty"</span>;  <span class="comment">// 错误："Empty" 是一个局部临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第二条 <code>return</code> 语句中，字符串字面值转换成一个局部临时 <code>string</code> 对象，对于 manip 来说，该对象和 ret 一样都是局部的。</p>
</li>
<li><p><strong>调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。</strong>因此，如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用 string 对象的 size 成员，该 string 对象是由 shorterString 函数返回的</span></span><br><span class="line"><span class="keyword">auto</span> sz = shorterString(s1, s2).size();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>函数的返回类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以像使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值，如果返回类型 是常量引用，我们不能给调用的结果赋值。</strong></p>
</li>
<li><p><strong>C++11 新标准规定，函数可以返回花括号包围的值的列表。类似于其他返回结果，此处的列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// expected和actual是string对象</span></span><br><span class="line">    <span class="keyword">if</span> (expected.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 返回一个空vector对象</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (expected == actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"functionX"</span>, <span class="string">"okay"</span>&#125;;</span><br><span class="line">    <span class="comment">// 返回列表初始化的vector对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">"functionX"</span>, expected, actual&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一条 <code>return</code> 语句返回一个空列表，此时，proceess 函数返回的 <code>vector</code> 对象是空的。如果 expected 不为空，根据 expected 和 actual 是否相等，函数返回的 <code>vector</code> 对象分别用两个或三个元素初始化。<br>如果函数返回的是内置类型，则花括号包围的列表最多包含一个值而且该值所占空间不应该大于且标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。</p>
</li>
<li><p>允许 <code>main</code> 函数没有 <code>return</code> 语句直接结束。如果控制到达了 <code>main</code> 函数的结尾处而且没有 <code>return</code> 语句，编译器将隐式地插入一条返回 0 的 <code>return</code> 语句。<code>main</code> 函数的返回值可以看做是状态指示器。返回 0 表示执行成功，返回其他值表示执行失败，其中非 0 值的具体含义依机器而定。为了使返回值与机器无关，<code>cstdlib</code> 头文件定义了两个预处理变量：<code>EXIT_FAILURE</code> 和 <code>EXIT_SUCCESS</code>。<strong>因为它们是预处理变量，所以既不能在前面加上 <code>std::</code>，也不能在 <code>using</code> 声明中出现。</strong></p>
</li>
<li><p>如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为<strong>递归函数</strong>（recursive function）。在递归函数中，一定有某条路径是不包含递归调用的；否则，函数将“永远”递归下去，换句话说，函数将不断地调用它自身直到程序栈空间耗尽为止。我们有时候会说这种函数含有<strong>递归循环</strong>（recursion loop）。注意，<code>main</code> 函数不能调用它自己。</p>
</li>
<li><p>编写一个递归函数，输出 <code>vector</code> 对象的内容：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion_cout</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; v.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    v.pop_back();</span><br><span class="line">    recursion_cout(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>因为数组不能被拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];  <span class="comment">// arrT 是一个类型别名，它表示的类型是含有 10 个整数的数组</span></span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];  <span class="comment">// arrT 的等价声明</span></span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;     <span class="comment">// func 返回一个指向含有 10 个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];           <span class="comment">// arr 是一个含有 10 个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *p1[<span class="number">10</span>];           <span class="comment">// p1 是一个含有 10 个指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*p2)[<span class="number">10</span>] = &amp;arr;  <span class="comment">// p2 是一个指针，它指向含有 10 个整数的数组</span></span><br></pre></td></tr></table></figure>
<p><strong>如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。</strong> 返回数组指针的函数形式如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">type (*function(parameter_list)) [dimension]</span><br></pre></td></tr></table></figure>
<p><code>(*function(parameter_list))</code> 两端的括号必须存在，就像我们定义 p2 时两端必须有括号一样。如果没有这对括号，函数的返回类型将是指针的数组。</p>
</li>
<li><p>在 C++11 新标准中可以使用<strong>尾置返回类型</strong>（railing return type）简化函数声明。任何函数的定义都能使用尾置返回，但是这种形式对于返回类型比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个 <code>-&gt;</code> 符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个 <code>auto</code>：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func 接受一个 int 类型的实参，返回一个指针，该指针指向含有 10 个整数的数</span></span><br><span class="line">auto func(int i)-&gt;int(*)[10];</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果我们知道函数返回的指针将指向哪个数组，就可以使用 <code>decltype</code> 关键字声明返回类型。<code>decltype</code> 并不负责把数组类型转换成对应的指针，所以 <code>decltype</code> 的结果是个数组。<strong>对数组应用 <code>decltype</code> 关键字时，得到的推断类型是数组类型（包括数组维度在内）；使用数组作为一个 <code>auto</code> 变量的初始值时，得到的推断类型是指向数组元素类型的指针，而非数组。</strong></p>
</li>
<li><p>编写一个函数的声明，使其返回数组的引用并且该数组包含 10 个 <code>string</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> (&amp;func(parameter_list))[<span class="number">10</span>];          <span class="comment">// 普通声明方式</span></span><br><span class="line">typedef string (&amp;func(parameter_list))[10];  // 使用类型别的名声明方式</span><br><span class="line">auto func(parameter_list)-&gt;string(&amp;)[10];    // 使用尾置返回类型的声明方式</span><br><span class="line"><span class="built_in">string</span> s[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">decltype</span>(s) &amp;func(parameter_list);           <span class="comment">// 使用 decltype 关键字的声明方式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>同一作用域内的几个函数名字相同但形参列表不同，我们称之为<strong>重载</strong>（overloaded）<strong>函数</strong>。<strong><code>main</code> 函数不能重载。</strong></p>
</li>
<li><p>对于重载的函数来说，它们应该在形参数量或形参类型上有所不同。不允许两个函数除了返回类型外其他所有的要素都相同。</p>
</li>
<li><p><strong>有时候两个形参列表看起来不一样，但实际上是相同的</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每对声明的是同一个函数</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account &amp;acct)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;  <span class="comment">// 省略了形参的名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Phone Telno;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone&amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Telno&amp;)</span></span>;    <span class="comment">// Telno 和 Phone 的类型相同</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>顶层 <code>const</code> 不影响传入函数的对象。一个拥有顶层 <code>const</code> 的形参无法和另一个没有顶层 <code>const</code> 的形参区分开来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Phone)</span></span>;   <span class="comment">// 重复声明了Record lookup(Phone)</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone*)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone* <span class="keyword">const</span>)</span></span>;  <span class="comment">// 重复声明了Record lookup(Phone*)</span></span><br></pre></td></tr></table></figure>
<p><strong>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的 <code>const</code> 是底层的</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同</span></span><br><span class="line"><span class="comment">// 定义了 4 个独立的重载函数</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account&amp;)</span></span>;        <span class="comment">// 函数作用于 Account 的引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account&amp;)</span></span>;  <span class="comment">// 新函数，作用于常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;        <span class="comment">// 新函数，作用于指向 Account 的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;  <span class="comment">// 新函数，作用于指向常量的指针</span></span><br></pre></td></tr></table></figure>
<p><strong>编译器可以通过实参是否是常量来推断应该调用哪个函数。因为 <code>const</code> 不能转换成其他类型，所以我们只能把 <code>const</code> 对象（或指向 <code>const</code> 的指针）传递给 <code>const</code> 形参。相反的，因为非常量可以转换成 <code>const</code>，所以上面的 4 个函数都能作用于非常量对象或者指向非常量对象的指针。不过，当我们传递一个非常量对象或者指向非常量对象的指针时，编译器会优先选用非常量版本的函数。</strong></p>
</li>
<li><blockquote>
<p>最好只重载那些确实非常相似的操作。有些情况下，给函数起不同的名字能使得程序更易理解。</p>
</blockquote>
</li>
<li><p><strong>函数匹配</strong>（function matching）是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做<strong>重载确定</strong>（overload resolution）。编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。</p>
</li>
<li><p>当调用重载函数时有三种可能的结果：</p>
<ul>
<li>编译器找到一个与实参<strong>最佳匹配</strong>（best match）的函数，并生成调用该函数的代码；</li>
<li>找不到任何一个函数与调用的实参匹配，此时编译器发出<strong>无匹配</strong>（no match）的错误信息；</li>
<li>有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为<strong>二义性调用</strong>（ambiguous call）。<br><br></li>
</ul>
</li>
<li><p>如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。<strong>一旦在当前作用域中找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。</strong>剩下的工作就是检查函数调用是否有效了。</p>
<blockquote>
<p>在 C++ 语言中，名字查找发生在类型检查之前。</p>
</blockquote>
</li>
<li><p>某些函数有这样一种形参，在函数的很多次调用中它们都被赋了一个相同的值，此时，我们把这个反复出现的值称为函数的<strong>默认实参</strong>（defaultargument）。调用含有默认实参的函数时，可以包含该实参，也可以省略该实参。<strong>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</strong>（应该是为了确保函数调用时实参与形参匹配关系的唯一性——博主注）</p>
</li>
<li><p>如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了。函数调用时实参按其位置解析，默认实参负责填补函数调用缺少的尾部实参（靠右侧位置）。当设计含有默认实参的函数时，其中一项任务是合理设置形参的顺序，<strong>尽量让不怎么使用默认值的形参出现在前面，而让那些经常使用默认值的形参出现在后面</strong>。</p>
</li>
<li><p>通常，一个函数只声明一次，但是多次声明同一个函数也是合法的。不过有一点需要注意，<strong>在给定的作用域中一个形参只能被赋予一次默认实参。换句话说，函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须都有默认值</strong>。</p>
</li>
<li><blockquote>
<p>最佳实践：通常，应该在函数声明中指定默认实参，并将该声明放在合适的头文件中。</p>
</blockquote>
</li>
<li><p><strong>局部变量不能作为默认实参。</strong> 除此之外，只要表达式的类型能转换成形参所需的类型该表达式就能作为默认实参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// wd、def 和 ht 的声明必须出现在函数之外</span></span><br><span class="line">sz wd=<span class="number">80</span>;</span><br><span class="line"><span class="keyword">char</span> def = <span class="string">' '</span>;</span><br><span class="line"><span class="function">sz <span class="title">ht</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">screen</span><span class="params">(sz = ht(), sz = wd, <span class="keyword">char</span> = def)</span></span>;</span><br><span class="line"><span class="built_in">string</span> window = screen();  <span class="comment">// 调用 screen(ht(), 80, ' ')</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>用作默认实参的名字在函数声明所在的作用域内解析，而这些名字的求值过程发生在函数调用时</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    def = <span class="string">'*'</span>;          <span class="comment">// 改变默认实参的值</span></span><br><span class="line">    sz wd = <span class="number">100</span>;        <span class="comment">// 隐藏了外层定义的 wd，但是没有改变默认值</span></span><br><span class="line">    window = screen();  <span class="comment">// 调用 screen(ht(), 80, '*')</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数 f2 内部改变了 def 的值，所以对 screen 的调用将会传递这个更新过的值。另一方面，虽然我们的函数还声明了一个局部变量用于隐藏外层的 wd，但是该局部变量与传递给 screen 的默认实参没有任何关系。</p>
</li>
<li><p>调用函数一般比求等价表达式的值要慢一些。<strong>在大多数机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。</strong></p>
</li>
<li><p><strong>内联函数可避免函数调用的开销。</strong> 将函数指定为<strong>内联函数</strong>（inline），通常就是将它在每个调用点上“内联地”展开。</p>
<blockquote>
<p>内联说明只是向编译器发出的一个请求，编译器可以选择忽略这个请求。</p>
</blockquote>
<p>一般来说，内联机制用于优化规模较小、流程直接、频繁调用的函数。很多编译器都不支持内联递归函数，而且一个 75 行的函数也不大可能在调用点内联地展开。</p>
</li>
<li><p><strong>constexpr 函数</strong>（constexpr function）是指能用于常量表达式的函数。定义 <code>constexpr</code> 函数的方法与其他函数类似，不过要遵循几项约定：</p>
<ul>
<li>函数的返回类型及所有形参的类型都得是字面值类型；</li>
<li>函数体中必须有且只有一条 <code>return</code> 语句。<br><br></li>
</ul>
</li>
<li><p>为了能在编译过程中随时展开，<strong><code>constexpr</code> 函数被隐式地指定为内联函数</strong>。<code>constexpr</code> 函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行。例如，<code>constexpr</code> 函数中可以有空语句、类型别名以及 <code>using</code> 声明。允许 <code>constexpr</code> 函数的返回值并非一个常量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果 arg 是常量表达式，则 scale(arg) 也是常量表达式</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> <span class="title">scale</span><span class="params">(<span class="keyword">size_t</span> cnt)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> new_sz() * cnt;  <span class="comment">// new_sz 是另一个 constexpr 函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 scale 的实参是常量表达式时，它的返回值也是常量表达式；反之则不然。</p>
</li>
<li><p>和其他函数不一样，<strong>内联函数和 <code>constexpr</code> 函数可以在程序中多次定义。不过，对于某个给定的内联函数或者 <code>constexpr</code> 函数来说，它的多个定义必须完全一致。基于这个原因，内联函数和 <code>constexpr</code> 函数通常定义在头文件中</strong>。</p>
</li>
<li><p><strong><code>assert</code></strong> 是一种<strong>预处理宏</strong>（preprocessor marco）。所谓预处理宏其实是一个预处理变量，它的行为有点类似于内联函数。<code>assert</code> 宏使用一个表达式作为它的条件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">assert(expr);</span><br></pre></td></tr></table></figure>
<p>首先对 expr 求值，如果表达式为假（即 0），<code>assert</code> 输出信息并终止程序的执行。如果表达式为真（即非 0），<code>assert</code> 什么也不做。<code>assert</code> 宏定义在 <code>cassert</code> 头文件中。如我们所知，预处理名字由预处理器而非编译器管理，因此我们可以直接使用预处理名字而无须提供 <code>using</code> 声明。也就是说，我们应该使用 <code>assert</code> 而不是 <code>std::assert</code>，也不需要为 <code>assert</code> 提供 <code>using</code> 声明。和预处理变量一样，宏名字在程序内必须唯一。含有 <code>cassert</code> 头文件的程序不能再定义名为 <code>assert</code> 的变量、函数或者其他实体。<code>assert</code> 宏常用于检查“不能发生”的条件。</p>
</li>
<li><p><code>assert</code> 的行为依赖于一个名为 <code>NDEBUG</code> 的预处理变量的状态。如果定义了 <code>NDEBUG</code>，则 <code>assert</code> 什么也不做。默认状态下没有定义 <code>NDEBUG</code>，此时 <code>assert</code> 将执行运行时检查。我们可以使用一个 <code>#define</code> 语句定义 <code>NDEBUG</code>，从而关闭调试状态。定义 <code>NDEBUG</code> 能避免检查各种条件所需的运行时开销，当然此时根本就不会执行运行时检查。因此，<code>assert</code> 应该仅用于验证那些确实不可能发生的事情。我们可以把 <code>assert</code> 当成调试程序的一-种辅助手段，但是不能用它替代真正的运行时逻辑检查，也不能替代程序本身应该包含的错误检查。</p>
</li>
<li><p>编译器为每个函数都定义了 <code>_ _func_ _</code>，它是 <code>const char</code> 的一个静态数组，用于存放函数的名字。除了 C++编译器定义的 <code>_ _func_ _</code> 之外，预处理器还定义了另外 4 个对于程序调试很有用的名字：</p>
<ul>
<li><code>_ _FILE_ _</code>，存放文件名的字符串字面值；</li>
<li><code>_ _LINE_ _</code>，存放当前行号的整型字面值；</li>
<li><code>_ _TIME_ _</code>，存放文件编译时间的字符串字面值；</li>
<li><code>_ _DATE_ _</code>，存放文件编译日期的字符串字面值。<br><br></li>
</ul>
</li>
<li><p>函数匹配分三步：</p>
<ul>
<li>第一步，选定本次调用对应的重载函数集，集合中的函数称为<strong>候选函数</strong>（candidate function）。候选函数具备两个特征：一是与被调用的函数同名，二是其声明在调用点可见；</li>
<li>第二步，考察本次调用提供的实参，然后从候选函数中选出能被这组实参调用的函数，这些新选出的函数称为<strong>可行函数</strong>（viable function）。可行函数也有两个特征：一是其形参数量与本次调用提供的实参数量相等，二是每个实参的类型与对应的形参类型相同，或者能转换成形参的类型。<strong>如果没找到可行函数，编译器将报告无匹配函数的错误</strong>；</li>
<li>第三步，从可行函数中选择与本次调用最匹配的函数。在这一过程中，逐一检查函数调用提供的实参，寻找形参类型与实参类型最匹配的那个可行函数，它的基本思想是，<strong>实参类型与形参类型越接近，它们匹配得越好</strong>。<br><br></li>
</ul>
</li>
<li><blockquote>
<p>最佳实践：调用重载函数时应尽量避免强制类型转换。如果在实际应用中确实需要强制类型转换，则说明我们设计的形参集合不合理。</p>
</blockquote>
</li>
<li><p>分析函数调用前，我们应该知道小整型一般都会提升到 <code>int</code> 类型或更大的整数类型。假设有两个函数，一个接受 <code>int</code>、另一个接受 <code>short</code>，则只有当调用提供的是 <code>short</code> 类型的值时才会选择 <code>short</code> 版本的函数。</p>
</li>
<li><p>所有算术类型转换的级别都一样。例如，从 <code>int</code> 向 <code>unsigned int</code> 的转换并不比从 <code>int</code> 向 <code>double</code> 的转换级别高。</p>
</li>
<li><p>如果重载函数的区别在于它们的引用类型的形参是否引用了 <code>const</code>，或者指针类型的形参是否指向 <code>const</code>，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数。<strong>切记，不能把普通引用绑定到 <code>const</code> 对象上，即常量引用的初值只能是左值。</strong>如果两个函数的唯一区别是它的指针形参指向常量或非常量，则编译器能通过实参是否是常量决定选用哪个函数：如果实参是指向常量的指针，调用形参是 <code>const*</code> 的函数：如果实参是指向非常量的指针，调用形参是普通指针的函数。</p>
</li>
<li><p>函数指针指向的是函数而非对象。要想声明一个可以指向该函数的指针，只需要用指针替换函数名即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pf 指向一个函数，该函数的参数是两个 const string 的引用，返回值是 bool</span></span><br><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);  <span class="comment">// 未初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当我们把函数名作为一个值使用时，该函数自动地转换成指针。</strong> 假设存在一个名为 lengthCompare 函数，则下述的赋值语句是等价的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pf = lengthCompare;   <span class="comment">// pf 指向名为 lengthCompare 的函数</span></span><br><span class="line">pf = &amp;lengthCompare;  <span class="comment">// 等价的赋值语句：取地址符是可选的</span></span><br></pre></td></tr></table></figure>
<p><strong>可以直接使用指向函数的指针调用该函数，无须提前解引用指针</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> bl = pf(<span class="string">"he1lo"</span>，<span class="string">"goodbye"</span>);             <span class="comment">// 调用 lengthCompare 函数</span></span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>);          <span class="comment">// 一个等价的调用</span></span><br><span class="line"><span class="keyword">bool</span> b3 = lengthCompare(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>);  <span class="comment">// 另一个等价的调用</span></span><br></pre></td></tr></table></figure>
<p>在指向不同函数类型的指针间不存在转换规则。但是和往常一样，我们<strong>可以为函数指针赋一个 <code>nullptr</code> 或者值为 0 的整型常量表达式，表示该指针没有指向任何一个函数</strong>。</p>
</li>
<li><p>当我们使用重载函数时，上下文必须清晰地界定到底应该选用哪个函数。如果定义了指向重载函数的指针，编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某一个精确匹配。</p>
</li>
<li><p><strong>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用。</strong></p>
</li>
<li><p>类型别名和 <code>decltype</code> 能让我们简化使用了函数指针的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Func 和 Func2 是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;  <span class="comment">// 等价的类型</span></span><br><span class="line"><span class="comment">// FuncP 和 FuncP2 是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span><span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;  <span class="comment">// 等价的类型</span></span><br></pre></td></tr></table></figure>
<p><strong>需要注意的是，<code>decltype</code> 返回函数类型，此时不会将函数类型自动转换成指针类型。（类似 <code>decltype</code> 对数组的处理方式）</strong></p>
</li>
<li><p>和数组类似，<strong>虽然不能返回一个函数，但是能返回指向函数类型的指针</strong>。然而，我们<strong>必须把返回类型写成指针形式，编译器不会自动地将函数返回类型当成对应的指针类型处理</strong>。与往常一样，要想声明一个返回函数指针的函数，最简单的办法是使用类型别名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);      <span class="comment">// F 是函数类型，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);  <span class="comment">// PF 是指针类型</span></span><br></pre></td></tr></table></figure>
<p><strong>必须时刻注意的是，和函数类型的形参不一样，返回类型不会自动地转换成指针。我们必须显式地将返回类型指定为指针</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 正确：PF 是指向函数的指针，f1 返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;   <span class="comment">// 错误：F 是函数类型，f1 不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;  <span class="comment">// 正确：显式地指定返回类型是指向函数的指针</span></span><br></pre></td></tr></table></figure>
<p>还可以使用尾置返回类型的方式声明一个返回函数指针的函数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto f1(int)-&gt;int(*)(int*, int);</span><br></pre></td></tr></table></figure>
<p>如果我们明确知道返回的函数是哪一个，就能使用 <code>decltype</code> 简化书写函数指针返回类型的过程。</p>
</li>
<li><p>编写函数的声明，令其接受两个 <code>int</code> 形参并且返回类型也是 <code>int</code>；然后声明一个 <code>vector</code> 对象，令其元素是指向该函数的指针。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">decltype</span>(func)*&gt; v;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些关键术语：</p>
<ul>
<li><strong>二义性调用（ambiguous call）</strong> 是一种编译时发生的错误，<strong>造成二义性调用的原因是在函数匹配时两个或多个函数提供的匹配一样好，编译器找不到唯一的最佳匹配</strong>；</li>
<li><strong>最佳匹配（best match）</strong> 从一组重载函数中为调用选出的一个函数。如果存在最佳匹配，则选出的函数与其他所有可行函数相比，至少在一个实参上是更优的匹配，同时在其他实参的匹配上不会更差。</li>
</ul>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 7 章 类</title>
    <url>/archives/53fe514.html</url>
    <content><![CDATA[<ol>
<li><p>类的基本思想是<strong>数据抽象</strong>（data abstraction）和<strong>封装</strong>（encapsulation）。数据抽象是一种依赖于<strong>接口</strong>（interface）和<strong>实现</strong>（implementation）分离的编程（以及设计）技术。</p>
</li>
<li><p>作为一个设计良好的类，既要有直观且易于使用的接口，也必须具备高效的实现过程。</p>
</li>
<li><p><strong>定义在类内部的函数是隐式的 <code>inline</code> 函数。</strong></p>
</li>
<li><p>尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。</p>
</li>
<li><p><strong>成员函数通过一个名为 <code>this</code> 的额外的隐式参数来访问调用它的那个对象。</strong>当我们调用一个成员函数时，用请求该函数的对象地址初始化 <code>this</code>。例如，如果调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">total.isbn()</span><br></pre></td></tr></table></figure>
<p>则编译器负责把 total 的地址传递给 isbn 的隐式形参 <code>this</code>，可以等价地认为编译器将该调用重写成了如下的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码，用于说明调用成员函数的实际执行过程</span></span><br><span class="line">Sales_data::isbn(&amp;total)</span><br></pre></td></tr></table></figure>
<p>在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为 <code>this</code> 所指的正是这个对象。任何对类成员的直接访问都被看作 <code>this</code> 的隐式引用，也就是说，当 isbn 使用 bookNo 时，它隐式地使用 <code>this</code> 指向的成员，就像我们书写了 <code>this-&gt;bookNo</code> 一样。</p>
</li>
<li><p>任何自定义名为 <code>this</code> 的参数或变量的行为都是非法的。我们可以在成员函数体内部使用 <code>this</code>，因此尽管没有必要，但我们还是能把 isbn 定义成如下的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>-&gt;bookNo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>this</code> 的目的总是指向“这个”对象，所以 <strong><code>this</code> 是一个常量指针，我们不允许改变 <code>this</code> 中保存的地址</strong>。</p>
</li>
<li><p>紧随参数列表之后的 <code>const</code> 关键字的作用是修改隐式 <code>this</code> 指针的类型。默认情况下，<code>this</code> 的类型是指向类类型非常量版本的常量指针。尽管 <code>this</code> 是隐式的，但它仍然需要遵循初始化规则，意味着（在默认情况下）我们不能把 <code>this</code> 绑定到一个常量对象上。这一情况也就使得我们<strong>不能在一个常量对象上调用普通的成员函数</strong>。把 <code>this</code> 设置为指向常量的指针有助于提高函数的灵活性。把 <code>const</code> 关键字放在成员函数的参数列表之后表示 <code>this</code> 是一个指向常量的指针。像这样使用 <code>const</code> 的成员函数被称作<strong>常量成员函数</strong>（const member function）。<strong>常量成员函数不能改变调用它的对象的内容。</strong></p>
<blockquote>
<p>常量对象，以及常量对象的引用或指针都只能调用常量成员函数。</p>
</blockquote>
</li>
<li><p>编译器分两步处理类：首先编译成员的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。</p>
</li>
<li><p><strong>如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定 <code>const</code> 属性。</strong>同时，类外部定义的成员的名字必须包含它所属的类名。</p>
</li>
<li><p>可以定义一个返回 <code>this</code> 对象的函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Sales_data&amp; <span class="title">Sales_data::combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    units_sold += rhs.units_sold;  <span class="comment">// 把 rhs 的成员加到 this 对象的成员上</span></span><br><span class="line">    revenue += rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回调用该函数的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符。如前所述，我们无须使用隐式的 <code>this</code> 指针访问函数调用者的某个具体成员，而是需要把调用函数的对象当成一个整体来访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回调用该函数的对象</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>return</code> 语句解引用 <code>this</code> 指针以获得执行该函数的对象。</p>
</li>
<li><p>如果函数在概念上属于类但是不定义在类中，则它一般应与类声明（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。</p>
</li>
<li><p><strong>IO 类属于不能被拷贝的类型，因此我们只能通过引用来传递它们，而且读取和写入的操作会改变流的内容。</strong></p>
</li>
<li><p>默认情况下，拷贝类的对象其实拷贝的是对象的数据成员。</p>
</li>
<li><p>每个类都分别定义了它的对象被初始化的方式，类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做<strong>构造函数</strong>（constructor）。构造函数的任务是初始化类对象的数据成员，<strong>无论何时只要类的对象被创建，就会执行构造函数</strong>。</p>
</li>
<li><p>构造函数的名字和类名相同。和其他函数不一样的是，构造函数没有返回类型：除此之外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。类可以包含多个构造函数，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。</p>
</li>
<li><p>不同于其他成员函数，<strong>构造函数不能被声明成 <code>const</code> 的</strong>。当我们创建类的一个 <code>const</code> 对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，构造函数在 <code>const</code> 对象的构造过程中可以向其写值。</p>
</li>
<li><p>类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做<strong>默认构造函数</strong>（default constructor）。<strong>默认构造函数无须任何实参。如果我们的类没有显式地定义构造函数，那么编译器就会为我们隐式地定义一个默认构造函数。</strong></p>
</li>
<li><p>编译器创建的构造函数又被称为<strong>合成的默认构造函数</strong>（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：</p>
<ul>
<li>如果存在<strong>类内的初始值</strong>，用它来初始化成员；</li>
<li>否则，默认初始化该成员。<br><br></li>
</ul>
</li>
<li><p><strong>对于一个普通的类来说，必须定义它自己的默认构造函数</strong>，原因有三：</p>
<ul>
<li><strong>编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数。</strong> 一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。这条规则的依据是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制；</li>
<li>对于某些类来说，合成的默认构造函数可能执行错误的操作。如果定义在块中的内置类型或复合类型（比如数组和指针）的对象被默认初始化，则它们的值将是未定义的。该准则同样适用于默认初始化的内置类型成员。因此，<strong>含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时就可能得到未定义的值。</strong><blockquote>
<p>WARNING：如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内的初始值时，这个类才适合于使用合成的默认构造函数。</p>
</blockquote>
</li>
<li>有的时候编译器不能为某些类合成默认的构造函数。例如，如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。<br><br></li>
</ul>
</li>
<li><p>在 C++11 新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 <code>= default</code> 来要求编译器生成构造函数。其中，<code>= default</code> 既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，<strong>如果 <code>= default</code> 在类的内部，则默认构造函数是内联的；如果它在类的外部，则该成员默认情况下不是内联的</strong>。</p>
</li>
<li><blockquote>
<p>WARNING：如果你的编译器不支持类内初始值，那么你的默认构造函数就应该使用构造函数初始值列表来初始化类的每个成员。</p>
</blockquote>
</li>
<li><p>类的构造函数形参列表后的冒号以及冒号和花括号之间的代码被称为<strong>构造函数初始值列表</strong>。构造函数初始值列表（constructor initialize list）负责为新创建的对象的一个或几个数据成员赋初值。构造函数初始值是成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值。不同成员的初始化通过逗号分隔开来。<strong>当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。</strong></p>
</li>
<li><p>通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p>
<blockquote>
<p>最佳实践：构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。</p>
</blockquote>
</li>
<li><p>没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。</p>
</li>
<li><p>对象在几种情况下会被拷贝，如我们初始化变量以及以值的方式传递或返回一个对象。当我们使用了赋值运算符时会发生对象的赋值操作。当对象不再存在时执行销毁的操作，比如一个局部对象会在创建它的块结束时被销毁，当 <code>vector</code> 对象（或者数组）销毁时存储在其中的对象也会被销毁。如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。</p>
</li>
<li><p>尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，当类需要分配类对象之外的资源时，合成的版本常常会失效。不过值得注意的是，<strong>很多需要动态内存的类能（而且应该）使用 <code>vector</code> 对象或者 <code>string</code> 对象管理必要的存储空间。使用 <code>vector</code> 或者 <code>string</code> 的类能避免分配和释放内存带来的复杂性</strong>。进一步讲，如果类包含 <code>vector</code> 或者 <code>string</code> 成员，则其拷贝、赋值和销毁的合成版本能够正常工作。当我们对含有<code>vector</code>成员的对象执行拷贝或者赋值操作时，<code>vector</code>类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁 <code>vector</code> 对象，也就是依次销毁 <code>vector</code> 中的每一个元素。这一点与 <code>string</code> 是非常类似的。</p>
</li>
<li><p>在 C++ 语言中，我们使用<strong>访问说明符</strong>（access specifiers）加强类的封装性：</p>
<ul>
<li>定义在 <code>public</code> 说明符之后的成员在整个程序内可被访问，<code>public</code> 成员定义类的接口；</li>
<li>定义在 <code>private</code> 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，<code>private</code> 部分封装了（即隐藏了）类的实现细节。<br><br></li>
</ul>
</li>
<li><p>一个类可以包含 0 个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定。<strong>每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。</strong></p>
</li>
<li><p>类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。<strong>如果我们使用 <code>struct</code> 关键字，则定义在第一个访问说明符之前的成员是 <code>public</code> 的：相反，如果我们使用 <code>class</code> 关键字，则这些成员是<code>private</code>的。</strong>出于统一编程风格的考虑，当我们希望定义的类的所有成员是 <code>public</code> 的时，使用 <code>struct</code>；反之，如果希望成员是 <code>private</code> 的，使用 <code>class</code>。</p>
<blockquote>
<p>WARNING：使用 class 和 struct 定义类唯一的区别就是默认的访问权限。</p>
</blockquote>
</li>
<li><p>类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的<strong>友元</strong>（friend）。如果类想把一个函数作为它的友元，只需要增加一条以 <code>friend</code> 关键字开始的函数声明语句即可。</p>
</li>
<li><p>友元声明只能出现在类定义的内部，但是在类内出现的具体位置不限。友元不是类的成员也不受它所在区域访问控制级别的约束。</p>
<blockquote>
<p>Tip：一般来说，最好在类定义开始或结束前的位置集中声明友元。</p>
</blockquote>
</li>
<li><p>友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行次声明。为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（类的外部）。</p>
<blockquote>
<p>许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。</p>
</blockquote>
<p>一些编译器允许在尚无友元函数的初始声明的情况下就调用它。不过即使你的编译器支持这种行为，最好还是提供一个独立的函数声明。这样即使你更换了一个有这种强制要求的编译器，也不必改变代码。</p>
</li>
<li><p>除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是 <code>public</code> 或者 <code>private</code> 中的一种。用来定义类型的成员必须先定义后使用，这一点与普通成员有所区别，因此，类型成员通常出现在类开始的地方。</p>
</li>
<li><p><strong>定义在类内部的成员函数是自动 <code>inline</code> 的。</strong> 我们可以在类的内部把 <code>inline</code> 作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用 <code>inline</code> 关键字修饰函数的定义。虽然我们无须在声明和定义的地方同时说明 <code>inline</code>，但这么做其实是合法的。不过，<strong>最好只在类外部定义的地方说明 <code>inline</code></strong>，这样可以使类更容易理解。</p>
</li>
<li><p>和非成员函数一样，<strong>成员函数也可以被重载</strong>，只要函数之间在参数的数量和/或类型上有所区别就行，编译器根据实参的类型决定运行哪个版本的函数。</p>
</li>
<li><p>有时（但并不频繁）会发生这样一种情况，我们希望能修改类的某个数据成员，即使是在一个 <code>const</code> 成员函数内。可以通过在变量的声明中加入 <code>mutable</code> 关键字做到这一点。<strong>一个可变数据成员（mutable data member）永远不会是 <code>const</code>，即使它是 <code>const</code> 对象的成员。因此，一个 <code>const</code> 成员函数可以改变一个可变成员的值。</strong></p>
</li>
<li><p>当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参。<strong>类内初始值必须使用 <code>=</code> 的初始化形式或者花括号括起来的直接初始化形式。</strong></p>
</li>
<li><p><strong>返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。</strong>（成员函数返回调用成员函数的对象本身似乎很有用——博主注）</p>
</li>
<li><blockquote>
<p>一个 const 成员函数如果以引用的形式返回 *this，那么它的返回类型将是常量引用。</p>
</blockquote>
</li>
<li><p>通过区分成员函数是否是 <code>const</code> 的，我们可以对其进行重载。<strong>因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用 <code>const</code> 成员函数。</strong>另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。</p>
</li>
<li><p>普通成员函数调用常成员函数时，<code>this</code> 指针将临时隐式地从指向非常量的指针转换成指向常量的指针。</p>
</li>
<li><p>在实践中，设计良好的 C++ 代码常常包含大量小函数，通过调用这些函数，可以完成一组其他函数的“实际”工作。</p>
</li>
<li><p>即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它的成员和其他任何类（或者任何其他作用域）的成员都不是一回事儿。</p>
</li>
<li><p>我们可以把类名作为类型的名字使用，从而直接指向类类型。或者，我们也可以把类名跟在关键字 <code>class</code> 或 <code>struct</code> 后面：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Sales_data iteml;        <span class="comment">// 默认初始化 sales_data 类型的对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> <span class="title">item1</span>;</span>  <span class="comment">// 一条等价的声明</span></span><br></pre></td></tr></table></figure>
<p>上面这两种使用类类型的方式是等价的，其中第二种方式从 C 语言继承而来，并且在 C++ 语言中也是合法的。</p>
</li>
<li><p>我们也能仅仅声明类而暂时不定义它：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span>;</span>  <span class="comment">// Screen 类的声明</span></span><br></pre></td></tr></table></figure>
<p>这种声明有时被称作<strong>前向声明</strong>（forward declaration），它向程序中引入了名字 Screen 并且指明 Screen 是一种类类型。对于类型 Screen 来说，在它声明之后定义之前是一个<strong>不完全类型</strong>（incomplete type），<strong>不完全类型只能在非常有限的情景下使用：可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数</strong>。</p>
</li>
<li><p><strong>一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Link</span> <span class="title">screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Screen window;</span><br><span class="line">    Link_screen *next;</span><br><span class="line">    Link_screen *prev;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义一对类 X 和 Y，其中 X 包含一个指向 Y 的指针，而 Y 包含一个类型为 X 的对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Y *py;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    X x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。</strong></p>
</li>
<li><p>必须要注意的一点是，<strong>友元关系不存在传递性</strong>。（不能由“A 是 B 的朋友，B 是 C 的朋友”这一事实推导出“A 是 C 的朋友”——博主注）</p>
<blockquote>
<p>每个类负责控制自己的友元类或友元函数。</p>
</blockquote>
</li>
<li><p>当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Window_mgr::clear 必须在 Screen 类之前被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">Window_mgr::clear</span><span class="params">(ScreenIndex)</span></span>;</span><br><span class="line">    <span class="comment">// Screen 类的剩余部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。</strong></p>
</li>
<li><p>尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明。</p>
</li>
<li><p><strong>类和非成员函数的声明不是必须在它们的友元声明之前。</strong>当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。然而，友元本身不一定真的声明在当前作用域中。<strong>甚至就算在类的内部定义该函数，我们也必须在类的外部提供相应的声明从而使得函数可见。换句话说，即使我们仅仅是用声明友元的类的成员调用该友元函数，它也必须是被声明过的</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; <span class="comment">/* 友元函数可以定义在类的内部 */</span> &#125;</span><br><span class="line">    X() &#123; f(); &#125;  <span class="comment">// 错误：f还没有被声明</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::g</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f(); &#125;  <span class="comment">// 错误：f 还没有被声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;                    <span class="comment">// 声明那个定义在 X 中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">X::h</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> f(); &#125;  <span class="comment">// 正确：现在 f 的声明在作用城中了</span></span><br></pre></td></tr></table></figure>
<p>关于这段代码最重要的是理解<strong>友元声明的作用是影响访问权限，它本身并非普通意义上的声明</strong>。</p>
</li>
<li><p>一个类就是一个作用域的事实能够很好地解释为什么当我们在类的外部定义成员函数时必须同时提供类名和函数名。在类的外部，成员的名字被隐藏起来了。一旦遇到了类名，定义的剩余部分就在类的作用域之内了，这里的剩余部分包括参数列表和函数体。结果就是，我们可以直接使用类的其他成员而无须再次授权了。</p>
</li>
<li><p>通常情况下，<strong>名字查找</strong>（name lookup）（寻找与所用名字最匹配的声明的过程）的过程比较直截了当：</p>
<ul>
<li>首先，<strong>在名字所在的块中寻找其声明语句，只考虑在名字的使用之前出现的声明</strong>；</li>
<li><strong>如果没找到，继续查找外层作用域；</strong></li>
<li>如果最终没有找到匹配的声明，则程序报错。<br><br></li>
</ul>
<p>对于定义在类内部的成员函数来说，解析其中名字的方式与上述的查找规则有所区别。类的定义分两步处理：</p>
<ul>
<li><strong>首先，编译成员的声明；</strong></li>
<li><strong>直到类全部可见后才编译函数体。</strong><br><br></li>
</ul>
<p>按照这种两阶段的方式处理类可以简化类代码的组织方式。<strong>因为成员函数体直到整个类可见后才会被处理，所以它能使用类中定义的任何名字。</strong> 相反，如果函数的定义和成员的声明被同时处理，那么我们将不得不在成员函数中只使用那些已经出现的名字。</p>
</li>
<li><p><strong>这种两阶段的处理方式只适用于成员函数中使用的名字。声明中使用的名字，包括返回类型或者参数列表中使用的名字，都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。</strong> 例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="built_in">string</span> bal;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Money bal;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当编译器看到 balance 函数的声明语句时，它将在 Account 类的范围内寻找对 Money 的声明。编译器只考虑 Account 中在使用 Money 前出现的声明，因为没找到匹配的成员，所以编译器会接着到 Account 的外层作用域中查找。在这个例子中，编译器会找到 Money 的 typedef 语句，该类型被用作 balance 函数的返回类型以及数据成员 bal 的类型。另一方面，<strong>balance 函数体在整个类可见后才被处理，因此，该函数的 return 语句返回名为 bal 的成员，而非外层作用域的 string 对象</strong>。</p>
</li>
<li><p>一般来说，内层作用域可以重新定义外层作用域中的名字，即使该名字已经在内层作用域中使用过。然而<strong>在类中，如果成员使用了外层作用域中的某个名字，而该名字代表一种类型，则类不能在之后重新定义该名字</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> Money;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Money <span class="title">balance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bal; &#125;  <span class="comment">// 使用外层作用城的 Money</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">double</span> Money;  <span class="comment">// 错误：不能重新定义 Money</span></span><br><span class="line">    Money bal;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>需要特别注意的是，<strong>即使 Account 中定义的 Money 类型与外层作用域一致，上述代码仍然是错误的</strong>。<br>尽管重新定义类型名字是一种错误的行为，但是编译器并不为此负责。一些编译器仍将顺利通过这样的代码，而忽略代码有错的事实。</p>
<blockquote>
<p>Tip：类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。</p>
</blockquote>
</li>
<li><p>成员函数中使用的名字按照如下方式解析：</p>
<ul>
<li><strong>首先，在成员函数内查找该名字的声明。和前面一样，只有在函数使用之前出现的声明才被考虑；</strong></li>
<li>如果在成员函数内没有找到，则在类内继续查找，这时类的所有成员都可以被考虑；</li>
<li>如果类内也没找到该名字的声明，在成员函数定义之前的作用域内继续查找。<br><br></li>
</ul>
<p>一般来说，不建议使用其他成员的名字作为某个成员函数的参数。</p>
<blockquote>
<p>尽管类的成员可能被隐蔽，但我们仍然可以通过加上类的名字或显式地使用 this 指针来强制访问成员。</p>
</blockquote>
</li>
<li><p><strong>如果编译器在函数和类的作用域中都没有找到名字，它将接着在外围的作用域中查找。</strong> 如果我们需要的是外层作用域中的名字，可以显式地通过作用域运算符来进行请求。</p>
</li>
<li><p><strong>当成员定义在类的外部时，名字查找的第三步不仅要考虑类定义之前的全局作用域中的声明，还需要考虑在成员函数定义之前的全局作用域中的声明。</strong></p>
</li>
<li><p>如果没有在构造函数的初始值列表中显式地初始化成员，则该成员将在构造函数体之前执行默认初始化。</p>
</li>
<li><p>有时我们可以忽略数据成员初始化和赋值之间的差异，但并非总能这样。<strong>如果成员是 <code>const</code> 或者是引用的话，必须将其初始化。类似的，当成员属于某种类类型且该类没有定义默认构造函数时，也必须将这个成员初始化。</strong></p>
</li>
<li><p><strong>随着构造函数体一开始执行，初始化就完成了。我们初始化 <code>const</code> 或者引用类型的数据成员的唯一机会就是通过构造函数初始值。</strong></p>
<blockquote>
<p>如果成员是 const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。</p>
</blockquote>
</li>
<li><p><strong>建议：使用构造函数初始值。</strong> 在很多类中，初始化和赋值的区别事关底层效率问题：前者直接初始化数据成员，后者则先初始化再赋值。除了效率问题外更重要的是，一些数据成员必须被初始化。建议读者养成使用构造函数初始值的习惯，这样能避免某些意想不到的编译错误，特别是遇到有的类含有需要构造函数初始值的成员时。</p>
</li>
<li><p>在构造函数初始值中每个成员只能出现一次。构造函数初始值列表只说明用于初始化成员的值，而不限定初始化的具体执行顺序。<strong>成员的初始化顺序与它们在类定义中的出现顺序一致：第一个成员先被初始化，然后第二个，以此类推。构造函数初始值列表中初始值的前后位置关系不会影响实际的初始化顺序。</strong></p>
</li>
<li><p>有的编译器具备一项比较友好的功能，即当构造函数初始值列表中的数据成员顺序与这些成员声明的顺序不符时会生成一条警告信息。</p>
<blockquote>
<p>最佳实践：最好令构造函数初始值的顺序与成员声明的顺序保持一致。而且如果可能的话，尽量避免使用某些成员初始化其他成员。<br>如果可能的话，最好用构造函数的参数作为成员的初始值，而尽量避免使用同一个对象的其他成员。这样的好处是我们可以不必考虑成员的初始化顺序。</p>
</blockquote>
</li>
<li><p><strong>如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。</strong></p>
</li>
<li><p>一个<strong>委托构造函数</strong>使用它所属类的其他构造函数执行它自己的初始化过程，或者说它把它自己的一些（或者全部）职责委托给了其他构造函数。<strong>和其他构造函数一样，一一个委托构造函数也有一个成员初始值的列表和一个函数体。</strong> 在委托构造函数内，成员初始值列表只有一个唯一的入口，就是类名本身。和其他成员初始值一样，类名后面紧跟圆括号括起来的参数列表，参数列表必须与类中另外一个构造函数匹配。</p>
</li>
<li><p><strong>当一个构造函数委托给另一个构造函数时，受委托的构造函数的初始值列表和函数体被依次执行，然后控制权才会交还给委托者的函数体。</strong></p>
</li>
<li><p>当对象被默认初始化或值初始化时自动执行默认构造函数。默认初始化在以下情况下发生：</p>
<ul>
<li>当我们在块作用域内不使用任何初始值定义一个非静态变量；</li>
<li>当一个类本身含有类类型的成员且使用合成的默认构造函数时；</li>
<li>当类类型的成员没有在构造函数初始值列表中显式地初始化时。<br><br></li>
</ul>
<p>值初始化在以下情况下发生：</p>
<ul>
<li>在数组初始化的过程中如果我们提供的初始值数量少于数组的大小时；</li>
<li>当我们不使用初始值定义一个局部静态变量时；</li>
<li>当我们通过书写形如 T()的表达式显式地请求值初始化时，其中 T 是类型名（<code>vector</code> 的一个构造函数只接受一个实参用于说明 <code>vector</code> 大小，它就是使用一个这种形式的实参来对它的元素初始化器进行值初始化）。<br><br></li>
</ul>
<p>类必须包含一个默认构造函数以便在上述情况下使用，其中的大多数情况非常容易判断。不那么明显的一种情况是类的某些数据成员缺少默认构造函数。</p>
<blockquote>
<p>最佳实践：在实际中，如果定义了其他构造函数，那么最好也提供一个默认构造函数。</p>
</blockquote>
</li>
<li><p>如果想定义一个使用默认构造函数进行初始化的对象，正确的方法是去掉对象名之后的空的括号对。</p>
</li>
<li><p>如果构造函数只接受一个实参，则它实际上定义了转换为此类类型的隐式转换机制，有时我们把这种构造函数称作<strong>转换构造函数</strong>（converting constructor）。</p>
<blockquote>
<p>能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则。</p>
</blockquote>
</li>
<li><p><strong>编译器只会自动地执行一步类型转换。</strong>例如，因为下面的代码隐式地使用了两种转换规则，所以它是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误：需要用户定义的两种转换：</span></span><br><span class="line"><span class="comment">//（1）把“9-999-99999-9”转换成 string</span></span><br><span class="line"><span class="comment">//（2）再把这个（临时的）string 转换成 sales_data.</span></span><br><span class="line">item.combine(<span class="string">"9-999-99999-9"</span>);</span><br></pre></td></tr></table></figure>
<p>如果我们想完成上述调用，可以显式地把字符串转换成 <code>string</code> 或者 sales_data 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：显式地转换成 string，隐式地转换成 Sales_data：</span></span><br><span class="line">item.combine(<span class="built_in">string</span>(<span class="string">"9-999-99999-9"</span>));</span><br><span class="line"><span class="comment">// 正确：隐式地转换成 string，显式地转换成 sales_data</span></span><br><span class="line">item.combine(Sales_data(<span class="string">"9-999-99999-9"</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p>在要求隐式转换的程序上下文中，我们可以通过将构造函数声明为 <code>explicit</code> 加以阻止：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;S, <span class="keyword">unsigned</span> n, <span class="keyword">double</span> p):</span><br><span class="line">               bookNo(s), units_sold(n), revenue(p * n) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span>: <span class="title">bookNo</span><span class="params">(s)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="built_in">std</span>::istream&amp;)</span></span>;</span><br><span class="line"><span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此时，没有任何构造函数能用于隐式地创建 Sales_data 对象，之前的两种用法都无法通过编译：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">item.combine(null_book);  <span class="comment">// 错误：string 构造函数是 explicit 的</span></span><br><span class="line">item.combine(<span class="built_in">cin</span>);        <span class="comment">// 错误：istream 构造函数是 explicit 的</span></span><br></pre></td></tr></table></figure>
<p><strong>关键字 <code>explicit</code> 只对一个实参的构造函数有效。需要多个实参的构造函数不能用于执行隐式转换，所以无须将这些构造函数指定为 <code>explicit</code> 的。只能在类内声明构造函数时使用 <code>explicit</code> 关键字，在类外部定义时不应重复。</strong></p>
</li>
<li><p>发生隐式转换的一种情况是当我们执行拷贝形式的初始化时（使用=。此时，我们只能使用直接初始化而不能使用 <code>explicit</code> 构造函数。</p>
<blockquote>
<p>当我们用 explicit 关键字声明构造函数时，它将只能以直接初始化的形式使用。而且，编译器将不会在自动转换过程中使用该构造函数。</p>
</blockquote>
</li>
<li><p>尽管编译器不会将 <code>explicit</code> 的构造函数用于隐式转换过程，但是我们可以使用这样的构造函数显式地强制进行转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：实参是一个显式构造的 Sales_data 对象</span></span><br><span class="line">item.combine(Sales_data(null__book));</span><br><span class="line"><span class="comment">// 正确：static_cast 可以使用 explicit 的构造函数</span></span><br><span class="line">item.combine(<span class="keyword">static</span> cast&lt;Sales_data&gt;(<span class="built_in">cin</span>));</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>聚合类</strong>（aggregate class）使得用户可以直接访问其成员，并且具有特殊的初始化语法形式。当一个类满足如下条件时，我们说它是聚合的：</p>
<ul>
<li>所有成员都是 <code>public</code> 的；</li>
<li>没有定义任何构造函数；</li>
<li>没有类内初始值；</li>
<li>没有基类，也没有 <code>virtual</code> 函数。<br><br></li>
</ul>
</li>
<li><p>可以使用一个花括号括起来的成员初始值列表来初始化聚合类的数据成员。初始值的顺序必须与声明的顺序一致，也就是说，第一个成员的初始值要放在第一个，然后是第二个，以此类推。与初始化数组元素的规则一样，如果初始值列表中的元素个数少于类的成员数量，则靠后的成员被值初始化。初始值列表的元素个数绝对不能超过类的成员数量。</p>
</li>
<li><p>值得注意的是，显式地初始化类的对象的成员存在三个明显的缺点：</p>
<ul>
<li>要求类的所有成员都是 <code>public</code> 的；</li>
<li>将正确初始化每个对象的每个成员的重任交给了类的用户（而非类的作者）。因为用户很容易忘掉某个初始值，或者提供一个不恰当的初始值，所以这样的初始化过程冗长乏味且容易出错；</li>
<li>添加或删除一个成员之后，所有的初始化语句都需要更新。<br><br></li>
</ul>
</li>
<li><p><code>constexpr</code> 函数的参数和返回值必须是字面值类型。除了算术类型、引用和指针外，某些类也是字面值类型。和其他类不同，字面值类型的类可能含有 <code>constexpr</code> 函数成员。这样的成员必须符合 <code>constexpr</code> 函数的所有要求，它们是隐式 <code>const</code> 的。数据成员都是字面值类型的聚合类是字面值常量类。如果一个类不是聚合类，但它符合下述要求，则它也是一个字面值常量类：</p>
<ul>
<li>数据成员都必须是字面值类型；</li>
<li>类必须至少含有一个 <code>constexpr</code> 构造函数；</li>
<li>如果一个数据成员含有类内初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的 <code>constexpr</code> 构造函数；</li>
<li>类必须使用析构函数的默认定义，该成员负责销毁类的对象。<br><br></li>
</ul>
</li>
<li><p><strong>尽管构造函数不能是 <code>const</code> 的，但是字面值常量类的构造函数可以是 <code>constexpr</code> 函数。</strong>事实上，必须至少提供一个 <code>constexpr</code> 构造函数。</p>
</li>
<li><p><code>constexpr</code> 构造函数可以声明成 <code>=default</code> 的形式（或者是删除函数的形式）。否则，<code>constexpr</code> 构造函数就必须既符合构造函数的要求（意味着不能包含返回语句），又符合 <code>constexpr</code> 函数的要求（意味着它能拥有的唯一可执行语句就是返回语句。综合这两点可知，<strong><code>constexpr</code> 构造函数体一般来说应该是空的</strong>。我们通过前置关键字 <code>constexpr</code> 就可以声明一个 <code>constexpr</code> 构造函数了。</p>
</li>
<li><p><strong><code>constexpr</code> 构造函数必须初始化所有数据成员，初始值或者使用 <code>constexpr</code> 构造函数，或者是一条常量表达式。</strong><code>constexpr</code> 构造函数用于生成 <code>constexpr</code> 对象以及 <code>constexpr</code> 函数的参数或返回类型。</p>
</li>
<li><p>我们通过在成员的声明之前加上关键字 <code>static</code> 使得其与类关联在一起。和其他成员一样，静态成员可以是 <code>public</code> 的或 <code>private</code> 的。静态数据成员的类型可以是常量、引用、指针、类类型等。类的静态成员存在于任何对象之外，对象中不包含任何与静态数据成员有关的数据。<strong>静态成员函数也不与任何对象绑定在一起，它们不包含 <code>this</code> 指针。作为结果，静态成员函数不能声明成 <code>const</code> 的，而且我们也不能在 <code>static</code> 函数体内使用 <code>this</code> 指针。这一限制既适用于 <code>this</code> 的显式使用，也对调用非静态成员的隐式使用有效。</strong></p>
</li>
<li><p>我们可以通过作用域运算符直接访问类的静态成员。虽然静态成员不属于类的某个对象，但是我们仍然可以使用类的对象、引用或者指针来访问静态成员。</p>
</li>
<li><p>和其他的成员函数一样，我们既可以在类的内部也可以在类的外部定义静态成员函数。<strong>当在类的外部定义静态成员时，不能重复 <code>static</code> 关键字，该关键字只出现在类内部的声明语句。</strong></p>
</li>
<li><p>因为静态数据成员不属于类的任何一个对象，所以它们并不是在创建类的对象时被定义的。这意味着<strong>静态数据成员不是由类的构造函数初始化的。而且一般来说，我们不能在类的内部初始化静态成员。相反的，必须在类的外部定义和初始化每个静态成员</strong>。和其他对象一样，一个静态数据成员只能定义一次。类似于全局变量，静态数据成员定义在任何函数之外。因此一旦它被定义，就将一直存在于程序的整个生命周期中。<strong>定义静态数据成员的方式和在类的外部定义成员函数类似，需要指定对象的类型名，然后是类名、作用域运算符以及成员自己的名字。</strong></p>
</li>
<li><blockquote>
<p>Tip：要想确保对象只定义一次，最好的办法是把静态数据成员的定义与其他非内联函数的定义放在同一个文件中。</p>
</blockquote>
</li>
<li><p>通常情况下，类的静态成员不应该在类的内部初始化。然而，我们<strong>可以为静态成员提供 <code>const</code> 整数类型的类内初始值，不过要求静态成员必须是字面值常量类型的 <code>constexpr</code>。初始值必须是常量表达式</strong>，因为这些成员本身就是常量表达式，所以它们能用在所有适合于常量表达式的地方。例如，我们<strong>可以用一个初始化了的静态数据成员指定数组成员的维度</strong>。</p>
</li>
<li><p>如果某个静态成员的应用场景仅限于编译器可以替换它的值的情况，则一个初始化的 <code>const</code> 或 <code>constexpr static</code> 不需要分别定义。相反，如果我们将它用于值不能替换的场景中，则该成员必须有一条定义语句。<strong>如果在类的内部提供了一个初始值，则成员的定义不能再指定一个初始值了</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个不带初始值的静态成员的定义</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> Account::period; <span class="comment">// 初始值在类的定义内提供</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>最佳实践：即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员。</p>
</blockquote>
</li>
<li><p>静态成员独立于任何对象，因此，在某些非静态数据成员可能非法的场合，静态成员却可以正常地使用。举个例子，<strong>静态数据成员可以是不完全类型。特别的，静态数据成员的类型可以就是它所属的类类型。而非静态数据成员则受到限制，只能声明成它所属类的指针或引用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> Bar mem1;  <span class="comment">// 正确：静态成员可以是不完全类型</span></span><br><span class="line">    Bar *mem2;        <span class="comment">// 正确：指针成员可以是不完全类型</span></span><br><span class="line">    Bar mem3;         <span class="comment">// 错误：数据成员必须是完全类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>静态成员和普通成员的另外一个区别是我们可以使用静态成员作为默认实参</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Screen</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// bkground 表示一个在类中稍后定义的静态成员</span></span><br><span class="line">    <span class="function">Screen &amp;<span class="title">clear</span><span class="params">(<span class="keyword">char</span> = bkground)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> bkground;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>非静态数据成员不能作为默认实参，因为它的值本身属于对象的一部分，这么做的结果是无法真正提供一个对象以便从中获取成员的值，最终将引发错误。</strong></p>
</li>
<li><p>带有类内初始化表达式的静态数据成员必须具有不可变的常量整型类型，或必须被指定为“内联”。</p>
</li>
<li><p>一些关键术语：</p>
<ul>
<li><p><strong>常量成员函数（const member function）</strong> 一个成员函数，在其中不能修改对象的普通（即既不是 <code>static</code> 也不是 <code>mutable</code>）数据成员。<code>const</code> 成员的 <code>this</code> 指针是指向常量的指针，通过区分函数是否是 <code>const</code> 可以进行重载。</p>
</li>
<li><p><strong>转换构造函数（converting constructor）</strong> 可以用一个实参调用的非显式构造函数。这样的函数隐式地将参数类型转换成类类型。</p>
</li>
<li><p><strong>委托构造函数（delegating constructor）</strong> 委托构造的数的初始值列表只有一个入口，指定类的另一个构造函数执行初始化操作。</p>
</li>
<li><p><strong>显式构造函数（explicit constructor）</strong> 可以用一个单独的实参调用但是不能用于隐式转换的构造函数。通过在构造函数的声明之前加上 <code>explicit</code> 关键字就可以将其声明成显式构造函数。</p>
</li>
<li><p><strong>不完全类型（incomplete type）</strong> 已经声明但是尚未定义的类型。不完全类型不能用于定义变量或者类的成员，但是<strong>用不完全类型定义指针或者引用是合法的</strong>。</p>
</li>
<li><p><strong>成员函数（member function）</strong> 类的函数成员。普通的成员函数通过隐式的 <code>this</code> 指针与类的对象绑定在一起：静态成员函数不与对象绑定在一起也没有 <code>this</code> 指针。成员函数可以重载，此时隐式的 <code>this</code> 指针参与函数匹配的过程。</p>
</li>
<li><p><strong>可变数据成员（mutable data member）</strong> 这种成员永远不是 <code>const</code>，即使它属于 <code>const</code> 对象。<strong>在 <code>const</code> 函数内可以修改可变数据成员。</strong></p>
</li>
<li><p><strong>合成默认构造函数（synthesized default constructor）</strong> 对于没有显式地定义任何构造函数的类，编译器为其创建（合成）的默认构造函数。<strong>合成默认构造函数检查类的数据成员，如果提供了类内初始值，就用它执行初始化操作；否则就对数据成员执行默认初始化。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。</strong></p>
</li>
<li><p><strong>= default</strong> 一种语法形式，位于类内部默认构造函数声明语句的参数列表之后，要求编译器生成构造函数，而不管类是否已经有了其他构造函数。</p>
</li>
</ul>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux Perf性能优化工具使用说明</title>
    <url>/archives/51299274.html</url>
    <content><![CDATA[<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p><strong>Perf</strong>工具是随 Linux 内核一起发布的系统级性能调优工具，<span class="exturl" data-url="aHR0cDovL3d3dy5icmVuZGFuZ3JlZ2cuY29tL3BlcmYuaHRtbA==" title="http://www.brendangregg.com/perf.html">官网<i class="fa fa-external-link"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly9wZXJmLndpa2kua2VybmVsLm9yZy9pbmRleC5waHAvTWFpbl9QYWdl" title="https://perf.wiki.kernel.org/index.php/Main_Page">Wiki<i class="fa fa-external-link"></i></span>对 Perf 工具做了详细介绍。</p>
<h1 id="1-背景" class="heading-control"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景<a class="heading-anchor" href="#1-背景" aria-hidden="true"></a></h1><p>在工作中开发车道线融合模块<code>CtApLaneFusion</code>时曾经出现过偶发的模块卡死的情况，通过查阅资料，使用 Perf 工具排查出了问题所在。</p>
<h1 id="2-实践" class="heading-control"><a href="#2-实践" class="headerlink" title="2 实践"></a>2 实践<a class="heading-anchor" href="#2-实践" aria-hidden="true"></a></h1><p>通过 Linux <code>top</code>命令查看时发现，<code>CtApLaneFusion</code>进程 CPU 占用率很高。使用 Perf 工具排查具体原因：</p>
<ul>
<li>从整体视角查看当前 iECU 各进程运行状态，登录 iECU 终端，输入<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perf top</span><br></pre></td></tr></table></figure></li>
<li><p>记录并分析指定进程的调用情况及资源使用情况</p>
<ul>
<li>首先，登录 iECU 终端，使用<code>top</code>命令查看<code>CtApLaneFusion</code>模块所在进程的 PID<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure></li>
<li>然后，记录 perf 数据。<code>-p</code>后指定的为 PID 号，<code>sleep</code>后指定的为数据记录持续时间（s），数据文件名称默认为<code>perf.data</code>，保存在打开终端的目录下，<strong>应注意<code>--</code>与<code>sleep</code>间有空格符</strong><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perf record -e cpu-clock -g -p 3729 -- sleep 120</span><br></pre></td></tr></table></figure></li>
<li><p>最后，分析 perf 数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">perf report</span><br></pre></td></tr></table></figure>
<p>可将 perf 数据文件拷贝至台架 iECU 的任意目录进行离线分析，<code>Self</code>是最后一列的符号（可以理解为函数）本身所占比例，<code>Self</code>列所有数据的和为 100%，<code>Children</code>是这个符号调用的其它符号（可以理解为子函数，包括直接和间接调用）占用的比例之和。若<code>Children</code>列和<code>Self</code>列的数据都比较高(<strong>飙红</strong>)，说明该进程或函数存在资源消耗过高的情况，可按回车键展开该进程查看调用情况，如下图所示：</p>
<p><img data-src="https://image.shipengx.com/perf%20report%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E7%A4%BA%E4%BE%8B.png" alt="perf report数据分析示例"></p>
<p>图中从上至下表明 CPU 占用较高进程的函数调用层级关系，可以发现，CPU 占用较高的原因是使用 ipc 库时出现了读写锁死锁。</p>
</li>
</ul>
</li>
</ul>
<h1 id="3-参考" class="heading-control"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考<a class="heading-anchor" href="#3-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5icmVuZGFuZ3JlZ2cuY29tL3BlcmYuaHRtbA==" title="http://www.brendangregg.com/perf.html">perf Examples<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZXJmLndpa2kua2VybmVsLm9yZy9pbmRleC5waHAvTWFpbl9QYWdl" title="https://perf.wiki.kernel.org/index.php/Main_Page">perf: Linux profiling with performance counters<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wZXJmLndpa2kua2VybmVsLm9yZy9pbmRleC5waHAvVHV0b3JpYWwjU2FtcGxlX2FuYWx5c2lzX3dpdGhfcGVyZl9yZXBvcnQ=" title="https://perf.wiki.kernel.org/index.php/Tutorial#Sample_analysis_with_perf_report">Linux kernel profiling with perf<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux gcc/g++中的-I、-l、-L</title>
    <url>/archives/8b42591c.html</url>
    <content><![CDATA[<h1 id="结论" class="heading-control"><a href="#结论" class="headerlink" title="结论"></a>结论<a class="heading-anchor" href="#结论" aria-hidden="true"></a></h1><ul>
<li><code>-I</code> 指定第一个用于寻找头文件的目录；</li>
<li><code>-L</code> 指定第一个用于寻找库文件的目录；</li>
<li><code>-l</code> 用于指定程序具体要链接的库的名字。</li>
</ul>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzQ3JhenliaW5nL2FydGljbGUvZGV0YWlscy84MDMzNzc3Nw==" title="https://blog.csdn.net/csCrazybing/article/details/80337777">gcc “-I”（大写 i），“-L”（大写 l），“-l”（小写 l）的区别<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下使用 vscode 调试 C++ 程序的一般步骤</title>
    <url>/archives/f27f966b.html</url>
    <content><![CDATA[<blockquote>
<p>实施以下步骤前，应确保 vscode 已安装对应插件，如 C/C++、C++ Intellisense、CMake、CMake Tools 等。</p>
</blockquote>
<ol>
<li><p>创建 <code>launch.json</code> 文件</p>
<ul>
<li>按下 <code>F5</code> 键</li>
<li>选择 <code>C++(GDB/LLDB)</code></li>
<li>选择 <code>Default Configuration</code>，生成 <code>launch.json</code> 文件</li>
<li><p>自定义 <code>launch.json</code> 文件中的 <code>program</code> 项为可执行文件路径，一般以工作空间路径 <code>${workspaceFolder}</code> 为起始。其它配置项可视具体情况而定：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line">  <span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line">  <span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">  <span class="attr">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"name"</span>: <span class="string">"(gdb) Launch"</span>,</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">      <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">      <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/bin/CtApLaneFusion_EP21H2_SW025_x86_debug"</span>,</span><br><span class="line">      <span class="attr">"args"</span>: [],</span><br><span class="line">      <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">      <span class="attr">"environment"</span>: [],</span><br><span class="line">      <span class="attr">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">      <span class="attr">"setupCommands"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">"description"</span>: <span class="string">"Enable pretty-printing for gdb"</span>,</span><br><span class="line">          <span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">          <span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>程序中指定位置打断点</p>
</li>
<li><p>点击 vscode 下方工具栏的 <code>CMake</code> 项，选择 <code>Debug</code> 模式</p>
</li>
<li><p>点击 vscode 下方工具栏的 <code>Build</code> 项，构建包含调试信息的可执行文件</p>
</li>
<li><p>按下 <code>F5</code> 键，进入 <code>Debug</code> 模式，vscode 侧边栏 <code>Debug</code> 窗口可以看到<strong>变量值</strong>、<strong>回调栈</strong>（Call Stack）等信息</p>
</li>
<li><p>vscode 顶部会出现 <code>Debug</code> 控制工具栏：</p>
<ul>
<li><code>F5</code>：Continue</li>
<li><code>F10</code>：Step Over</li>
<li><code>F11</code>：Step Into</li>
<li><code>Shift + F11</code>：Step Out</li>
<li><code>Ctrl + Shift + F5</code>：Restart</li>
<li><code>Shift + F5</code>：Stop</li>
</ul>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中使用core dump进行程序调试</title>
    <url>/archives/f52fa610.html</url>
    <content><![CDATA[<h1 id="背景" class="heading-control"><a href="#背景" class="headerlink" title="背景"></a>背景<a class="heading-anchor" href="#背景" aria-hidden="true"></a></h1><ul>
<li>在ubuntu 14.04系统中临时编译了LaneViewer（项目中基于QGLViewer编写的一个GUI界面），但在ubuntu 14.04系统中无法正常运行，启动后闪退，想到了使用<code>core dump</code>文件进行调试，定位问题所在；</li>
<li>项目中所负责的某模块在iECU中运行时会出现<code>defunct</code>（挂掉）问题，想到了使用<code>core dump</code>文件进行调试，定位问题所在。</li>
</ul>
<h1 id="解决" class="heading-control"><a href="#解决" class="headerlink" title="解决"></a>解决<a class="heading-anchor" href="#解决" aria-hidden="true"></a></h1><ol>
<li>临时开启<code>core dump</code>，取消core文件大小限制（仅对当前终端有效）<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -c unlimited</span><br></pre></td></tr></table></figure></li>
<li>运行目标程序，若非正常退出，会在程序所在目录下生成对应core文件</li>
<li>使用<code>gdb</code>调试core文件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb .&#x2F;LaneViewer core</span><br></pre></td></tr></table></figure></li>
<li>进入<code>gdb</code>调试界面后，输入<code>r</code>并回车，可使程序运行至断点位置，输入<code>bt</code>并回车，可显示程序运行时的调用堆栈，<code>bt</code>代表<code>backtrace</code>。</li>
</ol>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXRleWUuY29tL2Jsb2cvdmFxZXRlYXJ0LTEwMTMzOTc=" title="https://www.iteye.com/blog/vaqeteart-1013397">利用Core Dump调试程序<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中使用sed命令进行字符串查找和替换</title>
    <url>/archives/31e5f0fe.html</url>
    <content><![CDATA[<h1 id="1-常见用法及用法说明" class="heading-control"><a href="#1-常见用法及用法说明" class="headerlink" title="1 常见用法及用法说明"></a>1 常见用法及用法说明<a class="heading-anchor" href="#1-常见用法及用法说明" aria-hidden="true"></a></h1><p>下面的代码行是<code>sed</code>命令最为常见的用法，用于将Input_File中所有的Search_String全部替换为Replacement_String：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">'s/Search_String/Replacement_String/g'</span> Input_File</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>sed</code> 是一个Linux命令；</li>
<li><code>-i</code> 是<code>sed</code>命令的一个选项，默认情况下，<code>sed</code>打印结果到标准输出。当使用<code>sed</code>添加这个选项时，它会在适当的位置修改文件。当添加一个后缀（比如，<code>-i.bak</code>）时，就会创建原始文件的备份；</li>
<li><code>s</code> 替换标识；</li>
<li><code>Search_String</code> 搜索一个给定的字符串或正则表达式；</li>
<li><code>Replacement_String</code> 替换的字符串；</li>
<li><code>g</code> 全局替换标识。默认情况下，<code>sed</code>命令替换每一行第一次出现的模式，不会替换行中的其它匹配结果。但是，提供了该替换选项时，所有匹配都将被替换；</li>
<li><code>/</code> 分界符；</li>
<li><code>Input_File</code> 要执行操作的文件名。</li>
</ul>
<h1 id="2-用法大全" class="heading-control"><a href="#2-用法大全" class="headerlink" title="2 用法大全"></a>2 用法大全<a class="heading-anchor" href="#2-用法大全" aria-hidden="true"></a></h1><h2 id="2-1-查找和替换每一行中“第一次”模式匹配" class="heading-control"><a href="#2-1-查找和替换每一行中“第一次”模式匹配" class="headerlink" title="2.1 查找和替换每一行中“第一次”模式匹配"></a>2.1 查找和替换每一行中“第一次”模式匹配<a class="heading-anchor" href="#2-1-查找和替换每一行中“第一次”模式匹配" aria-hidden="true"></a></h2><p>下面的<code>sed</code>命令用<code>linux</code>替换文件中的<code>unix</code>。这仅仅改变了每一行模式的第一个实例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/unix/linux/'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-查找和替换每一行中“第N次”出现的模式" class="heading-control"><a href="#2-2-查找和替换每一行中“第N次”出现的模式" class="headerlink" title="2.2 查找和替换每一行中“第N次”出现的模式"></a>2.2 查找和替换每一行中“第N次”出现的模式<a class="heading-anchor" href="#2-2-查找和替换每一行中“第N次”出现的模式" aria-hidden="true"></a></h2><p>在行中使用<code>/1</code>、<code>/2</code> …… <code>/n</code>等标志来代替相应的匹配。下面的<code>sed</code>命令在每一行中用<code>linux</code>来替换<code>unix</code>模式的第二个实例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/unix/linux/2'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-3-搜索和替换每一行中所有的模式实例" class="heading-control"><a href="#2-3-搜索和替换每一行中所有的模式实例" class="headerlink" title="2.3 搜索和替换每一行中所有的模式实例"></a>2.3 搜索和替换每一行中所有的模式实例<a class="heading-anchor" href="#2-3-搜索和替换每一行中所有的模式实例" aria-hidden="true"></a></h2><p>下面的<code>sed</code>命令用<code>linux</code>替换<code>unix</code>格式的所有实例，因为<code>g</code>是一个全局替换标识：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/unix/linux/g'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-查找和替换每一行中从“第N个“开始的所有匹配的模式实例" class="heading-control"><a href="#2-4-查找和替换每一行中从“第N个“开始的所有匹配的模式实例" class="headerlink" title="2.4 查找和替换每一行中从“第N个“开始的所有匹配的模式实例"></a>2.4 查找和替换每一行中从“第N个“开始的所有匹配的模式实例<a class="heading-anchor" href="#2-4-查找和替换每一行中从“第N个“开始的所有匹配的模式实例" aria-hidden="true"></a></h2><p>下面的<code>sed</code>命令在每一行中替换从模式的“第N个”开始的匹配实例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;s&#x2F;unix&#x2F;linux&#x2F;2g&#39; sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-5-在特定的行号搜索和替换模式" class="heading-control"><a href="#2-5-在特定的行号搜索和替换模式" class="headerlink" title="2.5 在特定的行号搜索和替换模式"></a>2.5 在特定的行号搜索和替换模式<a class="heading-anchor" href="#2-5-在特定的行号搜索和替换模式" aria-hidden="true"></a></h2><p>可以替换特定行号中的字符串。下面的<code>sed</code>命令用<code>linux</code>仅替换第三行的第一个<code>unix</code>模式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'3 s/unix/linux/'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-6-在特定范围行号间搜索和替换模式" class="heading-control"><a href="#2-6-在特定范围行号间搜索和替换模式" class="headerlink" title="2.6 在特定范围行号间搜索和替换模式"></a>2.6 在特定范围行号间搜索和替换模式<a class="heading-anchor" href="#2-6-在特定范围行号间搜索和替换模式" aria-hidden="true"></a></h2><p>可以指定行号的范围，以替换字符串。下面的<code>sed</code>命令在1到3行间用<code>linux</code>替换第一个<code>unix</code>模式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'1,3 s/unix/linux/'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-7-查找和修改最后一行的模式" class="heading-control"><a href="#2-7-查找和修改最后一行的模式" class="headerlink" title="2.7 查找和修改最后一行的模式"></a>2.7 查找和修改最后一行的模式<a class="heading-anchor" href="#2-7-查找和修改最后一行的模式" aria-hidden="true"></a></h2><p>下面的<code>sed</code>命令只在最后一行用<code>Unix</code>替换<code>Linux</code>模式：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'$ s/Linux/Unix/'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-8-在一行中只查找和替换正确的模式匹配" class="heading-control"><a href="#2-8-在一行中只查找和替换正确的模式匹配" class="headerlink" title="2.8 在一行中只查找和替换正确的模式匹配"></a>2.8 在一行中只查找和替换正确的模式匹配<a class="heading-anchor" href="#2-8-在一行中只查找和替换正确的模式匹配" aria-hidden="true"></a></h2><p>如果只想更改正确的匹配词，在搜索串的两端用边界符<code>\b</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'1,3 s/\bunix\b/linux/'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-9-以不区分大小写来搜索与替换模式" class="heading-control"><a href="#2-9-以不区分大小写来搜索与替换模式" class="headerlink" title="2.9 以不区分大小写来搜索与替换模式"></a>2.9 以不区分大小写来搜索与替换模式<a class="heading-anchor" href="#2-9-以不区分大小写来搜索与替换模式" aria-hidden="true"></a></h2><p>Linux是区分大小写的，为了与不区分大小写的模式匹配，使用<code>I</code>标志：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/unix/linux/gI'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-10-查找和替换包含分隔符的字符串" class="heading-control"><a href="#2-10-查找和替换包含分隔符的字符串" class="headerlink" title="2.10 查找和替换包含分隔符的字符串"></a>2.10 查找和替换包含分隔符的字符串<a class="heading-anchor" href="#2-10-查找和替换包含分隔符的字符串" aria-hidden="true"></a></h2><p>当搜索和替换含分隔符的字符串时，需要用反斜杠<code>\</code>来取消转义。在下面的例子中，将用<code>/usr/bin/fish</code>来替换<code>/bin/bash</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/\/bin\/bash/\/usr\/bin\/fish/g'</span> sed-test.txt</span><br></pre></td></tr></table></figure><br>上述<code>sed</code>命令按预期工作，但过于繁琐，可以使用竖线<code>|</code>作为正则表达式的定位符：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s|/bin/bash|/usr/bin/fish/|g'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-11-以给定的模式来查找和替换数字" class="heading-control"><a href="#2-11-以给定的模式来查找和替换数字" class="headerlink" title="2.11 以给定的模式来查找和替换数字"></a>2.11 以给定的模式来查找和替换数字<a class="heading-anchor" href="#2-11-以给定的模式来查找和替换数字" aria-hidden="true"></a></h2><p>数字可以用模式来代替，下面的sed命令以<code>[0-9]</code>将所有数字替换为<code>number</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/[0-9]/number/g'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-12-用模式仅查找和替换两位数字" class="heading-control"><a href="#2-12-用模式仅查找和替换两位数字" class="headerlink" title="2.12 用模式仅查找和替换两位数字"></a>2.12 用模式仅查找和替换两位数字<a class="heading-anchor" href="#2-12-用模式仅查找和替换两位数字" aria-hidden="true"></a></h2><p>如果想用模式来代替两位数字，使用下面的<code>sed</code>命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'s/\b[0-9]\&#123;2\&#125;\b/number/g'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-13-用sed命令仅打印被替换的行" class="heading-control"><a href="#2-13-用sed命令仅打印被替换的行" class="headerlink" title="2.13 用sed命令仅打印被替换的行"></a>2.13 用sed命令仅打印被替换的行<a class="heading-anchor" href="#2-13-用sed命令仅打印被替换的行" aria-hidden="true"></a></h2><p>如果仅想显示更改的行，使用下面的<code>sed</code>命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -n <span class="string">'s/Unix/Linux/p'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<ul>
<li><code>p</code> 它在终端上输出替换的行两次；</li>
<li><code>-n</code> 它抑制由<code>p</code>标识所产生的重复行。</li>
</ul>
<h2 id="2-14-同时运行多个sed命令" class="heading-control"><a href="#2-14-同时运行多个sed命令" class="headerlink" title="2.14 同时运行多个sed命令"></a>2.14 同时运行多个sed命令<a class="heading-anchor" href="#2-14-同时运行多个sed命令" aria-hidden="true"></a></h2><p>下面的<code>sed</code>命令同时搜索<code>linuxunix</code>和<code>CentOS</code>模式，并分别用<code>LINUXUNIX</code>和<code>RHEL8</code>分别更换它们：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">'s/linuxunix/LINUXUNIX/g'</span> -e <span class="string">'s/CentOS/RHEL8/g'</span> sed-test.txt</span><br></pre></td></tr></table></figure><br>以下<code>sed</code>命令搜索<code>linuxunix</code>和<code>CentOS</code>模式，用<code>Fedora30</code>替换它们：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -e <span class="string">'s/\(linuxunix\|CentOS\)/Fedora30/g'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-15-给定的模式匹配，查找和替换整个行" class="heading-control"><a href="#2-15-给定的模式匹配，查找和替换整个行" class="headerlink" title="2.15 给定的模式匹配，查找和替换整个行"></a>2.15 给定的模式匹配，查找和替换整个行<a class="heading-anchor" href="#2-15-给定的模式匹配，查找和替换整个行" aria-hidden="true"></a></h2><p>如果模式匹配，可以使用<code>sed</code>命令用新行来代替整行。这可以通过使用<code>c</code>标识来完成。下面的命令搜索sed-test.txt中含有<code>OS</code>字段的行，并将模式匹配的整行用<code>New Line</code>替换：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sed &#39;&#x2F;OS&#x2F; c\</span><br><span class="line">New Line</span><br><span class="line">&#39; sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h2 id="2-16-搜索和替换相匹配的模式行" class="heading-control"><a href="#2-16-搜索和替换相匹配的模式行" class="headerlink" title="2.16 搜索和替换相匹配的模式行"></a>2.16 搜索和替换相匹配的模式行<a class="heading-anchor" href="#2-16-搜索和替换相匹配的模式行" aria-hidden="true"></a></h2><p>在<code>sed</code>命令中可以为行指定适合的模式，在匹配该模式的情况下，<code>sed</code>命令搜索要被替换的字符串。下面的<code>sed</code>命令首先查找具有<code>OS</code>模式的行，然后用<code>ArchLinux</code>替换<code>Linux</code>：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed <span class="string">'/OS/ s/Linux/ArchLinux/'</span> sed-test.txt</span><br></pre></td></tr></table></figure></p>
<h1 id="3-参考" class="heading-control"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考<a class="heading-anchor" href="#3-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9tcC53ZWl4aW4ucXEuY29tL3M/X19iaXo9TXpBeE9ESTVPRE13T0E9PSZhbXA7bWlkPTI2NjY1NDQ3MjMmYW1wO2lkeD0xJmFtcDtzbj00MzdkMDcyNDc0ZTJiNTRiYTM0MTQ5NGU4NmU5YTQ0MSZhbXA7Y2hrc209ODBkY2ZhZjhiN2FiNzNlZWUzMzA2NTRiNjAwMDVhMzBmOGQxMWQ4ZWFjYzI5Y2NjMDFlYTFjNTIxMjk4MzFiNDJkNmVkNTQyYzFkNCZhbXA7bXBzaGFyZT0xJmFtcDtzY2VuZT0xJmFtcDtzcmNpZD0xMDI3blN6bFRrV3pqR1hCWlZnUThkSjMmYW1wO3NoYXJlcl9zaGFyZXRpbWU9MTU3MjE4MjQ2NjEyOCZhbXA7c2hhcmVyX3NoYXJlaWQ9MWZmNDAxZDk0ZDBlMzQyYTQxZGNlOGYzYTBhMTY3NDEmYW1wO2tleT0yNDczYTMyMGVmMWE2MjQxMTAyMjQ3YWFiMDE3M2FmODdlOGY1YTNkYTg1YzY1MDg1NzU1MGU1ZjNkN2Q3NDdlMTBjZTE5NjliNzYxZDI4ZGQwZGI0YmQ3MjMzZjg2NTVlNDI1MjEzOTQ1MWM1NjA1N2E0MTFiNmEwZmIzZjYwYWJlN2FmYmIzNjFiMDg0NDA3YzJjOGQ4MGE2MGJmMTkzJmFtcDthc2NlbmU9MSZhbXA7dWluPU1UZzROalE1TXpNMk1RJTNEJTNEJmFtcDtkZXZpY2V0eXBlPVdpbmRvd3MrMTAmYW1wO3ZlcnNpb249NjIwNzAxNTImYW1wO2xhbmc9emhfQ04mYW1wO3Bhc3NfdGlja2V0PU03MWx1RVh4QWcyMGphdjFXYTdtS1lKd0FpMnh0Z0RpTkJud2lBRGN2JTJCWHZseUxCQTBzOTRMZ3ZXJTJGcjFqaW0x" title="https://mp.weixin.qq.com/s?__biz=MzAxODI5ODMwOA==&amp;mid=2666544723&amp;idx=1&amp;sn=437d072474e2b54ba341494e86e9a441&amp;chksm=80dcfaf8b7ab73eee330654b60005a30f8d11d8eacc29ccc01ea1c52129831b42d6ed542c1d4&amp;mpshare=1&amp;scene=1&amp;srcid=1027nSzlTkWzjGXBZVgQ8dJ3&amp;sharer_sharetime=1572182466128&amp;sharer_shareid=1ff401d94d0e342a41dce8f3a0a16741&amp;key=2473a320ef1a6241102247aab0173af87e8f5a3da85c650857550e5f3d7d747e10ce1969b761d28dd0db4bd7233f8655e4252139451c56057a411b6a0fb3f60abe7afbb361b084407c2c8d80a60bf193&amp;ascene=1&amp;uin=MTg4NjQ5MzM2MQ%3D%3D&amp;devicetype=Windows+10&amp;version=62070152&amp;lang=zh_CN&amp;pass_ticket=M71luEXxAg20jav1Wa7mKYJwAi2xtgDiNBnwiADcv%2BXvlyLBA0s94LgvW%2Fr1jim1">sed命令查找和替换字符串的 16 个示例<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdG9uZ3llL3AvMTA2NjU3NzEuaHRtbA==" title="https://www.cnblogs.com/tongye/p/10665771.html">Shell 基础 — 流编辑器 sed 详解<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux中的ld-so与ld-linux-so</title>
    <url>/archives/c5106d85.html</url>
    <content><![CDATA[<h1 id="1-结论" class="heading-control"><a href="#1-结论" class="headerlink" title="1 结论"></a>1 结论<a class="heading-anchor" href="#1-结论" aria-hidden="true"></a></h1><p>动态链接器/加载器，<code>ld.so</code>和 <code>ld-linux.so*</code>查找并加载程序运行时所需要的共享对象（共享库），然后准备好程序并运行它，Linux二进制文件需要在运行时进行动态链接，除非在程序编译期间为ld（GNU链接器）指定了<code>-static</code>选项。<code>ld.so</code>程序处理a.out二进制格式（一种年代久远的二进制格式），<code>ld-linux.so*</code>（于libc5而言是/lib/ld-linux.so.1，于glibc2而言是/lib/ld-linux.so.2）处理更加现代的ELF二进制格式。两个程序具有相同的行为，使用相同的支持文件和程序（ldd、ldconfig和/etc/ld.so.conf）。<strong>ld.so与ld-linux.so是相似的，于程序运行期间起作用</strong>。</p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cDovL21hbjcub3JnL2xpbnV4L21hbi1wYWdlcy9tYW44L2xkLWxpbnV4LnNvLjguaHRtbA==" title="http://man7.org/linux/man-pages/man8/ld-linux.so.8.html">ld.so, ld-linux.so - dynamic linker/loader<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Not able to execute a .sh file: /bin/bash^M: bad interpreter</title>
    <url>/archives/ffbee3f1.html</url>
    <content><![CDATA[<h1 id="背景" class="heading-control"><a href="#背景" class="headerlink" title="背景"></a>背景<a class="heading-anchor" href="#背景" aria-hidden="true"></a></h1><p>在搭建某项目CI环境过程中，在Windows下写了个shell脚本，通过winscp传到了<code>gitlab runner</code>所在的Linux工作站上，在工作站上执行该shell脚本时报错：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash^M: bad interpreter: No such file or directory</span><br></pre></td></tr></table></figure></p>
<h1 id="知识" class="heading-control"><a href="#知识" class="headerlink" title="知识"></a>知识<a class="heading-anchor" href="#知识" aria-hidden="true"></a></h1><p>错误信息指出，脚本在试图查找位于<code>/bin/bash^M</code>处的解释器时出错：文件或目录不存在。事实也确实如此，目标解释器应该是<code>/bin/bash</code>。<code>^M</code>表示回车符（Carriage Return，CR）。</p>
<p>回车符<code>\r</code>本义是光标重新回到本行开头，r的英文return，控制字符可以写成<code>CR</code>，即Carriage Return，十六进制表示为<code>0x0D</code>；换行符<code>\n</code>本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成<code>LF</code>，即Line Feed，十六进制表示为<code>0x0A</code>。<code>EOL</code>（End of Line）是<code>CR</code>和<code>LF</code>的组合，表示到下一行并把焦点移到第一列。</p>
<p>在不同的操作系统这几个字符表现不同：</p>
<ul>
<li>在Windows系统下，<code>\r</code> <code>\n</code>这两个字符就是表现的本义，即用<code>EOL</code>作为行结尾符；</li>
<li>在类Unix系统下，<code>\n</code>表现为光标下一行并回到行首，即用<code>LF</code>作为行结尾符；</li>
<li>在Mac系统下，<code>\r</code>表现为回到本行开头并往下一行，即用<code>CR</code>作为行结尾符。</li>
</ul>
<p>至于ENTER键的定义是与操作系统有关的，通常用的Enter是两个加起来。</p>
<p>现实中的具体表现是：</p>
<ul>
<li>Unix/Mac系统下的文件在Windows下打开的话，所有文字会变成一行；</li>
<li>Windows下的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个<code>^M</code>符号。</li>
</ul>
<h1 id="解决" class="heading-control"><a href="#解决" class="headerlink" title="解决"></a>解决<a class="heading-anchor" href="#解决" aria-hidden="true"></a></h1><p>删除Windows环境下编辑的脚本中的多余<code>\r</code>回车符：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i -e <span class="string">'s/\r$//'</span> script.sh</span><br></pre></td></tr></table></figure><br>关于Linux中<code>sed</code>命令的使用，可参考此前的一篇文章：<a href="https://blog.shipengx.com/archives/31e5f0fe.html">《Linux中使用sed命令进行字符串查找和替换》</a>。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9hc2t1YnVudHUuY29tL3F1ZXN0aW9ucy8zMDQ5OTkvbm90LWFibGUtdG8tZXhlY3V0ZS1hLXNoLWZpbGUtYmluLWJhc2htLWJhZC1pbnRlcnByZXRlcg==" title="https://askubuntu.com/questions/304999/not-able-to-execute-a-sh-file-bin-bashm-bad-interpreter">Not able to execute a .sh file: /bin/bash^M: bad interpreter<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3F1aW5jeWZhbmcvYXJ0aWNsZS9kZXRhaWxzLzUzMTU2NDc2" title="https://blog.csdn.net/quincyfang/article/details/53156476">The differences between Carriage Return(CR) and Line Feed(LF)<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rvbmdkb25nMjA1L2FydGljbGUvZGV0YWlscy82NzgyMTYx" title="https://blog.csdn.net/dongdong205/article/details/6782161">关于换行符CR(Carriage return) 和 LF(line feed) 的区别<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的当前工作路径与当前脚本文件所在路径</title>
    <url>/archives/43b2dca3.html</url>
    <content><![CDATA[<h1 id="背景" class="heading-control"><a href="#背景" class="headerlink" title="背景"></a>背景<a class="heading-anchor" href="#背景" aria-hidden="true"></a></h1><p>在编写Robot Framework测试库的过程中，需要将自建库的<strong>init</strong>.py脚本文件所在路径添加进系统路径，Python才能够识别库中的各个模块。</p>
<h1 id="结论" class="heading-control"><a href="#结论" class="headerlink" title="结论"></a>结论<a class="heading-anchor" href="#结论" aria-hidden="true"></a></h1><p>假如，在桌面创建了一个名为<code>test.py</code>的Python脚本，并输入如下代码：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">print(os.path.dirname(__file__))</span><br><span class="line">print(os.getcwd())</span><br></pre></td></tr></table></figure><br>然后，我们在电脑中的另一个位置<code>F:\04_Individual\03_Tech\00_Hexo</code>打开终端，并运行刚刚创建的脚本<code>test.py</code>，会得到如下结果：<br><figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">ShiPeng@HelloWorld MINGW64 /f/<span class="number">04</span>_Individual/<span class="number">03</span>_Tech/<span class="number">00</span>_Hexo</span><br><span class="line">$ python3 -u "c:\Users\ShiPeng\Desktop\test.py"</span><br><span class="line"><span class="function">c:\<span class="title">Users</span>\<span class="title">ShiPeng</span>\<span class="title">Desktop</span></span></span><br><span class="line"><span class="function"><span class="title">F</span>:\04<span class="title">_Individual</span>\03<span class="title">_Tech</span>\00<span class="title">_Hexo</span></span></span><br></pre></td></tr></table></figure><br>可以发现，<code>os.getcwd()</code>获取的是当前工作目录（即工程目录），而<code>os.path.dirname(__file__)</code>获得的才是当前Python脚本所在目录（不包含文件名）。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8xNDY1NDQuaHRt" title="https://www.jb51.net/article/146544.htm">浅析python3中的os.path.dirname的使用<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>Python</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python字典数据结构的item()函数</title>
    <url>/archives/b11e5b5a.html</url>
    <content><![CDATA[<h1 id="结论" class="heading-control"><a href="#结论" class="headerlink" title="结论"></a>结论<a class="heading-anchor" href="#结论" aria-hidden="true"></a></h1><p>在学习Robot Framework自动化测试框架测试库编写过程中，了解到了字典的<code>item()</code>函数，通过调用此函数，会返回一个列表，列表中包含的是可遍历的(键, 值) 元组数组。如在vscode中运行下面的Python代码片段：<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;<span class="string">'key1'</span>: <span class="string">'value1'</span>, <span class="string">'key2'</span>: <span class="string">'value2'</span>, <span class="string">'key3'</span>: <span class="string">'value3'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> dic.items():</span><br><span class="line">    print(key, value)</span><br></pre></td></tr></table></figure><br>会得到下面的输出：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key1 value1</span><br><span class="line">key2 value2</span><br><span class="line">key3 value3</span><br></pre></td></tr></table></figure></p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5ydW5vb2IuY29tL3B5dGhvbi9hdHQtZGljdGlvbmFyeS1pdGVtcy5odG1s" title="http://www.runoob.com/python/att-dictionary-items.html">Python 字典(Dictionary) items()方法<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>Python</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python类的静态方法（static method）和类方法（class method）</title>
    <url>/archives/875015e3.html</url>
    <content><![CDATA[<h1 id="静态方法" class="heading-control"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法<a class="heading-anchor" href="#静态方法" aria-hidden="true"></a></h1><p>静态方法是类中的函数，不需要实例（类似于C++中的静态成员函数）。静态方法主要是用来存放逻辑性的代码，主要是一些逻辑属于类，但是和类本身没有交互，即在静态方法中，不会涉及到类中的方法和属性的操作。</p>
<h1 id="类方法" class="heading-control"><a href="#类方法" class="headerlink" title="类方法"></a>类方法<a class="heading-anchor" href="#类方法" aria-hidden="true"></a></h1><p>类方法是将类本身作为对象进行操作的方法，和静态方法的区别在于：<strong>不管这个方法是从实例调用还是从类调用，它都用第一个参数把类传递过来</strong>。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcGlua2luZy9wLzc5NDQzNzYuaHRtbA==" title="https://www.cnblogs.com/pinking/p/7944376.html">python中的静态方法和类方法<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>Python</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>ROS 1 安装——从手动到自动：以 Ubuntu 18.04 + ROS Melodic 为例</title>
    <url>/archives/f969107a.html</url>
    <content><![CDATA[<p><img data-src="https://image.shipengx.com/ROS-1-%E5%AE%89%E8%A3%85%E2%80%94%E2%80%94%E4%BB%8E%E6%89%8B%E5%8A%A8%E5%88%B0%E8%87%AA%E5%8A%A8%EF%BC%9A%E4%BB%A5-Ubuntu-18-04-ROS-Melodic-%E4%B8%BA%E4%BE%8B.png" alt="ROS-1-安装——从手动到自动：以-Ubuntu-18-04-ROS-Melodic-为例"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>近期在 Ubuntu 18.04 下安装 ROS 1 Melodic 的过程中遇到 <code>rosdep init</code> 和 <code>rosdep update</code> 报错的问题，手动解决不免繁琐，而且 <code>rosdistro</code> 库会时常更新，如果 <code>rosdep update</code> 时使用了旧版的 <code>YAML</code> 文件，有可能导致后期安装其它 ROS 组件时出现问题，为此开发了完全一键安装开源工具 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JvY1NoaS9yb3N0YWxsZXI=" title="https://github.com/RocShi/rostaller">rostaller<i class="fa fa-external-link"></i></span>。</p>
<h1 id="1-手动安装" class="heading-control"><a href="#1-手动安装" class="headerlink" title="1 手动安装"></a>1 手动安装<a class="heading-anchor" href="#1-手动安装" aria-hidden="true"></a></h1><h2 id="1-1-配置-Ubuntu-软件仓库" class="heading-control"><a href="#1-1-配置-Ubuntu-软件仓库" class="headerlink" title="1.1 配置 Ubuntu 软件仓库"></a>1.1 配置 Ubuntu 软件仓库<a class="heading-anchor" href="#1-1-配置-Ubuntu-软件仓库" aria-hidden="true"></a></h2><p>确保 restricted、universe 和 multiverse 被勾选，选择国内更稳定的镜像源，例如清华源：<span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL3VidW50dS8=" title="https://mirrors.tuna.tsinghua.edu.cn/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/ubuntu/<i class="fa fa-external-link"></i></span></p>
<p><img data-src="https://image.shipengx.com/%E9%85%8D%E7%BD%AE%20Ubuntu%20%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93.png" alt="配置 Ubuntu 软件仓库"></p>
<h2 id="1-2-添加-ros-源" class="heading-control"><a href="#1-2-添加-ros-源" class="headerlink" title="1.2 添加 ros 源"></a>1.2 添加 ros 源<a class="heading-anchor" href="#1-2-添加-ros-源" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">'. /etc/lsb-release &amp;&amp; echo "deb http://mirrors.tuna.tsinghua.edu.cn/ros/ubuntu/ `lsb_release -cs` main" &gt; /etc/apt/sources.list.d/ros-latest.list'</span></span><br></pre></td></tr></table></figure>
<h2 id="1-3-设置密钥" class="heading-control"><a href="#1-3-设置密钥" class="headerlink" title="1.3 设置密钥"></a>1.3 设置密钥<a class="heading-anchor" href="#1-3-设置密钥" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install curl</span><br><span class="line">curl -sSL <span class="string">'http://keyserver.ubuntu.com/pks/lookup?op=get&amp;search=0xC1CF6E31E6BADE8868B172B4F42ED6FBAB17C654'</span> | sudo apt-key add -</span><br></pre></td></tr></table></figure>
<h2 id="1-4-安装-ROS" class="heading-control"><a href="#1-4-安装-ROS" class="headerlink" title="1.4 安装 ROS"></a>1.4 安装 ROS<a class="heading-anchor" href="#1-4-安装-ROS" aria-hidden="true"></a></h2><p>这里以 ROS Melodic 桌面完全版为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install ros-melodic-desktop-full</span><br></pre></td></tr></table></figure>
<h2 id="1-5-配置环境" class="heading-control"><a href="#1-5-配置环境" class="headerlink" title="1.5 配置环境"></a>1.5 配置环境<a class="heading-anchor" href="#1-5-配置环境" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"source /opt/ros/melodic/setup.bash"</span> &gt;&gt;~/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="1-6-安装构建包所需依赖" class="heading-control"><a href="#1-6-安装构建包所需依赖" class="headerlink" title="1.6 安装构建包所需依赖"></a>1.6 安装构建包所需依赖<a class="heading-anchor" href="#1-6-安装构建包所需依赖" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python-rosdep python-rosinstall python-rosinstall-generator python-wstool build-essential</span><br></pre></td></tr></table></figure>
<h2 id="1-7-初始化-rosdep" class="heading-control"><a href="#1-7-初始化-rosdep" class="headerlink" title="1.7 初始化 rosdep"></a>1.7 初始化 rosdep<a class="heading-anchor" href="#1-7-初始化-rosdep" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo rosdep init</span><br></pre></td></tr></table></figure>
<p>由于域名污染，这一步往往会报下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ERROR: cannot download default sources list from:</span><br><span class="line">https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;rosdep&#x2F;sources.list.d&#x2F;20-default.list</span><br><span class="line">Website may be down.</span><br></pre></td></tr></table></figure>
<p>为解决该问题，首先，克隆 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Jvcy9yb3NkaXN0cm8=" title="https://github.com/ros/rosdistro">rosdistro<i class="fa fa-external-link"></i></span> 仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ros/rosdistro.git</span><br></pre></td></tr></table></figure>
<p>然后，本地新建对应目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/ros/rosdep/sources.list.d</span><br></pre></td></tr></table></figure>
<p>最后，将克隆下来的 <code>rosdistro</code> 仓库中的 <code>list</code> 文件拷贝到上述目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> rosdistro</span><br><span class="line">sudo cp rosdep/sources.list.d/20-default.list /etc/ros/rosdep/sources.list.d/</span><br></pre></td></tr></table></figure>
<h2 id="1-8-更新本地-rosdep-数据库" class="heading-control"><a href="#1-8-更新本地-rosdep-数据库" class="headerlink" title="1.8 更新本地 rosdep 数据库"></a>1.8 更新本地 rosdep 数据库<a class="heading-anchor" href="#1-8-更新本地-rosdep-数据库" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosdep update</span><br></pre></td></tr></table></figure>
<p>同样是由于域名污染，这一步往往会报下面的错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reading in sources list data from &#x2F;etc&#x2F;ros&#x2F;rosdep&#x2F;sources.list.d</span><br><span class="line">ERROR: unable to process source [https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;rosdep&#x2F;osx-homebrew.yaml]:</span><br><span class="line">	&lt;urlopen error [Errno 111] Connection refused&gt; (https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;rosdep&#x2F;osx-homebrew.yaml)</span><br><span class="line">ERROR: unable to process source [https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;rosdep&#x2F;base.yaml]:</span><br><span class="line">	&lt;urlopen error [Errno 111] Connection refused&gt; (https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;rosdep&#x2F;base.yaml)</span><br><span class="line">ERROR: unable to process source [https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;rosdep&#x2F;python.yaml]:</span><br><span class="line">	&lt;urlopen error [Errno 111] Connection refused&gt; (https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;rosdep&#x2F;python.yaml)</span><br><span class="line">ERROR: unable to process source [https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;rosdep&#x2F;ruby.yaml]:</span><br><span class="line">	&lt;urlopen error [Errno 111] Connection refused&gt; (https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;rosdep&#x2F;ruby.yaml)</span><br><span class="line">ERROR: unable to process source [https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;releases&#x2F;fuerte.yaml]:</span><br><span class="line">	Failed to download target platform data for gbpdistro:</span><br><span class="line">	&lt;urlopen error [Errno 111] Connection refused&gt;</span><br><span class="line">Query rosdistro index https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;index-v4.yaml</span><br><span class="line">ERROR: error loading sources list:</span><br><span class="line">	&lt;urlopen error &lt;urlopen error [Errno 111] Connection refused&gt; (https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ros&#x2F;rosdistro&#x2F;master&#x2F;index-v4.yaml)&gt;</span><br></pre></td></tr></table></figure>
<p>假设已经解决上面步骤中 <code>rosdep init</code> 遇到的问题，现在需要编辑以下四个文件（<strong>做好备份</strong>）：</p>
<ul>
<li><code>/etc/ros/rosdep/sources.list.d/20-default.list</code></li>
<li><code>/usr/lib/python2.7/dist-packages/rosdep2/gbpdistro_support.py</code></li>
<li><code>/usr/lib/python2.7/dist-packages/rosdep2/rep3.py</code></li>
<li><code>/usr/lib/python2.7/dist-packages/rosdistro/__init__.py</code></li>
</ul>
<p>搜索文件中的 <code>https://raw.githubusercontent.com/ros/rosdistro/master</code> 字段，将其替换为本地 <code>rosdistro</code> 仓库的绝对地址，例如本示例中为 <code>file:///home/shipeng/Desktop/rosdistro</code>。编辑后的 <code>list</code> 文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># os-specific listings first</span><br><span class="line">yaml file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;rosdep&#x2F;osx-homebrew.yaml osx</span><br><span class="line"></span><br><span class="line"># generic</span><br><span class="line">yaml file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;rosdep&#x2F;base.yaml</span><br><span class="line">yaml file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;rosdep&#x2F;python.yaml</span><br><span class="line">yaml file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;rosdep&#x2F;ruby.yaml</span><br><span class="line">gbpdistro file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;releases&#x2F;fuerte.yaml fuerte</span><br><span class="line"></span><br><span class="line"># newer distributions (Groovy, Hydro, ...) must not be listed anymore, they are being fetched from the rosdistro index.yaml instead</span><br></pre></td></tr></table></figure>
<p>然后重新执行 <code>rosdep update</code> 命令即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reading in sources list data from &#x2F;etc&#x2F;ros&#x2F;rosdep&#x2F;sources.list.d</span><br><span class="line">Hit file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;rosdep&#x2F;osx-homebrew.yaml</span><br><span class="line">Hit file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;rosdep&#x2F;base.yaml</span><br><span class="line">Hit file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;rosdep&#x2F;python.yaml</span><br><span class="line">Hit file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;rosdep&#x2F;ruby.yaml</span><br><span class="line">Hit file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;releases&#x2F;fuerte.yaml</span><br><span class="line">Query rosdistro index file:&#x2F;&#x2F;&#x2F;home&#x2F;shipeng&#x2F;Desktop&#x2F;rosdistro&#x2F;index-v4.yaml</span><br><span class="line">Skip end-of-life distro &quot;ardent&quot;</span><br><span class="line">Skip end-of-life distro &quot;bouncy&quot;</span><br><span class="line">Skip end-of-life distro &quot;crystal&quot;</span><br><span class="line">Skip end-of-life distro &quot;dashing&quot;</span><br><span class="line">Skip end-of-life distro &quot;eloquent&quot;</span><br><span class="line">Add distro &quot;foxy&quot;</span><br><span class="line">Add distro &quot;galactic&quot;</span><br><span class="line">Skip end-of-life distro &quot;groovy&quot;</span><br><span class="line">Skip end-of-life distro &quot;hydro&quot;</span><br><span class="line">Skip end-of-life distro &quot;indigo&quot;</span><br><span class="line">Skip end-of-life distro &quot;jade&quot;</span><br><span class="line">Skip end-of-life distro &quot;kinetic&quot;</span><br><span class="line">Skip end-of-life distro &quot;lunar&quot;</span><br><span class="line">Add distro &quot;melodic&quot;</span><br><span class="line">Add distro &quot;noetic&quot;</span><br><span class="line">Add distro &quot;rolling&quot;</span><br><span class="line">updated cache in &#x2F;home&#x2F;shipeng&#x2F;.ros&#x2F;rosdep&#x2F;sources.cache</span><br></pre></td></tr></table></figure>
<h2 id="1-8-运行小海龟示例" class="heading-control"><a href="#1-8-运行小海龟示例" class="headerlink" title="1.8 运行小海龟示例"></a>1.8 运行小海龟示例<a class="heading-anchor" href="#1-8-运行小海龟示例" aria-hidden="true"></a></h2><p>打开终端，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roscore</span><br></pre></td></tr></table></figure>
<p>另开新的终端，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun turtlesim turtlesim_node</span><br></pre></td></tr></table></figure>
<p>弹出小海龟界面：</p>
<p><img data-src="https://image.shipengx.com/%E5%B0%8F%E6%B5%B7%E9%BE%9F.png" alt="小海龟"></p>
<p>另开新的终端，执行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rosrun turtle_teleop_key</span><br></pre></td></tr></table></figure>
<p>保持该终端中的光标处于激活状态，通过方向键即可控制小海龟的移动。</p>
<h1 id="2-自动化安装——使用-rostaller" class="heading-control"><a href="#2-自动化安装——使用-rostaller" class="headerlink" title="2 自动化安装——使用 rostaller"></a>2 自动化安装——使用 rostaller<a class="heading-anchor" href="#2-自动化安装——使用-rostaller" aria-hidden="true"></a></h1><p>上述手动安装的步骤中，处理 <code>rosdep init</code> 和 <code>rosdep update</code> 报错问题的方法操作起来不免繁琐，而且 <code>rosdistro</code> 库会时常更新，如果 <code>rosdep update</code> 时使用了旧版的 <code>YAML</code> 文件，有可能导致后期安装其它 ROS 组件时出现问题，为此开发了 Ubuntu 18.04 下 ROS 1 Melodic 完全一键安装的开源工具 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JvY1NoaS9yb3N0YWxsZXI=" title="https://github.com/RocShi/rostaller">rostaller<i class="fa fa-external-link"></i></span>，再也不用纠结 <code>rosdep init</code> 和 <code>rosdep update</code> 报错的问题，工具执行时会尝试在线更新 <code>YAML</code> 文件，后面可能会增加对 ROS 1 其它版本及 ROS 2 的支持。欢迎使用 + star，欢迎提 issue，欢迎 folk + pull request。工具使用方法：</p>
<ul>
<li><p>克隆仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/RocShi/rostaller.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入本地仓库目录，为脚本添加可执行权限（仅首次执行需要）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x run.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行脚本，一键安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./run.sh</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>Enjoy!</strong></p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cDovL3dpa2kucm9zLm9yZy9jbi9tZWxvZGljL0luc3RhbGxhdGlvbi9VYnVudHU=" title="http://wiki.ros.org/cn/melodic/Installation/Ubuntu">在 Ubuntu 中安装 ROS Melodic<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3dpa2kucm9zLm9yZy9tZWxvZGljL0luc3RhbGxhdGlvbi9VYnVudHU=" title="http://wiki.ros.org/melodic/Installation/Ubuntu">Ubuntu install of ROS Melodic<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzMxMTkyMC9hcnRpY2xlL2RldGFpbHMvMTE0Nzk2NzQ4P3V0bV9zb3VyY2U9YXBwJmFtcDthcHBfdmVyc2lvbj00LjUuNA==" title="https://blog.csdn.net/weixin_43311920/article/details/114796748?utm_source=app&amp;app_version=4.5.4">rosdep init/update 解决方法<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjU4NDkxNy9hcnRpY2xlL2RldGFpbHMvMTE0NDQ4MzU1" title="https://blog.csdn.net/weixin_42584917/article/details/114448355">ROS rosdep init/update 报错终极解决方法<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>ROS</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>ROS</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell中美元符$与数字及其它各种符号组合的含义</title>
    <url>/archives/55ffbd22.html</url>
    <content><![CDATA[<h1 id="结论" class="heading-control"><a href="#结论" class="headerlink" title="结论"></a>结论<a class="heading-anchor" href="#结论" aria-hidden="true"></a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$0</span></span><br></pre></td></tr></table></figure>
<p>脚本本身的文件名；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$n</span></span><br></pre></td></tr></table></figure>
<p>传递给脚本或函数的参数。n 是一个数字，表示第几个参数，取值范围为1~9。例如，第一个参数是<code>$1</code>，第二个参数是<code>$2</code>；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$*</span><br></pre></td></tr></table></figure>
<p>以一个单字符串显示传给脚本或函数的所有参数，<code>$1 $2 $3 … $n</code>；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$@</span></span><br></pre></td></tr></table></figure>
<p>传给脚本的所有参数列表，<code>$1</code> <code>$2</code> <code>$3</code> … <code>$n</code>；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$#</span></span><br></pre></td></tr></table></figure>
<p>传给脚本或函数的参数个数；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>当前Shell进程ID。对于Shell脚本，就是这些脚本所在的进程ID；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$?</span><br></pre></td></tr></table></figure>
<p>上个命令的退出状态（0表示没有错误，其它任何值表明有错误）或函数的返回值。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aGlkYW8uYmFpZHUuY29tL3F1ZXN0aW9uLzc1ODEyMjgxNjUwMjA1MjY4NC5odG1s" title="https://zhidao.baidu.com/question/758122816502052684.html">linux shell 中的“$1”代表什么？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3BsZW5kaWQvcC8xMTIxMTQzMC5odG1s" title="https://www.cnblogs.com/splendid/p/11211430.html">shell中的$0 $n $# $* $@ $? $$<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC91LzM5OTcxODIvYmxvZy8zMDcxNDYw" title="https://my.oschina.net/u/3997182/blog/3071460">linux中$#,$0,$1,$2,$@,$*,$$,$?的含义<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell中各种括号的作用</title>
    <url>/archives/17a8c28.html</url>
    <content><![CDATA[<h1 id="1-小括号，圆括号" class="heading-control"><a href="#1-小括号，圆括号" class="headerlink" title="1 小括号，圆括号()"></a>1 小括号，圆括号()<a class="heading-anchor" href="#1-小括号，圆括号" aria-hidden="true"></a></h1><h2 id="1-1-单小括号" class="heading-control"><a href="#1-1-单小括号" class="headerlink" title="1.1 单小括号()"></a>1.1 单小括号()<a class="heading-anchor" href="#1-1-单小括号" aria-hidden="true"></a></h2><ul>
<li><strong>命令组</strong>。<code>(cmd1;cmd2;cmd3)</code>将会新开一个子shell顺序执行命令cmd1、cmd2、cmd3，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。</li>
<li><strong>命令替换</strong>。等同于`cmd`，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</li>
<li><strong>初始化数组</strong>。如：array=(a b c d)</li>
</ul>
<h2 id="1-2-双小括号" class="heading-control"><a href="#1-2-双小括号" class="headerlink" title="1.2 双小括号(())"></a>1.2 双小括号(())<a class="heading-anchor" href="#1-2-双小括号" aria-hidden="true"></a></h2><ul>
<li><strong>整数扩展</strong>。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是”假”，而一个非零值的表达式所返回的退出状态码将为0，或者是”true”。若是逻辑判断，表达式exp为真则为1,假则为0。</li>
<li><strong>只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符</strong>。作不同进位（如二进制、八进制、十六进制）运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f))结果为95（16进位转十进制）。</li>
<li><strong>可重定义变量值</strong>。比如 a=5; ((a++)) 可将 $a 重定义为6。</li>
<li><strong>算术运算比较，双括号中的变量可以不使用$符号前缀</strong>。括号内支持多个表达式用逗号分开。只要括号中的表达式符合C语言运算规则，比如对于for循环，下面3种写法是等效的：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>((i=0;i&lt;5;i++))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 0 4`</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..4&#125;</span><br></pre></td></tr></table></figure>
对if逻辑判断，下面两种写法是等效的：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((<span class="variable">$i</span>&lt;5))</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$i</span> -lt 5 ]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="2-中括号，方括号" class="heading-control"><a href="#2-中括号，方括号" class="headerlink" title="2 中括号，方括号[]"></a>2 中括号，方括号[]<a class="heading-anchor" href="#2-中括号，方括号" aria-hidden="true"></a></h1><h2 id="2-1-单中括号" class="heading-control"><a href="#2-1-单中括号" class="headerlink" title="2.1 单中括号[]"></a>2.1 单中括号[]<a class="heading-anchor" href="#2-1-单中括号" aria-hidden="true"></a></h2><ul>
<li><strong>bash的内部命令，[和test是等同的</strong>。如果不用绝对路径指明，通常用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的bash中要求必须这样。</li>
<li><strong>test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式</strong>。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较”ab”和”bc”：[ ab \&lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</li>
<li><strong>字符范围</strong>。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。</li>
<li><strong>在一个array结构的上下文中，中括号用来引用数组中每个元素的编号</strong>。</li>
</ul>
<h2 id="2-2-双中括号" class="heading-control"><a href="#2-2-双中括号" class="headerlink" title="2.2 双中括号[[]]"></a>2.2 双中括号[[]]<a class="heading-anchor" href="#2-2-双中括号" aria-hidden="true"></a></h2><ul>
<li><strong>[[是bash程序语言的关键字，并不是一个命令</strong>。[[ ]] 结构比[ ]结构更加通用，在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</li>
<li><strong>支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式</strong>。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</li>
<li><strong>使用[[ … ]]条件判断结构，而不是[ … ]，能够防止脚本中的许多逻辑错误</strong>。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如下面的几种写法是等效的：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> != 1 &amp;&amp; <span class="variable">$a</span> != 2 ]]</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ne 1] &amp;&amp; [ <span class="variable">$a</span> != 2 ]</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ne 1 -a <span class="variable">$a</span> != 2 ]</span><br></pre></td></tr></table></figure></li>
<li><strong>bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码</strong>。</li>
</ul>
<p>一些示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$i</span>&lt;5) </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$i</span> -lt 5 ] </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ne 1 -a <span class="variable">$a</span> != 2 ] </span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$a</span> -ne 1] &amp;&amp; [ <span class="variable">$a</span> != 2 ] </span><br><span class="line"><span class="keyword">if</span> [[ <span class="variable">$a</span> != 1 &amp;&amp; <span class="variable">$a</span> != 2 ]] </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> $(seq 0 4);<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> `seq 0 4`;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> ((i=0;i&lt;5;i++));<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;0..4&#125;;<span class="keyword">do</span> <span class="built_in">echo</span> <span class="variable">$i</span>;<span class="keyword">done</span></span><br></pre></td></tr></table></figure></p>
<h1 id="3-大括号，花括号" class="heading-control"><a href="#3-大括号，花括号" class="headerlink" title="3 大括号，花括号{}"></a>3 大括号，花括号{}<a class="heading-anchor" href="#3-大括号，花括号" aria-hidden="true"></a></h1><h2 id="3-1-常规用法" class="heading-control"><a href="#3-1-常规用法" class="headerlink" title="3.1 常规用法"></a>3.1 常规用法<a class="heading-anchor" href="#3-1-常规用法" aria-hidden="true"></a></h2><ul>
<li><strong>大括号拓展</strong>。(通配(globbing))将对大括号中的文件名做扩展。在大括号中，不允许有空白，除非这个空白被引用或转义。第一种：对大括号中的以逗号分割的文件列表进行拓展。如 touch {a,b}.txt 结果为a.txt b.txt。第二种：对大括号中以点点（..）分割的顺序文件列表起拓展作用，如：touch {a..d}.txt 结果为a.txt b.txt c.txt d.txt。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ls &#123;ex1,ex2&#125;.sh </span></span><br><span class="line">ex1.sh ex2.sh </span><br><span class="line"><span class="comment"># ls &#123;ex&#123;1..3&#125;,ex4&#125;.sh </span></span><br><span class="line">ex1.sh ex2.sh ex3.sh ex4.sh </span><br><span class="line"><span class="comment"># ls &#123;ex[1-3],ex4&#125;.sh </span></span><br><span class="line">ex1.sh ex2.sh ex3.sh ex4.sh</span><br></pre></td></tr></table></figure></li>
<li><strong>代码块，又被称为内部组，这个结构事实上创建了一个匿名函数</strong>。与小括号中的命令不同，大括号内的命令不会新开一个子shell运行，即脚本余下部分仍可使用括号内变量。<code>{ cmd1;cmd2;cmd3;}</code>在当前shell顺序执行命令cmd1、cmd2、cmd3，括号内的命令间用分号隔开，最后一个也必须有分号。{}的第一个命令和左括号之间必须要有一个空格。</li>
</ul>
<h2 id="3-2-几种特殊的替换结构" class="heading-control"><a href="#3-2-几种特殊的替换结构" class="headerlink" title="3.2 几种特殊的替换结构"></a>3.2 几种特殊的替换结构<a class="heading-anchor" href="#3-2-几种特殊的替换结构" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;var:-string&#125;</span>,<span class="variable">$&#123;var:+string&#125;</span>,<span class="variable">$&#123;var:=string&#125;</span>,<span class="variable">$&#123;var:?string&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>${var:-string}</code>和<code>${var:=string}</code>：若变量var为空，则用在命令行中用string来替换<code>${var:-string}</code>，否则变量var不为空时，则用变量var的值来替换<code>${var:-string}</code>；对于<code>${var:=string}</code>的替换规则和<code>${var:-string}</code>是一样的，不同之处是<code>${var:=string}</code>若var为空时，用string替换<code>${var:=string}</code>的同时，把string赋给变量var。<code>${var:=string}</code>很常用的一种用法是，判断某个变量是否赋值，没有的话则给它赋上一个默认值。</li>
<li><code>${var:+string}</code>的替换规则和上面的相反，即只有当var不是空的时候才替换成string，若var为空时则不替换或者说是替换成变量var的值，即空值。(因为变量var此时为空，所以这两种说法是等价的)。</li>
<li><code>${var:?string}</code>替换规则为：若变量var不为空，则用变量var的值来替换<code>${var:?string}</code>；若变量var为空，则把string输出到标准错误中，并从脚本中退出。可利用此特性来检查是否设置了变量的值。</li>
</ul>
<blockquote>
<p>补充扩展：在上面五种替换结构中string不一定是常值的，可用另外一个变量的值或是一种命令的输出。</p>
</blockquote>
<h2 id="3-3-四种模式匹配替换结构" class="heading-control"><a href="#3-3-四种模式匹配替换结构" class="headerlink" title="3.3 四种模式匹配替换结构"></a>3.3 四种模式匹配替换结构<a class="heading-anchor" href="#3-3-四种模式匹配替换结构" aria-hidden="true"></a></h2><p>模式匹配记忆方法：</p>
<blockquote>
<p>#是去掉左边（在键盘上#在$之左边），%是去掉右边（在键盘上%在$之右边）。#和%中的单一符号是最小匹配，两个相同符号是最大匹配。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;var%pattern&#125;</span>,<span class="variable">$&#123;var%%pattern&#125;</span>,<span class="variable">$&#123;var#pattern&#125;</span>,<span class="variable">$&#123;var##pattern&#125;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>第一种模式：<code>${variable%pattern}</code>，这种模式时，shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容<strong>去掉右边最短</strong>的匹配模式。</li>
<li>第二种模式：<code>${variable%%pattern}</code>，这种模式时，shell在variable中查找，看它是否以给的模式pattern结尾，如果是，就从命令行把variable中的内容<strong>去掉右边最长</strong>的匹配模式。</li>
<li>第三种模式：<code>${variable#pattern}</code>，这种模式时，shell在variable中查找，看它是否以给的模式pattern开始，如果是，就从命令行把variable中的内容<strong>去掉左边最短</strong>的匹配模式。</li>
<li>第四种模式：<code>${variable##pattern}</code>，这种模式时，shell在variable中查找，看它是否以给的模式pattern开始，如果是，就从命令行把variable中的内容<strong>去掉左边最长</strong>的匹配模式。</li>
</ul>
<p>这四种模式中都不会改变variable的值，其中，只有在pattern中使用了*匹配符号时，%和%%，#和##才有区别。结构中的pattern支持通配符，*表示零个或多个任意字符，?表示仅与一个任意字符匹配，[…]表示匹配中括号里面的字符，[!…]表示不匹配中括号里面的字符。</p>
</blockquote>
<p>示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=testcase </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> </span><br><span class="line">testcase </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var%s*e&#125;</span> </span><br><span class="line">testca </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> </span><br><span class="line">testcase </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var%%s*e&#125;</span> </span><br><span class="line">te </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var#?e&#125;</span> </span><br><span class="line">stcase </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var##?e&#125;</span> </span><br><span class="line">stcase </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var##*e&#125;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var##*s&#125;</span> </span><br><span class="line">e </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var##test&#125;</span> </span><br><span class="line"><span class="keyword">case</span></span><br></pre></td></tr></table></figure></p>
<h2 id="3-4-字符串提取和替换" class="heading-control"><a href="#3-4-字符串提取和替换" class="headerlink" title="3.4 字符串提取和替换"></a>3.4 字符串提取和替换<a class="heading-anchor" href="#3-4-字符串提取和替换" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;var:num&#125;</span>,<span class="variable">$&#123;var:num1:num2&#125;</span>,<span class="variable">$&#123;var/pattern/pattern&#125;</span>,<span class="variable">$&#123;var//pattern/pattern&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一种模式：<code>${var:num}</code>，这种模式时，shell在var中提取第num个字符到末尾的所有字符。若num为正数，从左边0处开始；若num为负数，从右边开始提取字串，但必须使用在冒号后面加空格或一个数字或整个num加上括号，如<code>${var: -2}</code>、<code>${var:1-3}</code>或<code>${var:(-2)}</code>。</li>
<li>第二种模式：<code>${var:num1:num2}</code>，num1是位置，num2是长度。表示从$var字符串的第$num1个位置开始提取长度为$num2的子串。不能为负数。</li>
<li>第三种模式：<code>${var/pattern1/pattern2}</code>，表示将var字符串的第一个匹配的pattern1替换为pattern2。</li>
<li>第四种模式：<code>${var//pattern1/pattern2}</code>，表示将var字符串中的所有能匹配的pattern1替换为pattern2。</li>
</ul>
<p>示例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">var=/home/centos </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$var</span> </span><br><span class="line">/home/centos</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:5&#125;</span> </span><br><span class="line">/centos</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var: -6&#125;</span> </span><br><span class="line">centos </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:(-6)&#125;</span> </span><br><span class="line">centos </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var:1:4&#125;</span> </span><br><span class="line">home </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var/o/h&#125;</span> </span><br><span class="line">/hhme/centos</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$&#123;var//o/h&#125;</span> </span><br><span class="line">/hhme/cenths</span><br></pre></td></tr></table></figure></p>
<h1 id="4-符号-后的括号" class="heading-control"><a href="#4-符号-后的括号" class="headerlink" title="4 符号$后的括号"></a>4 符号$后的括号<a class="heading-anchor" href="#4-符号-后的括号" aria-hidden="true"></a></h1><ul>
<li><code>${a}</code>表示变量a的值，在不引起歧义的情况下可以省略大括号。</li>
<li><code>$(cmd)</code>表示命令替换，和`cmd`效果相同，结果为shell命令cmd的输出，然而某些Shell版本不支持$()形式的命令替换, 如tcsh。</li>
<li><code>$((expression))</code>和`exprexpression`效果相同，计算数学表达式exp的数值，其中exp只要符合C语言的运算规则即可, 甚至三目运算符和逻辑表达式都可以计算。</li>
</ul>
<h1 id="5-参考" class="heading-control"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考<a class="heading-anchor" href="#5-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8xMjMwODEuaHRt" title="https://www.jb51.net/article/123081.htm">shell中各种括号的作用详解()、(())、[ ]、[[]]、{}<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaG9uZzIwMTYvcC85NDY1NzExLmh0bWw=" title="https://www.cnblogs.com/hong2016/p/9465711.html">Linux shell 中 $() ` `，${}，$[ ] $(())，[ ] (( )) [[]] 作用与区别<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy56c3l0aGluay5uZXQvYXJjaGl2ZXMvMjI1Mi8=" title="http://www.zsythink.net/archives/2252/">bash中[ ]与[[]]的区别<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell中设置文字输出的颜色及字体格式</title>
    <url>/archives/a1691b48.html</url>
    <content><![CDATA[<h1 id="1-描述" class="heading-control"><a href="#1-描述" class="headerlink" title="1 描述"></a>1 描述<a class="heading-anchor" href="#1-描述" aria-hidden="true"></a></h1><p>在shell脚本中，有时会定制特殊格式的字符串用以强调一些信息，例如以下字符串：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gbError=<span class="string">"\033[1;31m[ERROR]\033[0m"</span></span><br><span class="line">gbWarning=<span class="string">"\033[1;33m[WARNING]\033[0m"</span></span><br><span class="line">gbInfo=<span class="string">"\033[1;32m[INFO]\033[0m"</span></span><br><span class="line">gbGood=<span class="string">"\033[1;32m[GOOD]\033[0m"</span></span><br><span class="line">gbCancel=<span class="string">"\033[1;4;35mCTRL + C\033[0m"</span></span><br></pre></td></tr></table></figure></p>
<h1 id="2-结论" class="heading-control"><a href="#2-结论" class="headerlink" title="2 结论"></a>2 结论<a class="heading-anchor" href="#2-结论" aria-hidden="true"></a></h1><p>以<code>gbCancel=&quot;\033[1;4;35mCTRL + C\033[0m&quot;</code>为例：<br><code>\033[</code>表示转义序列开始，接下来的<code>1</code>表示加粗字体，<code>4</code>表示添加下划线，<code>35</code>表示文本颜色为紫红色，<code>m</code>表示终止转义序列，<code>CTRL + C</code>为待格式化的目标文本，<code>\033[0m</code>表示格式化效果仅对目标文本生效（若无此字段将导致后面的文本输出都被格式化）。</p>
<h1 id="3-参考" class="heading-control"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考<a class="heading-anchor" href="#3-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS9sb25nbGVpLzIzNTc4OTg/c291cmNlPWRyYQ==" title="https://blog.51cto.com/longlei/2357898?source=dra">shell中设置文字输出的颜色及字体格式<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>VS Code C++程序中cout输出中文显示乱码</title>
    <url>/archives/65fedf51.html</url>
    <content><![CDATA[<h1 id="1-问题描述" class="heading-control"><a href="#1-问题描述" class="headerlink" title="1 问题描述"></a>1 问题描述<a class="heading-anchor" href="#1-问题描述" aria-hidden="true"></a></h1><p>有如下代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Please input your string: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span> &lt;&lt; <span class="string">"The string is: "</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>起初使用 Code Runner 插件的 OUTPUT 窗口进行调试，发现 OUTPUT 窗口只读，无法进行输入交互；后勾选了 Code Runner 插件的“Run In Terminal”选项（勾选方法不再赘述），从而在 VS Code Terminal 中进行调试，发现 cin 读取中文后，cout 输出为乱码。</p>
<h1 id="2-问题解决" class="heading-control"><a href="#2-问题解决" class="headerlink" title="2 问题解决"></a>2 问题解决<a class="heading-anchor" href="#2-问题解决" aria-hidden="true"></a></h1><p>将 Windows 自带的 CMD 终端的属性设置为旧版，<strong>但这会导致点击 TERMINAL 时弹出系统终端，而非 vscode 内置终端</strong>：</p>
<p><img data-src="https://image.shipengx.com/%E9%99%84%E5%9B%BE.png" alt="附图"></p>
<h1 id="3-结论" class="heading-control"><a href="#3-结论" class="headerlink" title="3 结论"></a>3 结论<a class="heading-anchor" href="#3-结论" aria-hidden="true"></a></h1><p>Windows 自带 CMD 终端属性的修改影响所有 IDE 及代码编辑器。</p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>Win 10 中通过 VMWare 16 在 UEFI 引导模式下安装 Ubuntu 18.04 虚拟机并自定义分区</title>
    <url>/archives/5103b2eb.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/Win-10-%E4%B8%AD%E9%80%9A%E8%BF%87-VMWare-16-%E5%9C%A8-UEFI-%E5%BC%95%E5%AF%BC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%AE%89%E8%A3%85-Ubuntu-18-04-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA.png" alt="Win-10-中通过-VMWare-16-在-UEFI-引导模式下安装-Ubuntu-18-04-虚拟机并自定义分区"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>近期有在 Win 10 中使用 Ubuntu 18.04 虚拟机操作系统的需求，这本应该是个很简单的事情，起初安装了 VMware Workstation 12 Pro，使用该版本的 VMWare 安装虚拟机的过程中遇到的以下两个问题花费了较多时间：</p>
<ul>
<li>虚拟机中的声卡务必移除，否则启动虚拟机后必然蓝屏</li>
<li>完成虚拟机中的 Ubuntu 安装后，主机一旦插入 U 盘、硬盘等 USB 存储设备必然蓝屏</li>
</ul>
<p>通过查阅资料发现，问题原因应该是 VMware Workstation 12 Pro 和新版 Win 10 间的兼容性较差，需要使用更新的 VMware Workstation 16 Pro。</p>
<h1 id="1-环境信息" class="heading-control"><a href="#1-环境信息" class="headerlink" title="1 环境信息"></a>1 环境信息<a class="heading-anchor" href="#1-环境信息" aria-hidden="true"></a></h1><h2 id="1-1-操作系统" class="heading-control"><a href="#1-1-操作系统" class="headerlink" title="1.1 操作系统"></a>1.1 操作系统<a class="heading-anchor" href="#1-1-操作系统" aria-hidden="true"></a></h2><p>Windows 10 2004 企业版</p>
<h2 id="1-2-硬件配置" class="heading-control"><a href="#1-2-硬件配置" class="headerlink" title="1.2 硬件配置"></a>1.2 硬件配置<a class="heading-anchor" href="#1-2-硬件配置" aria-hidden="true"></a></h2><p><strong>CPU：</strong> Intel Core i7-8750，6 核 12 线程<br><strong>内存：</strong> 32 GB DDR4<br><strong>硬盘：</strong> 1T NVMe SSD（系统盘，软件盘） + 1T HDD（数据盘）<br><strong>显卡：</strong> Nvidia GeForce GTX 1060，6 GB 显存</p>
<h2 id="1-3-VMWare" class="heading-control"><a href="#1-3-VMWare" class="headerlink" title="1.3 VMWare"></a>1.3 VMWare<a class="heading-anchor" href="#1-3-VMWare" aria-hidden="true"></a></h2><p>VMware Workstation 16 Pro，版本号 16.1.2 build-17966106</p>
<h1 id="2-安装" class="heading-control"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装<a class="heading-anchor" href="#2-安装" aria-hidden="true"></a></h1><h2 id="2-1-基本设置" class="heading-control"><a href="#2-1-基本设置" class="headerlink" title="2.1 基本设置"></a>2.1 基本设置<a class="heading-anchor" href="#2-1-基本设置" aria-hidden="true"></a></h2><p><img data-src="https://image.shipengx.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%89%E8%A3%85.png" alt="自定义安装"></p>
<p><img data-src="https://image.shipengx.com/%E9%80%89%E6%8B%A9%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="选择虚拟机硬件兼容性"></p>
<p><img data-src="https://image.shipengx.com/%E7%A8%8D%E5%90%8E%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" alt="稍后安装操作系统"></p>
<p><img data-src="https://image.shipengx.com/%E9%80%89%E6%8B%A9%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B%E4%B8%8E%E7%89%88%E6%9C%AC.png" alt="选择系统类型与版本"></p>
<p><img data-src="https://image.shipengx.com/%E5%91%BD%E5%90%8D%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B9%B6%E4%B8%BA%E5%85%B6%E9%80%89%E6%8B%A9%E5%AD%98%E6%94%BE%E4%BD%8D%E7%BD%AE.png" alt="命名虚拟机并为其选择存放位置"></p>
<h2 id="2-2-处理器配置" class="heading-control"><a href="#2-2-处理器配置" class="headerlink" title="2.2 处理器配置"></a>2.2 处理器配置<a class="heading-anchor" href="#2-2-处理器配置" aria-hidden="true"></a></h2><p><img data-src="https://image.shipengx.com/%E5%A4%84%E7%90%86%E5%99%A8%E9%85%8D%E7%BD%AE.png" alt="处理器配置"></p>
<h2 id="2-3-内存配置" class="heading-control"><a href="#2-3-内存配置" class="headerlink" title="2.3 内存配置"></a>2.3 内存配置<a class="heading-anchor" href="#2-3-内存配置" aria-hidden="true"></a></h2><p><img data-src="https://image.shipengx.com/%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE.png" alt="内存配置"></p>
<h2 id="2-4-网络连接配置" class="heading-control"><a href="#2-4-网络连接配置" class="headerlink" title="2.4 网络连接配置"></a>2.4 网络连接配置<a class="heading-anchor" href="#2-4-网络连接配置" aria-hidden="true"></a></h2><p>选择<strong>桥接</strong>，否则无法在宿主机中通过 SSH 或 WinSCP 连接虚拟机。</p>
<p><img data-src="https://image.shipengx.com/%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5%E9%85%8D%E7%BD%AE.png" alt="网络连接配置"></p>
<h2 id="2-5-IO-配置" class="heading-control"><a href="#2-5-IO-配置" class="headerlink" title="2.5 IO 配置"></a>2.5 IO 配置<a class="heading-anchor" href="#2-5-IO-配置" aria-hidden="true"></a></h2><p><img data-src="https://image.shipengx.com/%E9%80%89%E6%8B%A9%20IO%20%E6%8E%A7%E5%88%B6%E5%99%A8%E7%B1%BB%E5%9E%8B.png" alt="选择 IO 控制器类型"></p>
<h2 id="2-6-磁盘配置" class="heading-control"><a href="#2-6-磁盘配置" class="headerlink" title="2.6 磁盘配置"></a>2.6 磁盘配置<a class="heading-anchor" href="#2-6-磁盘配置" aria-hidden="true"></a></h2><p><img data-src="https://image.shipengx.com/%E9%80%89%E6%8B%A9%E7%A3%81%E7%9B%98%E7%B1%BB%E5%9E%8B.png" alt="选择磁盘类型"></p>
<p><img data-src="https://image.shipengx.com/%E9%80%89%E6%8B%A9%E7%A3%81%E7%9B%98.png" alt="选择磁盘"></p>
<p><img data-src="https://image.shipengx.com/%E6%8C%87%E5%AE%9A%E7%A3%81%E7%9B%98%E5%AE%B9%E9%87%8F.png" alt="指定磁盘容量"></p>
<p><img data-src="https://image.shipengx.com/%E6%8C%87%E5%AE%9A%E7%A3%81%E7%9B%98%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE.png" alt="指定磁盘文件存储位置"></p>
<h2 id="2-7-自定义硬件" class="heading-control"><a href="#2-7-自定义硬件" class="headerlink" title="2.7 自定义硬件"></a>2.7 自定义硬件<a class="heading-anchor" href="#2-7-自定义硬件" aria-hidden="true"></a></h2><p><img data-src="https://image.shipengx.com/%E8%87%AA%E5%AE%9A%E4%B9%89%E7%A1%AC%E4%BB%B6.png" alt="自定义硬件"></p>
<p><img data-src="https://image.shipengx.com/%E5%BC%80%E5%90%AF%E8%99%9A%E6%8B%9F%E5%8C%96%E5%BC%95%E6%93%8E.png" alt="开启虚拟化引擎"></p>
<p>开启虚拟化引擎的前提是主机硬件支持，且在 BISO 设置中开启了相关的硬件虚拟化选项。</p>
<p><img data-src="https://image.shipengx.com/%E5%8A%A0%E8%BD%BD%E7%B3%BB%E7%BB%9F%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6.png" alt="加载系统镜像文件"></p>
<p><img data-src="https://image.shipengx.com/%E6%8C%87%E5%AE%9A%20USB%20%E5%85%BC%E5%AE%B9%E6%80%A7.png" alt="指定 USB 兼容性"></p>
<h2 id="2-8-设置宿主机到虚拟机的文件夹共享" class="heading-control"><a href="#2-8-设置宿主机到虚拟机的文件夹共享" class="headerlink" title="2.8 设置宿主机到虚拟机的文件夹共享"></a>2.8 设置宿主机到虚拟机的文件夹共享<a class="heading-anchor" href="#2-8-设置宿主机到虚拟机的文件夹共享" aria-hidden="true"></a></h2><p><img data-src="https://image.shipengx.com/%E7%BC%96%E8%BE%91%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%AE%BE%E7%BD%AE.png" alt="编辑虚拟机设置"></p>
<p>启用文件夹共享，并添加宿主机到虚拟机的共享目录：</p>
<p><img data-src="https://image.shipengx.com/%E8%AE%BE%E7%BD%AE%E6%96%87%E4%BB%B6%E5%A4%B9%E5%85%B1%E4%BA%AB.png" alt="设置文件夹共享"></p>
<p>要最终实现宿主机到虚拟机的文件夹共享还需在完成虚拟机操作系统的安装后安装 VMWare Tools，后文将会阐述。</p>
<h2 id="2-9-自定义引导前等待时间与引导模式" class="heading-control"><a href="#2-9-自定义引导前等待时间与引导模式" class="headerlink" title="2.9 自定义引导前等待时间与引导模式"></a>2.9 自定义引导前等待时间与引导模式<a class="heading-anchor" href="#2-9-自定义引导前等待时间与引导模式" aria-hidden="true"></a></h2><p>打开虚拟机存放目录下的 <code>.vmx</code> 配置文件，这里为 <code>Ubuntu_18045.vmx</code>，在其末尾追加下面两行内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bios.bootDelay &#x3D; &quot;3000&quot;</span><br><span class="line">firmware &#x3D; &quot;efi&quot;</span><br></pre></td></tr></table></figure>
<p><code>firmware</code> 配置项指定了引导模式，这里设置为 UEFI 引导模式，若不配置此项将按照 Legacy 引导模式进行引导；<code>bios.bootDelay</code> 配置项指定了引导前的等待时间（单位 <code>ms</code>），这里设置为 <code>3000 ms</code>。开启虚拟机后，在虚拟机界面内点击鼠标（将输入从宿主机转移到虚拟机），在引导前等待期间可通过按下 <code>ESC</code> 键进入引导管理界面（通常不需要设置，这里只为演示）：</p>
<p><img data-src="https://image.shipengx.com/Boot%20Manager.png" alt="Boot Manager"></p>
<h2 id="2-10-引导并安装" class="heading-control"><a href="#2-10-引导并安装" class="headerlink" title="2.10 引导并安装"></a>2.10 引导并安装<a class="heading-anchor" href="#2-10-引导并安装" aria-hidden="true"></a></h2><p><img data-src="https://image.shipengx.com/GNU%20GRUB.png" alt="GNU GRUB"></p>
<p><img data-src="https://image.shipengx.com/%E9%80%89%E6%8B%A9%E5%8F%AF%E8%87%AA%E5%AE%9A%E4%B9%89%E5%88%86%E5%8C%BA%E7%9A%84%E5%AE%89%E8%A3%85%E7%B1%BB%E5%9E%8B.png" alt="选择可自定义分区的安装类型"></p>
<p>分区策略通用，由于虚拟机磁盘存放在固态硬盘上，故所有分区类型均默认选择主分区（Primary）即可，无需更改：</p>
<ul>
<li><code>EFI</code> 系统分区：无挂载点，1 GB</li>
<li><code>SWAP</code> 交换分区：无挂载点，两倍内存，8 GB ✖ 2 = 16 GB</li>
<li><code>/</code> 分区：挂载点 <code>/</code>，100 GB</li>
<li><code>home</code> 分区：挂载点 <code>/home</code>，剩余空间</li>
</ul>
<p>引导加载器（boot loader）放置在 <code>EFI</code> 系统分区上：</p>
<p><img data-src="https://image.shipengx.com/%E6%96%B0%E5%BB%BA%E5%88%86%E5%8C%BA%E8%A1%A8%E5%B9%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%84%E4%B8%AA%E5%88%86%E5%8C%BA.png" alt="新建分区表并自定义各个分区"></p>
<p>执行后续步骤，等待安装完成即可。</p>
<h2 id="2-11-安装-VMWare-Tools" class="heading-control"><a href="#2-11-安装-VMWare-Tools" class="headerlink" title="2.11 安装 VMWare Tools"></a>2.11 安装 VMWare Tools<a class="heading-anchor" href="#2-11-安装-VMWare-Tools" aria-hidden="true"></a></h2><p>完成虚拟机操作系统安装后，需要安装 VMWare Tools，才能使虚拟机操作系统界面在自由拉伸全屏模式下可以铺满屏幕，以及最终实现宿主机到虚拟机的文件共享（仅有 2.8 节的步骤是不够的）。选择 VMWare 菜单栏的的“虚拟机”选项，安装 VMWare Tools（这里我已经安装过了，所以会显示重新安装）：</p>
<p><img data-src="https://image.shipengx.com/%E5%AE%89%E8%A3%85%20VMWare%20Tools.png" alt="安装 VMWare Tools"></p>
<p>虚拟机操作系统桌面会出现 VMWare Tools 镜像文件图标，双击打开后会看到包含安装文件的 <code>.tar.gz</code> 格式的压缩文件：</p>
<p><img data-src="https://image.shipengx.com/%E5%8A%A0%E8%BD%BD%20VMWare%20Tools%20%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6.png" alt="加载 VMWare Tools 镜像文件"></p>
<p>将压缩文件拖到桌面并解压，在终端中以 <code>sudo</code> 模式执行安装文件 <code>vmware-install.pl</code>，首先会问你是否要安装，默认为 no，输入 yes 后一路回车即可：</p>
<p><img data-src="https://image.shipengx.com/%E6%89%A7%E8%A1%8C%20VMWare%20Tools%20%E5%AE%89%E8%A3%85%E6%96%87%E4%BB%B6.png" alt="执行 VMWare Tools 安装文件"></p>
<p>完成 VMWare Tools 的安装后虚拟机操作系统界面已经可以在自由拉伸全屏模式下铺满屏幕了，在 <code>/mnt/hfgs</code> 目录下可以看到此前挂载的共享目录：</p>
<p><img data-src="https://image.shipengx.com/%E8%A2%AB%E6%8C%82%E8%BD%BD%E7%9A%84%E5%85%B1%E4%BA%AB%E7%9B%AE%E5%BD%95.png" alt="被挂载的共享目录"></p>
<p>Enjoy!</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L255aXN0X3p4cC9hcnRpY2xlL2RldGFpbHMvMTA4NTAzNTgw" title="https://blog.csdn.net/nyist_zxp/article/details/108503580">VMware 设置虚拟机全屏<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vSmVzZWUvcC8xMDYwODY5Ni5odG1s" title="https://www.cnblogs.com/Jesee/p/10608696.html">Winscp 无法连接 linux 虚拟机解决<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>虚拟机</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>gitignore与gitkeep的作用</title>
    <url>/archives/ba569070.html</url>
    <content><![CDATA[<h1 id="1-gitignore" class="heading-control"><a href="#1-gitignore" class="headerlink" title="1 .gitignore"></a>1 .gitignore<a class="heading-anchor" href="#1-gitignore" aria-hidden="true"></a></h1><p>.gitignore用于指定版本库中的某些文件或目录将被git系统忽略，例如，个人在腾讯云的git服务器上维护某工程时，.gitignore中的内容如下所示，用以忽略工程根目录下的build目录以及所有包目录内的一些并不参与编译的目录：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;build</span><br><span class="line">**&#x2F;0000_Common</span><br><span class="line">**&#x2F;0600_Toolkit</span><br><span class="line">**&#x2F;0900_System&#x2F;01_core</span><br><span class="line">**&#x2F;0900_System&#x2F;03_flashing</span><br><span class="line">**&#x2F;0900_System&#x2F;04_model</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>其中的“**”可以匹配工程目录内的多级目录，参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqYl93aC9hcnRpY2xlL2RldGFpbHMvNTEwODM0MDI=" title="https://blog.csdn.net/ljb_wh/article/details/51083402">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="2-gitkeep" class="heading-control"><a href="#2-gitkeep" class="headerlink" title="2 .gitkeep"></a>2 .gitkeep<a class="heading-anchor" href="#2-gitkeep" aria-hidden="true"></a></h1><p>git系统并不会追踪版本库中的空目录，通过在空目录中创建一个.gitkeep文件即可让git系统对这个空目录进行追踪，.gitkeep实则是一个占位符，并没有其它特性，通俗点讲，.fu*k可以实现和.gitkeep相同的功能。</p>
<h1 id="3-参考" class="heading-control"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考<a class="heading-anchor" href="#3-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xqYl93aC9hcnRpY2xlL2RldGFpbHMvNTEwODM0MDI=" title="https://blog.csdn.net/ljb_wh/article/details/51083402">TIPS：.gitignore 忽略多层文件夹用 **<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxODE5MTAzMD91dG1fc291cmNlPXRhZy1uZXdlc3Q=" title="https://segmentfault.com/a/1190000018191030?utm_source=tag-newest">.gitkeep 是什么? .gitignore 和. gitkeep 之间的区别<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>git的cherry-pick命令</title>
    <url>/archives/f390ae43.html</url>
    <content><![CDATA[<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMyNDUyNjIzL2FydGljbGUvZGV0YWlscy83OTQ0OTUzNA==" title="https://blog.csdn.net/qq_32452623/article/details/79449534">Git - 用 cherry-pick 挑好看的小樱桃<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxMjg5NzU0Mg==" title="https://segmentfault.com/a/1190000012897542">Git 之 cherry-pick<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>《Effective C++》第三版总结（一）：第 0 - 3 章</title>
    <url>/archives/cc0b7731.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%9B%AE%E5%BD%95-%E3%80%8AEffective%20C%2B%2B%E3%80%8B%EF%BC%88%E7%AC%AC%E4%B8%89%E7%89%88%EF%BC%89%E4%B9%A6%E6%91%98%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.png" alt="目录-《Effective C++》（第三版）书摘与学习笔记"></p>
<h1 id="0-导读" class="heading-control"><a href="#0-导读" class="headerlink" title="0 导读"></a>0 导读<a class="heading-anchor" href="#0-导读" aria-hidden="true"></a></h1><ol>
<li><p>定义式是编译器为此对象分配内存的地点。</p>
</li>
<li><p>所谓 <code>default</code> 构造函数，即<strong>缺省构造函数</strong>（也称默认构造函数），是一个可被调用而不带任何实参的构造函数，这样的构造函数要不没有参数，要不就是每个参数都有缺省值。</p>
</li>
<li><p><code>explicit</code> 可以阻止类的构造函数被用来执行隐式类型转换（implicit type conversions），但被 <code>explicit</code> 关键字修饰的构造函数仍可被用来进行显示类型转换（explicit type conversions）。例如下面这个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">B</span><span class="params">(<span class="keyword">int</span> x = <span class="number">0</span>, <span class="keyword">bool</span> b = <span class="literal">true</span>)</span></span>; <span class="comment">// default 构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(B bObject)</span></span>; <span class="comment">// 函数接受一个类型为 B 的对象</span></span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">28</span>);    <span class="comment">// 错误，28 不能被隐式转换为 B 类型的对象</span></span><br><span class="line">doSomething(B(<span class="number">28</span>)); <span class="comment">// 正确，使用 B 的构造函数将 28 显示转换为一个 B 类型的对象</span></span><br></pre></td></tr></table></figure>
<p>被声明为 <code>explicit</code> 的构造函数禁止编译器执行非预期（往往也不被期望）的类型转换，构造函数应尽量使用 <code>explicit</code> 进行修饰，除非你真的希望允许构造函数被用于隐式类型转换。</p>
</li>
<li><p><strong>拷贝构造函数</strong>被用来“以同类型对象初始化自我对象”，拷贝赋值操作符（即 <code>=</code>）被用来“从另一个同型对象中拷贝其值到自我对象”。观察下面的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget();                             <span class="comment">// default 构造函数</span></span><br><span class="line">    Widget(<span class="keyword">const</span> Widget &amp;rhs);            <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Widget &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs); <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Widget <span class="title">w1</span><span class="params">()</span></span>;   <span class="comment">// 调用 default 构造函数</span></span><br><span class="line"><span class="function">Widget <span class="title">w2</span><span class="params">(w1)</span></span>; <span class="comment">// 调用拷贝构造函数</span></span><br><span class="line">w1 = w2;       <span class="comment">// 调用拷贝赋值运算符</span></span><br></pre></td></tr></table></figure>
<p><code>=</code> 也可以用来调用拷贝构造函数，例如下面的语句中，<code>w3</code> 是新定义的对象，此时会调用 <code>Widget</code> 的拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Widget w3 = w2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>以<strong>传值</strong>的形式向函数中传递用户自定义类型是个不好的习惯，因为函数内部会创建匿名对象，造成资源消耗，通常情况下应该是<strong>传引用</strong>，如果传入参数不会被改变，引用还应指定为 <code>const</code> 的。</p>
</li>
<li><p>对 <code>null</code> 指针解引用会造成<strong>未定义行为</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = <span class="number">0</span>;  <span class="comment">// p 是个 null 指针</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *p;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>char</code> 数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> name[] = <span class="string">"Darla"</span>;  <span class="comment">// name 是个 char 数组，大小为 6（字符串常量末尾还有有个结束符）</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="1-让自己习惯-C" class="heading-control"><a href="#1-让自己习惯-C" class="headerlink" title="1 让自己习惯 C++"></a>1 让自己习惯 C++<a class="heading-anchor" href="#1-让自己习惯-C" aria-hidden="true"></a></h1><h2 id="条款-01：视-C-为一个语言联邦" class="heading-control"><a href="#条款-01：视-C-为一个语言联邦" class="headerlink" title="条款 01：视 C++ 为一个语言联邦"></a>条款 01：视 C++ 为一个语言联邦<a class="heading-anchor" href="#条款-01：视-C-为一个语言联邦" aria-hidden="true"></a></h2><ol>
<li><p>C++ 核心就是以下四点：</p>
<ul>
<li><strong>C</strong>：C++ 以 C 为基础</li>
<li><strong>面向对象</strong>：<code>class</code>（包括构造函数和析构函数），封装、继承、多态、虚函数（动态绑定）</li>
<li><strong>模板</strong>：泛型编程。神器</li>
<li><strong>STL</strong>：容器（<code>array</code>、<code>vector</code>、<code>list</code> 等顺序容器，<code>map</code>、<code>set</code> 等关联容器）、迭代器、算法、函数对象（仿函数）。</li>
</ul>
</li>
</ol>
<h2 id="条款-02：尽量以-const-enum-inline-替换-define" class="heading-control"><a href="#条款-02：尽量以-const-enum-inline-替换-define" class="headerlink" title="条款 02：尽量以 const, enum, inline 替换 #define"></a>条款 02：尽量以 const, enum, inline 替换 #define<a class="heading-anchor" href="#条款-02：尽量以-const-enum-inline-替换-define" aria-hidden="true"></a></h2><ol>
<li><p>如下面这样一个宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ASPECT_RATIO 1.653</span></span><br></pre></td></tr></table></figure>
<p>所使用的宏名称可能并未进入记号表，因为宏在预处理阶段会被替换掉，应该用常量替换宏：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> AspectRatio = <span class="number">1.653</span></span><br></pre></td></tr></table></figure>
<p>对浮点常量（float point constant）而言，使用常量可能比使用 <code>#define</code> 导致较小量的码，因为预处理器会将代码中所有的 <code>ASPECT_RATIO</code> 替换为 <code>1.653</code> ，导致目标码（object code）出现多份 <code>1.653</code>，若改用常量 <code>AspectRatio</code> 则不会出现这种问题。</p>
</li>
<li><p>下面的 <code>authorName</code> 是一个常指针，这个指针指向一个 <code>char</code> 型常量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> authorName = <span class="string">"Scott Meyers"</span>;</span><br></pre></td></tr></table></figure>
<p>阅读技巧就是<strong>从右向左看</strong>。</p>
</li>
<li><p>类的专属常量，即 <code>static const</code> 变量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> NumTurns = <span class="number">5</span>; <span class="comment">// 类内专属常量的声明式</span></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];          <span class="comment">// 使用类内专属常量指定数组维度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果类的某个成员变量是 <code>static const</code> 的整数型（<code>int</code>、<code>char</code>、<code>bool</code>），且不会执行取其地址的操作，则可以在只声明而未提供定义的情况使用它，否则<strong>需要在源文件而非头文件中对其进行定义，且不能在构造函数初始值列表中进行初始化</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> GamePlayer::NumTurns;</span><br></pre></td></tr></table></figure>
<p><code>NumTurns</code> 已在声明时获得初值，所以在定义时不可以再设初值。若编译器不支持在类的 <code>static</code> 成员声明时为其给定初值，或该 <code>static</code> 成员不是整数型，则可以在定义时给定其初值。</p>
</li>
<li><p>无法通过宏来创建类的专属常量，因为宏不重视作用域，一旦宏被定义，它就在其后的编译过程中有效（除非在某处被 <code>#undef</code>），这意味着 <code>#define</code> 不仅不能用来定义类的专属常量，也不提供任何封装性，意即没有所谓的 <code>private #define</code> 私有宏。</p>
</li>
<li><p>代码在编译期间，数组的维度必须是已知的。</p>
</li>
<li><p>“<strong>the enum hack</strong>” 补偿，理论基础是<strong>一个枚举类型的值可以当作 <code>int</code> 来使用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GamePlayer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span></span><br><span class="line">    &#123;</span><br><span class="line">        NumTurns = <span class="number">5</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> scores[NumTurns];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>取一个 <code>const</code> 的地址合法，取一个 <code>enum</code> 的地址非法，取一个 <code>#define</code> 的地址通常也不合法。<strong>如果你不想让别人获得一个指针或引用指向你的某个整数常量，<code>enum</code> 可以实现</strong>。</p>
</li>
<li><p>“enum hack” 是模板元编程（template metaprogramming）的基础技术。</p>
</li>
<li><p><strong>宏函数看起来像函数，但不会招致函数调用（function call）的额外开销，因此效率更高。模板内联函数具有宏函数的效率，是更好的选择</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">callWithMax</span><span class="params">(<span class="keyword">const</span> T &amp;a, <span class="keyword">const</span> T &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(a &gt; b ? a : b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两点结论：</p>
<ul>
<li>对于单纯常量，最好以 <code>const</code> 对象或 <code>enums</code> 替换 <code>#define</code></li>
<li>对于形似函数的宏（macros），最好改用 <code>inline</code> 函数替换 <code>#define</code></li>
</ul>
</li>
</ol>
<h2 id="条款-03：尽可能使用-const" class="heading-control"><a href="#条款-03：尽可能使用-const" class="headerlink" title="条款 03：尽可能使用 const"></a>条款 03：尽可能使用 const<a class="heading-anchor" href="#条款-03：尽可能使用-const" aria-hidden="true"></a></h2><ol>
<li><p><code>const</code> 与指针一起出现时应注意区分，<strong>从右向左</strong>读即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> greeting[] = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="keyword">char</span> *p = greeting;             <span class="comment">// non-const 指针，non-const 数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p = greeting;       <span class="comment">// non-const 指针，const 数据（只是说明不能通过 p 修改所指向的数据）</span></span><br><span class="line"><span class="keyword">char</span> *<span class="keyword">const</span> p = greeting;       <span class="comment">// const 指针，non-const 数据</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> p = greeting; <span class="comment">// const 指针，const 数据（只是说明不能通过 p 修改所指向的数据）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以下两种写法等价，<code>pw</code> 均表示一个指向 <code>Widget</code> 型常量的指针。更习惯前者的写法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">const</span> Widget *pw)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(Widget <span class="keyword">const</span> *pw)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器的作用类似指针，<code>const_iterator</code> 表示<strong>常迭代器</strong>，意即迭代器本身的数值不可改变，但迭代器所指向的数据可以改变，类似于常指针。</p>
</li>
<li><p><code>const</code> 作用于函数时，可用于修饰函数返回值、函数参数、函数本身（如果是成员函数）。关于修饰返回值，观察下面对 <code>*</code> 进行重载的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rational</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Rational <span class="keyword">operator</span>*(<span class="keyword">const</span> Rational &amp;lhs, <span class="keyword">const</span> Rational &amp;rhs);</span><br></pre></td></tr></table></figure>
<p><code>*</code> 的返回值使用 <code>const</code> 进行了修饰，所以像下面误把 <code>=</code> 当作 <code>==</code> 来使用的情况就不会在程序编译阶段通过，因为你尝试为不可修改的值进行赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a * b = c)  <span class="comment">// 本来是想判断 a * b 的结果与 c 是否相等</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当类的成员函数被 <code>const</code> 修饰时，成员函数的 <code>this</code> 指针由 <code>T *const</code> 转换为 <code>const T *const</code>。类的 <code>const</code> 成员函数需要说明以下两点：</p>
<ul>
<li>某个类的 <code>const</code> 实例只能调用其 <code>const</code> 成员函数，不能调用其普通成员函数</li>
<li>类的 <code>const</code> 成员函数不能修改一般的数据成员，除非数据成员被 <code>mutable</code> 或 <code>static</code> 修饰</li>
</ul>
<p>观察下面的示例，类 <code>demo_03</code> 的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demo_03</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    demo_03();</span><br><span class="line">    ~demo_03();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func_const</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func_normal</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> data1;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> data2;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> data3;</span><br><span class="line">    <span class="keyword">int</span> data4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> demo_03::data1 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">demo_03::demo_03()</span><br><span class="line">    : data2(<span class="number">2</span>),</span><br><span class="line">      data3(<span class="number">3</span>),</span><br><span class="line">      data4(<span class="number">4</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demo_03::~demo_03()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo_03::func_const</span><span class="params">(<span class="keyword">void</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data1 = <span class="number">11</span>; <span class="comment">// 正确，data1 被 static 修饰</span></span><br><span class="line">    data2 = <span class="number">22</span>; <span class="comment">// 错误，data2 被 const 修饰，不可重新赋值</span></span><br><span class="line">    data3 = <span class="number">33</span>; <span class="comment">// 正确，data3 被 mutable 修饰</span></span><br><span class="line">    data4 = <span class="number">44</span>; <span class="comment">// 错误，const 成员函数不能修改一般的数据成员</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">demo_03::func_normal</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    data1 = <span class="number">111</span>; <span class="comment">// 正确，一般成员函数可以修改非 const 成员的值</span></span><br><span class="line">    data2 = <span class="number">222</span>; <span class="comment">// 错误，data2 被 const 修饰，不可重新赋值</span></span><br><span class="line">    data3 = <span class="number">333</span>; <span class="comment">// 正确，一般成员函数可以修改非 const 成员的值</span></span><br><span class="line">    data4 = <span class="number">444</span>; <span class="comment">// 正确，一般成员函数可以修改非 const 成员的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 <code>const</code> 成员函数尝试修改非 <code>mutable</code> 或 <code>static</code> 的数据成员时，编译器会提示你<strong>表达式必须是可修改的左值</strong>：</p>
<p><img data-src="https://image.shipengx.com/const%20%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%8F%AA%E8%83%BD%E4%BF%AE%E6%94%B9%20mutable%20%E6%88%96%20static%20%E7%9A%84%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98.png" alt="const 成员函数只能修改 mutable 或 static 的数据成员"></p>
<p>我们尝试对 <code>demo_03</code> 的一个 <code>const</code> 实例调用一般方法 <code>func_normal</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"header.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> demo_03 instance;</span><br><span class="line">    instance.func_normal();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会提示实例与所调用成员函数的类型限定符不兼容：</p>
<p><img data-src="https://image.shipengx.com/%E7%B1%BB%E7%9A%84%20const%20%E5%AE%9E%E4%BE%8B%E5%B0%9D%E8%AF%95%E8%B0%83%E7%94%A8%E4%B8%80%E8%88%AC%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0.png" alt="类的 const 实例尝试调用一般成员函数"></p>
</li>
<li><p>类的两个成员函数如果只是常量性（constness）不同，可以被重载，观察下面的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something else</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something else</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> TextBlock &amp;ctb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; ctb[<span class="number">0</span>]; <span class="comment">// 调用 const TextBlock::operator[]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>operator[]</code> 返回的若是 <code>char</code>，则返回值只是 <code>text[position]</code> 的一个临时副本，对其赋值不合法。</p>
</li>
<li><p>当 <code>const</code> 和 <code>non-const</code> 成员函数有着实质等价的实现时，令 <code>non-const</code> 版本调用 <code>const</code> 版本可避免代码重复：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TextBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something else</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> position)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something else</span></span><br><span class="line">        <span class="keyword">return</span> text[position];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> text;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>分两步进行：</p>
<ul>
<li>通过 <code>static_cast</code> 为 <code>*this</code> 加上 <code>const</code> 属性，接下来就会调用重载函数的 <code>const</code> 版本</li>
<li>通过 <code>const_cast</code> 移除 <code>const</code> 重载函数返回值中的 <code>const</code> 属性</li>
</ul>
</li>
</ol>
<h2 id="条款-04：确定对象被使用前已先被初始化" class="heading-control"><a href="#条款-04：确定对象被使用前已先被初始化" class="headerlink" title="条款 04：确定对象被使用前已先被初始化"></a>条款 04：确定对象被使用前已先被初始化<a class="heading-anchor" href="#条款-04：确定对象被使用前已先被初始化" aria-hidden="true"></a></h2><ol>
<li><p>变量的赋值和初始化是不同的，<strong>类的成员初始化过程在构造函数函数体执行前就已完成</strong>。</p>
</li>
<li><p><strong>构造函数初始值列表效率更高</strong>，即使成员变量是内置类型（此时初始化和赋值成本相同），也最好使用构造函数初始值列表对其进行初始化，因为对于 <code>const</code> 成员或引用成员，只能进行初始化，而不能进行赋值。</p>
</li>
<li><p>C++ 的成员初始化次序：</p>
<ul>
<li>基类早于派生类被初始化</li>
<li>类的成员变量按照其声明次序进行初始化，与其在构造函数初始值列表中的次序无关，所以成员的构造函数初始值列表次序应尽量与声明次序相同<br><br></li>
</ul>
</li>
<li><p>函数内的 <code>static</code> 对象称为 <code>local static</code> 对象（因为它们对函数而言是 <code>local</code>），其它 <code>static</code> 对象称为 <code>non-local static</code> 对象。函数结束时 <code>static</code> 对象会被自动销毁，也就是它们的析构函数会在 <code>main()</code> 结束时被自动调用。</p>
</li>
<li><p>C++ 对“定义于不同的编译单元内的 <code>non-local static</code> 对象”的初始化相对次序无明确定义。C++ 保证，函数内的 <code>local static</code> 对象会在“该函数被调用期间” “首次遇上该对象之定义式”时被初始化，这引出了经典的 Meyers 形式的 <strong>Singleton</strong> 模式实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParamsManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ParamsManager();  <span class="comment">// 通过将构造函数声明为 private，可以阻止用户私自创建实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~ParamsManager();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> ParamsManager &amp;<span class="title">GetInstance</span><span class="params">(<span class="keyword">void</span>)</span>  <span class="comment">// 用户只能通过这个 static 方法获取唯一实例</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> ParamsManager instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用 Singleton 模式进行参数管理是个不错的选择，博主在某项目某功能组件的配置参数管理及车身参数管理上使用了类似实现，该实现在 C++11 及以后的标准中是线程安全的。</p>
</li>
<li><p>任何一种 <code>non-const static</code> 对象，无论是 <code>local</code> 还是 <code>non-local</code>，在多线程环境下“等待某事放生”都会有麻烦。处理这个麻烦的一种做法是：在程序的单线程启动阶段手工调用所有 <code>reference-returning</code> 函数，这可消除与初始化有关的“<strong>竞速形式（race conditions）</strong>”。</p>
</li>
</ol>
<h1 id="2-构造-析构-赋值运算" class="heading-control"><a href="#2-构造-析构-赋值运算" class="headerlink" title="2 构造/析构/赋值运算"></a>2 构造/析构/赋值运算<a class="heading-anchor" href="#2-构造-析构-赋值运算" aria-hidden="true"></a></h1><h2 id="条款-05：了解-C-默默编写并调用哪些函数" class="heading-control"><a href="#条款-05：了解-C-默默编写并调用哪些函数" class="headerlink" title="条款 05：了解 C++ 默默编写并调用哪些函数"></a>条款 05：了解 C++ 默默编写并调用哪些函数<a class="heading-anchor" href="#条款-05：了解-C-默默编写并调用哪些函数" aria-hidden="true"></a></h2><ol>
<li><p>如果类中没有得话，编译器会自动声明编译器版本的缺省构造函数、拷贝构造函数、拷贝赋值运算符和析构函数，所有这些函数都是 <code>public</code> 和 <code>inline</code>。假如写下如下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span> &#123;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>那它和下面的代码是等同的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">publi</span><br><span class="line">    Empty() &#123;&#125;                            <span class="comment">// 缺省构造函数</span></span><br><span class="line">    Empty(<span class="keyword">const</span> Empty &amp;rhs) &#123;&#125;            <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    ~Empty() &#123;&#125;                           <span class="comment">// 析构函数</span></span><br><span class="line">    Empty &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Empty &amp;rhs) &#123;&#125; <span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些成员函数只有被调用时才会被编译器创建出来。编译器创建的析构函数是个 <code>non-virtual</code>，除非这个的类的基类自身声明有 <code>virtual</code> 析构函数（这种情况下这个函数的虚属性 <code>virtualness</code> 主要来自基类）。编译器创建的拷贝构造函数和拷贝赋值运算符只是单纯地将来源对象的每一个 <code>non-static</code> 成员变量拷贝到目标对象。</p>
</li>
<li><p>出现以下三种情况，编译器不会生成编译器版本的拷贝赋值运算符，而需要用户自行定义：</p>
<ul>
<li>类内含有引用成员</li>
<li>类内含有 <code>const</code> 成员</li>
<li>类的基类的拷贝赋值运算符被声明为 <code>private</code></li>
</ul>
</li>
</ol>
<h2 id="条款-06：若不想使用编译器自动生成的函数，就该明确拒绝" class="heading-control"><a href="#条款-06：若不想使用编译器自动生成的函数，就该明确拒绝" class="headerlink" title="条款 06：若不想使用编译器自动生成的函数，就该明确拒绝"></a>条款 06：若不想使用编译器自动生成的函数，就该明确拒绝<a class="heading-anchor" href="#条款-06：若不想使用编译器自动生成的函数，就该明确拒绝" aria-hidden="true"></a></h2><ol>
<li><p>通过将类的成员函数声明为 <code>private</code>，并且不给出具体实现，可以达到阻止某些行为的目的，观察下面的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HomeForSale();</span><br><span class="line">    ~HomeForSale();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HomeForSale(<span class="keyword">const</span> HomeForSale &amp;);</span><br><span class="line">    HomeForSale &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HomeForSale &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>有两点需要说明：</p>
<ul>
<li>通过将拷贝构造函数和拷贝赋值运算符声明为 <code>private</code>，<strong>编译器</strong>可以阻止对 <code>HomeForSale</code> 类的拷贝构造及其实例的拷贝赋值</li>
<li>通过不给出拷贝构造函数和拷贝赋值运算符的具体实现，<strong>链接器</strong>可以阻止类的成员函数和友元（<code>friend</code>）函数对它们的相关调用，因为链接器找不到对象文件中的相应符号（Symbol）<br><br></li>
</ul>
<p>将链接期的错误移至编译期是可以实现的，只需要创建一个基类，在基类中声明 <code>private</code> 的拷贝构造函数和拷贝赋值运算符，并让 <code>HomeForSale</code> 继承它即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uncopyable</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    Uncopyable() &#123;&#125;</span><br><span class="line">    ~Uncopyable() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Uncopyable(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">    Uncopyable &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Uncopyable &amp;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeForSale</span> :</span> <span class="keyword">private</span> Uncopyable</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其原理在于，当尝试拷贝构造或拷贝赋值 <code>HomeForSale</code> 的实例时，编译器首先试图拷贝构造或拷贝赋值基类（<code>Uncopyable</code>）部分，由于 <code>Uncopyable</code> 的拷贝构造函数和拷贝赋值运算符被声明为 <code>private</code>，导致派生类无权访问，基类部分无法拷贝构造或拷贝赋值，最终导致编译器不会为派生类生成合成的拷贝构造函数和拷贝赋值运算符。</p>
<p>也可以使用 <code>Boost</code> 库中的 <code>noncopyable</code> 类。如上文所述，在配置参数管理类 <code>ParamsManager</code> 的单例模式实现中，为防止用户私自尝试对其进行实例化，将构造函数声明为 <code>private</code>。</p>
</li>
</ol>
<h2 id="条款-07：为多态基类声明-virtual-析构函数" class="heading-control"><a href="#条款-07：为多态基类声明-virtual-析构函数" class="headerlink" title="条款 07：为多态基类声明 virtual 析构函数"></a>条款 07：为多态基类声明 virtual 析构函数<a class="heading-anchor" href="#条款-07：为多态基类声明-virtual-析构函数" aria-hidden="true"></a></h2><p>该条款与《C++ Primer》第五版第 15.7.1 小节“虚析构函数”相对应。</p>
<ol>
<li><p>工厂（factory）函数返回指向派生类对象的基类指针。</p>
</li>
<li><p>如果一个基类指针指向派生类对象，而基类中的析构函数是 <code>non-virtual</code> 的，则在 <code>delete</code> 这个基类指针后，由于无法多态地调用派生类的析构函数，会导致派生类对象中的派生类部分无法销毁，从而造成内存泄漏。</p>
</li>
<li><p>带有 <code>virtual</code> 函数的 <code>class</code>，其数据成员隐含一个 <strong>vptr</strong>（virtual table pointer，虚表指针），vptr 指向一个由函数指针构成的数组，称为 <strong>vtbl</strong>（virtual table，虚函数表）。当基类的指针或引用绑定到派生类对象上，并通过该指针或引用调用虚函数时，实际执行的虚函数版本由 vptr 和 vtbl 决定。</p>
</li>
<li><p>STL 中的标准容器的析构函数都是 <code>non-virtual</code> 的，因此不应该继承它们。</p>
</li>
<li><p>可以将类的析构函数定位为 <code>pure virtual</code>（纯虚）的，带有纯虚函致的类是抽象（abstract）的，不可实例化（instantiated）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMOV</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~AMOV() = <span class="number">0</span>; <span class="comment">// 声明纯虚析构函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此处的<strong>纯虚析构函数的定义是必不可少的</strong>，否则链接器会报找不到对应的析构函数符号（Symbol）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">AMOV::~AMOV() &#123;&#125; <span class="comment">// 纯虚析构函数的定义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>析构函数的调用是自底向上的，即派生类的析构函数先于基类析构函数被调用。</p>
</li>
<li><p>一个类的析构函数被声明为 <code>virtual</code> 应该满足两个前提条件：</p>
<ul>
<li>该类会作为基类被继承</li>
<li>该类会表现多态特性（拥有至少一个虚函数）<br><br></li>
</ul>
<p>任一条件不满足，类的析构函数都不应是虚函数，所以最佳实践是：<strong>如果类中包含虚函数，则该类的析构函数也应该是虚函数</strong>。</p>
</li>
</ol>
<h2 id="条款-08：别让异常逃离析构函数" class="heading-control"><a href="#条款-08：别让异常逃离析构函数" class="headerlink" title="条款 08：别让异常逃离析构函数"></a>条款 08：别让异常逃离析构函数<a class="heading-anchor" href="#条款-08：别让异常逃离析构函数" aria-hidden="true"></a></h2><ol>
<li><p>两个异常同时存在的情况下，程序一般会结束执行或发生不明确行为。</p>
</li>
<li><p>可以使用 <code>std::abort()</code> 直接终止程序运行，不进行任何资源释放工作。</p>
</li>
<li><p>如果某个操作可能在失败时抛出异常，而又必须处理该异常，则该异常必须来自析构函数意外的函数。</p>
</li>
<li><p>析构函数不应抛出异常，若析构函数中某些操作可能产生异常，则析构函数应吞下它们或结束程序。</p>
</li>
</ol>
<h2 id="条款-09：绝不在构造和析构过程中调用-virtual-函数" class="heading-control"><a href="#条款-09：绝不在构造和析构过程中调用-virtual-函数" class="headerlink" title="条款 09：绝不在构造和析构过程中调用 virtual 函数"></a>条款 09：绝不在构造和析构过程中调用 virtual 函数<a class="heading-anchor" href="#条款-09：绝不在构造和析构过程中调用-virtual-函数" aria-hidden="true"></a></h2><ol>
<li><p>在构造派生类对象时，对象中的基类成员会先于派生类自己的成员被构造，因此在构造基类成员时，派生类成员尚未初始化，此时的对象是一个基类对象，<code>virtual</code> 函数调用会被编译器解析至基类类型，而不会呈现出想象中的多态特性。</p>
</li>
<li><p>一旦派生类析构函数开始执行，派生类对象中的派生类成员变量便呈现未定义状态，进入基类析构函数后，对象彻底退化为基类对象。</p>
</li>
<li><p><code>pure virtual</code> 函数被调用时，大多数执行系统会终止程序（通常会对此结果发出一个信息）。</p>
</li>
<li><p>在构造和析构期间不要调用 <code>virtual</code> 函数，因为这类调用不会下降至派生类（比起当前执行构造函数和析构函数的那层）。</p>
</li>
</ol>
<h2 id="条款-10：令-operator-返回一个-reference-to-this" class="heading-control"><a href="#条款-10：令-operator-返回一个-reference-to-this" class="headerlink" title="条款 10：令 operator= 返回一个 reference to *this"></a>条款 10：令 operator= 返回一个 reference to *this<a class="heading-anchor" href="#条款-10：令-operator-返回一个-reference-to-this" aria-hidden="true"></a></h2><ol>
<li><p>连锁赋值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x, y, z;</span><br><span class="line">x = y = z = <span class="number">15</span>;</span><br></pre></td></tr></table></figure>
<p><strong>赋值采用右结合律</strong>，因此上述上述赋值语句等同于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">x = (y = (z = <span class="number">15</span>));</span><br></pre></td></tr></table></figure>
<p>15 先被赋值给 <code>z</code>，然后更新过的 <code>z</code> 被赋值给 <code>y</code>，最后更新过的 <code>y</code> 被赋值给 <code>x</code>。</p>
</li>
<li><p><strong>为实现连锁赋值，赋值操作符必须返回一个引用指向操作符的左侧实参</strong>，自定义的类都应该遵守这条约定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs) <span class="comment">// 返回类型是个引用</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// do something</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">// 返回左侧对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="条款-11：在-operator-中处理“自我赋值”" class="heading-control"><a href="#条款-11：在-operator-中处理“自我赋值”" class="headerlink" title="条款 11：在 operator= 中处理“自我赋值”"></a>条款 11：在 operator= 中处理“自我赋值”<a class="heading-anchor" href="#条款-11：在-operator-中处理“自我赋值”" aria-hidden="true"></a></h2><ol>
<li><p>通过“证同测试（identity test）”检验“自我赋值”的安全性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == &amp;rhs) <span class="comment">// 证同测试（identity test）</span></span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span> pb;</span><br><span class="line">        pb = <span class="keyword">new</span> BitMap(*rhs.pb);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BitMap *pb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>证同测试虽然检验了自我赋值的安全性，但不具备“异常安全性”，因为执行 <code>pb = new BitMap(*rhs.pb);</code> 时可能产生异常，此时 <code>pb</code> 是个野值。</p>
</li>
<li><p>如果 <code>operator=</code> 具备异常安全性，那它往往也具备自我赋值安全性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Widget &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        BitMap *pOrig = pb;</span><br><span class="line">        pb = <span class="keyword">new</span> BitMap(*rhs.pb);</span><br><span class="line">        <span class="keyword">delete</span> pOrig;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BitMap *pb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过 <strong>copy and swap</strong> 技术实现的 <code>operator=</code> 兼具异常安全性与自我赋值安全性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BitMap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Widget</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Widget &amp;rhs)</span></span>; <span class="comment">// 交换 *this 和 rhs 的数据</span></span><br><span class="line"></span><br><span class="line">    Widget &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Widget &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        Widget temp(rhs); <span class="comment">// 拷贝构造 rhs 的副本</span></span><br><span class="line">        swap(temp);       <span class="comment">// 交换 *this 和 rhs 的副本</span></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BitMap *pb;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="条款-12：复制对象时勿忘其每一个成分" class="heading-control"><a href="#条款-12：复制对象时勿忘其每一个成分" class="headerlink" title="条款 12：复制对象时勿忘其每一个成分"></a>条款 12：复制对象时勿忘其每一个成分<a class="heading-anchor" href="#条款-12：复制对象时勿忘其每一个成分" aria-hidden="true"></a></h2><ol>
<li><p>拷贝构造函数和拷贝赋值运算符我们统称为 copying 函数，编译器会在必要的时候为我们的类创建 copying 函数。</p>
</li>
<li><p>如果为类添加一个成员变量，必须修改 copying 函数及其它的构造函数，如果忘记，编译器一般不会提醒。</p>
</li>
<li><p><strong>自定义派生类的拷贝构造函数或拷贝赋值运算符时，应显示地调用基类相应的拷贝构造函数或拷贝赋值运算符</strong>，目的是拷贝构造或拷贝赋值派生类对象时，对象中的基类部分也能进行相应地拷贝构造或拷贝赋值。</p>
</li>
<li><p>拷贝构造函数和拷贝赋值运算符不应调用彼此，若两者间有重复代码，可新建第三方成员函数将重复代码进行封装，以供两者调用。</p>
</li>
</ol>
<h1 id="3-资源管理" class="heading-control"><a href="#3-资源管理" class="headerlink" title="3 资源管理"></a>3 资源管理<a class="heading-anchor" href="#3-资源管理" aria-hidden="true"></a></h1><h2 id="条款-13：以对象管理资源" class="heading-control"><a href="#条款-13：以对象管理资源" class="headerlink" title="条款 13：以对象管理资源"></a>条款 13：以对象管理资源<a class="heading-anchor" href="#条款-13：以对象管理资源" aria-hidden="true"></a></h2><ol>
<li><p>假如有一个基类 <code>Investment</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Investment</span> // 基类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Investment</code> 有若干派生类，我们通过<strong>工厂函数</strong> <code>createInvestment</code> 可以获得动态分配的派生类对象指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Investment *<span class="title">createInvestment</span><span class="params">()</span></span>; <span class="comment">// 工厂函数，内部返回动态分配的派生类对象指针</span></span><br></pre></td></tr></table></figure>
<p>我们 asda 使用函数 <code>f</code> 管理 <code>createInvestment</code> 返回的派生类对象指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Investment *pInv = createInvestment(); <span class="comment">// 调用工厂函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pInv; <span class="comment">// 释放 pInv 所指对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种情况下 <code>f</code> 可能无法删除 <code>createInvestment</code> 返回的派生类对象指针，导致资源释放失败：</p>
<ul>
<li>执行 <code>delete pInv;</code> 语句前发生了过早的 <code>return</code> 语句</li>
<li>对 <code>createInvestment</code> 的使用及 <code>delete</code> 动作位于循环体内，该循环由于某个 <code>continue</code> 或 <code>goto</code> 语句过早退出</li>
<li>执行 <code>delete pInv;</code> 语句前发生了异常<br><br></li>
</ul>
<p>为保证 <code>createInvestment</code> 返回的资源总是能够被释放，需要将其返回的资源通过对象进行管理，当控制流离开 <code>f</code> 后，对象的析构函数会自动被调用以释放资源。</p>
</li>
<li><p>许多资源被动态配于 <code>heap</code> 内而后被用于单一区块或函数，它们应该在控制流离开那个区块或函数时被释放，可以使用 <code>auto_ptr</code> 智能指针（<code>auto_ptr</code> 在 C++11 标准中已被弃用，可用新标准中的 <code>unique_ptr</code> 独占智能指针替代）实现，<code>auto_ptr</code> 的析构函数自动对其所指对象调用 <code>delete</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>; <span class="comment">// 通过工厂函数返回的派生类指针初   始化 auto_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="comment">// 利用 auto_ptr 的析构函数自动释放 pInv 所指对象</span></span><br></pre></td></tr></table></figure>
<p>“以对象管理资源”蕴含两个关键想法：</p>
<ul>
<li><strong>获得资源后立刻放进管理对象（managing object）内。</strong> “以对象管理资源”的观念被称为“资源取得时机便是初始化时机”（Resource Acquisition Is Initialization，<strong>RAII</strong>），RAII 意味着资源在获得的同时会被放进资源管理对象：初始化或赋值资源管理对象</li>
<li><strong>管理对象（managing object）运用析构函数确保资源被释放。</strong> 不论控制流如何离开区块，一旦资源被销毁（例如当对象离开作用域）其析构函数自然会被自动调用以释放资源。若资源释放动作可能抛出异常，可参考<a href="https://blog.shipengx.com/archives/640eb467.html#%E6%9D%A1%E6%AC%BE-08%EF%BC%9A%E5%88%AB%E8%AE%A9%E5%BC%82%E5%B8%B8%E9%80%83%E7%A6%BB%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0">条款 8</a><br><br></li>
</ul>
<p>由于 <code>auto_ptr</code> 被销毁时会自动删除所指对象，所以不应让多个 <code>auto_ptr</code> 同时指向同一个对象。若通过拷贝构造函数或拷贝赋值运算符拷贝 <code>auto_ptr</code>，被拷贝的指针将变为 <code>nullptr</code>，拷贝得到的新的 <code>auto_ptr</code> 将独占资源。</p>
</li>
<li><p>C++11 新标准中，以对象管理资源时，应使用“引用计数型智能指针”（reference-counting smart pointer，RCSP）替代 <code>auto_ptr</code>。RCSP 持续追踪共有多少对象指向资源，并在没有对象指向资源时自动删除资源。RCSP 的行为类似垃圾回收（garbage collection），不同的是 RCSP 无法打破环状引用（cycle of references，例如两个其实已经没被使用的对象彼此互指，因而好像还处在“被使用”状态），共享智能指针 <code>shared_ptr</code> 就是典型的 RCSP：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Investment&gt; <span class="title">pInv</span><span class="params">(createInvestment())</span></span>; <span class="comment">// 通过工厂函数返回的派生类指针   初始化 shared_ptr</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125; <span class="comment">// 利用 shared_ptr 的析构函数自动释放 pInv 所指对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>auto_ptr</code> 和 <code>shared_ptr</code> 在其析构函数内调用的都是 <code>delete</code> 操作，而非 <code>delete[]</code>，因此在管理动态分配的数组时不应像上面那样仅使用 <code>auto_ptr</code> 或 <code>shared_ptr</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; <span class="title">aps</span><span class="params">(<span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">10</span>])</span></span>; <span class="comment">// 释放 new 出来的数组时应使用 delete[]</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spi</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1024</span>])</span></span>;             <span class="comment">// 同上</span></span><br></pre></td></tr></table></figure>
<p>标准 C++ 中没有针对动态分配的数组而设计的类似 <code>auto_ptr</code> 和 <code>shared_ptr</code> 的内容，类似的可参考 Boost 库中的 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9vc3Qub3JnL2RvYy9saWJzLzFfNzZfMC9saWJzL3NtYXJ0X3B0ci9kb2MvaHRtbC9zbWFydF9wdHIuaHRtbCNzY29wZWRfYXJyYXk=" title="https://www.boost.org/doc/libs/1_76_0/libs/smart_ptr/doc/html/smart_ptr.html#scoped_array">boost::scoped_array<i class="fa fa-external-link"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9vc3Qub3JnL2RvYy9saWJzLzFfNzZfMC9saWJzL3NtYXJ0X3B0ci9kb2MvaHRtbC9zbWFydF9wdHIuaHRtbCNzaGFyZWRfYXJyYXk=" title="https://www.boost.org/doc/libs/1_76_0/libs/smart_ptr/doc/html/smart_ptr.html#shared_array">boost::shared_array<i class="fa fa-external-link"></i></span>（在新版的 Boost 库中已弃用）。</p>
</li>
<li><p>总结：为防止资源泄漏，应使用 RAII 对象对资源进行管理，RAII 对象在构造函数中获得资源并在析构函数中释放资源，<code>shared_ptr</code> 常被用于实现 RAII 对象</p>
</li>
</ol>
<h2 id="条款-14：在资源管理类中小心-copying-行为" class="heading-control"><a href="#条款-14：在资源管理类中小心-copying-行为" class="headerlink" title="条款 14：在资源管理类中小心 copying 行为"></a>条款 14：在资源管理类中小心 copying 行为<a class="heading-anchor" href="#条款-14：在资源管理类中小心-copying-行为" aria-hidden="true"></a></h2><ol>
<li><p>假设我们使用 C API 函数处理类型为 <code>Mutex</code> 的互斥器对象（mutex objects），有 <code>lock</code> 和 <code>unlock</code> 两函数可用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">(Mutex *pm)</span></span>;   <span class="comment">// 锁定 pm 所指的互斥器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">(Mutex *pm)</span></span>; <span class="comment">// 将互斥器解除锁定</span></span><br></pre></td></tr></table></figure>
<p>为确保加锁的 <code>Mutex</code> 能够不忘解锁，我们使用 RAII 对象对其进行管理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock(Mutex *pm)</span><br><span class="line">        : mutexPtr(pm)</span><br><span class="line">    &#123;</span><br><span class="line">        lock(mutexPtr); <span class="comment">// RAII 获得资源：锁住 Mutex 指针所指的互斥器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Lock()</span><br><span class="line">    &#123;</span><br><span class="line">        unlock(mutexPtr); <span class="comment">// RAII 释放资源：解锁 Mutex 指针所指的互斥器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用户可以像下面这样通过 <code>Lock</code> 管理 <code>Mutex</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Mutex m; <span class="comment">// 定义互斥器</span></span><br><span class="line"></span><br><span class="line">&#123;                <span class="comment">// 使用 &#123;&#125; 限定作用域</span></span><br><span class="line">    <span class="function">Lock <span class="title">ml</span><span class="params">(&amp;m)</span></span>; <span class="comment">// 在限定作用域内创建用于管理 Mutex 的 RAII 对象</span></span><br><span class="line">&#125;                <span class="comment">// 自动调用 ml 的析构函数，释放 m</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>对于 RAII 对象的复制，通常有以下几种处理手段：</p>
<ul>
<li><p><strong>禁止复制。</strong> 如果复制动作对 RAII 类不合理，应该参照条款 6 的做法禁止 RAII 类内部的拷贝构造函数和拷贝赋值运算符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span> :</span> <span class="keyword">private</span> Uncopyable  <span class="comment">// 禁止拷贝构造或拷贝赋值 RAII 对象</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Lock(Mutex *pm)</span><br><span class="line">        : mutexPtr(pm)</span><br><span class="line">    &#123;</span><br><span class="line">        lock(mutexPtr); <span class="comment">// RAII 获得资源：锁住 Mutex 指针所指的互斥器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~Lock()</span><br><span class="line">    &#123;</span><br><span class="line">        unlock(mutexPtr); <span class="comment">// RAII 释放资源：解锁 Mutex 指针所指的互斥器</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>对底层资源进行“引用计数”（reference-count）。</strong> 有时我们希望保有资源，直到它的最后一个使用者（某对象）被销毁，此种情况下复制 RAII 对象时，应将该资源的“被引用数”递增，类似于共享智能指针 <code>shared_ptr</code>。假如我们为上面的 <code>Lock</code> 类加入引用计数的功能，可以将互斥器指针 <code>mutexPtr</code> 的类型由 <code>Mutex *</code> 改为 <code>shared_ptr&lt;Mutex&gt;</code>，然而这里存在一个问题，<code>shared_ptr</code> 的缺省行为是“当引用次数为 0 时删除其所指物”，而我们想要的动作是当互斥器对象的引用计数为 0 时对其进行解锁而非删除，可以通过指定 <code>shared_ptr</code> 的“删除器”（<code>deleter</code>）来解决这个问题。<code>deleter</code> 是一个函数或函数对象（function object），当引用计数为 0 时便被调用，<code>deleter</code> 对 <code>shared_ptr</code> 构造函数而言是可有可无的第二参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Lock</span><span class="params">(Mutex *pm)</span>   <span class="comment">// 以某个 Mutex 初始化 shared_ptr</span></span></span><br><span class="line"><span class="function">        : <span class="title">mutexPtr</span><span class="params">(pm, unlock)</span> <span class="comment">// 并以 unlock 函数作为删除器</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock(mutexPtr.get()); <span class="comment">// get 方法（条款 15 中会提到）返回 shared_ptr 中保存的指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Mutex&gt; mutexPtr; <span class="comment">// 使用 shared_ptr 替换 raw pointer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以发现，上述代码并未声明析构函数，因为类的析构函数（无论是编译器生成的，或用户自定义的）会自动调用类内 <code>non-static</code> 成员变量（本例中为 <code>mutexPtr</code>）的析构函数，而 <code>mutexPtr</code> 的析构函数会在其所管理的互斥器对象的引用计数为 0 时自动调用 <code>shared_ptr</code> 的删除器（本例中为 <code>unlock</code> 函数），因而不再需要显式地在 <code>Lock</code> 类的析构函数中进行资源释放。</p>
</li>
<li><p><strong>复制底部资源。</strong> 复制资源管理对象时，进行的是“深拷贝”。</p>
</li>
<li><p><strong>转移底部资源的拥有权。</strong> 某些场合下希望任何时刻只有一个 RAII 对象指向某个原始资源（raw resource），即使 RAII 对象被复制依然如此，此时资源的拥有权会从被复制的 RAII 对象转移到目标 RAII 对象，此时需要使用的是独占智能指针 <code>unique_ptr</code>。</p>
</li>
</ul>
</li>
<li><p>总结：复制 RAII 对象必须一并复制它所管理的资源，所以资源的 <code>copying</code> 行为决定 RAII 对象的 <code>copying</code> 行为。常见的 RAII class <code>copying</code> 行为是：抑制 <code>copying</code> 和对所管理的资源进行引用计数（reference counting）。</p>
</li>
</ol>
<h2 id="条款-15：在资源管理类中提供对原始资源的访问" class="heading-control"><a href="#条款-15：在资源管理类中提供对原始资源的访问" class="headerlink" title="条款 15：在资源管理类中提供对原始资源的访问"></a>条款 15：在资源管理类中提供对原始资源的访问<a class="heading-anchor" href="#条款-15：在资源管理类中提供对原始资源的访问" aria-hidden="true"></a></h2><ol>
<li>RAII 类应该提供访问其所管理的原始资源的方法，例如条款 14 中提到的 <code>shared_ptr</code> 中的 <code>get</code> 方法。</li>
</ol>
<h2 id="条款-16：成对使用-new-和-delete-时要采用相同的形式" class="heading-control"><a href="#条款-16：成对使用-new-和-delete-时要采用相同的形式" class="headerlink" title="条款 16：成对使用 new 和 delete 时要采用相同的形式"></a>条款 16：成对使用 new 和 delete 时要采用相同的形式<a class="heading-anchor" href="#条款-16：成对使用-new-和-delete-时要采用相同的形式" aria-hidden="true"></a></h2><ol>
<li><p>错误代码范例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> *stringArray = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">delete</span> stringArray; <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<p>上述代码最后执行的 <code>delete</code> 动作将无法正确释放申请的动态内存。<code>delete</code> 最大的问题在于：即将被释放的内存里究竟存有多少对象。这决定了最终释放内存时会有多少析构函数被调用。单一对象的内存布局一般不同于数组的内存布局，数组所占用的内存通常还包括“数组大小”的记录，以便 <code>delete</code> 知道需要调用多少次析构函数，单一对象的内存则没有这笔记录。</p>
<p>如果使用 <code>delete</code> 时加上中括号，<code>delete</code> 便认定指针指向一个数组，否则它认定指针指向一个单一对象，改正后的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> *stringArray = <span class="keyword">new</span> <span class="built_in">std</span>::<span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line"><span class="keyword">delete</span>[] stringArray; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个值得小心的例子是当对数组形式作 <code>typedef</code> 动作，并进行动态内存分配后，通过 <code>delete</code> 释放内存时也不应忘记中括号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">string</span> AddressLines[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> *pal = <span class="keyword">new</span> AddressLines; <span class="comment">// 注意，"new AddressLines" 返回一个 string *，</span></span><br><span class="line">                                     <span class="comment">// 如同 "new string[4]" 一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> pal;   <span class="comment">// 错误</span></span><br><span class="line"><span class="keyword">delete</span>[] pal; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>为避免错误，尽量不要对数组形式作 <code>typedef</code> 动作。</p>
</li>
<li><p>总结：<code>new</code> 内存时如果使用了 <code>[]</code>，<code>delete</code> 时也需要使用 <code>[]</code>；<code>new</code> 内存时如果没使用 <code>[]</code>，<code>delete</code> 时也不能使用 <code>[]</code>。</p>
</li>
</ol>
<h2 id="条款-17：以独立语句将-newed-对象置入智能指针" class="heading-control"><a href="#条款-17：以独立语句将-newed-对象置入智能指针" class="headerlink" title="条款 17：以独立语句将 newed 对象置入智能指针"></a>条款 17：以独立语句将 newed 对象置入智能指针<a class="heading-anchor" href="#条款-17：以独立语句将-newed-对象置入智能指针" aria-hidden="true"></a></h2><ol>
<li><p>假设我们有下面两个函数声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">priority</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processWidget</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; pw, <span class="keyword">int</span> priority)</span></span>;</span><br></pre></td></tr></table></figure>
<p>则下面的函数调用无法通过编译，因为 <code>shared_ptr</code> 的构造函数是 <code>explicit</code> 的，无法进行隐式类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="keyword">new</span> Widget, priority());</span><br></pre></td></tr></table></figure>
<p>改成下面这样显示构造出一个 <code>shared_ptr&lt;Widget&gt;</code> 是可以通过编译的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">processWidget(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt;(<span class="keyword">new</span> Widget), priority());</span><br></pre></td></tr></table></figure>
<p>但上述这种写法在实际执行时有可能造成内存泄漏，下面进行原因分析。</p>
<p>在具体执行 <code>processWidget</code> 函数体内的代码前，需要计算实参，第一实参的计算包含两个步骤：</p>
<p>1）执行 <code>new Widget</code> 表达式进行内存分配<br>2）使用内存分配得到的指针构造出一个 <code>shared_ptr&lt;Widget&gt;</code> 对象</p>
<p>而且内存分配的过程一定先于 <code>shared_ptr&lt;Widget&gt;</code> 的构造过程被执行。</p>
<p>第二实参只是单纯对 <code>priority()</code> 函数的调用，但这个函数调用与第一实参计算过程中的两个步骤的相对执行顺序是不确定的（编译优化），三个步骤有可能是按照下面的顺序被执行的：</p>
<p>1）执行 <code>new Widget</code> 表达式进行内存分配<br>2）调用 <code>priority()</code><br>3）使用内存分配得到的指针构造出一个 <code>shared_ptr&lt;Widget&gt;</code> 对象</p>
<p>如果对 <code>priority()</code> 的调用出现异常，则 <code>new Widget</code> 返回的指针将会丢失，因为它最终未被放入 <code>shared_ptr</code> 中进行管理。意即，在对 <code>processWidget</code> 的调用过程中可能引发内存泄漏，因为在“资源被创建（经由 <code>new Widget</code>）”和“资源被转换为资源管理对象”两个时间点之间可能发生异常干扰。</p>
<p>为避免该问题，应使用<strong>分离语句</strong>：将内存申请与 <code>shared_ptr</code> 构造这两个步骤写为单独的语句，最后将智能指针传入 <code>processWidget</code>。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Widget&gt; <span class="title">pw</span><span class="params">(<span class="keyword">new</span> Widget)</span></span>; <span class="comment">// 在独立语句内以智能指针存储 newed 所得的对象</span></span><br><span class="line">processWidget(pw, priority());          <span class="comment">// processWidget 调用时 pw 已完成构造</span></span><br></pre></td></tr></table></figure>
<p>上面这种写法之所以是内存安全的是因为，编译器只可能对某条语句内的动作进行重排，但不可能对跨语句的动作进行重排。因此上面这种写法对应的语句执行顺序是：</p>
<p>1）执行 <code>new Widget</code> 表达式进行内存分配<br>2）使用内存分配得到的指针构造出一个 <code>shared_ptr&lt;Widget&gt;</code> 对象<br>3）调用 <code>priority()</code></p>
</li>
<li><p>总结：在独立语句内将 <code>newed</code> 对象存储于智能指针内，否则有可能发生内存泄漏（申请的内存被智能指针管理起来前发生了异常）。</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《Effective C++》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Effective C++</tag>
      </tags>
  </entry>
  <entry>
    <title>【OJ】表示数字</title>
    <url>/archives/c6c7f3af.html</url>
    <content><![CDATA[<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>一道新势力 OEM 机试题（非本人），实则为牛客网上的一道<span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzYzNzA2MmRmNTE2NzRkZThiYTQ2NGU3OTJkMWEwYWM2P3RwSWQ9MzcmYW1wO3RhZ3M9JmFtcDt0aXRsZT0mYW1wO2RpZmZjdWx0eT0wJmFtcDtqdWRnZVN0YXR1cz0wJmFtcDt0YWI9YW5zd2VyS2V5" title="https://www.nowcoder.com/practice/637062df51674de8ba464e792d1a0ac6?tpId=37&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;tab=answerKey">华为校招机试题<i class="fa fa-external-link"></i></span>，这里记录下个人解法与牛客网上的最佳解法。</p>
<h1 id="1-题目描述" class="heading-control"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述<a class="heading-anchor" href="#1-题目描述" aria-hidden="true"></a></h1><p>将一个字符中所有的整数前后加上符号“*”，其他字符保持不变。连续的数字视为一个整数。注意：本题有多组样例输入。</p>
<p><strong>输入描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入一个字符串</span><br></pre></td></tr></table></figure>
<p><strong>输出描述:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">字符中所有出现的数字前后加上符号“*”，其他字符保持不变</span><br></pre></td></tr></table></figure>
<p><strong>示例 1</strong></p>
<p>输入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jkdi234klowe90a3</span><br><span class="line">5151</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Jkdi*234*klowe*90*a*3*</span><br><span class="line">*5151*</span><br></pre></td></tr></table></figure>
<h1 id="2-求解" class="heading-control"><a href="#2-求解" class="headerlink" title="2 求解"></a>2 求解<a class="heading-anchor" href="#2-求解" aria-hidden="true"></a></h1><h2 id="2-1-我的解法" class="heading-control"><a href="#2-1-我的解法" class="headerlink" title="2.1 我的解法"></a>2.1 我的解法<a class="heading-anchor" href="#2-1-我的解法" aria-hidden="true"></a></h2><p><strong>函数声明</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _SOLUTION_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _SOLUTION_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GenNewStr</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="built_in">string</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>函数实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"solution.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GenNewStr</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="built_in">string</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag_found_number = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = <span class="built_in">string</span>.begin(); iter != <span class="built_in">string</span>.end(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// process the head of number</span></span><br><span class="line">        <span class="keyword">if</span> (!flag_found_number &amp;&amp; ((*iter &gt;= <span class="string">'0'</span>) &amp;&amp; (*iter &lt;= <span class="string">'9'</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            result += <span class="string">"*"</span>;</span><br><span class="line">            flag_found_number = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// process the trail of number</span></span><br><span class="line">        <span class="keyword">if</span> (flag_found_number &amp;&amp; ((*iter &lt; <span class="string">'0'</span>) || (*iter &gt; <span class="string">'9'</span>)))</span><br><span class="line">        &#123;</span><br><span class="line">            result += <span class="string">"*"</span>;</span><br><span class="line">            flag_found_number = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        result += *iter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// process the end of input</span></span><br><span class="line">    <span class="keyword">if</span> (flag_found_number)</span><br><span class="line">    &#123;</span><br><span class="line">        result += <span class="string">"*"</span>;</span><br><span class="line">        flag_found_number = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>主函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"solution.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> input;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; input)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; GenNewStr(input) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试结果</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;XP_Code.exe</span><br><span class="line">asdad83kasd</span><br><span class="line">asdad*83*kasd</span><br><span class="line">1</span><br><span class="line">*1*</span><br><span class="line">902934</span><br><span class="line">*902934*</span><br><span class="line">sdfiw8</span><br><span class="line">sdfiw*8*</span><br><span class="line">123ksdf9384js823jd8</span><br><span class="line">*123*ksdf*9384*js*823*jd*8*</span><br></pre></td></tr></table></figure>
<p>提交到牛客上，运行时间 8ms，占用内存 612KB。</p>
<h2 id="2-2-最佳解法" class="heading-control"><a href="#2-2-最佳解法" class="headerlink" title="2.2 最佳解法"></a>2.2 最佳解法<a class="heading-anchor" href="#2-2-最佳解法" aria-hidden="true"></a></h2><p>截止至 2021 年 4 月 20 日，牛客上排名第一的 C++ 实现，运行时间 1ms，占用内存 372KB。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span> &amp;&amp; (i == <span class="number">0</span> || s[i - <span class="number">1</span>] &lt; <span class="string">'0'</span> || s[i - <span class="number">1</span>] &gt; <span class="string">'9'</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                s = s.substr(<span class="number">0</span>, i) + <span class="string">"*"</span> + s.substr(i);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">'0'</span> &amp;&amp; s[i] &lt;= <span class="string">'9'</span> &amp;&amp; (i + <span class="number">1</span> == s.length() || s[i + <span class="number">1</span>] &lt; <span class="string">'0'</span> || s[i + <span class="number">1</span>] &gt; <span class="string">'9'</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                s = s.substr(<span class="number">0</span>, i + <span class="number">1</span>) + <span class="string">"*"</span> + s.substr(i + <span class="number">1</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现比较巧妙，通过 <code>string</code> 的 <code>substr</code> 方法进行字符串拼接，避免了 2.1 方法中遍历字符串的每个字符时都需要进行的“累加字符”操作，因此耗时更少。<code>substr</code> 中的参数是需要注意的点。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubm93Y29kZXIuY29tL3ByYWN0aWNlLzYzNzA2MmRmNTE2NzRkZThiYTQ2NGU3OTJkMWEwYWM2P3RwSWQ9MzcmYW1wO3RhZ3M9JmFtcDt0aXRsZT0mYW1wO2RpZmZjdWx0eT0wJmFtcDtqdWRnZVN0YXR1cz0wJmFtcDt0YWI9YW5zd2VyS2V5" title="https://www.nowcoder.com/practice/637062df51674de8ba464e792d1a0ac6?tpId=37&amp;tags=&amp;title=&amp;diffculty=0&amp;judgeStatus=0&amp;tab=answerKey">表示数字<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5jcGx1c3BsdXMuY29tL3JlZmVyZW5jZS9zdHJpbmcvc3RyaW5nL3N1YnN0ci8=" title="http://www.cplusplus.com/reference/string/string/substr/">std::string::substr<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWNodW8vYXJ0aWNsZS9kZXRhaWxzLzU0NTk5ODQw" title="https://blog.csdn.net/liuchuo/article/details/54599840">【C++】C++中 substr 的用法<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veHp4bC9wLzcyNDM0OTAuaHRtbA==" title="https://www.cnblogs.com/xzxl/p/7243490.html">C++中 substr 函数的用法<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzMxMDAwNzc4Nw==" title="https://www.zhihu.com/question/310007787">C++ string 类型结尾会像 C 一样添加\0 吗？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxOTMwNDk5L2FydGljbGUvZGV0YWlscy84MDM3NDMxMA==" title="https://blog.csdn.net/qq_31930499/article/details/80374310">C++ string 是否以‘\0’结尾 讨论<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构与算法</tag>
        <tag>OJ</tag>
      </tags>
  </entry>
  <entry>
    <title>【LeetCode】341. 扁平化嵌套列表迭代器</title>
    <url>/archives/ef26ff66.html</url>
    <content><![CDATA[<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>本文记录 LeetCode 第 341 题“扁平化嵌套列表迭代器”的求解过程，及遇到的一点小问题，<span class="exturl" data-url="aHR0cHM6Ly9sZWV0Y29kZS1jbi5jb20vcHJvYmxlbXMvZmxhdHRlbi1uZXN0ZWQtbGlzdC1pdGVyYXRvci8=" title="https://leetcode-cn.com/problems/flatten-nested-list-iterator/">原题链接<i class="fa fa-external-link"></i></span>。</p>
<h1 id="1-题目描述" class="heading-control"><a href="#1-题目描述" class="headerlink" title="1 题目描述"></a>1 题目描述<a class="heading-anchor" href="#1-题目描述" aria-hidden="true"></a></h1><h2 id="1-1-官方描述" class="heading-control"><a href="#1-1-官方描述" class="headerlink" title="1.1 官方描述"></a>1.1 官方描述<a class="heading-anchor" href="#1-1-官方描述" aria-hidden="true"></a></h2><p>给你一个嵌套的整型列表。请你设计一个迭代器，使其能够遍历这个整型列表中的所有整数。</p>
<p>列表中的每一项或者为一个整数，或者是另一个列表。其中列表的元素也可能是整数或是其他列表。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [[1,1],2,[1,1]]</span><br><span class="line">输出: [1,1,2,1,1]</span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</span><br></pre></td></tr></table></figure>
<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,[4,[6]]]</span><br><span class="line">输出: [1,4,6]</span><br><span class="line">解释: 通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,4,6]。</span><br></pre></td></tr></table></figure>
<h2 id="1-2-代码中的描述" class="heading-control"><a href="#1-2-代码中的描述" class="headerlink" title="1.2 代码中的描述"></a>1.2 代码中的描述<a class="heading-anchor" href="#1-2-代码中的描述" aria-hidden="true"></a></h2><p>上面是官方的文字描述，其实并不清晰，反而在代码里的注释说得很明白。大致是这样的：有一个 <code>NestedInteger</code> 类，这个类中有一个私有数据成员，这个数据成员可能是 <code>int</code> 型数字，也可能是元素类型为 <code>NestedInteger</code> 的 <code>vector</code>，<code>NestedInteger</code> 类同时提供下面的公有 API 可供外部调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment">// You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedInteger</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line">     <span class="function"><span class="keyword">bool</span> <span class="title">isInteger</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line">     <span class="comment">// The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">getInteger</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line">     <span class="comment">// The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line">     <span class="function"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;<span class="title">getList</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果 <code>NestedInteger</code> 的数据成员是 <code>int</code> 型数字，则调用 <code>isInteger</code> 方法会得到 <code>true</code>，否则得到 <code>false</code>；</li>
<li>如果 <code>NestedInteger</code> 的数据成员是 <code>int</code> 型数字，则调用 <code>getInteger</code> 方法会得到该数字，否则得到一个不确定值；</li>
<li>如果 <code>NestedInteger</code> 的数据成员是元素类型为 <code>NestedInteger</code> 的 <code>vector</code>，则调用 <code>getList</code> 方法会得到该 <code>vector</code>，否则得到一个不确定值。</li>
</ul>
<p>题目要求我们实现下面这样一个迭代器类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList) &#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>NestedIterator</code> 类会被实例化并被这样调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">NestedIterator <span class="title">i</span><span class="params">(nestedList)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (i.hasNext()) <span class="built_in">cout</span> &lt;&lt; i.next();</span><br></pre></td></tr></table></figure>
<p>其实就是想要得到输入的 <code>nestedList</code> 中的所有真正的数字，这和 1.1 中的描述就对应起来了，我们最终需要填充 <code>NestedIterator</code> 类中的构造函数、<code>next</code> 方法 和 <code>hasNext</code> 方法。</p>
<h1 id="2-解题思路" class="heading-control"><a href="#2-解题思路" class="headerlink" title="2 解题思路"></a>2 解题思路<a class="heading-anchor" href="#2-解题思路" aria-hidden="true"></a></h1><p>题目的关键是将输入 <code>nestedList</code> 视作一个 <strong>N 叉树</strong>，这样题目便可以转化为 N 叉树的遍历问题，所有的叶子节点即所有的数字。例如，输入是<code>[[1,1],2,[1,1]]</code>，则其对应的 N 叉树结构为：</p>
<p><img data-src="https://image.shipengx.com/N%20%E5%8F%89%E6%A0%91%E4%B8%BE%E4%BE%8B.png" alt="N 叉树举例"></p>
<p>遍历的过程中，将得到的叶子节点值插入到一个 <code>vector</code> 中，用于被 <code>next</code> 方法间接调用输出数值。</p>
<h1 id="3-代码实现" class="heading-control"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现<a class="heading-anchor" href="#3-代码实现" aria-hidden="true"></a></h1><p>代码实现很简单，主要是新建递归方法 <code>traverse</code>、用于存储节点值的 <code>result</code>、用于遍历 <code>result</code> 的迭代器 <code>iter</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList)</span><br><span class="line">        : result&#123;&#125;,</span><br><span class="line">          iter(result.begin())</span><br><span class="line">    &#123;</span><br><span class="line">        traverse(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(iter++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iter != result.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;         <span class="comment">// store all values of leaf nodes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter; <span class="comment">// iterstor of result</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * traverse the nestedList just like traversing a N tree, and store all values</span></span><br><span class="line"><span class="comment">     * in a vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : nestedList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.isInteger())</span><br><span class="line">                result.push_back(item.getInteger());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                traverse(item.getList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>运行测试用例，然后报错了：😂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Line 830: Char 44: runtime error: applying non-zero offset 4 to null pointer (stl_iterator.h)</span><br><span class="line">Line 830: Char 44: runtime error: applying non-zero offset 4 to null pointer (stl_iterator.h)</span><br><span class="line">SUMMARY: UndefinedBehaviorSanitizer: undefined-behavior &#x2F;usr&#x2F;bin&#x2F;..&#x2F;lib&#x2F;gcc&#x2F;x86_64-linux-gnu&#x2F;9&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;include&#x2F;c++&#x2F;9&#x2F;bits&#x2F;stl_iterator.h:835:44</span><br></pre></td></tr></table></figure>
<p><strong>向非空指针施加了数值为 4 的非零偏移量</strong>。根据错误信息很容易定位到 <code>next</code> 方法的函数体中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> *(iter++);</span><br></pre></td></tr></table></figure>
<p>应该是 <code>iter</code> 自增时出现了空指针自增的情况。在构造函数初始值列表中我们已经将 <code>result</code> 初始化为了空 <code>vector</code>，并将 <code>iter</code> 初始化为了 <code>result</code> 的首迭代器，此时 <code>iter</code> 确实尚且是个空指针，因为 <code>result</code> 为空，但 <code>traverse</code> 方法中我们向 <code>result</code> 插入了值啊！</p>
<p>问题其实在于，调用 <code>traverse</code> 更新 <code>result</code> 后，我们需要更新一下 <code>iter</code> 的值为 <code>result</code> 最新的首迭代器，使其脱离最初的空值，因为<code>iter</code> 不会随着 <code>result</code> 的更新而主动更新。小改一下代码即可 AC，时间复杂度 $\mathcal{O}(n)$，空间复杂度 $\mathcal{O}(n)$：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NestedIterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NestedIterator(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList)</span><br><span class="line">        : result&#123;&#125;,</span><br><span class="line">          iter(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        traverse(nestedList);</span><br><span class="line">        iter = result.begin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> *(iter++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> iter != result.end();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;         <span class="comment">// store all values of leaf nodes</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter; <span class="comment">// iterstor of result</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * traverse the nestedList just like traversing a N tree, and store all values</span></span><br><span class="line"><span class="comment">     * in a vector</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt; &amp;nestedList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;item : nestedList)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.isInteger())</span><br><span class="line">                result.push_back(item.getInteger());</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                traverse(item.getList());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>AC 结果如下：</p>
<ul>
<li>43/43 cases passed (8 ms)</li>
<li>Your runtime beats 83.97 % of cpp submissions</li>
<li>Your memory usage beats 44.22 % of cpp submissions (13.1 MB)</li>
</ul>
<h1 id="4-后记" class="heading-control"><a href="#4-后记" class="headerlink" title="4 后记"></a>4 后记<a class="heading-anchor" href="#4-后记" aria-hidden="true"></a></h1><p>用 vscode + LeetCode 插件刷题着实太香了。随着刷题量越来越大，笔记都放到 blog 上不太现实，可能需要找时间搭个 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2l0Ym9vay5jb20v" title="https://www.gitbook.com/">GitBook<i class="fa fa-external-link"></i></span> 专门用来放刷题笔记了，我的理解是 GitBook 和 Hexo 类似，都是基于 Node.js 的 markdown 静态渲染引擎，所以基本可以参考 blog 的搭建过程：</p>
<ul>
<li>(a) 本地使用 vscode 撰写 markdown，通过 GitBook 引擎渲染成静态 HTML 文件；</li>
<li>(b) 将静态 HTML 文件 push 到远程服务器的 Git 仓库，触发 git hooks 将文件拷贝到服务器中预设的网页目录；</li>
<li>(c) DNS 服务商那里新建一个二级域名解析到远程服务器 IP，比如 <code>gitbook.shipengx.com</code>；</li>
<li>(d) 自定义 Nginx 配置，将新的二级域名解析目录指定到步骤 (b) 中的网页目录；</li>
<li>(e) 重启 Nginx，开始代理指向 <code>gitbook.shipengx.com</code> 的网络访问。</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>数据结构与算法</category>
        <category>练习</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>数据结构与算法</tag>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>一款图片文件转 Base64 编码的 Python GUI 工具</title>
    <url>/archives/5c20384a.html</url>
    <content><![CDATA[<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>最近整理文件的时候找到了之前写的一个用于将图像转换为 base64 字符串的 Python GUI 小工具。写这个工具的初衷是当时刚刚接触 markdown，有时需要往 markdown 文件中嵌入一些图片，而向 markdown 中嵌入图片通常有以下三种方式：</p>
<ul>
<li>将图片上传图床，在 markdown 文件中进行 URL 引用</li>
<li>将图片置于某个位置，在 markdown 文件中进行相对位置引用或绝对位置引用</li>
<li>将图片转换为 base64 字符串，在 markdown 文件中直接引用字符串来呈现图像</li>
</ul>
<p>方式一有网络访问的实时要求，方式二需要保证 markdown 文件总是能访问到图片文件，两种方式都不利于文档的共享传播。为实现方式三，使用 Python + Tkinter 写了一个 GUI 小工具，它长下面这样：</p>
<p><img data-src="https://image.shipengx.com/img2base64%20%E5%B7%A5%E5%85%B7%E6%88%AA%E5%9B%BE.png" alt="img2base64 工具截图"></p>
<p>代码已经上传 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JvY1NoaS9pbWcyYmFzZTY0" title="https://github.com/RocShi/img2base64">github<i class="fa fa-external-link"></i></span>，下面我直接将工程的 README 搬过来了。</p>
<h1 id="1-特性" class="heading-control"><a href="#1-特性" class="headerlink" title="1 特性"></a>1 特性<a class="heading-anchor" href="#1-特性" aria-hidden="true"></a></h1><ul>
<li>将单一图片转换为 base64 字符串，并将转换结果自动复制到剪贴板</li>
<li>将多图片转换为 base64 字符串，并将转换结果保存至各自的文本文件</li>
<li>转换进度显示</li>
</ul>
<h1 id="2-依赖" class="heading-control"><a href="#2-依赖" class="headerlink" title="2 依赖"></a>2 依赖<a class="heading-anchor" href="#2-依赖" aria-hidden="true"></a></h1><ul>
<li>Python 3.1 及更高版本</li>
<li><p><code>pyperclip</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install pyperclip</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>tkinter</code></p>
<p>对于 windows 系统，自 Python 3.1 起，<code>tkinter</code> 默认包含于 Python 发行版。对于 ubuntu 系统，需要执行下述命令安装 <code>tkinter</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install python3-tk</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>xclip</code></p>
<p>对于 ubuntu 系统，在使用本工具前需要先安装 <code>xclip</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install xclip</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="3-用法" class="heading-control"><a href="#3-用法" class="headerlink" title="3 用法"></a>3 用法<a class="heading-anchor" href="#3-用法" aria-hidden="true"></a></h1><h2 id="3-1-运行工具" class="heading-control"><a href="#3-1-运行工具" class="headerlink" title="3.1 运行工具"></a>3.1 运行工具<a class="heading-anchor" href="#3-1-运行工具" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python img2base64.py</span><br></pre></td></tr></table></figure>
<h2 id="3-2-单一图片转换" class="heading-control"><a href="#3-2-单一图片转换" class="headerlink" title="3.2 单一图片转换"></a>3.2 单一图片转换<a class="heading-anchor" href="#3-2-单一图片转换" aria-hidden="true"></a></h2><ul>
<li>首先点击<code>Select single image</code>按钮选择目标图片，然后点击<code>Convert &amp; Copy</code>按钮转换图片，转换得到的 base64 字符串会自动复制到剪贴板。</li>
</ul>
<h2 id="3-3-多图片转换" class="heading-control"><a href="#3-3-多图片转换" class="headerlink" title="3.3 多图片转换"></a>3.3 多图片转换<a class="heading-anchor" href="#3-3-多图片转换" aria-hidden="true"></a></h2><ul>
<li>首先点击<code>Select several images</code>按钮选择目标图片的存放路径，然后点击<code>Convert &amp; Export</code>按钮选择存放转换结果的路径，每张图片会被转换到各自对应的文件。</li>
</ul>
<h1 id="4-后记" class="heading-control"><a href="#4-后记" class="headerlink" title="4 后记"></a>4 后记<a class="heading-anchor" href="#4-后记" aria-hidden="true"></a></h1><p>可以使用 <a href="https://pypi.org/project/pyinstaller/" target="_blank" rel="noopener"><code>PyInstaller</code></a> 将工具脚本及其所有依赖打包为一个单一可执行文件。这里我没有将可执行文件上传，打包方法比较简单，有兴趣得话可以查阅相关资料，通常执行下面的命令行即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pyinstaller -F -w img2base64.py</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>Python</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>工具开发</tag>
        <tag>图像编码</tag>
      </tags>
  </entry>
  <entry>
    <title>从概率到贝叶斯滤波</title>
    <url>/archives/9fb25cec.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%9B%AE%E5%BD%95-%E4%BB%8E%E6%A6%82%E7%8E%87%E5%88%B0%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2.png" alt="目录-从概率到贝叶斯滤波"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p><strong>贝叶斯滤波</strong>基于贝叶斯公式，通过上一时刻的状态及当前时刻的输入，对当前时刻的状态作出预测，并通过当前时刻的观测对预测作出更新（也可称为纠正），最终实现对当前时刻状态的估计。贝叶斯滤波思想是卡尔曼滤波、粒子滤波等算法的基础。本文从概率基础概念出发，逐步进行贝叶斯滤波的推导。</p>
<h1 id="1-概率基础概念拾遗" class="heading-control"><a href="#1-概率基础概念拾遗" class="headerlink" title="1 概率基础概念拾遗"></a>1 概率基础概念拾遗<a class="heading-anchor" href="#1-概率基础概念拾遗" aria-hidden="true"></a></h1><h2 id="1-1-随机变量" class="heading-control"><a href="#1-1-随机变量" class="headerlink" title="1.1 随机变量"></a>1.1 随机变量<a class="heading-anchor" href="#1-1-随机变量" aria-hidden="true"></a></h2><h3 id="1-1-1-定义" class="heading-control"><a href="#1-1-1-定义" class="headerlink" title="1.1.1 定义"></a>1.1.1 定义<a class="heading-anchor" href="#1-1-1-定义" aria-hidden="true"></a></h3><p>定义在样本空间 $\Omega$ 上的实值函数：</p>
<script type="math/tex; mode=display">
X = X(\omega), \omega \in \Omega</script><p>被称为<strong>随机变量</strong>（random variable），如下图所示。$\omega$ 表示样本空间 $\Omega$ 里的随机事件，可能与数量有关（如传感器随机测得的前方障碍物的距离值，随机掷骰子得到的点数），也可能与数量无关（如随机掷硬币的结果可能为正面或反面）。</p>
<p><img data-src="https://image.shipengx.com/%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F.png" alt="随机变量"></p>
<p>随机变量表示随机试验各种结果的实值单值函数。随机事件不论与数量是否直接有关，都可以数量化，即都能用数量化的方式表达。</p>
<p>“随机变量 $X$ 的取值为 $x$ ”就是满足等式 $X(\omega)=x$ 的一切 $\omega$ 组成的集合，简记为“ $X=x$”，这是 $\Omega$ 的一个子集，即：</p>
<script type="math/tex; mode=display">
“X=x”=\{\omega:X(\omega)=x\} \subset \Omega</script><p>类似地，有：</p>
<script type="math/tex; mode=display">
“X\leqslant x”=\{\omega:X(\omega)\leqslant x\} \subset \Omega</script><h3 id="1-1-2-离散型随机变量" class="heading-control"><a href="#1-1-2-离散型随机变量" class="headerlink" title="1.1.2 离散型随机变量"></a>1.1.2 离散型随机变量<a class="heading-anchor" href="#1-1-2-离散型随机变量" aria-hidden="true"></a></h3><p>如果随机变量的函数值是实数轴上孤立的点（有限个或者无限个），则称为<strong>离散型随机变量</strong>：</p>
<p><img data-src="https://image.shipengx.com/%E7%A6%BB%E6%95%A3%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F.png" alt="离散型随机变量"></p>
<h3 id="1-1-3-连续型随机变量" class="heading-control"><a href="#1-1-3-连续型随机变量" class="headerlink" title="1.1.3 连续型随机变量"></a>1.1.3 连续型随机变量<a class="heading-anchor" href="#1-1-3-连续型随机变量" aria-hidden="true"></a></h3><p>如果随机变量的函数值是实数轴上某个区间上所有的值（也可以是 $(-\infty, +\infty)$ 区间），则称为<strong>连续型随机变量</strong>：</p>
<p><img data-src="https://image.shipengx.com/%E8%BF%9E%E7%BB%AD%E5%9E%8B%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F.png" alt="连续型随机变量"></p>
<h2 id="1-2-累积分布函数" class="heading-control"><a href="#1-2-累积分布函数" class="headerlink" title="1.2 累积分布函数"></a>1.2 累积分布函数<a class="heading-anchor" href="#1-2-累积分布函数" aria-hidden="true"></a></h2><p>设 $X$ 为一个随机变量，对于任意实数 $x$，称：</p>
<script type="math/tex; mode=display">
F(x)=P(X\le x)</script><p>为随机变量 $X$ 的<strong>累积分布函数</strong>（Cumulative Distribution Function，CDF），又称概率分布函数，简称<strong>分布函数</strong>。</p>
<p>若 $X$ 为离散型随机变量，存在函数 $f_X(x)$，使其分布函数满足：</p>
<script type="math/tex; mode=display">
F(x)=P(X\le x)=\sum_{u \le x}f_X(u)</script><p>若 $X$ 为连续型随机变量，存在函数 $f_X(x)$，使其分布函数满足：</p>
<script type="math/tex; mode=display">
F(x)=P(X\le x)= \int_{-\infty}^{x}f_X(u)\mathrm{d}u</script><p>分布函数满足单调性、有界性和右连续性：</p>
<ul>
<li>单调性<br>对任意 $x_1\le x_2$，有 $F(x_1)\le F(x_2)$</li>
<li>有界性<br>对任意 $x$，有：<script type="math/tex; mode=display">
0\le F(x)\le 1</script>且有：<script type="math/tex; mode=display">
\lim_{x\to -\infty}F(x)=0,\quad \lim_{x\to +\infty}F(x)=1</script></li>
<li>右连续性<br>对任意 $x_0$，有：<script type="math/tex; mode=display">
\lim_{x\to x_0^+}F(x)=F(x_0)</script></li>
</ul>
<h2 id="1-3-概率质量函数" class="heading-control"><a href="#1-3-概率质量函数" class="headerlink" title="1.3 概率质量函数"></a>1.3 概率质量函数<a class="heading-anchor" href="#1-3-概率质量函数" aria-hidden="true"></a></h2><p>假设 $X$ 为离散型随机变量，其全部可能取值为 $x_1, x_2, x_3, ···$ ，其<strong>概率分布列</strong>可表述为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">$X$</th>
<th style="text-align:center">$x_1$</th>
<th style="text-align:center">$x_2$</th>
<th style="text-align:center">$x_3$</th>
<th style="text-align:center">···</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$P$</td>
<td style="text-align:center">$p(x_1)$</td>
<td style="text-align:center">$p(x_2)$</td>
<td style="text-align:center">$p(x_3)$</td>
<td style="text-align:center">···</td>
</tr>
</tbody>
</table>
</div>
<p>则称：</p>
<script type="math/tex; mode=display">
f_X(x)=
\begin{cases}
    p(x)=P(X=x), \quad x \in \{x_i\}, i=1, 2, 3, ··· \\
    0, \quad 其它
\end{cases}</script><p>为离散型随机变量 $X$ 的<strong>概率质量函数</strong>（Probability Mass Function，PMF）。</p>
<p>也可采用如下的表示方法：</p>
<script type="math/tex; mode=display">
X\sim p(x)</script><p>读作 $X$ 服从 $p(x)$ 的概率分布。</p>
<p>概率质量函数表征了离散型随机变量在各特定取值上的概率，其满足<strong>非负性</strong>、<strong>规范性</strong>和<strong>可加性</strong>：</p>
<ul>
<li>非负性<script type="math/tex; mode=display">
f_X(x_i) \ge 0</script></li>
<li>规范性和可加性<script type="math/tex; mode=display">
\sum_{i=1}^{\infty}f_X(x_i)=1</script></li>
</ul>
<p><strong>离散型随机变量概率质量函数的叠加得到了离散型随机变量的累积分布函数。</strong></p>
<h2 id="1-4-概率密度函数" class="heading-control"><a href="#1-4-概率密度函数" class="headerlink" title="1.4 概率密度函数"></a>1.4 概率密度函数<a class="heading-anchor" href="#1-4-概率密度函数" aria-hidden="true"></a></h2><p>假设 $X$ 为连续型随机变量，存在函数 $f_X(x)$，且满足：</p>
<ul>
<li>非负性<script type="math/tex; mode=display">
f_X(x) \ge 0</script></li>
<li>规范性和可加性<script type="math/tex; mode=display">
\int_{-\infty}^{+\infty}f_X(x)\mathrm{d}x=1</script></li>
</ul>
<p>则称函数 $f_X(x)$ 为连续型随机变量 $X$ 的<strong>概率密度函数</strong>（Probability Density Function，PDF），<strong>连续型随机变量概率密度函数的积分得到了连续型随机变量的累积分布函数</strong>。</p>
<p>概率密度函数表征了连续型随机变量的输出值在某个确定的取值点<strong>附近</strong>的可能性。连续型随机变量的输出值在某个确定的取值点上的概率为 0，但并不代表该事件不会发生。</p>
<h2 id="1-5-联合概率" class="heading-control"><a href="#1-5-联合概率" class="headerlink" title="1.5 联合概率"></a>1.5 联合概率<a class="heading-anchor" href="#1-5-联合概率" aria-hidden="true"></a></h2><h3 id="1-5-1-二维离散型随机变量的联合概率质量函数" class="heading-control"><a href="#1-5-1-二维离散型随机变量的联合概率质量函数" class="headerlink" title="1.5.1 二维离散型随机变量的联合概率质量函数"></a>1.5.1 二维离散型随机变量的联合概率质量函数<a class="heading-anchor" href="#1-5-1-二维离散型随机变量的联合概率质量函数" aria-hidden="true"></a></h3><p>若二维离散型随机变量 $(X,Y)$ 所有可能的取值为</p>
<script type="math/tex; mode=display">
(x_i, y_j), i, j=1, 2, 3, \cdots</script><p>且存在函数 $f_{X,Y}(x,y)$：</p>
<script type="math/tex; mode=display">
f_{X,Y}(x,y)=p(x,y)=P(X=x,Y=y), \quad (x,y) \in \{x_i,y_j\}, i,j=1, 2, 3, ···</script><p>函数 $f_{X,Y}(x,y)$ 满足如下性质（即概率的三大公理）：</p>
<ul>
<li><p>非负性</p>
<script type="math/tex; mode=display">
f_{X,Y}(x_i, y_i) \ge 0</script></li>
<li><p>规范性和可加性</p>
<script type="math/tex; mode=display">
\sum_{i=1}^{\infty}\sum_{j=1}^{\infty}f_{X,Y}(x_i, y_i)=1</script></li>
</ul>
<p>则称函数 $f_{X,Y}(x,y)$ 为 $(X,Y)$ 的<strong>联合概率质量函数</strong>（Joint Probability Mass Function），又称联合分布列，此定义可以推广到多维离散型随机变量。</p>
<p><strong>二维离散型随机变量联合概率质量函数的叠加得到了二维离散型随机变量的联合累积分布函数（Joint Cumulative Distribution Function）</strong>：</p>
<script type="math/tex; mode=display">
F_{X,Y}(x,y)=P(X\le x, Y\le y)=\sum_{u\le x}\sum_{v\le y}f_{X,Y}(u, v)</script><h3 id="1-5-2-二维连续型随机变量的联合概率密度函数" class="heading-control"><a href="#1-5-2-二维连续型随机变量的联合概率密度函数" class="headerlink" title="1.5.2 二维连续型随机变量的联合概率密度函数"></a>1.5.2 二维连续型随机变量的联合概率密度函数<a class="heading-anchor" href="#1-5-2-二维连续型随机变量的联合概率密度函数" aria-hidden="true"></a></h3><p>若对于二维连续型随机变量 $(X,Y)$，存在二元函数 $f_{X,Y}(x,y)$ 满足：</p>
<ul>
<li><p>非负性</p>
<script type="math/tex; mode=display">
f_{X,Y}(x,y) \ge 0</script></li>
<li><p>规范性和可加性</p>
<script type="math/tex; mode=display">
\int_{-\infty}^{+\infty}\int_{-\infty}^{+\infty}f_{X,Y}(x,y)\mathrm{d}x\mathrm{d}y=1</script></li>
</ul>
<p>则称函数 $f_{X,Y}(x,y)$ 为 $(X,Y)$ 的<strong>联合概率密度函数</strong>（Joint Probability Density Function），此定义可以推广到多维连续型随机变量。</p>
<p><strong>二维连续型随机变量联合概率密度函数的积分得到了二维连续型随机变量的联合累积分布函数</strong>：</p>
<script type="math/tex; mode=display">
F_{X,Y}(x,y)=P(X\le x, Y\le y)=\int_{-\infty}^{x}\int_{-\infty}^{y}f_{X,Y}(u,v)\mathrm{d}v\mathrm{d}u</script><h2 id="1-6-边缘概率" class="heading-control"><a href="#1-6-边缘概率" class="headerlink" title="1.6 边缘概率"></a>1.6 边缘概率<a class="heading-anchor" href="#1-6-边缘概率" aria-hidden="true"></a></h2><h3 id="1-6-1-二维离散型随机变量的边缘概率质量函数" class="heading-control"><a href="#1-6-1-二维离散型随机变量的边缘概率质量函数" class="headerlink" title="1.6.1 二维离散型随机变量的边缘概率质量函数"></a>1.6.1 二维离散型随机变量的边缘概率质量函数<a class="heading-anchor" href="#1-6-1-二维离散型随机变量的边缘概率质量函数" aria-hidden="true"></a></h3><p>若二维离散型随机变量 $(X,Y)$ 所有可能的取值为</p>
<script type="math/tex; mode=display">
(x_i, y_j), i, j=1, 2, 3, \cdots</script><p>且联合概率质量函数 $f_{X,Y}(x,y)$ 为：</p>
<script type="math/tex; mode=display">
f_{X,Y}(x,y)=p(x,y)=P(X=x,Y=y), \quad (x,y) \in \{x_i,y_j\}, i,j=1, 2, 3, ···</script><p>对 $j$ 求和所得的函数：</p>
<script type="math/tex; mode=display">
f_X(x)=\sum_{j=1}^{\infty}f_{X,Y}(x,y_j)=\sum_{j=1}^{\infty}P(X=x,Y=y_j)=P(X=x), \quad x \in \{x_i\}, i=1, 2, 3, ···</script><p>称为 $X$ 的<strong>边缘概率质量函数</strong>（Marginal Probability Mass Function），又称边缘分布列。</p>
<p>类似的对 $i$ 求和所得的函数：</p>
<script type="math/tex; mode=display">
f_Y(y)=\sum_{i=1}^{\infty}f_{X,Y}(x_i,y)=\sum_{i=1}^{\infty}P(X=x_i,Y=y)=P(Y=y), \quad y \in \{y_j\}, j=1, 2, 3, ···</script><p>称为 $Y$ 的边缘概率质量函数。</p>
<p><strong>二维离散型随机变量边缘概率质量函数的叠加得到了二维离散型随机变量的边缘累积分布函数（Marginal Cumulative Distribution Function）</strong>：</p>
<script type="math/tex; mode=display">
F_X(x)=P(X\le x)=\sum_{u\le x}f_X(u)=\sum_{u\le x}\sum_{j=1}^{\infty}P(X=u,Y=y_j)=\sum_{u\le x}P(X=u) \\
F_Y(y)=P(Y\le y)=\sum_{v\le y}f_Y(v)=\sum_{v\le y}\sum_{i=1}^{\infty}P(Y=v,X=x_i)=\sum_{v\le y}P(Y=v)</script><h3 id="1-6-2-二维连续型随机变量的边缘概率密度函数" class="heading-control"><a href="#1-6-2-二维连续型随机变量的边缘概率密度函数" class="headerlink" title="1.6.2 二维连续型随机变量的边缘概率密度函数"></a>1.6.2 二维连续型随机变量的边缘概率密度函数<a class="heading-anchor" href="#1-6-2-二维连续型随机变量的边缘概率密度函数" aria-hidden="true"></a></h3><p>若二维连续型随机变量 $(X,Y)$ 的联合概率密度函数为 $f_{X,Y}(x,y)$，则：</p>
<script type="math/tex; mode=display">
f_X(x)=\int_{-\infty}^{+\infty}f_{X,Y}(x,y)\mathrm{d}y</script><p>称为 $X$ 的<strong>边缘概率密度函数</strong>（Marginal Probability Density Function）。</p>
<p>类似的：</p>
<script type="math/tex; mode=display">
f_Y(y)=\int_{-\infty}^{+\infty}f_{X,Y}(x,y)\mathrm{d}x</script><p>称为 $Y$ 的边缘概率密度函数。</p>
<p><strong>二维连续型随机变量边缘概率密度函数的积分得到了二维连续型随机变量的边缘累积分布函数</strong>：</p>
<script type="math/tex; mode=display">
F_X(x)=P(X\le x)=\int_{-\infty}^xf_X(u)\mathrm{d}u=\int_{-\infty}^x\int_{-\infty}^{+\infty}f_{X,Y}(u,y)\mathrm{d}y\mathrm{d}u \\
F_Y(y)=P(Y\le y)=\int_{-\infty}^yf_Y(v)\mathrm{d}v=\int_{-\infty}^y\int_{-\infty}^{+\infty}f_{X,Y}(x,v)\mathrm{d}x\mathrm{d}v</script><h2 id="1-7-条件概率" class="heading-control"><a href="#1-7-条件概率" class="headerlink" title="1.7 条件概率"></a>1.7 条件概率<a class="heading-anchor" href="#1-7-条件概率" aria-hidden="true"></a></h2><h3 id="1-7-1-二维离散型随机变量的条件概率质量函数" class="heading-control"><a href="#1-7-1-二维离散型随机变量的条件概率质量函数" class="headerlink" title="1.7.1 二维离散型随机变量的条件概率质量函数"></a>1.7.1 二维离散型随机变量的条件概率质量函数<a class="heading-anchor" href="#1-7-1-二维离散型随机变量的条件概率质量函数" aria-hidden="true"></a></h3><p>若 $(X,Y)$ 是二维离散型随机变量，对于固定的 $j$，若 $P(Y=y_j) &gt; 0$ ，则称：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x \ | \ y)=P(X=x \ | \ Y=y)=\frac{P(X=x, Y=y)}{P(Y=y)}=\frac{f_{X,Y}(x,y)}{f_Y(y)}, \quad (x,y) \in \{x_i,y_j\}, i,j=1, 2, 3, ···</script><p>为 $Y=y$ 条件下离散型随机变量 $X$ 的<strong>条件概率质量函数</strong>（Conditional Probability Mass Function）。</p>
<p>同样的，对于固定的 $i$，若 $P(X=x_i) &gt; 0$，则称：</p>
<script type="math/tex; mode=display">
f_{Y|X}(y \ | \ x)=P(Y=y \ | \ X=x)=\frac{P(X=x, Y=y)}{P(X=x)}=\frac{f_{X,Y}(x,y)}{f_X(x)}, \quad (x,y) \in \{x_i,y_j\}, i,j=1, 2, 3, ···</script><p>为 $X=x$ 条件下离散型随机变量 $Y$ 的条件概率质量函数。</p>
<p>简言之，对于二维离散型随机变量：</p>
<script type="math/tex; mode=display">
条件概率质量函数=\frac{联合概率质量函数}{边缘概率质量函数}</script><p><strong>二维离散型随机变量条件概率质量函数的叠加得到了二维离散型随机变量的条件累积分布函数（Conditional Cumulative Distribution Function）</strong>：</p>
<script type="math/tex; mode=display">
F_{X|Y}(x \ | \ y)=P(X\le x \ | \ Y=y)=\sum_{u\le x}f_{X|Y}(u \ | \ y)=\sum_{u\le x}\frac{f_{X,Y}(u,y)}{f_Y(y)} \\
F_{Y|X}(y \ | \ x)=P(Y\le y \ | \ X=x)=\sum_{v\le y}f_{Y|X}(v \ | \ x)=\sum_{v\le y}\frac{f_{X,Y}(x,v)}{f_X(x)}</script><h3 id="1-7-2-二维连续型随机变量的条件概率密度函数" class="heading-control"><a href="#1-7-2-二维连续型随机变量的条件概率密度函数" class="headerlink" title="1.7.2 二维连续型随机变量的条件概率密度函数"></a>1.7.2 二维连续型随机变量的条件概率密度函数<a class="heading-anchor" href="#1-7-2-二维连续型随机变量的条件概率密度函数" aria-hidden="true"></a></h3><p>假设二维连续型随机变量 $(X,Y)$ 的联合概率密度函数为 $f_{X,Y}(x,y)$，若对于固定的 $Y=y$，有边缘概率密度函数 $f_Y(y) &gt; 0$，则称函数：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x\ | \ y)=\frac{f_{X,Y}(x,y)}{f_Y(y)}</script><p>为随机变量 $X$ 在 $Y=y$ 条件下的<strong>条件概率密度函数</strong>（Conditional Probability Density Function）。</p>
<p>若对于固定的 $X=x$，有边缘概率密度函数 $f_X(x) &gt; 0$，则称函数：</p>
<script type="math/tex; mode=display">
f_{Y|X}(y\ | \ x)=\frac{f_{X,Y}(x,y)}{f_X(x)}</script><p>为随机变量 $Y$ 在 $X=x$ 条件下的条件概率密度函数。</p>
<p>简言之，对于二维连续型随机变量：</p>
<script type="math/tex; mode=display">
条件概率密度函数=\frac{联合概率密度函数}{边缘概密度函数}</script><p><strong>二维连续型随机变量条件概率密度函数的积分得到了二维连续型随机变量的条件累积分布函数</strong>：</p>
<script type="math/tex; mode=display">
F_{X|Y}(x\ |\ y)=P(X \le x \ | \ Y=y)=\int_{-\infty}^{x}f_{X|Y}(u\ | \ y)\mathrm{d}u=\int_{-\infty}^{x}\frac{f_{X,Y}(u,y)}{f_Y(y)}\mathrm{d}u \\
F_{Y|X}(y\ |\ x)=P(Y \le y \ | \ X=x)=\int_{-\infty}^{y}f_{Y|X}(v\ | \ x)\mathrm{d}v=\int_{-\infty}^{y}\frac{f_{X,Y}(x,v)}{f_X(x)}\mathrm{d}v</script><h2 id="1-8-全概率" class="heading-control"><a href="#1-8-全概率" class="headerlink" title="1.8 全概率"></a>1.8 全概率<a class="heading-anchor" href="#1-8-全概率" aria-hidden="true"></a></h2><h3 id="1-8-1-二维离散型随机变量的全概率公式" class="heading-control"><a href="#1-8-1-二维离散型随机变量的全概率公式" class="headerlink" title="1.8.1 二维离散型随机变量的全概率公式"></a>1.8.1 二维离散型随机变量的全概率公式<a class="heading-anchor" href="#1-8-1-二维离散型随机变量的全概率公式" aria-hidden="true"></a></h3><p>对于二维离散型随机变量 $(X,Y)$，已知条件概率质量函数：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x \ | \ y)=\frac{f_{X,Y}(x,y)}{f_Y(y)}, \quad (x,y) \in \{x_i,y_j\}, i,j=1, 2, 3, ··· \\
f_{Y|X}(y \ | \ x)=\frac{f_{X,Y}(x,y)}{f_X(x)}, \quad (x,y) \in \{x_i,y_j\}, i,j=1, 2, 3, ···</script><p>容易得到二维离散型随机变量联合概率质量函数的等价形式：</p>
<script type="math/tex; mode=display">
f_{X,Y}(x,y)=f_{X|Y}(x \ | \ y)f_Y(y)=f_{Y|X}(y \ | \ x)f_X(x)</script><p>由边缘概率质量函数与联合概率质量函数间的数量关系，得到二维离散型随机变量的全概率公式：</p>
<script type="math/tex; mode=display">
f_X(x)=\sum_{j=1}^{\infty}f_{X,Y}(x,y_j)=\sum_{j=1}^{\infty}f_{X|Y}(x \ | \ y_j)f_Y(y_j) \\
f_Y(y)=\sum_{i=1}^{\infty}f_{X,Y}(x_i,y)=\sum_{i=1}^{\infty}f_{Y|X}(y \ | \ x_i)f_X(x_i)</script><h3 id="1-8-2-二维连续型随机变量的全概率公式" class="heading-control"><a href="#1-8-2-二维连续型随机变量的全概率公式" class="headerlink" title="1.8.2 二维连续型随机变量的全概率公式"></a>1.8.2 二维连续型随机变量的全概率公式<a class="heading-anchor" href="#1-8-2-二维连续型随机变量的全概率公式" aria-hidden="true"></a></h3><p>对于二维连续型随机变量 $(X,Y)$，已知条件概率密度函数：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x\ | \ y)=\frac{f_{X,Y}(x,y)}{f_Y(y)} \\
f_{Y|X}(y\ | \ x)=\frac{f_{X,Y}(x,y)}{f_X(x)}</script><p>容易得到二维连续型随机变量联合概率密度函数的等价形式：</p>
<script type="math/tex; mode=display">
f_{X,Y}(x,y)=f_{X|Y}(x \ | \ y)f_Y(y)=f_{Y|X}(y \ | \ x)f_X(x)</script><p>由边缘概率密度函数与联合概率密度函数间的数量关系，得到二维连续型随机变量的全概率公式：</p>
<script type="math/tex; mode=display">
f_X(x)=\int_{-\infty}^{+\infty}f_{X|Y}(x \ | \ y)f_Y(y)\mathrm{d}y \\
f_Y(y)=\int_{-\infty}^{+\infty}f_{Y|X}(y \ | \ x)f_X(x)\mathrm{d}x</script><h2 id="1-9-随机过程" class="heading-control"><a href="#1-9-随机过程" class="headerlink" title="1.9 随机过程"></a>1.9 随机过程<a class="heading-anchor" href="#1-9-随机过程" aria-hidden="true"></a></h2><p><strong>随机过程</strong>（Stochastic Process）是定义在 $\Omega \times T$ 上的二元函数 $X(\omega, t)$，简单的定义为一组随机变量的集合，即指定一参数集 $T$ （又称指标集，通常为时间集），其中：</p>
<ul>
<li>对于固定的时间 $t$，$X(\omega, t)$ 为随机变量，简记为 $X(t)$ 或 $X_t$；</li>
<li>对于固定的 $\omega$（即固定每一时刻对应的随机变量的取值），$X(\omega, t)$ 为时间 $t$ 的一般函数，称为<strong>样本函数</strong>（Sample Function）或样本轨道（Sample Path），简记为 $x(t)$。随机过程也可定义为一组样本函数的集合。</li>
</ul>
<p>注意：随机变量 $X(t)$ 或 $X_t$ 并不是时间 $t$ 的函数，它只表示所有样本函数 $x(t)$ 在 $t$ 时刻的取值。</p>
<p>依据随机变量和参数集的连续离散情况，随机过程有以下四种类型：</p>
<ul>
<li><strong>连续型随机过程</strong>：随机变量连续，参数连续；</li>
<li><strong>离散型随机过程</strong>：随机变量离散，参数连续；</li>
<li><strong>连续型随机序列</strong>：随机变量连续，参数离散；</li>
<li><strong>离散型随机序列</strong>：随机变量离散，参数离散。</li>
</ul>
<p>不同于确定过程，<strong>随机过程中的随机变量彼此间不独立</strong>。应该理解，<strong>贝叶斯滤波处理的是一个随机过程</strong>，而且往往是一个连续型随机过程。</p>
<h1 id="2-贝叶斯滤波" class="heading-control"><a href="#2-贝叶斯滤波" class="headerlink" title="2 贝叶斯滤波"></a>2 贝叶斯滤波<a class="heading-anchor" href="#2-贝叶斯滤波" aria-hidden="true"></a></h1><h2 id="2-1-贝叶斯公式" class="heading-control"><a href="#2-1-贝叶斯公式" class="headerlink" title="2.1 贝叶斯公式"></a>2.1 贝叶斯公式<a class="heading-anchor" href="#2-1-贝叶斯公式" aria-hidden="true"></a></h2><h3 id="2-1-1-二维离散型随机变量的贝叶斯公式" class="heading-control"><a href="#2-1-1-二维离散型随机变量的贝叶斯公式" class="headerlink" title="2.1.1 二维离散型随机变量的贝叶斯公式"></a>2.1.1 二维离散型随机变量的贝叶斯公式<a class="heading-anchor" href="#2-1-1-二维离散型随机变量的贝叶斯公式" aria-hidden="true"></a></h3><p>对于二维离散型随机变量 $(X, Y)$，由其条件概率质量函数与全概率公式，容易得到其贝叶斯公式：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x \ | \ y)=\frac{f_{X,Y}(x,y)}{f_Y(y)}=\frac{f_{Y|X}(y \ | \ x)f_X(x)}{\sum\limits_{i=1}^{\infty}f_{Y|X}(y \ | \ x_i)f_X(x_i)}, \quad (x,y) \in \{x_i,y_j\}, i,j=1, 2, 3, ···</script><p>二维离散型随机变量的贝叶斯公式可通过作图的方式轻松证得。</p>
<h3 id="2-1-2-二维连续型随机变量的贝叶斯公式" class="heading-control"><a href="#2-1-2-二维连续型随机变量的贝叶斯公式" class="headerlink" title="2.1.2 二维连续型随机变量的贝叶斯公式"></a>2.1.2 二维连续型随机变量的贝叶斯公式<a class="heading-anchor" href="#2-1-2-二维连续型随机变量的贝叶斯公式" aria-hidden="true"></a></h3><p><strong>(1) 结论</strong></p>
<p>对于二维连续型随机变量 $(X, Y)$，由其条件概率密度函数与全概率公式，容易得到其贝叶斯公式：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x \ | \ y)=\frac{f_{X,Y}(x,y)}{f_Y(y)}=\frac{f_{Y|X}(y \ | \ x)f_X(x)}{\int_{-\infty}^{+\infty}f_{Y|X}(y \ | \ x)f_X(x)\mathrm{d}x}</script><p><strong>(2) 推导</strong></p>
<p>二维连续型随机变量的贝叶斯公式无法通过作图的方式推得，下面进行公式推导，首先计算二维连续型随机变量的条件累积分布函数：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    F_{X|Y}(x\ |\ y) & = P(X \le x \ | \ Y=y) \\
    & = \sum_{u=-\infty}^xP(X=u \ | \ Y=y) \quad \Rightarrow \color{red}{化连续为离散无穷小的累加} \\
    & = \sum_{u=-\infty}^x\frac{P(Y=y \ | \ X=u)P(X=u)}{P(Y=y)} \quad \Rightarrow \color{red}{二维离散型随机变量的贝叶斯公式} \\
    & = \lim_{\epsilon \to 0}\sum_{u=-\infty}^x\frac{P(y \le Y \le y+\epsilon \ | \ X=u)P(u \le X \le u+\epsilon)}{P(y \le Y \le y+\epsilon)} \quad \Rightarrow \color{red}{化无穷小为极限形式} \\
    & = \lim_{\epsilon \to 0}\sum_{u=-\infty}^x\frac{[F_{Y|X}(y+\epsilon \ |\ u)-F_{Y|X}(y \ |\ u)][F_X(u+\epsilon)-F_X(u)]}{F_Y(y+\epsilon)-F_Y(y)} \quad \Rightarrow \color{red}{分布函数性质} \\
    & = \lim_{\epsilon \to 0}\sum_{u=-\infty}^x\frac{[f_{Y|X}(\xi_1 \ | \ u)·\epsilon][f_X(\xi_2)·\epsilon]}{f_Y(\xi_3)·\epsilon} \quad \Rightarrow \color{red}{拉格朗日中值定理，\xi_1, \xi_3 \in (y, y+\epsilon)，\xi_2 \in (u, u+\epsilon)} \\
    & = \lim_{\epsilon \to 0}\sum_{u=-\infty}^x\frac{f_{Y|X}(y \ | \ u)f_X(u)}{f_Y(y)}·\epsilon \quad \Rightarrow \color{red}{\epsilon \to 0 \ 时，\xi_1 \to y，\xi_2 \to u，\xi_3 \to y} \\
    & = \int_{-\infty}^x\frac{f_{Y|X}(y \ | \ u)f_X(u)}{f_Y(y)}\mathrm{d}u \quad \Rightarrow \color{red}{积分定义} \\
    & = \int_{-\infty}^x\frac{f_{Y|X}(y \ | \ x)f_X(x)}{f_Y(y)}\mathrm{d}x \quad \Rightarrow \color{red}{替换自变量符号u为x}
\end{aligned}</script><p>故，二维连续型随机变量的条件概率密度函数为：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x\ |\ y)=\frac{\mathrm{d}F_{X|Y}(x\ |\ y)}{\mathrm{d}x}=\frac{f_{Y|X}(y \ | \ x)f_X(x)}{f_Y(y)}</script><p>代入全概率公式：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x\ |\ y)=\frac{f_{Y|X}(y \ | \ x)f_X(x)}{\int_{-\infty}^{+\infty}f_{Y|X}(y \ | \ x)f_X(x)\mathrm{d}x}</script><p>上式即为二维连续型随机变量的贝叶斯公式，推导完毕。</p>
<h2 id="2-2-先验概率、似然概率与后验概率" class="heading-control"><a href="#2-2-先验概率、似然概率与后验概率" class="headerlink" title="2.2 先验概率、似然概率与后验概率"></a>2.2 先验概率、似然概率与后验概率<a class="heading-anchor" href="#2-2-先验概率、似然概率与后验概率" aria-hidden="true"></a></h2><p>在二维连续型随机变量的贝叶斯公式中，有如下定义：</p>
<ul>
<li>$f_X(x)$ 被称为<strong>先验概率密度</strong>（Prior Probability Density），表示根据以往的经验和分析，在本次试验或采样前便可获得的随机变量 $X$ 的概率密度；</li>
<li>$f_{Y|X}(y \ | \ x)$ 被称为<strong>似然概率密度</strong>（Likelihood Probability Density），表示在状态随机变量 $X$ 取值为 $x$ 的条件下，观测随机变量 $Y$ 取值为 $y$ 的概率密度，状态为因，观测为果，即<strong>由因推果</strong>；</li>
<li>$f_{X|Y}(x\ |\ y)$ 被成为<strong>后验概率密度</strong>（Posterior Probability Density），表示在观测随机变量 $Y$ 取值为 $y$ 的条件下，状态随机变量 $X$ 取值为 $x$ 的概率密度，状态为因，观测为果，即<strong>由果推因</strong>。</li>
</ul>
<p>此外，当 $y$ 为定值时，$\eta=\left[\int_{-\infty}^{+\infty}f_{Y|X}(y \ | \ x)f_X(x)\mathrm{d}x\right]^{-1}$ 为一常数，常被称为贝叶斯公式的<strong>归一化常数</strong>。</p>
<p>因此，二维连续型随机变量的贝叶斯公式可表示为：</p>
<script type="math/tex; mode=display">
后验概率密度=\eta \times 似然概率密度 \times 先验概率密度</script><h2 id="2-3-再谈似然概率" class="heading-control"><a href="#2-3-再谈似然概率" class="headerlink" title="2.3 再谈似然概率"></a>2.3 再谈似然概率<a class="heading-anchor" href="#2-3-再谈似然概率" aria-hidden="true"></a></h2><p>上文中提到，似然概率密度函数 $f_{Y|X}(y \ | \ x)$ 表示在状态随机变量 $X$ 取值为 $x$ 的条件下，观测随机变量 $Y$ 取值为 $y$ 的概率密度。<strong>似然概率密度函数表征了传感器检测精度</strong>，对于给定的状态条件 $X=x$，观测结果 $Y=y$ 的概率分布通常有三种模型：</p>
<p><strong>(1) 等可能型</strong></p>
<p>观测值在状态量真值附近呈均匀分布，此时的似然概率密度函数为常数。</p>
<p><strong>(2) 阶梯型</strong></p>
<p>观测值在状态量真值附近呈阶梯分布，此时的似然概率密度函数为分段常数。</p>
<p><strong>(3) 正态分布型</strong></p>
<p>观测值在状态量真值附近呈高斯分布，此时的似然概率密度函数为高斯函数：</p>
<script type="math/tex; mode=display">
f_{Y|X}(y \ | \ x)=\frac{1}{\sigma \sqrt{2\pi}}e^{-\frac{(y-x)^2}{2\sigma ^2}}</script><p>若假定似然概率密度函数为高斯函数，此时，似然概率密度函数的均值 $x$ 代表状态量真值，$\sigma$ 代表传感器检测精度范围。若同时假定先验概率密度函数为高斯函数，即：</p>
<script type="math/tex; mode=display">
f_X(x) \sim \mathcal{N}(\mu_1, \ \sigma_1^2), \quad f_{Y|X}(y \ | \ x) \sim \mathcal{N}(\mu_2, \ \sigma_2^2)</script><p>则</p>
<script type="math/tex; mode=display">
f_{X|Y}(x \ | \ y) \sim \mathcal{N}(\frac{\sigma_2^2}{\sigma_1^2 + \sigma_2^2}\mu_1+\frac{\sigma_1^2}{\sigma_1^2 + \sigma_2^2}\mu_2, \ \frac{\sigma_1^2\sigma_2^2}{\sigma_1^2+\sigma_2^2})</script><p>由于</p>
<script type="math/tex; mode=display">
\frac{\sigma_1^2\sigma_2^2}{\sigma_1^2+\sigma_2^2}=\frac{\sigma_1^2}{1+\frac{\sigma_1^2}{\sigma_2^2}} < \sigma_1^2</script><p>且</p>
<script type="math/tex; mode=display">
\frac{\sigma_1^2\sigma_2^2}{\sigma_1^2+\sigma_2^2}=\frac{\sigma_2^2}{1+\frac{\sigma_2^2}{\sigma_1^2}} < \sigma_2^2</script><p>故，<strong>后验概率密度函数方差既小于先验概率密度函数方差，也小于似然概率密度函数方差，系统不确定度降低</strong>。</p>
<p>若 $\sigma_1^2 \gg \sigma_2^2$，则近似有：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x \ | \ y) \sim \mathcal{N}(\mu_2, \ \sigma_2^2)</script><p>此时，后验倾向于观测。</p>
<p>若 $\sigma_1^2 \ll \sigma_2^2$，则近似有：</p>
<script type="math/tex; mode=display">
f_{X|Y}(x \ | \ y) \sim \mathcal{N}(\mu_1, \ \sigma_1^2)</script><p>此时，后验倾向于先验。</p>
<h2 id="2-4-贝叶斯滤波推导" class="heading-control"><a href="#2-4-贝叶斯滤波推导" class="headerlink" title="2.4 贝叶斯滤波推导"></a>2.4 贝叶斯滤波推导<a class="heading-anchor" href="#2-4-贝叶斯滤波推导" aria-hidden="true"></a></h2><h3 id="2-4-1-问题建模" class="heading-control"><a href="#2-4-1-问题建模" class="headerlink" title="2.4.1 问题建模"></a>2.4.1 问题建模<a class="heading-anchor" href="#2-4-1-问题建模" aria-hidden="true"></a></h3><p><strong>(1) 问题描述</strong></p>
<p>对于某状态量随机变量 $X$，从初始时刻 0 开始，对其进行观测，得到 0 ~ k 时刻的观测值：</p>
<script type="math/tex; mode=display">
y_0, y_1, y_2, \cdots , y_k</script><p>求解 k 时刻状态量随机变量 $X_k$ 的最优估计 $\hat{x}_k$。</p>
<p><strong>(2) 求解思路</strong></p>
<p>以贝叶斯公式为求解方向，将问题转化为求解状态量随机变量 $X_k$ 后验概率密度函数的期望：</p>
<script type="math/tex; mode=display">
\hat{x}_k=E[f_{X_k}^+(x)]</script><p>进而需要求解状态量随机变量 $X_k$ 的先验概率密度函数与似然概率密度函数。我们认为，<strong>k 时刻的状态量随机变量 $X_k$ 与且仅与上一时刻的状态量随机变量 $X_{k-1}$ 有关，k 时刻的观测量随机变量 $Y_k$ 与且仅与 k 时刻的状态量随机变量 $X_k$ 有关</strong>，其中的数量关系我们分别称之为<strong>状态方程</strong>与<strong>观测方程</strong>：</p>
<script type="math/tex; mode=display">
\begin{cases}
    X_k=f(X_{k-1})+Q_k \quad \Rightarrow \color{red}{状态方程} \\
    Y_k=h(X_k)+R_k \quad \Rightarrow \color{red}{观测方程}
\end{cases}</script><p>$f(x)$ 被称为状态转移函数，$h(x)$ 被称为观测函数。</p>
<p>对于 0 时刻的初始状态量随机变量 $X_0$，认为观测值 $y_0$ 即为其真值，其后验概率密度函数即为其先验概率密度函数。我们可以根据经验知识（建模精度和传感器精度）写出 0 时刻的初始状态量随机变量 $X_0$ 的后验概率密度函数 $f_{X_0}^+(x)$、k 时刻过程噪声随机变量 $Q_k$ 的概率密度函数 $f_{Q_k}(x)$ 和 k 时刻观测噪声随机变量 $R_k$ 的概率密度函数 $f_{R_k}(x)$。</p>
<p><strong>(3) 符号定义</strong></p>
<ul>
<li><p>各时刻的状态量随机变量</p>
<script type="math/tex; mode=display">
X_0, X_1, X_2, \cdots , X_k</script></li>
<li><p>各时刻的观测量随机变量</p>
<script type="math/tex; mode=display">
Y_0, Y_1, Y_2, \cdots , Y_k</script></li>
<li><p>各时刻的观测值</p>
<script type="math/tex; mode=display">
y_0, y_1, y_2, \cdots , y_k</script></li>
<li><p>各时刻的过程噪声随机变量</p>
<script type="math/tex; mode=display">
Q_1, Q_2, \cdots , Q_k</script></li>
<li><p>各时刻的观测噪声随机变量</p>
<script type="math/tex; mode=display">
R_1, R_2, \cdots , R_k</script></li>
<li><p>各时刻的过程噪声随机变量概率密度函数</p>
<script type="math/tex; mode=display">
f_{Q_1}(x), f_{Q_2}(x), \cdots , f_{Q_k}(x)</script></li>
<li><p>各时刻的观测噪声随机变量概率密度函数</p>
<script type="math/tex; mode=display">
f_{R_1}(x), f_{R_2}(x), \cdots , f_{R_k}(x)</script></li>
<li><p>各时刻的状态量随机变量先验概率密度函数</p>
<script type="math/tex; mode=display">
f_{X_0}^-(x), f_{X_1}^-(x), f_{X_2}^-(x), \cdots , f_{X_k}^-(x)</script></li>
<li><p>各时刻的状态量随机变量后验概率密度函数</p>
<script type="math/tex; mode=display">
f_{X_0}^+(x), f_{X_1}^+(x), f_{X_2}^+(x), \cdots , f_{X_k}^+(x)</script></li>
<li><p>各时刻状态量随机变量与观测量随机变量的似然概率密度函数</p>
<script type="math/tex; mode=display">
f_{Y_1|X_1}(y_1 \ | \ x), f_{Y_2|X_2}(y_2 \ | \ x), \cdots , f_{Y_k|X_k}(y_k \ | \ x)</script></li>
</ul>
<p><strong>(4) 重要假设</strong></p>
<ul>
<li>$X_0$ 分别与 $Q_1, Q_2, \cdots , Q_k$ 相互独立；</li>
<li>$X_0$ 分别与 $R_1, R_2, \cdots , R_k$ 相互独立；</li>
<li>$X_{k-1}$ 与 $Q_k$ 相互独立；</li>
<li>$X_{k}$ 与 $R_k$ 相互独立。</li>
</ul>
<p><strong>(5) 重要定理</strong></p>
<p>$\star$ <strong>条件概率里的条件可以作逻辑推导</strong>。例如：</p>
<script type="math/tex; mode=display">
P(X=1 \ | \ Y=2,Z=3)=P(X+Y=3 \ | \ Y=2,Z=3)=P(X+Y=3 \ | \ Y=2,Z-Y=1)</script><h3 id="2-4-2-预测步推导" class="heading-control"><a href="#2-4-2-预测步推导" class="headerlink" title="2.4.2 预测步推导"></a>2.4.2 预测步推导<a class="heading-anchor" href="#2-4-2-预测步推导" aria-hidden="true"></a></h3><p>已知 0 时刻状态量随机变量 $X_0$ 的后验概率密度函数 $f_{X_0}^+(x)$，状态转移函数 $f(x)$，1 时刻过程噪声随机变量 $Q_1$ 的概率密度函数 $f_{Q_1}(x)$，求解 1 时刻状态量随机变量 $X_1$ 的先验概率密度函数 $f_{X_1}^-(x)$。</p>
<p>类似二维连续型随机变量贝叶斯公式的推导过程，我们从求解 $X_1$ 的先验累积分布函数 $F_{X_1}^-$ 入手。</p>
<script type="math/tex; mode=display">
\begin{aligned}
    F_{X_1}^-(x) & = P(X_1 \le x) \\
    & = \sum_{u=-\infty}^xP(X_1=u) \quad \Rightarrow \color{red}{化连续为离散无穷小的累加} \\
    & = \sum_{u=-\infty}^x\sum_{v=-\infty}^{+\infty}P(X_1=u \ | \ X_0=v)P(X_0=v) \quad \Rightarrow \color{red}{全概率公式} \\
    & = \sum_{u=-\infty}^x\sum_{v=-\infty}^{+\infty}P[X_1-f(X_0)=u-f(v) \ | \ X_0=v]P(X_0=v) \quad \Rightarrow \color{red}{条件概率里的条件可以作逻辑推导} \\
    & = \sum_{u=-\infty}^x\sum_{v=-\infty}^{+\infty}P[Q_1=u-f(v) \ | \ X_0=v]P(X_0=v) \quad \Rightarrow \color{red}{状态方程} \\
    & = \sum_{u=-\infty}^x\sum_{v=-\infty}^{+\infty}P[Q_1=u-f(v)]P(X_0=v) \quad \Rightarrow \color{red}{X_{k-1}与Q_k相互独立} \\
    & = \sum_{u=-\infty}^x\left\{\lim_{\epsilon \to 0}\sum_{v=-\infty}^{+\infty}f_{Q_1}[u-f(v)]·\epsilon · f_{X_0}^+(v)·\epsilon \right\} \quad \Rightarrow \color{red}{类似二维连续型随机变量贝叶斯公式的推导过程，将点概率化为概率密度与无穷小的乘积} \\
    & = \sum_{u=-\infty}^x\left\{\lim_{\epsilon \to 0}\int_{-\infty}^{+\infty}f_{Q_1}[u-f(v)]f_{X_0}^+(v)\mathrm{d}v·\epsilon \right\} \quad \Rightarrow \color{red}{积分定义} \\
    & = \int_{-\infty}^x \int_{-\infty}^{+\infty}f_{Q_1}[u-f(v)]f_{X_0}^+(v)\mathrm{d}v\mathrm{d}u \quad \Rightarrow \color{red}{积分定义} \\
    & = \int_{-\infty}^x \int_{-\infty}^{+\infty}f_{Q_1}[x-f(v)]f_{X_0}^+(v)\mathrm{d}v\mathrm{d}x \quad \Rightarrow \color{red}{替换自变量符号u为x}
\end{aligned}</script><p>故，1 时刻状态量随机变量 $X_1$ 的先验概率密度函数为：</p>
<script type="math/tex; mode=display">
f_{X_1}^-(x)=\frac{\mathrm{d}F_{X_1}^-(x)}{\mathrm{d}x}=\int_{-\infty}^{+\infty}f_{Q_1}[x-f(v)]f_{X_0}^+(v)\mathrm{d}v</script><p>推导完毕。可以发现，<strong>先验概率密度函数本质来源于状态方程</strong>。</p>
<h3 id="2-4-3-更新步推导" class="heading-control"><a href="#2-4-3-更新步推导" class="headerlink" title="2.4.3 更新步推导"></a>2.4.3 更新步推导<a class="heading-anchor" href="#2-4-3-更新步推导" aria-hidden="true"></a></h3><p>已知 1 时刻观测量随机变量 $Y_1$ 的取值 $y_1$，求解 1 时刻状态量随机变量与观测量随机变量的似然概率密度函数 $f_{Y_1|X_1}(y_1 \ | \ x)$，并联合预测步得到的 1 时刻状态量随机变量 $X_1$ 的先验概率密度函数 $f_{X_1}^-(x)$，求解 1 时刻状态量随机变量 $X_1$ 的后验概率密度函数 $f_{X_1}^+(x)$。</p>
<p>首先，求解似然概率密度函数 $f_{Y_1|X_1}(y_1 \ | \ x)$：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    f_{Y_1|X_1}(y_1 \ | \ x) & =\lim_{\epsilon \to 0}\frac{F_{Y_1 | X_1}(y_1+\epsilon \ | \ x)-F_{Y_1 | X_1}(y_1 \ | \ x)}{\epsilon} \quad \Rightarrow \color{red}{导数的定义} \\
    & =\lim_{\epsilon \to 0}\frac{P(y_1 \le Y_1 \le y_1 + \epsilon \ | \ X_1=x)}{\epsilon} \quad \Rightarrow \color{red}{累积分布函数的性质} \\
    & =\lim_{\epsilon \to 0}\frac{P[y_1-h(x) \le Y_1-h(X_1) \le y_1 - h(x) + \epsilon \ | \ X_1=x]}{\epsilon} \quad \Rightarrow \color{red}{条件概率里的条件可以作逻辑推导} \\
    & =\lim_{\epsilon \to 0}\frac{P[y_1-h(x) \le R_1 \le y_1 - h(x) + \epsilon \ | \ X_1=x]}{\epsilon} \quad \Rightarrow \color{red}{观测方程} \\
    & =\lim_{\epsilon \to 0}\frac{P[y_1-h(x) \le R_1 \le y_1 - h(x) + \epsilon]}{\epsilon} \quad \Rightarrow \color{red}{X_{k}与R_k相互独立} \\
    & =\lim_{\epsilon \to 0}\frac{F_{R_1}[y_1 - h(x) + \epsilon]-F_{R_1}[y_1 - h(x)]}{\epsilon} \quad \Rightarrow \color{red}{累积分布函数的性质} \\
    & =f_{R_1}[y_1-h(x)] \quad \Rightarrow \color{red}{导数的定义}
\end{aligned}</script><p>可以发现，<strong>似然概率密度函数本质来源于观测方程</strong>。</p>
<p>然后，联合预测步得到的 1 时刻状态量随机变量 $X_1$ 的先验概率密度函数 $f_{X_1}^-(x)$，求解 1 时刻状态量随机变量 $X_1$ 的后验概率密度函数 $f_{X_1}^+(x)$：</p>
<script type="math/tex; mode=display">
f_{X_1}^+(x)=\eta_1·f_{Y_1|X_1}(y_1 \ | \ x)·f_{X_1}^-(x)=\eta_1·f_{R_1}[y_1-h(x)]·f_{X_1}^-(x)</script><p>其中，归一化常数 $\eta_1$为：</p>
<script type="math/tex; mode=display">
\eta_1=\left[\int_{-\infty}^{+\infty}f_{Y_1|X_1}(y_1 \ | \ x)f_{X_1}^-(x)\mathrm{d}x\right]^{-1}=\left\{\int_{-\infty}^{+\infty}f_{R_1}[y_1-h(x)]f_{X_1}^-(x)\mathrm{d}x\right\}^{-1}</script><p>推导完毕。</p>
<h3 id="2-4-4-递推流程" class="heading-control"><a href="#2-4-4-递推流程" class="headerlink" title="2.4.4 递推流程"></a>2.4.4 递推流程<a class="heading-anchor" href="#2-4-4-递推流程" aria-hidden="true"></a></h3><p>由预测步和更新步的推导结果，可得到由 0 时刻状态量随机变量 $X_0$ 的后验概率密度函数 $f_{X_0}^+(x)$ 到 k 时刻状态量随机变量 $X_k$ 的后验概率密度函数 $f_{X_k}^+(x)$ 的递推流程：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    f_{X_0}^+(x) & \stackrel{预测}{\Longrightarrow} f_{X_1}^-(x)=\int_{-\infty}^{+\infty}f_{Q_1}[x-f(v)]f_{X_0}^+(v)\mathrm{d}v \stackrel{观测更新}{\Longrightarrow} f_{X_1}^+(x)=\eta_1·f_{R_1}[y_1-h(x)]·f_{X_1}^-(x) \\
    & \stackrel{预测}{\Longrightarrow} f_{X_2}^-(x)=\int_{-\infty}^{+\infty}f_{Q_2}[x-f(v)]f_{X_1}^+(v)\mathrm{d}v \stackrel{观测更新}{\Longrightarrow} f_{X_2}^+(x)=\eta_2·f_{R_2}[y_2-h(x)]·f_{X_2}^-(x) \\
    & \cdots \\
    & \stackrel{预测}{\Longrightarrow} f_{X_k}^-(x)=\int_{-\infty}^{+\infty}f_{Q_k}[x-f(v)]f_{X_{k-1}}^+(v)\mathrm{d}v \stackrel{观测更新}{\Longrightarrow} f_{X_k}^+(x)=\eta_k·f_{R_k}[y_k-h(x)]·f_{X_k}^-(x)
\end{aligned}</script><p>其中，归一化常数 $\eta_k$ 为：</p>
<script type="math/tex; mode=display">
\eta_k=\left\{\int_{-\infty}^{+\infty}f_{R_k}[y_k-h(x)]f_{X_k}^-(x)\mathrm{d}x\right\}^{-1}</script><p>最终，可得到 k 时刻状态量随机变量 $X_k$ 的最优估计 $\hat{x}_k$：</p>
<script type="math/tex; mode=display">
\hat{x}_k=E[f_{X_k}^+(x)]=\int_{-\infty}^{+\infty}xf_{X_k}^+(x)\mathrm{d}x</script><h3 id="2-4-5-完整算法框架" class="heading-control"><a href="#2-4-5-完整算法框架" class="headerlink" title="2.4.5 完整算法框架"></a>2.4.5 完整算法框架<a class="heading-anchor" href="#2-4-5-完整算法框架" aria-hidden="true"></a></h3><p><strong>(1) 设初值</strong></p>
<p>初始 0 时刻状态量随机变量 $X_0$ 的后验概率密度函数：</p>
<script type="math/tex; mode=display">
f_{X_0}^+(x)</script><p><strong>(2) 预测步</strong></p>
<p>k 时刻状态量随机变量 $X_k$ 的先验概率密度函数：</p>
<script type="math/tex; mode=display">
f_{X_k}^-(x)=\int_{-\infty}^{+\infty}f_{Q_k}[x-f(v)]f_{X_{k-1}}^+(v)\mathrm{d}v</script><p><strong>(3) 更新步</strong></p>
<p>k 时刻状态量随机变量 $X_k$ 的后验概率密度函数：</p>
<script type="math/tex; mode=display">
f_{X_k}^+(x)=\eta_k·f_{R_k}[y_k-h(x)]·f_{X_k}^-(x)</script><p>归一化常数 $\eta_k$：</p>
<script type="math/tex; mode=display">
\eta_k=\left\{\int_{-\infty}^{+\infty}f_{R_k}[y_k-h(x)]f_{X_k}^-(x)\mathrm{d}x\right\}^{-1}</script><p><strong>(4) 求解状态量后验估计</strong></p>
<p>k 时刻状态量随机变量 $X_k$ 的后验估计：</p>
<script type="math/tex; mode=display">
\hat{x}_k^+=E[f_{X_k}^+(x)]=\int_{-\infty}^{+\infty}xf_{X_k}^+(x)\mathrm{d}x</script><h2 id="2-5-贝叶斯滤波的缺点及解决方法" class="heading-control"><a href="#2-5-贝叶斯滤波的缺点及解决方法" class="headerlink" title="2.5 贝叶斯滤波的缺点及解决方法"></a>2.5 贝叶斯滤波的缺点及解决方法<a class="heading-anchor" href="#2-5-贝叶斯滤波的缺点及解决方法" aria-hidden="true"></a></h2><h3 id="2-5-1-缺点" class="heading-control"><a href="#2-5-1-缺点" class="headerlink" title="2.5.1 缺点"></a>2.5.1 缺点<a class="heading-anchor" href="#2-5-1-缺点" aria-hidden="true"></a></h3><p>从上文的推导及结论中可以发现，求解预测步中的先验概率密度函数 $f_{X_k}^-(x)$、更新步中的归一化常数 $\eta_k$、最终的最优估计 $\hat{x}_k$ 时均涉及到<strong>无穷积分</strong>，而大多数情况无法得到解析解，使得贝叶斯滤波算法的直接应用十分困难。</p>
<h3 id="2-5-2-解决办法" class="heading-control"><a href="#2-5-2-解决办法" class="headerlink" title="2.5.2 解决办法"></a>2.5.2 解决办法<a class="heading-anchor" href="#2-5-2-解决办法" aria-hidden="true"></a></h3><p>为了解决贝叶斯滤波中的无穷积分问题，通常从两个角度出发：</p>
<p><strong>(1) 作理想假设</strong></p>
<ul>
<li>假设状态转移函数 $f(x)$ 和观测函数 $h(x)$ 均为线性函数，过程噪声随机变量 $Q_k$ 和 观测噪声随机变量 $R_k$ 均服从均值为 0 的正态分布——卡尔曼滤波（Kalman Filter）</li>
<li>假设状态转移函数 $f(x)$ 和（或）观测函数 $h(x)$ 为非线性函数，过程噪声随机变量 $Q_k$ 和 观测噪声随机变量 $R_k$ 均服从均值为 0 的正态分布——扩展卡尔曼滤波（Extended Kalman Filter）和无迹卡尔曼滤波（Unscented Kalman Filter）</li>
</ul>
<p><strong>(2) 化连续为离散</strong></p>
<p>将无穷积分转化为数值积分，一般有以下方法：</p>
<ul>
<li>高斯积分（不常用）</li>
<li>蒙特卡罗积分（粒子滤波，Particle Filter）</li>
<li>直方图滤波</li>
</ul>
<p>针对本节内容中提到的卡尔曼滤波、扩展卡尔曼滤波、无迹卡尔曼滤波、粒子滤波、直方图滤波等常用滤波算法，将在后续文章中进行详细展开讨论。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0b25neHVlLmNvbS8=" title="https://www.matongxue.com/">马同学数学课程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODglODYlRTUlQjglODMlRTUlODclQkQlRTYlOTUlQjAvMjQzOTc5Nj9mcj1hbGFkZGlu" title="https://baike.baidu.com/item/%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0/2439796?fr=aladdin">百度百科 - 分布函数<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTklOUElOEYlRTYlOUMlQkElRTglQkYlODclRTclQTglOEIvMzY4ODk1P2ZyPWFsYWRkaW4=" title="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E8%BF%87%E7%A8%8B/368895?fr=aladdin">百度百科 - 随机过程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2Njk0NDg2L2Fuc3dlci8xMjcyODk2OTQz" title="https://www.zhihu.com/question/26694486/answer/1272896943">如何从深刻地理解随机过程的含义？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zcGFjZS5iaWxpYmlsaS5jb20vMjg3OTg5ODUyL3ZpZGVv" title="https://space.bilibili.com/287989852/video">b 站忠实的王大头《贝叶斯滤波与卡尔曼滤波》系列教学视频<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dxMXBzYTc4L2FydGljbGUvZGV0YWlscy8xMDU4NDkzNTM=" title="https://blog.csdn.net/wq1psa78/article/details/105849353">你真的搞懂贝叶斯滤波了吗？<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>多传感器信息融合</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>数学</tag>
        <tag>滤波</tag>
        <tag>贝叶斯滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>从贝叶斯滤波到卡尔曼滤波</title>
    <url>/archives/3bb74af.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%9B%AE%E5%BD%95-%E4%BB%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%88%B0%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.png" alt="目录-从贝叶斯滤波到卡尔曼滤波"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p><strong>卡尔曼滤波</strong>（Kalman Filter，KF）以贝叶斯滤波为理论基础，并通过假设状态量随机变量（以下简称状态量）、观测量均服从正态分布，假设过程噪声、观测噪声均服从均值为 0 的正态分布，以及假设状态转移函数和观测函数均为线性函数，实现对连续型随机过程的递推状态估计。简言之，卡尔曼滤波是在贝叶斯滤波框架下求解线性高斯问题。</p>
<h1 id="1-贝叶斯滤波的三大概率密度函数" class="heading-control"><a href="#1-贝叶斯滤波的三大概率密度函数" class="headerlink" title="1 贝叶斯滤波的三大概率密度函数"></a>1 贝叶斯滤波的三大概率密度函数<a class="heading-anchor" href="#1-贝叶斯滤波的三大概率密度函数" aria-hidden="true"></a></h1><p>在此前的文章<a href="https://blog.shipengx.com/archives/9fb25cec.html">《从概率到贝叶斯滤波》</a>中，已经讲到贝叶斯滤波的先验概率密度函数、似然概率密度函数和后验概率密度函数：</p>
<p><strong>(1) 先验概率密度函数</strong></p>
<script type="math/tex; mode=display">
f_{X_k}^-(x)=\int_{-\infty}^{+\infty}f_{Q_k}[x-f(v)]f_{X_{k-1}}^+(v)\mathrm{d}v</script><p><strong>(2) 似然概率密度函数</strong></p>
<script type="math/tex; mode=display">
f_{Y_k|X_k}(y_k \ | \ x) = f_{R_k}[y_k-h(x)]</script><p><strong>(3) 后验概率密度函数</strong></p>
<script type="math/tex; mode=display">
f_{X_k}^+(x)=\eta_k·f_{R_k}[y_k-h(x)]·f_{X_k}^-(x)</script><p>其中，后验概率密度函数中的归一化常数 $\eta_k$ 为：</p>
<script type="math/tex; mode=display">
\eta_k=\left\{\int_{-\infty}^{+\infty}f_{R_k}[y_k-h(x)]f_{X_k}^-(x)\mathrm{d}x\right\}^{-1}</script><h1 id="2-卡尔曼滤波的假设" class="heading-control"><a href="#2-卡尔曼滤波的假设" class="headerlink" title="2 卡尔曼滤波的假设"></a>2 卡尔曼滤波的假设<a class="heading-anchor" href="#2-卡尔曼滤波的假设" aria-hidden="true"></a></h1><p>卡尔曼滤波以贝叶斯滤波为理论基础，并作了六个前提假设：</p>
<p><strong>(1) 假设一：状态量服从正态分布</strong></p>
<script type="math/tex; mode=display">
X \sim \mathcal{N}(\mu_X, \ \sigma_X^2)</script><p><strong>(2) 假设二：观测量服从正态分布</strong></p>
<script type="math/tex; mode=display">
Y \sim \mathcal{N}(\mu_Y, \ \sigma_Y^2)</script><p><strong>(3) 假设三：过程噪声服从均值为 0 的正态分布</strong></p>
<script type="math/tex; mode=display">
Q \sim \mathcal{N}(0, \ \sigma_Q^2)</script><p><strong>(4) 假设四：观测噪声服从均值为 0 的正态分布</strong></p>
<script type="math/tex; mode=display">
Q \sim \mathcal{N}(0, \ \sigma_R^2)</script><p><strong>(5) 假设五：状态转移函数为线性函数</strong></p>
<script type="math/tex; mode=display">
f(X_k)=F*X_{k-1}+B*u_k</script><p>其中，$F$ 为状态转移比例项，对于单一状态量的卡尔曼滤波中，$F$ 为一常数；$B$ 为控制比例项，$u_k$ 为控制量，$B$ 和 $u_k$ 的乘积可视为线性状态转移函数中的截距项。在简单的系统中，常常没有控制项 $B$ 和 $u_k$。</p>
<p><strong>(6) 假设六：观测函数为线性函数</strong></p>
<script type="math/tex; mode=display">
h(X_k)=H*X_k</script><p>$H$ 为观测比例项，对于单一状态量的卡尔曼滤波中，$H$ 为一常数。</p>
<h1 id="3-卡尔曼滤波的公式推导" class="heading-control"><a href="#3-卡尔曼滤波的公式推导" class="headerlink" title="3 卡尔曼滤波的公式推导"></a>3 卡尔曼滤波的公式推导<a class="heading-anchor" href="#3-卡尔曼滤波的公式推导" aria-hidden="true"></a></h1><h2 id="3-1-预测步的两个公式" class="heading-control"><a href="#3-1-预测步的两个公式" class="headerlink" title="3.1 预测步的两个公式"></a>3.1 预测步的两个公式<a class="heading-anchor" href="#3-1-预测步的两个公式" aria-hidden="true"></a></h2><p>根据假设一，$k-1$ 时刻状态量 $X_{k-1}$ 服从均值为 $\mu_{k-1}^+$，方差为 ${\sigma_{k-1}^+}^2$ 的正态分布：</p>
<script type="math/tex; mode=display">
X_{k-1} \sim \mathcal{N}(\mu_{k-1}^+, \ {\sigma_{k-1}^+}^2)</script><p>$X_{k-1}$ 的后验概率密度函数为：</p>
<script type="math/tex; mode=display">
f_{X_{k-1}}^+=\frac{1}{\sigma_{k-1}^+\sqrt{2\pi}}e^{-\frac{(x-\mu_{k-1}^+)^2}{2{\sigma_{k-1}^+}^2}}</script><p>结合假设三与假设五，k 时刻状态量 $X_k$ 的先验概率密度函数为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    f_{X_k}^-(x) & = \int_{-\infty}^{+\infty}f_{Q_k}[x-f(v)]f_{X_{k-1}}^+(v)\mathrm{d}v \\
    & = \int_{-\infty}^{+\infty}\frac{1}{\sigma_{Q_k}\sqrt{2\pi}}e^{-\frac{(x-F*v-B*u_k)^2}{2{\sigma_{Q_k}}^2}}*\frac{1}{\sigma_{k-1}^+\sqrt{2\pi}}e^{-\frac{(v-\mu_{k-1}^+)^2}{2{\sigma_{k-1}^+}^2}}\mathrm{d}v
\end{aligned}</script><p>对于 $f_{X_k}^-(x)$ 的推导，有三种方法：</p>
<ul>
<li>Mathematica 软件做符号推导</li>
<li>复变函数留数定理</li>
<li>傅里叶变换 + 卷积</li>
</ul>
<p>这里使用 Mathematica 软件做符号推导，创建 WolframScript（.wls）脚本文件，创建 $f_{X_k}^-(x)$ 公式：</p>
<p><img data-src="https://image.shipengx.com/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0wls%E8%84%9A%E6%9C%AC%E5%85%AC%E5%BC%8F.png" alt="卡尔曼滤波先验概率密度函数wls脚本公式"></p>
<p>其中，${\sigma_{Q_k}}^2$ 表示 k 时刻过程噪声的方差；$\mu_{k-one}^+$ 表示 $k-1$ 时刻状态量的后验概率密度函数均值；${\sigma_{k-one}^+}^2$ 表示 $k-1$ 时刻状态量的后验概率密度函数方差。</p>
<p>运行代码进行化简，得到如下条件表达式结果：</p>
<p><img data-src="https://image.shipengx.com/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%85%88%E9%AA%8C%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0wls%E8%84%9A%E6%9C%AC%E5%8C%96%E7%AE%80%E7%BB%93%E6%9E%9C.png" alt="卡尔曼滤波先验概率密度函数wls脚本化简结果"></p>
<p>条件表达式中的条件显然成立，整理表达式形式可知，先验概率密度函数 $f_{X_k}^-(x)$ 为正态分布函数，均值和方差分别为：</p>
<script type="math/tex; mode=display">
\mu_k^- = F*\mu_{k-1}^++B*u_k \tag{3.1}</script><script type="math/tex; mode=display">
{\sigma_k^-}^2 = F^2*{\sigma_{k-1}^+}^2+{\sigma_{Q_k}}^2 \tag{3.2}</script><h2 id="3-2-更新步的三个公式" class="heading-control"><a href="#3-2-更新步的三个公式" class="headerlink" title="3.2 更新步的三个公式"></a>3.2 更新步的三个公式<a class="heading-anchor" href="#3-2-更新步的三个公式" aria-hidden="true"></a></h2><p>结合假设四、假设六、公式 (3.1)、公式 (3.2)，可知，k 时刻状态量 $X_k$ 的后验概率密度函数为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    f_{X_k}^+(x) & = \eta_k·f_{R_k}[y_k-h(x)]·f_{X_k}^-(x) \\
    & = \eta_k*\frac{1}{\sigma_{R_k}\sqrt{2\pi}}e^{-\frac{(y_k-H*x)^2}{2{\sigma_{R_k}}^2}}*\frac{1}{\sigma_{k}^-\sqrt{2\pi}}e^{-\frac{(x-\mu_{k}^-)^2}{2{\sigma_{k}^-}^2}}
\end{aligned}</script><p>其中，归一化常数 $\eta_k$ 为：</p>
<script type="math/tex; mode=display">
\eta_k=\int_{-\infty}^{\infty}\frac{1}{\sigma_{R_k}\sqrt{2\pi}}e^{-\frac{(y_k-H*x)^2}{2{\sigma_{R_k}}^2}}*\frac{1}{\sigma_{k}^-\sqrt{2\pi}}e^{-\frac{(x-\mu_{k}^-)^2}{2{\sigma_{k}^-}^2}}\mathrm{d}x</script><p>创建 WolframScript（.wls）脚本文件，创建 $f_{X_k}^+(x)$ 公式：</p>
<p><img data-src="https://image.shipengx.com/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0wls%E8%84%9A%E6%9C%AC%E5%85%AC%E5%BC%8F.png" alt="卡尔曼滤波后验概率密度函数wls脚本公式"></p>
<p>其中，${\sigma_{R_k}}^2$ 表示 k 时刻观测噪声的方差；$y_k$ 表示 k 时刻观测量的取值。<code>Simplify[]</code> 函数的使用是为了简化结果。</p>
<p>运行代码进行化简，得到如下条件表达式结果：</p>
<p><img data-src="https://image.shipengx.com/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87%E5%AF%86%E5%BA%A6%E5%87%BD%E6%95%B0wls%E8%84%9A%E6%9C%AC%E5%8C%96%E7%AE%80%E7%BB%93%E6%9E%9C.png" alt="卡尔曼滤波后验概率密度函数wls脚本化简结果"></p>
<p>条件表达式中的条件显然成立，整理表达式形式可知后验概率密度函数 $f_{X_k}^+(x)$ 的均值和方差分别为：</p>
<script type="math/tex; mode=display">
\mu_k^+ = \mu_k^-+K*(y_k-H*\mu_k^-) \tag{3.3}</script><script type="math/tex; mode=display">
{\sigma_k^+}^2 = (1-K*H)*{\sigma_k^-}^2 \tag{3.4}</script><p>$\mu_k^+$ 即 k 时刻状态量 $X_k$ 的后验估计 $\hat{x}_k^+$。其中，$K$ 被称为卡尔曼增益系数：</p>
<script type="math/tex; mode=display">
K=\frac{H*{\sigma_k^-}^2}{H^2*{\sigma_k^-}^2+{\sigma_{R_k}}^2} \tag{3.5}</script><p>卡尔曼增益系数 $K$ 可变形为：</p>
<script type="math/tex; mode=display">
K=\frac{H*{\sigma_k^-}^2}{H^2*{\sigma_k^-}^2+{\sigma_{R_k}}^2} = \frac{H}{H^2+{\sigma_{R_k}}^2/{\sigma_k^-}^2}</script><p>当 ${\sigma_{R_k}}^2 \gg {\sigma_k^-}^2$ 时，$K\to0$，故</p>
<script type="math/tex; mode=display">
\mu_k^+ = \mu_k^-+K*(y_k-H*\mu_k^-) \to \mu_k^-</script><p>此时，后验估计结果倾向于预测；</p>
<p>当 ${\sigma_{R_k}}^2 \ll {\sigma_k^-}^2$ 时，$K\to\frac{1}{H}$，故</p>
<script type="math/tex; mode=display">
\mu_k^+ = \mu_k^-+K*(y_k-H*\mu_k^-) \to \frac{y_k}{H}</script><p>此时，后验估计结果倾向于观测。</p>
<p>点击<a href="/download/KalmanFilter.wls">这里</a>下载我的 WolframScript（.wls）脚本文件。</p>
<h1 id="4-矩阵形式的卡尔曼滤波" class="heading-control"><a href="#4-矩阵形式的卡尔曼滤波" class="headerlink" title="4 矩阵形式的卡尔曼滤波"></a>4 矩阵形式的卡尔曼滤波<a class="heading-anchor" href="#4-矩阵形式的卡尔曼滤波" aria-hidden="true"></a></h1><p>上文内容所描述的是一维的卡尔曼滤波，当状态量和观测量不再是单一的随机变量而是由多个随机变量组成的序列时，卡尔曼滤波中各个量的维数也将随之改变：</p>
<ul>
<li>状态量 $X$ 由随机变量演变为随机向量，随机向量中的每一个分量为一个状态量随机变量。维数为 $n_X \times 1$</li>
<li>状态转移比例项 $F$ 演变为矩阵，维数为 $n_X \times n_X$</li>
<li>控制量 $u_k$ 演变为矩阵，维数为 $n_u \times 1$</li>
<li>控制比例项 $B$ 演变为矩阵，维数为 $n_X \times n_u$</li>
<li>状态量概率密度函数均值 $\mu$ 演变为矩阵，维数为 $n_X \times 1$</li>
<li>状态量概率密度函数方差 $\sigma^2$ 演变为协方差矩阵，用 $\Sigma$ 表示，维数为 $n_X \times n_X$</li>
<li>过程噪声方差 ${\sigma_Q}^2$ 演变为协方差矩阵，用 $\Sigma_Q$ 表示，维数为 $n_X \times n_X$</li>
<li>观测量 $Y$ 由随机变量演变为随机向量，随机向量中的每一个分量为一个观测量随机变量。维数为 $n_Y \times 1$</li>
<li>观测值 $y_k$ 由单一值演变为由单一值组成的值矩阵，维数为 $n_Y \times 1$</li>
<li>观测比例项 $H$ 演变为矩阵，维数为 $n_Y \times n_X$</li>
<li>观测噪声方差 ${\sigma_R}^2$ 演变为协方差矩阵，用 $\Sigma_R$ 表示，维数为 $n_Y \times n_Y$</li>
<li>卡尔曼增益系数 $K$ 演变为矩阵，维数为 $n_X \times n_Y$</li>
</ul>
<p>对应的五个公式演变为：</p>
<script type="math/tex; mode=display">
\mu_k^- = F*\mu_{k-1}^++B*u_k \tag{4.1}</script><script type="math/tex; mode=display">
\Sigma_k^- = F*\Sigma_{k-1}^+*F^T+{\Sigma_{Q_k}} \tag{4.2}</script><script type="math/tex; mode=display">
\mu_k^+ = \mu_k^-+K*(y_k-H*\mu_k^-) \tag{4.3}</script><script type="math/tex; mode=display">
\Sigma_k^+ = (I-K*H)*\Sigma_k^- \tag{4.4}</script><script type="math/tex; mode=display">
K=\Sigma_k^-*H^T*(H*\Sigma_k^-*H^T+{\Sigma_{R_k}})^{-1} \tag{4.5}</script><p>公式 (4.3) 中 $\mu_k^+$ 即 k 时刻状态量 $X_k$ 的后验估计 $\hat{x}_k^+$，$y_k-H*\mu_k^-$ 常被称为残差（Residual）或新息（Innovation）；公式 (4.4) 中的 $I$ 代表单位矩阵，维数为 $n_X \times n_X$。</p>
<p>从结果中还可以发现，外部控制项 $B*u_k$ 通过影响先验估计均值间接影响了后验估计均值，但对后验估计方差没有影响。</p>
<h1 id="5-应用实例" class="heading-control"><a href="#5-应用实例" class="headerlink" title="5 应用实例"></a>5 应用实例<a class="heading-anchor" href="#5-应用实例" aria-hidden="true"></a></h1><p>卡尔曼滤波的应用实例可参考此前的学习文章<a href="https://blog.shipengx.com/archives/d3b96bd5.html">《（十三）手把手教你写卡尔曼滤波器》</a>，文章中的应用场景是使用激光雷达（Lidar）对匀速直线运动（Constant Velocity，CV）目标的测距过程。</p>
<p>博主工作中使用卡尔曼滤波对路口前的停止线（来自单目前向视觉）纵向距离进行了估计，系统模型抽象为匀加速直线运动（Constant Acceleration，CA），此时的状态转移函数 $f(x)$ 中存在外部控制项 $B*u_k$，停止线纵向距离估计结果用于下游规划控制模块的纵向速度规划输入参考。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUhUNHkxNTc3ZyNyZXBseTM0NjI4MDMxNTQ=" title="https://www.bilibili.com/video/BV1HT4y1577g#reply3462803154">b 站忠实的王大头《贝叶斯滤波与卡尔曼滤波》第七讲：卡尔曼滤波<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTIzODY4MQ==" title="https://zhuanlan.zhihu.com/p/45238681">无人驾驶技术入门（十三）| 手把手教你写卡尔曼滤波器<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5iemFyZy5jb20vcC9ob3ctYS1rYWxtYW4tZmlsdGVyLXdvcmtzLWluLXBpY3R1cmVzLw==" title="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/">How a Kalman filter works, in pictures<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA3MjA2NjEvYXJ0aWNsZS9kZXRhaWxzLzYzMjUzNTA5" title="https://blog.csdn.net/u010720661/article/details/63253509">详解卡尔曼滤波原理<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zeW5hcHRpY2xhYi5jby5rci9hdHRhY2htZW50L2NmaWxlMS51ZkAyNzM3QzU0QjU5MDkwN0JBMEQ0NkNFLnBkZg==" title="https://synapticlab.co.kr/attachment/cfile1.uf@2737C54B590907BA0D46CE.pdf">Understanding the Basis of the Kalman Filter Via a Simple and Intuitive Derivation<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>多传感器信息融合</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>数学</tag>
        <tag>滤波</tag>
        <tag>卡尔曼滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>从贝叶斯滤波到扩展卡尔曼滤波</title>
    <url>/archives/ea375326.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%9B%AE%E5%BD%95-%E4%BB%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%88%B0%E6%89%A9%E5%B1%95%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.png" alt="目录-从贝叶斯滤波到扩展卡尔曼滤波"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p><strong>扩展卡尔曼滤波</strong>（Extended Kalman Filter，EKF）是标准卡尔曼滤波在非线性情形下的一种扩展形式，它是一种高效率的递归滤波器（自回归滤波器）。</p>
<p>EKF 的基本思想是利用泰勒级数展开将非线性系统的状态转移函数 $f(x)$ 和（或）观测函数 $h(x)$ 线性化，然后采用卡尔曼滤波框架对信号进行滤波，因此它是一种次优滤波。</p>
<h1 id="1-贝叶斯滤波的三大概率密度函数" class="heading-control"><a href="#1-贝叶斯滤波的三大概率密度函数" class="headerlink" title="1 贝叶斯滤波的三大概率密度函数"></a>1 贝叶斯滤波的三大概率密度函数<a class="heading-anchor" href="#1-贝叶斯滤波的三大概率密度函数" aria-hidden="true"></a></h1><p>在此前的文章<a href="https://blog.shipengx.com/archives/9fb25cec.html">《从概率到贝叶斯滤波》</a>和<a href="https://blog.shipengx.com/archives/3bb74af.html">《从贝叶斯滤波到卡尔曼滤波》</a>中，已经讲到贝叶斯滤波的先验概率密度函数、似然概率密度函数和后验概率密度函数：</p>
<p><strong>(1) 先验概率密度函数</strong></p>
<script type="math/tex; mode=display">
f_{X_k}^-(x)=\int_{-\infty}^{+\infty}f_{Q_k}[x-f(v)]f_{X_{k-1}}^+(v)\mathrm{d}v</script><p><strong>(2) 似然概率密度函数</strong></p>
<script type="math/tex; mode=display">
f_{Y_k|X_k}(y_k \ | \ x) = f_{R_k}[y_k-h(x)]</script><p><strong>(3) 后验概率密度函数</strong></p>
<script type="math/tex; mode=display">
f_{X_k}^+(x)=\eta_k·f_{R_k}[y_k-h(x)]·f_{X_k}^-(x)</script><p>其中，后验概率密度函数中的归一化常数 $\eta_k$ 为：</p>
<script type="math/tex; mode=display">
\eta_k=\left\{\int_{-\infty}^{+\infty}f_{R_k}[y_k-h(x)]f_{X_k}^-(x)\mathrm{d}x\right\}^{-1}</script><h1 id="2-扩展卡尔曼滤波的假设" class="heading-control"><a href="#2-扩展卡尔曼滤波的假设" class="headerlink" title="2 扩展卡尔曼滤波的假设"></a>2 扩展卡尔曼滤波的假设<a class="heading-anchor" href="#2-扩展卡尔曼滤波的假设" aria-hidden="true"></a></h1><p>扩展卡尔曼滤波以贝叶斯滤波为理论基础，并作了五个前提假设。</p>
<h2 id="2-1-与卡尔曼滤波相同的假设" class="heading-control"><a href="#2-1-与卡尔曼滤波相同的假设" class="headerlink" title="2.1 与卡尔曼滤波相同的假设"></a>2.1 与卡尔曼滤波相同的假设<a class="heading-anchor" href="#2-1-与卡尔曼滤波相同的假设" aria-hidden="true"></a></h2><p><strong>(1) 假设一：状态量服从正态分布</strong></p>
<script type="math/tex; mode=display">
X \sim \mathcal{N}(\mu_X, \ \sigma_X^2)</script><p><strong>(2) 假设二：观测量服从正态分布</strong></p>
<script type="math/tex; mode=display">
Y \sim \mathcal{N}(\mu_Y, \ \sigma_Y^2)</script><p><strong>(3) 假设三：过程噪声服从均值为 0 的正态分布</strong></p>
<script type="math/tex; mode=display">
Q \sim \mathcal{N}(0, \ \sigma_Q^2)</script><p><strong>(4) 假设四：观测噪声服从均值为 0 的正态分布</strong></p>
<script type="math/tex; mode=display">
R \sim \mathcal{N}(0, \ \sigma_R^2)</script><h2 id="2-2-与卡尔曼滤波不同的假设" class="heading-control"><a href="#2-2-与卡尔曼滤波不同的假设" class="headerlink" title="2.2 与卡尔曼滤波不同的假设"></a>2.2 与卡尔曼滤波不同的假设<a class="heading-anchor" href="#2-2-与卡尔曼滤波不同的假设" aria-hidden="true"></a></h2><p><strong>(5) 假设五：状态转移函数和（或）观测函数为非线性函数</strong></p>
<p>在卡尔曼滤波的前提假设中，认为状态方程中的状态转移函数 $f(x)$ 以及观测方程中的观测函数 $h(x)$ 均为线性函数。基于这种线性假设，存在常数或常矩阵 $F$，使得 $f(x)$ 可以写成卡尔曼滤波中的线性形式，存在常数或常矩阵 $H$，使得 $h(x)$ 也可以写成卡尔曼滤波中的线性形式。</p>
<p>不同于标准卡尔曼滤波，扩展卡尔曼滤波处理的是非线性系统，假设系统的状态转移函数和（或）观测函数为非线性函数。</p>
<h1 id="3-扩展卡尔曼滤波的公式推导" class="heading-control"><a href="#3-扩展卡尔曼滤波的公式推导" class="headerlink" title="3 扩展卡尔曼滤波的公式推导"></a>3 扩展卡尔曼滤波的公式推导<a class="heading-anchor" href="#3-扩展卡尔曼滤波的公式推导" aria-hidden="true"></a></h1><h2 id="3-1-预测步的两个公式" class="heading-control"><a href="#3-1-预测步的两个公式" class="headerlink" title="3.1 预测步的两个公式"></a>3.1 预测步的两个公式<a class="heading-anchor" href="#3-1-预测步的两个公式" aria-hidden="true"></a></h2><p>当状态转移函数为线性函数时，扩展卡尔曼滤波的预测步与标准卡尔曼滤波相同；当状态转移函数为非线性函数时，扩展卡尔曼滤波的预测步采用下面的推导过程。</p>
<p>根据假设一，$k-1$ 时刻状态量 $X_{k-1}$ 服从均值为 $\mu_{k-1}^+$，方差为 ${\sigma_{k-1}^+}^2$ 的正态分布：</p>
<script type="math/tex; mode=display">
X_{k-1} \sim \mathcal{N}(\mu_{k-1}^+, \ {\sigma_{k-1}^+}^2)</script><p>$X_{k-1}$ 的后验概率密度函数为：</p>
<script type="math/tex; mode=display">
f_{X_{k-1}}^+=\frac{1}{\sigma_{k-1}^+\sqrt{2\pi}}e^{-\frac{(x-\mu_{k-1}^+)^2}{2{\sigma_{k-1}^+}^2}}</script><p>对状态转移函数 $f(x)$ 在 $X_{k-1}$ 的后验估计处 $\hat{x}_{k-1}^+$（即 $\mu_{k-1}^+$）进行<strong>一阶泰勒级数展开</strong>：</p>
<script type="math/tex; mode=display">
f(X_{k-1})=f(\hat{x}_{k-1}^+)+f'(\hat{x}_{k-1}^+)(X_{k-1}-\hat{x}_{k-1}^+)+o(X_{k-1}-\hat{x}_{k-1}^+)</script><p>其中，$o(X_{k-1}-\hat{x}_{k-1}^+)$ 为高阶无穷小量，对其进行舍弃，便可得到状态转移函数 $f(x)$ 的近似形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    f(X_{k-1}) & \approx f(\hat{x}_{k-1}^+)+f'(\hat{x}_{k-1}^+)(X_{k-1}-\hat{x}_{k-1}^+) \\
    & \approx f'(\hat{x}_{k-1}^+)(X_{k-1})+[f(\hat{x}_{k-1}^+)-f'(\hat{x}_{k-1}^+)\hat{x}_{k-1}^+]
\end{aligned}</script><p>令 $F_j=f’(\hat{x}_{k-1}^+), \quad C_F=f(\hat{x}_{k-1}^+)-f’(\hat{x}_{k-1}^+)\hat{x}_{k-1}^+$，则近似有：</p>
<script type="math/tex; mode=display">
f(X_{k-1}) \approx F_j*X_{k-1}+C_F</script><p>结合假设三与上式，$k$ 时刻状态量 $X_k$ 的先验概率密度函数为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    f_{X_k}^-(x) & = \int_{-\infty}^{+\infty}f_{Q_k}[x-f(v)]f_{X_{k-1}}^+(v)\mathrm{d}v \\
    & = \int_{-\infty}^{+\infty}\frac{1}{\sigma_{Q_k}\sqrt{2\pi}}e^{-\frac{(x-F_j*v-C_F)^2}{2{\sigma_{Q_k}}^2}}*\frac{1}{\sigma_{k-1}^+\sqrt{2\pi}}e^{-\frac{(x-\mu_{k-1}^+)^2}{2{\sigma_{k-1}^+}^2}}\mathrm{d}v
\end{aligned}</script><p>类似推导标准卡尔曼滤波时的做法，使用 Mathematica 软件做符号推导，整理表达式结果可知，先验概率密度函数 $f_{X_k}^-(x)$ 为正态分布函数，均值和方差分别为：</p>
<script type="math/tex; mode=display">
\mu_k^- = F_j*\mu_{k-1}^++C_F=f(\mu_{k-1}^+) \tag{3.1}</script><script type="math/tex; mode=display">
{\sigma_k^-}^2 = F_j^2*{\sigma_{k-1}^+}^2+{\sigma_{Q_k}}^2 \tag{3.2}</script><p>其中，$F_j=f’(\hat{x}_{k-1}^+)$，对于一维扩展卡尔曼滤波，$F_j$ 为一常数项，即状态转移函数 $f(x)$ 的一阶导函数 $f’(x)$ 在上一时刻状态量后验估计处的函数值。</p>
<h2 id="3-2-更新步的三个公式" class="heading-control"><a href="#3-2-更新步的三个公式" class="headerlink" title="3.2 更新步的三个公式"></a>3.2 更新步的三个公式<a class="heading-anchor" href="#3-2-更新步的三个公式" aria-hidden="true"></a></h2><p>当观测函数为线性函数时，扩展卡尔曼滤波的更新步与标准卡尔曼滤波相同；当观测函数为非线性函数时，扩展卡尔曼滤波的更新步采用下面的推导过程。</p>
<p>对观测函数 $h(x)$ 在 $X_k$ 的先验估计处 $\hat{x}_k^-$（即 $\mu_k^-$）进行<strong>一阶泰勒级数展开</strong>：</p>
<script type="math/tex; mode=display">
h(X_k)=h(\hat{x}_k^-)+h'(\hat{x}_k^-)(X_k-\hat{x}_k^-)+o(X_k-\hat{x}_k^-)</script><p>其中，$o(X_k-\hat{x}_k^-)$ 为高阶无穷小量，对其进行舍弃，便可得到观测函数 $f(x)$ 的近似形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    h(X_k) & \approx h(\hat{x}_k^-)+h'(\hat{x}_k^-)(X_k-\hat{x}_k^-) \\
    & \approx h'(\hat{x}_k^-)(X_k)+[h(\hat{x}_k^-)-h'(\hat{x}_k^-)\hat{x}_k^-]
\end{aligned}</script><p>令 $H_j=h’(\hat{x}_k^-), \quad C_H=h(\hat{x}_k^-)-h’(\hat{x}_k^-)\hat{x}_k^-$，则近似有：</p>
<script type="math/tex; mode=display">
h(X_k) \approx H_j*X_k+C_H</script><p>结合假设四、公式 (3.1)、公式 (3.2) 及 $h(x)$ 的线性化近似形式，可知，k 时刻状态量 $X_k$ 的后验概率密度函数为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    f_{X_k}^+(x) & = \eta_k·f_{R_k}[y_k-h(x)]·f_{X_k}^-(x) \\
    & = \eta_k*\frac{1}{\sigma_{R_k}\sqrt{2\pi}}e^{-\frac{(y_k-H_j*x-C_H)^2}{2{\sigma_{R_k}}^2}}*\frac{1}{\sigma_{k}^-\sqrt{2\pi}}e^{-\frac{(x-\mu_{k}^-)^2}{2{\sigma_{k}^-}^2}}
\end{aligned}</script><p>其中，归一化常数 $\eta_k$ 为：</p>
<script type="math/tex; mode=display">
\eta_k=\int_{-\infty}^{\infty}\frac{1}{\sigma_{R_k}\sqrt{2\pi}}e^{-\frac{(y_k-H_j*x-C_H)^2}{2{\sigma_{R_k}}^2}}*\frac{1}{\sigma_{k}^-\sqrt{2\pi}}e^{-\frac{(x-\mu_{k}^-)^2}{2{\sigma_{k}^-}^2}}\mathrm{d}x</script><p>类似推导标准卡尔曼滤波时的做法，使用 Mathematica 软件做符号推导，整理表达式结果可知，后验概率密度函数 $f_{X_k}^+(x)$ 为正态分布函数，均值和方差分别为：</p>
<script type="math/tex; mode=display">
\mu_k^+ = \mu_k^-+K*(y_k-H_j*\mu_k^--C_H)= \mu_k^-+K*[y_k-h(\mu_k^-)] \tag{3.3}</script><script type="math/tex; mode=display">
{\sigma_k^+}^2 = (1-K*H_j)*{\sigma_k^-}^2 \tag{3.4}</script><p>$\mu_k^+$ 即 k 时刻状态量 $X_k$ 的后验估计 $\hat{x}_k^+$。其中，$K$ 被称为卡尔曼增益系数：</p>
<script type="math/tex; mode=display">
K=\frac{H_j*{\sigma_k^-}^2}{H_j^2*{\sigma_k^-}^2+{\sigma_{R_k}}^2} \tag{3.5}</script><p>其中，$H_j=h’(\hat{x}_k^-)$，对于一维扩展卡尔曼滤波，$H_j$ 为一常数项，即观测函数 $h(x)$ 的一阶导函数 $h’(x)$ 在当前时刻状态量先验估计处的函数值。</p>
<h1 id="4-矩阵形式的扩展卡尔曼滤波" class="heading-control"><a href="#4-矩阵形式的扩展卡尔曼滤波" class="headerlink" title="4 矩阵形式的扩展卡尔曼滤波"></a>4 矩阵形式的扩展卡尔曼滤波<a class="heading-anchor" href="#4-矩阵形式的扩展卡尔曼滤波" aria-hidden="true"></a></h1><p>上文内容所描述的是一维的扩展卡尔曼滤波，当状态量和观测量不再是单一的随机变量而是由多个随机变量组成的序列时，扩展卡尔曼滤波中各个量的维数也将随之改变：</p>
<ul>
<li>状态量 $X$ 由随机变量演变为随机向量，随机向量中的每一个分量为一个状态量随机变量。维数为 $n_X \times 1$</li>
<li>状态转移比例项 $F_j$ 演变为<strong>雅可比矩阵</strong>，维数为 $n_X \times n_X$。此时，$F_j$ 是由每个状态转移函数对每个状态量分量求偏导后，将上一时刻状态量的后验估计代入得到：<script type="math/tex; mode=display">
F_j=
\begin{pmatrix}
    \frac{\partial f_1}{\partial X_{k-1}^1} & \frac{\partial f_1}{\partial X_{k-1}^2} & \cdots & \frac{\partial f_1}{\partial X_{k-1}^{n_X}} \\
    \frac{\partial f_2}{\partial X_{k-1}^1} & \frac{\partial f_2}{\partial X_{k-1}^2} & \cdots & \frac{\partial f_2}{\partial X_{k-1}^{n_X}} \\
    \vdots & \vdots & \ddots & \vdots \\
    \frac{\partial f_{n_X}}{\partial X_{k-1}^1} & \frac{\partial f_{n_X}}{\partial X_{k-1}^2} & \cdots & \frac{\partial f_{n_X}}{\partial X_{k-1}^{n_X}}
\end{pmatrix}
\Bigg|_{X_{k-1}=\hat{X}_{k-1}^+}</script></li>
<li>状态量概率密度函数均值 $\mu$ 演变为矩阵，维数为 $n_X \times 1$</li>
<li>状态量概率密度函数方差 $\sigma^2$ 演变为协方差矩阵，用 $\Sigma$ 表示，维数为 $n_X \times n_X$</li>
<li>过程噪声方差 ${\sigma_Q}^2$ 演变为协方差矩阵，用 $\Sigma_Q$ 表示，维数为 $n_X \times n_X$</li>
<li>观测量 $Y$ 由随机变量演变为随机向量，随机向量中的每一个分量为一个观测量随机变量。维数为 $n_Y \times 1$</li>
<li>观测值 $y_k$ 由单一值演变为由单一值组成的值矩阵，维数为 $n_Y \times 1$</li>
<li>观测比例项 $H_j$ 演变为<strong>雅可比矩阵</strong>，维数为 $n_Y \times n_X$。此时，$H_j$ 是由每个观测函数对每个观测量分量求偏导后，将当前时刻状态量的先验估计代入得到：<script type="math/tex; mode=display">
H_j=
\begin{pmatrix}
    \frac{\partial h_1}{\partial X_k^1} & \frac{\partial h_1}{\partial X_k^2} & \cdots & \frac{\partial h_1}{\partial X_k^{n_X}} \\
    \frac{\partial h_2}{\partial X_k^1} & \frac{\partial h_2}{\partial X_k^2} & \cdots & \frac{\partial h_2}{\partial X_k^{n_X}} \\
    \vdots & \vdots & \ddots & \vdots \\
    \frac{\partial h_{n_Y}}{\partial X_k^1} & \frac{\partial h_{n_Y}}{\partial X_k^2} & \cdots & \frac{\partial h_{n_Y}}{\partial X_k^{n_X}}
\end{pmatrix}
\Bigg|_{X_k=\hat{X}_k^-}</script></li>
<li>观测噪声方差 ${\sigma_R}^2$ 演变为协方差矩阵，用 $\Sigma_R$ 表示，维数为 $n_Y \times n_Y$</li>
<li>卡尔曼增益系数 $K$ 演变为矩阵，维数为 $n_X \times n_Y$</li>
</ul>
<p>对应的五个公式演变为：</p>
<script type="math/tex; mode=display">
\mu_k^- = f(\mu_{k-1}^+) \tag{4.1}</script><script type="math/tex; mode=display">
\Sigma_k^- = F_j*\Sigma_{k-1}^+*F_j^T+{\Sigma_{Q_k}} \tag{4.2}</script><script type="math/tex; mode=display">
\mu_k^+ = \mu_k^-+K*[y_k-h(\mu_k^-)] \tag{4.3}</script><script type="math/tex; mode=display">
\Sigma_k^+ = (I-K*H_j)*\Sigma_k^- \tag{4.4}</script><script type="math/tex; mode=display">
K=\Sigma_k^-*H_j^T*(H_j*\Sigma_k^-*H_j^T+{\Sigma_{R_k}})^{-1} \tag{4.5}</script><p>公式 (4.3) 中 $\mu_k^+$ 即 k 时刻状态量 $X_k$ 的后验估计 $\hat{x}_k^+$，$y_k-h(\mu_k^-)$ 常被称为<strong>残差</strong>（Residual）或<strong>新息</strong>（Innovation）；公式 (4.4) 中的 $I$ 代表单位矩阵，维数为 $n_X \times n_X$。</p>
<p>当然，对于某个非线性系统，不一定状态转移和观测都是非线性的：</p>
<ul>
<li><p>线性的状态转移 + 非线性的观测<br>此时，滤波递推公式由卡尔曼滤波的预测步两公式和扩展卡尔曼滤波的更新步三公式组成。</p>
</li>
<li><p>非线性的状态转移 + 线性的观测<br>此时，滤波递推公式由扩展卡尔曼滤波的预测步两公式和卡尔曼滤波的更新步三公式组成。</p>
</li>
</ul>
<h1 id="5-应用实例——基于毫米波雷达与扩展卡尔曼滤波的目标跟踪" class="heading-control"><a href="#5-应用实例——基于毫米波雷达与扩展卡尔曼滤波的目标跟踪" class="headerlink" title="5 应用实例——基于毫米波雷达与扩展卡尔曼滤波的目标跟踪"></a>5 应用实例——基于毫米波雷达与扩展卡尔曼滤波的目标跟踪<a class="heading-anchor" href="#5-应用实例——基于毫米波雷达与扩展卡尔曼滤波的目标跟踪" aria-hidden="true"></a></h1><h2 id="5-1-系统分析" class="heading-control"><a href="#5-1-系统分析" class="headerlink" title="5.1 系统分析"></a>5.1 系统分析<a class="heading-anchor" href="#5-1-系统分析" aria-hidden="true"></a></h2><p><strong>毫米波雷达</strong>（Radar）与激光雷达的的检测原理不同。激光雷达利用光的直线传播原理获得目标在笛卡尔坐标系下的距离信息；毫米波雷达利用电磁波的多普勒效应，获得目标在<strong>极坐标系</strong>下的距离 $\rho$、方向角 $\varphi$ 和距离变化率（径向速度）$\dot{\rho}$。</p>
<p>假设我们使用毫米波雷达对某作匀速直线运动的目标在笛卡尔坐标系内的横坐标 $p_x$、纵坐标 $p_y$、横向速度 $v_x$、纵向速度 $v_y$ 进行跟踪，则状态量可设为：</p>
<script type="math/tex; mode=display">
X=
\begin{bmatrix}
    p_x \\
    p_y \\
    v_x \\
    v_y
\end{bmatrix}</script><p>观测量可设为：</p>
<script type="math/tex; mode=display">
Y=
\begin{bmatrix}
    \rho \\
    \varphi \\
    \dot{\rho}
\end{bmatrix}</script><p>故，毫米波雷达的测量数据特性可用下图进行表征。</p>
<p><img data-src="https://image.shipengx.com/%E6%AF%AB%E7%B1%B3%E6%B3%A2%E9%9B%B7%E8%BE%BE%E7%9A%84%E6%B5%8B%E9%87%8F%E6%95%B0%E6%8D%AE%E7%89%B9%E6%80%A7.jpg" alt="毫米波雷达的测量数据特性"></p>
<p>其中，距离变化率 $\dot{\rho}$ 是绝对速度在径向上的投影。利用几何关系与三角函数进行推导，可知：</p>
<script type="math/tex; mode=display">
\begin{cases}
    \rho=\sqrt{ {p_x}^2+{p_y}^2} \\
    \varphi=\text{arctan}(\frac{p_y}{p_x}) \\
    \dot{\rho}=\frac{p_xv_x+p_yv_y}{\sqrt{ {p_x}^2+{p_y}^2} }
\end{cases}</script><p>故，观测函数 $h(X)$ 为：</p>
<script type="math/tex; mode=display">
h(X)=
\begin{pmatrix}
    h_1 \\
    h_2 \\
    h_3
\end{pmatrix}=
\begin{pmatrix}
    \sqrt{ {p_x}^2+{p_y}^2} \\
    \text{arctan}(\frac{p_y}{p_x}) \\
    \frac{p_xv_x+p_yv_y}{\sqrt{ {p_x}^2+{p_y}^2} }
\end{pmatrix}</script><p>$h(X)$ 显然为非线性函数，而系统的状态转移（CV 模型）又明显是线性的，因此，此处的扩展卡尔曼滤波形式为：线性的状态转移 + 非线性的观测。</p>
<p>此时，滤波递推公式由卡尔曼滤波的预测步两公式和扩展卡尔曼滤波的更新步三公式组成：</p>
<p><strong>卡尔曼滤波的预测步两公式</strong></p>
<script type="math/tex; mode=display">
\mu_k^- = F*\mu_{k-1}^++B*u_k \tag{5.1}</script><script type="math/tex; mode=display">
\Sigma_k^- = F*\Sigma_{k-1}^+*F^T+{\Sigma_{Q_k}} \tag{5.2}</script><p><strong>扩展卡尔曼滤波的更新步三公式</strong></p>
<script type="math/tex; mode=display">
\mu_k^+ = \mu_k^-+K*[y_k-h(\mu_k^-)] \tag{5.3}</script><script type="math/tex; mode=display">
\Sigma_k^+ = (I-K*H_j)*\Sigma_k^- \tag{5.4}</script><script type="math/tex; mode=display">
K=\Sigma_k^-*H_j^T*(H_j*\Sigma_k^-*H_j^T+{\Sigma_{R_k}})^{-1} \tag{5.5}</script><p>由于目标作匀速直线运动，故公式 (5.1) 中的控制项 $B*u_k$ 可以忽略。</p>
<h2 id="5-2-雅可比矩阵求解" class="heading-control"><a href="#5-2-雅可比矩阵求解" class="headerlink" title="5.2 雅可比矩阵求解"></a>5.2 雅可比矩阵求解<a class="heading-anchor" href="#5-2-雅可比矩阵求解" aria-hidden="true"></a></h2><p>公式 (5.4) 和公式 (5.5) 中的雅可比矩阵 $H_j$ 根据定义可表示为：</p>
<script type="math/tex; mode=display">
H_j=
\begin{bmatrix}
    \frac{\partial h_1}{\partial p_x} & \frac{\partial h_1}{\partial p_y} & \frac{\partial h_1}{\partial v_x} & \frac{\partial h_1}{\partial v_y} \\
    \frac{\partial h_2}{\partial p_x} & \frac{\partial h_2}{\partial p_y} & \frac{\partial h_2}{\partial v_x} & \frac{\partial h_2}{\partial v_y} \\
    \frac{\partial h_3}{\partial p_x} & \frac{\partial h_3}{\partial p_y} & \frac{\partial h_3}{\partial v_x} & \frac{\partial h_3}{\partial v_y}
\end{bmatrix}</script><p>直接求解 $H_j$ 较为繁琐，可通过 matlab 的内置函数 <code>jacobian()</code> 进行求解。创建 matlab 脚本，命名为 <code>CalculateHj.m</code> 并输入如下内容后保存：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% define symbol variables</span></span><br><span class="line">syms px py vx vy</span><br><span class="line"></span><br><span class="line"><span class="comment">% state random vector</span></span><br><span class="line">X = [px py vx vy];</span><br><span class="line"></span><br><span class="line"><span class="comment">% measurement functions</span></span><br><span class="line">h1 = <span class="built_in">sqrt</span>(px^<span class="number">2</span> + py^<span class="number">2</span>);</span><br><span class="line">h2 = <span class="built_in">atan</span>(py / px);</span><br><span class="line">h3 = (px * vx + py * vy) / <span class="built_in">sqrt</span>(px^<span class="number">2</span> + py^<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">% measurement jacobian matrix</span></span><br><span class="line">Hj = jacobian([h1 h2 h3], X)</span><br></pre></td></tr></table></figure>
<p>运行 <code>CalculateHj.m</code> 脚本，得到 $H_j$ 如下运算结果：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">Hj =</span><br><span class="line"></span><br><span class="line">[                                            px/(px^<span class="number">2</span> + py^<span class="number">2</span>)^(<span class="number">1</span>/<span class="number">2</span>),                                            py/(px^<span class="number">2</span> + py^<span class="number">2</span>)^(<span class="number">1</span>/<span class="number">2</span>),                      <span class="number">0</span>,                      <span class="number">0</span>]</span><br><span class="line">[                                        -py/(px^<span class="number">2</span>*(py^<span class="number">2</span>/px^<span class="number">2</span> + <span class="number">1</span>)),                                            <span class="number">1</span>/(px*(py^<span class="number">2</span>/px^<span class="number">2</span> + <span class="number">1</span>)),                      <span class="number">0</span>,                      <span class="number">0</span>]</span><br><span class="line">[ vx/(px^<span class="number">2</span> + py^<span class="number">2</span>)^(<span class="number">1</span>/<span class="number">2</span>) - (px*(px*vx + py*vy))/(px^<span class="number">2</span> + py^<span class="number">2</span>)^(<span class="number">3</span>/<span class="number">2</span>), vy/(px^<span class="number">2</span> + py^<span class="number">2</span>)^(<span class="number">1</span>/<span class="number">2</span>) - (py*(px*vx + py*vy))/(px^<span class="number">2</span> + py^<span class="number">2</span>)^(<span class="number">3</span>/<span class="number">2</span>), px/(px^<span class="number">2</span> + py^<span class="number">2</span>)^(<span class="number">1</span>/<span class="number">2</span>), py/(px^<span class="number">2</span> + py^<span class="number">2</span>)^(<span class="number">1</span>/<span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>可以直接使用上述结果，也可以对其进行化简：</p>
<script type="math/tex; mode=display">
H_j=
\begin{bmatrix}
    \frac{p_x}{\sqrt{ {p_x}^2+{p_y}^2} } & \frac{p_y}{\sqrt{ {p_x}^2+{p_y}^2} } & 0 & 0 \\
    -\frac{p_y}{\sqrt{ {p_x}^2+{p_y}^2} } & \frac{p_x}{\sqrt{ {p_x}^2+{p_y}^2} } & 0 & 0 \\
    \frac{p_y(v_xp_y-v_yp_x)}{({p_x}^2+{p_y}^2)^{3/2}} & \frac{p_x(v_yp_x-v_xp_y)}{({p_x}^2+{p_y}^2)^{3/2}} & \frac{p_x}{\sqrt{ {p_x}^2+{p_y}^2} } & \frac{p_y}{\sqrt{ {p_x}^2+{p_y}^2} }
\end{bmatrix}</script><h2 id="5-3-代码" class="heading-control"><a href="#5-3-代码" class="headerlink" title="5.3 代码"></a>5.3 代码<a class="heading-anchor" href="#5-3-代码" aria-hidden="true"></a></h2><p>代码与此前的文章<a href="https://blog.shipengx.com/archives/d3b96bd5.html">《（十三）手把手教你写卡尔曼滤波器》</a>相似，区别在于状态量和观测量有所不同，且使用雅可比矩阵 $H_j$ 代替了观测矩阵 $H$（对于状态转移非线性的系统，还需使用雅可比矩阵 $F_j$ 代替状态转移矩阵 $F$）。</p>
<p><strong>ExtendedKalmanFilter.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> EXTENDED_KALMAN_FILTER_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXTENDED_KALMAN_FILTER_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"D:/eigen3/Eigen/Dense"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExtendedKalmanFilter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> is_inited;          <span class="comment">// flag of initialization</span></span><br><span class="line">    <span class="keyword">bool</span> just_begin_filt;    <span class="comment">// flag of just begining filt data</span></span><br><span class="line">    Eigen::VectorXd X;       <span class="comment">// state vector</span></span><br><span class="line">    Eigen::MatrixXd F;       <span class="comment">// state transition matrix</span></span><br><span class="line">    Eigen::MatrixXd P;       <span class="comment">// state covariance matrix</span></span><br><span class="line">    Eigen::MatrixXd Q;       <span class="comment">// process noise covariance matrix</span></span><br><span class="line">    Eigen::MatrixXd Hj;      <span class="comment">// measurement jacobian matrix</span></span><br><span class="line">    Eigen::MatrixXd R;       <span class="comment">// measurement noise covariance matrix</span></span><br><span class="line">    Eigen::MatrixXd K;       <span class="comment">// extended kalman gain coefficient</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_last; <span class="comment">// timestamp of last frame: us</span></span><br><span class="line">    <span class="keyword">float</span> dt;                <span class="comment">// delta time: s</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Eigen::VectorXd Z;      <span class="comment">// measurement vector</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_now; <span class="comment">// timestamp of current frame: us</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ExtendedKalmanFilter();</span><br><span class="line">    ~ExtendedKalmanFilter();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> &amp;<span class="title">IsInited</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is_inited;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        is_inited = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SetF</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;f)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        F = f;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SetF</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        F &lt;&lt; <span class="number">1.0f</span>, <span class="number">0.0f</span>, dt, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>, dt,</span><br><span class="line">            <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">0.0f</span>, <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SetP</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;p)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        P = p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SetQ</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Q = q;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SetHj</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;hj)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Hj = hj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SetR</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        R = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Predict step.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Predict</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Update step.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief To update measurement vector and timestamp.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param Z0 Z(0)</span></span><br><span class="line"><span class="comment"> * @param Z1 Z(1)</span></span><br><span class="line"><span class="comment"> * @param Z2 Z(2)</span></span><br><span class="line"><span class="comment"> * @param timestamp Current timestamp.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecvRawData</span><span class="params">(<span class="keyword">float</span> &amp;Z0, <span class="keyword">float</span> &amp;Z1, <span class="keyword">float</span> &amp;Z2, <span class="keyword">uint32_t</span> &amp;timestamp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Z0 = rho;</span></span><br><span class="line">    <span class="comment">// Z1 = phi;</span></span><br><span class="line">    <span class="comment">// Z2 = rho_dot;</span></span><br><span class="line">    <span class="comment">// timestamp = timestamp_new;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>ExtendedKalmanFilter.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ExtendedKalmanFilter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Construct a new Extended Kalman Filter:: Extended Kalman Filter object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExtendedKalmanFilter::ExtendedKalmanFilter()</span><br><span class="line">    : is_inited(<span class="literal">false</span>),</span><br><span class="line">      just_begin_filt(<span class="literal">false</span>),</span><br><span class="line">      X(<span class="number">4</span>),</span><br><span class="line">      F(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">      P(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">      Q(<span class="number">4</span>, <span class="number">4</span>),</span><br><span class="line">      Z(<span class="number">3</span>),</span><br><span class="line">      Hj(<span class="number">3</span>, <span class="number">4</span>),</span><br><span class="line">      R(<span class="number">3</span>, <span class="number">3</span>),</span><br><span class="line">      K(<span class="number">4</span>, <span class="number">3</span>),</span><br><span class="line">      timestamp_now(<span class="number">0</span>),</span><br><span class="line">      timestamp_last(<span class="number">0</span>),</span><br><span class="line">      dt(<span class="number">0.0f</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Destroy the Extended Kalman Filter:: Extended Kalman Filter object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExtendedKalmanFilter::~ExtendedKalmanFilter() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Initialize the extended kalman filter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExtendedKalmanFilter::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsInited())</span><br><span class="line">    &#123;</span><br><span class="line">        X &lt;&lt; Z(<span class="number">0</span>) * <span class="built_in">cos</span>(Z(<span class="number">1</span>)),</span><br><span class="line">            Z(<span class="number">0</span>) * <span class="built_in">sin</span>(Z(<span class="number">1</span>)),</span><br><span class="line">            Z(<span class="number">2</span>) * <span class="built_in">cos</span>(Z(<span class="number">1</span>)),</span><br><span class="line">            Z(<span class="number">2</span>) * <span class="built_in">sin</span>(Z(<span class="number">1</span>));</span><br><span class="line">        P &lt;&lt; <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">10.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">10.0</span>;</span><br><span class="line">        Q &lt;&lt; <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>;</span><br><span class="line">        R &lt;&lt; <span class="number">0.09</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.009</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.09</span>;</span><br><span class="line">        timestamp_last = timestamp_now;</span><br><span class="line">        is_inited = <span class="literal">true</span>;</span><br><span class="line">        just_begin_filt = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        just_begin_filt = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Predict step.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExtendedKalmanFilter::Predict</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (just_begin_filt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    dt = (timestamp_now - timestamp_last) / <span class="number">1E6</span>;</span><br><span class="line">    SetF();</span><br><span class="line">    timestamp_last = timestamp_now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predict state vector</span></span><br><span class="line">    X = F * X;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predict state covariance matrix</span></span><br><span class="line">    P = F * P * F.transpose() + Q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Update step.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ExtendedKalmanFilter::Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (just_begin_filt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> c1 = X(<span class="number">0</span>) ^ <span class="number">2</span> + X(<span class="number">1</span>) ^ <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">float</span> c2 = <span class="built_in">sqrt</span>(c1);</span><br><span class="line">    <span class="keyword">float</span> c3 = c1 * c2;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fabs</span>(c1 &gt; <span class="number">0.0001</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        Hj &lt;&lt; X(<span class="number">0</span>) / c2, X(<span class="number">1</span>) / c2, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            -X(<span class="number">1</span>) / c2, X(<span class="number">0</span>) / c2, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            X(<span class="number">1</span>) * (X(<span class="number">2</span>) * X(<span class="number">1</span>) - X(<span class="number">3</span>) * X(<span class="number">0</span>)) / c3, X(<span class="number">0</span>) * (X(<span class="number">3</span>) * X(<span class="number">0</span>) - X(<span class="number">2</span>) * X(<span class="number">1</span>)) / c3, X(<span class="number">0</span>) / c2, X(<span class="number">1</span>) / c2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Eigen::VectorXd(<span class="number">3</span>) hx;</span><br><span class="line">    hx &lt;&lt; c2, <span class="built_in">atan2</span>(X(<span class="number">1</span>), X(<span class="number">0</span>)), (X(<span class="number">0</span>) * X(<span class="number">2</span>) + X(<span class="number">1</span>) * X(<span class="number">3</span>)) / c2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Eigen::MatrixXd I = Eigen::MatrixXd::Identity(X.size(), X.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate extended kalman gain</span></span><br><span class="line">    K = P * Hj.transpose() * (Hj * P * Hj.transpose() + R).inverse();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update state vector</span></span><br><span class="line">    X = X + K * (Z - hx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update state covariance matrix</span></span><br><span class="line">    P = (I - K * Hj) * P;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ExtendedKalmanFilter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ExtendedKalmanFilter ekf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        RecvRawData(ekf.Z(<span class="number">0</span>), ekf.Z(<span class="number">1</span>), ekf.Z(<span class="number">2</span>), ekf.timestamp_now);</span><br><span class="line">        Init();</span><br><span class="line">        Predict();</span><br><span class="line">        Update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击<a href="/download/ExtendedKalmanFilter.zip">这里</a>下载完整工程。</p>
<h1 id="6-扩展卡尔曼滤波器的优缺点" class="heading-control"><a href="#6-扩展卡尔曼滤波器的优缺点" class="headerlink" title="6 扩展卡尔曼滤波器的优缺点"></a>6 扩展卡尔曼滤波器的优缺点<a class="heading-anchor" href="#6-扩展卡尔曼滤波器的优缺点" aria-hidden="true"></a></h1><p><strong>优点</strong></p>
<p>扩展卡尔曼滤波与标准卡尔曼滤波有着相似的计算形式，因此运算速度同样很快。</p>
<p><strong>缺点</strong></p>
<p>扩展卡尔曼滤波对非线性的状态转移函数和（或）观测函数使用一阶泰勒级数展开作了线性近似，忽略了二阶及以上的高阶项，因此精度一般（通常称为一阶精度），对于高度非线性问题效果较差。此外，雅可比矩阵的计算较为繁琐，容易出错。</p>
<p><strong>总结</strong></p>
<p>扩展卡尔曼滤波所应用的线性近似是否具有优势主要取决于两个因素：被近似的局部非线性化程度和不确定程度。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMUd6NHkxUjdrOA==" title="https://www.bilibili.com/video/BV1Gz4y1R7k8">b 站忠实的王大头《贝叶斯滤波与卡尔曼滤波》第十三讲：扩展卡尔曼滤波及其代码<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MzY0MTY4MA==" title="https://zhuanlan.zhihu.com/p/63641680">无人驾驶技术入门（十八）| 手把手教你写扩展卡尔曼滤波器<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQjMlQjAlRTUlOEIlOTIlRTUlODUlQUMlRTUlQkMlOEYvNzY4MTQ4Nz9mcj1hbGFkZGlu" title="https://baike.baidu.com/item/%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F/7681487?fr=aladdin">百度百科 - 泰勒公式<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>多传感器信息融合</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>数学</tag>
        <tag>滤波</tag>
        <tag>扩展卡尔曼滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>从贝叶斯滤波到无迹卡尔曼滤波</title>
    <url>/archives/cfd8b171.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%9B%AE%E5%BD%95-%E4%BB%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%88%B0%E6%97%A0%E8%BF%B9%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2.png" alt="目录-从贝叶斯滤波到无迹卡尔曼滤波"></p>
<h1 id="0-引言" class="heading-control"><a href="#0-引言" class="headerlink" title="0 引言"></a>0 引言<a class="heading-anchor" href="#0-引言" aria-hidden="true"></a></h1><p>在此前的文章<a href="https://blog.shipengx.com/archives/ea375326.html">《从贝叶斯滤波到扩展卡尔曼滤波》</a>中，我们讲述了扩展卡尔曼滤波通过一阶泰勒级数展开将非线性高斯系统的状态转移函数 $f(x)$ 和（或）观测函数 $h(x)$ 线性化，然后采用标准卡尔曼滤波框架实现状态量的滤波过程。扩展卡尔曼滤波存在两方面的明显缺点：</p>
<ul>
<li>一阶泰勒级数展开忽略了二阶及以上的高阶项，因此精度一般（通常称为一阶精度），对于高度非线性问题效果较差；</li>
<li>雅可比矩阵的计算较为繁琐，容易出错。</li>
</ul>
<p>为解决强非线性条件下的状态估计问题，1995 年，S. J. Julier 和 J. K. Uhlmann 等人提出了无迹卡尔曼滤波（Unscented Kalman Filter，UKF）算法，并由 E. A. Wan 和 R. Vander Merwe 等人进一步完善。</p>
<p>无迹卡尔曼滤波基于无迹变换（Unscented Transform，UT），无迹变换研究的是如何通过<strong>确定的</strong>采样点捕获经非线性变换的高斯随机变量的后验分布的问题。通过无迹变换得到相应的统计特性后，再结合标准卡尔曼滤波框架，便得到无迹卡尔曼滤波。标准无迹卡尔曼滤波的计算量与扩展卡尔曼滤波相当，但滤波精度要优于扩展卡尔曼滤波。</p>
<h1 id="1-无迹变换" class="heading-control"><a href="#1-无迹变换" class="headerlink" title="1 无迹变换"></a>1 无迹变换<a class="heading-anchor" href="#1-无迹变换" aria-hidden="true"></a></h1><h2 id="1-1-什么是无迹变换" class="heading-control"><a href="#1-1-什么是无迹变换" class="headerlink" title="1.1 什么是无迹变换"></a>1.1 什么是无迹变换<a class="heading-anchor" href="#1-1-什么是无迹变换" aria-hidden="true"></a></h2><p>无迹变换的核心理念：</p>
<blockquote>
<p>近似概率分布比近似任意的非线性函数或变换要相对容易。</p>
</blockquote>
<p>无迹变换要解决的问题是：已知某随机变量（多维情形下是随机向量）的概率分布（均值和方差），求其经过某非线性函数 $g(·)$ 变换后的概率分布。基于上述思想，无迹变换的主要步骤为：</p>
<p>(1) 根据<strong>某种规则</strong>对随机变量的概率分布进行<strong>确定性采样</strong>，并为采样点<strong>分配权重</strong>（均值权重和方差权重），采样点我们通常称之为 sigma 点；</p>
<p>(2) 将每一个 sigma 点进行<strong>非线性变换</strong>，得到新的 sigma 点；</p>
<p>(3) 对非线性变换后的新的 sigma 点进行<strong>加权求和</strong>，分别计算加权均值和加权方差，用加权均值和加权方差<strong>近似表征</strong>随机变量经非线性变换后的概率分布。</p>
<p>如下图所示（《概率机器人》第 3.4 节 P49）：</p>
<p><img data-src="https://image.shipengx.com/%E6%97%A0%E8%BF%B9%E5%8F%98%E6%8D%A2%E7%A4%BA%E4%BE%8B.png" alt="无迹变换示例"></p>
<p>无迹卡尔曼滤波中使用的确定性采样方法是 sigma 点采样方法的一种具体实现，中心差分卡尔曼滤波（Central Difference Kalman Filter，CDKF）使用了 sigma 点采样方法的另一种具体实现，这类滤波算法我们统称为 sigma 点卡尔曼滤波（Sigma-Point Kalman Filter，SPKF）算法。</p>
<p>按照历史发展脉络来讲，无迹变换主要包括两种形式：一般形式的无迹变换和比例无迹变换（Scaled Unscented Transform，SUT）。两种无迹变换的区别主要体现在采样规则和权重计算上，下面将分别进行阐述。</p>
<h2 id="1-2-一般形式的无迹变换" class="heading-control"><a href="#1-2-一般形式的无迹变换" class="headerlink" title="1.2 一般形式的无迹变换"></a>1.2 一般形式的无迹变换<a class="heading-anchor" href="#1-2-一般形式的无迹变换" aria-hidden="true"></a></h2><p>假设存在 $n$ 维随机向量 $X$，其服从均值 $\mu_x$ 和协方差 $\Sigma_x$ 的正态分布：</p>
<script type="math/tex; mode=display">
X \sim \mathcal{N}(\mu_x, \Sigma_x)</script><p>将 $X$ 经过非线性函数 $g(·)$ 进行变换，得到随机向量 $Y$，我们使用一般形式的无迹变换估计 $Y$ 的概率分布。一般形式的无迹变换最早由 Julier 等人提出，其主要操作流程如下所述：</p>
<p><strong>步骤一：参数选择与权重计算</strong></p>
<p>一般形式的无迹变换只涉及一个外部引入参数 $\kappa$，各 sigma 点（$2n+1$ 个）的权重分配如下：</p>
<script type="math/tex; mode=display">
W^{(i)} =
\begin{cases}
    \frac{\kappa}{n+\kappa} & i = 0 \\
    \frac{1}{2(n+\kappa)} & i = 1, ··· , 2n
\end{cases}</script><p>其中，$\kappa \in \mathbb{R}$，表征了 sigma 点相对均值的散布程度，$\kappa$ 越大，非均值处的 sigma 点距离均值越远（参考步骤二），且所占权重越小，而均值处 sigma 点所占权重则相对越大。对于高斯问题，$n+\kappa = 3$ 是一个比较好的选择，对于非高斯问题（是的，无迹变换也适用于非高斯问题），$\kappa$ 应该选择其它更恰当的值。</p>
<p><strong>步骤二：确定性采样</strong></p>
<p>通常情况下，siama 点位于均值处及对称分布于主轴的协方差处（每维两个）。按照如下方法采样得到 $2n + 1$ 个 sigma 点，构成 $n \times (2n + 1)$ 的点集矩阵 $\mathcal{X}$：</p>
<script type="math/tex; mode=display">
\mathcal{X}^{(i)} =
\begin{cases}
    \mu_x &  i = 0 \\
    \mu_x + (\sqrt{(n + \kappa)\Sigma_x})^{(i-1)} & i = 1, ··· , n \\
    \mu_x - (\sqrt{(n + \kappa)\Sigma_x})^{(i-n-1)} & i = n + 1, ··· , 2n
\end{cases}</script><p>其中，$(\sqrt{(n + \kappa)\Sigma_x})^{(i-1)}$ 表示矩阵 $(n + \kappa)\Sigma_x$ 作 <strong>Cholesky 分解</strong>后<strong>下三角矩阵</strong>的第 $i-1$ 列，$(\sqrt{(n + \kappa)\Sigma_x})^{(i-n-1)}$ 同理。</p>
<p><strong>步骤三：sigma 点非线性变换</strong></p>
<p>将每个 sigma 点（即 $\mathcal{X}$ 的每一列）进行 $g(·)$ 的非线性变换，得到变换后的新的点集矩阵 $\mathcal{Y}$：</p>
<script type="math/tex; mode=display">
\mathcal{Y}^{(i)} = g(\mathcal{X}^{(i)}) \quad i = 0, ··· , 2n</script><p><strong>步骤四：加权计算近似均值与近似协方差</strong></p>
<script type="math/tex; mode=display">
\mu_y = \sum_{i=0}^{i=2n}W^{(i)}\mathcal{Y}^{(i)}</script><script type="math/tex; mode=display">
\Sigma_y = \sum_{i=0}^{i=2n}W^{(i)}[\mathcal{Y}^{(i)}-\mu_y][\mathcal{Y}^{(i)}-\mu_y]^T</script><h2 id="1-3-比例无迹变换" class="heading-control"><a href="#1-3-比例无迹变换" class="headerlink" title="1.3 比例无迹变换"></a>1.3 比例无迹变换<a class="heading-anchor" href="#1-3-比例无迹变换" aria-hidden="true"></a></h2><p>从 1.2 节的内容中我们可以发现，当参数 $\kappa &lt; 0$ 时，权重 $W^{(0)} = \frac{\kappa}{n+\kappa} &lt; 0$，加权算得的近似协方差可能存在非半正定的情况。为应对该问题，Julier 等人后来提出无迹变换的改进形式——比例无迹变换，并由 Merwe 等人对其进行了简化。比例无迹变换与一般形式的无迹变换的主要区别体现在参数选取与 sigma 点权重计算上，其主要操作流程如下所述：</p>
<p><strong>步骤一：参数选择与权重计算</strong></p>
<p>比例无迹变换引入了四个外部参数：$\alpha$、$\beta$、$\kappa$ 和 $\lambda$，各 sigma 点（$2n+1$ 个）的权重分配如下：</p>
<script type="math/tex; mode=display">
W_m^{(i)} =
\begin{cases}
    \frac{\lambda}{n+\lambda} & i = 0 \\
    \frac{1}{2(n+\lambda)} & i = 1, ··· , 2n
\end{cases}</script><script type="math/tex; mode=display">
W_c^{(i)} =
\begin{cases}
    \frac{\lambda}{n+\lambda} + 1 -\alpha^2 + \beta  & i = 0 \\
    \frac{1}{2(n+\lambda)} & i = 1, ··· , 2n
\end{cases}</script><p>其中，$W_m^{(i)}$ 表示计算近似均值时 sigma 点的权重，$W_c^{(i)}$ 表示计算近似协方差时 sigma 点的权重。参数 $\lambda$ 满足：</p>
<script type="math/tex; mode=display">
\lambda = \alpha^2(n+\kappa)-n</script><p>参数 $\alpha$ 和 $\kappa$ 为确定 sigma 点分布在均值多远的范围内的比例参数。$\alpha$ 满足 $10^{-4} \le \alpha \le 1$，为避免强非线性系统中的非局部效应问题，$\alpha$ 通常取一个较小值；$\kappa$ 满足 $\kappa \ge 0$，通常取 $\kappa = 3-n$ 或 $\kappa = 0$。</p>
<p>下图呈现了当 $\alpha$ 取值分别为 $0.3$ 和 $1$ 时，sigma 点的分布情况，从图中可以发现，$\alpha$ 取值越大，非均值处的 sigma 点距离均值越远。</p>
<p><img data-src="https://image.shipengx.com/alpha%20%E5%8F%96%E4%B8%8D%E5%90%8C%E5%80%BC%E6%97%B6%20sigma%20%E7%82%B9%E7%9A%84%E6%95%A3%E5%B8%83%E7%A4%BA%E4%BE%8B.png" alt="alpha 取不同值时 sigma 点的散布示例"></p>
<p>参数 $\beta$ 用于引入随机变量概率分布的高阶矩信息，如果分布是精确的高斯分布，则 $\beta = 2$ 是最优选择。</p>
<p><strong>步骤二：确定性采样</strong></p>
<p>通常情况下，siama 点位于均值处及对称分布于主轴的协方差处（每维两个）。按照如下方法采样得到 $2n + 1$ 个 sigma 点，构成 $n \times (2n + 1)$ 的点集矩阵 $\mathcal{X}$：</p>
<script type="math/tex; mode=display">
\mathcal{X}^{(i)} =
\begin{cases}
    \mu_x &  i = 0 \\
    \mu_x + (\sqrt{(n + \lambda)\Sigma_x})^{(i-1)} & i = 1, ··· , n \\
    \mu_x - (\sqrt{(n + \lambda)\Sigma_x})^{(i-n-1)} & i = n + 1, ··· , 2n
\end{cases}</script><p>其中，$(\sqrt{(n + \lambda)\Sigma_x})^{(i-1)}$ 表示矩阵 $(n + \lambda)\Sigma_x$ 作 <strong>Cholesky 分解</strong>后<strong>下三角矩阵</strong>的第 $i-1$ 列，$(\sqrt{(n + \lambda)\Sigma_x})^{(i-n-1)}$ 同理。</p>
<p><strong>步骤三：sigma 点非线性变换</strong></p>
<p>将每个 sigma 点（即 $\mathcal{X}$ 的每一列）进行 $g(·)$ 的非线性变换，得到变换后的新的点集矩阵 $\mathcal{Y}$：</p>
<script type="math/tex; mode=display">
\mathcal{Y}^{(i)} = g(\mathcal{X}^{(i)}) \quad i = 0, ··· , 2n</script><p><strong>步骤四：加权计算近似均值与近似协方差</strong></p>
<script type="math/tex; mode=display">
\mu_y = \sum_{i=0}^{i=2n}W_m^{(i)}\mathcal{Y}^{(i)}</script><script type="math/tex; mode=display">
\Sigma_y = \sum_{i=0}^{i=2n}W_c^{(i)}[\mathcal{Y}^{(i)}-\mu_y][\mathcal{Y}^{(i)}-\mu_y]^T</script><h1 id="2-无迹卡尔曼滤波的假设" class="heading-control"><a href="#2-无迹卡尔曼滤波的假设" class="headerlink" title="2 无迹卡尔曼滤波的假设"></a>2 无迹卡尔曼滤波的假设<a class="heading-anchor" href="#2-无迹卡尔曼滤波的假设" aria-hidden="true"></a></h1><p>无迹卡尔曼滤波与扩展卡尔曼滤波具有相同的前提假设。</p>
<h2 id="2-1-与卡尔曼滤波相同的假设" class="heading-control"><a href="#2-1-与卡尔曼滤波相同的假设" class="headerlink" title="2.1 与卡尔曼滤波相同的假设"></a>2.1 与卡尔曼滤波相同的假设<a class="heading-anchor" href="#2-1-与卡尔曼滤波相同的假设" aria-hidden="true"></a></h2><p><strong>(1) 假设一：状态量服从正态分布</strong></p>
<script type="math/tex; mode=display">
X \sim \mathcal{N}(\mu_X, \ \sigma_X^2)</script><p><strong>(2) 假设二：观测量服从正态分布</strong></p>
<script type="math/tex; mode=display">
Y \sim \mathcal{N}(\mu_Y, \ \sigma_Y^2)</script><p><strong>(3) 假设三：过程噪声服从均值为 0 的正态分布</strong></p>
<script type="math/tex; mode=display">
Q \sim \mathcal{N}(0, \ \sigma_Q^2)</script><p><strong>(4) 假设四：观测噪声服从均值为 0 的正态分布</strong></p>
<script type="math/tex; mode=display">
R \sim \mathcal{N}(0, \ \sigma_R^2)</script><h2 id="2-2-与卡尔曼滤波不同的假设" class="heading-control"><a href="#2-2-与卡尔曼滤波不同的假设" class="headerlink" title="2.2 与卡尔曼滤波不同的假设"></a>2.2 与卡尔曼滤波不同的假设<a class="heading-anchor" href="#2-2-与卡尔曼滤波不同的假设" aria-hidden="true"></a></h2><p><strong>(5) 假设五：状态转移函数和（或）观测函数为非线性函数</strong></p>
<p>在卡尔曼滤波的前提假设中，认为状态方程中的状态转移函数 $f(x)$ 以及观测方程中的观测函数 $h(x)$ 均为线性函数。基于这种线性假设，存在常数或常矩阵 $F$，使得 $f(x)$ 可以写成卡尔曼滤波中的线性形式，存在常数或常矩阵 $H$，使得 $h(x)$ 也可以写成卡尔曼滤波中的线性形式。</p>
<p>不同于标准卡尔曼滤波，无迹卡尔曼滤波处理的是非线性高斯系统，假设系统的状态转移函数和（或）观测函数为非线性函数。</p>
<h1 id="3-无迹卡尔曼滤波算法框架" class="heading-control"><a href="#3-无迹卡尔曼滤波算法框架" class="headerlink" title="3 无迹卡尔曼滤波算法框架"></a>3 无迹卡尔曼滤波算法框架<a class="heading-anchor" href="#3-无迹卡尔曼滤波算法框架" aria-hidden="true"></a></h1><p>根据噪声对系统的状态转移过程和观测过程的影响是线性可加的还是非线性不可加的，无迹卡尔曼滤波算法有两种形式：可加性噪声条件下的无迹卡尔曼滤波算法和非可加性噪声条件下的无迹卡尔曼滤波算法。</p>
<h2 id="3-1-可加性噪声条件下的无迹卡尔曼滤波" class="heading-control"><a href="#3-1-可加性噪声条件下的无迹卡尔曼滤波" class="headerlink" title="3.1 可加性噪声条件下的无迹卡尔曼滤波"></a>3.1 可加性噪声条件下的无迹卡尔曼滤波<a class="heading-anchor" href="#3-1-可加性噪声条件下的无迹卡尔曼滤波" aria-hidden="true"></a></h2><p>在此前的文章<a href="https://blog.shipengx.com/archives/9fb25cec.html">《从概率到贝叶斯滤波》</a>中，我们曾经这样描述系统的状态方程和观测方程：</p>
<script type="math/tex; mode=display">
\begin{cases}
    X_k=f(X_{k-1})+Q_k & \Rightarrow \color{red}{状态方程} \\
    Y_k=h(X_k)+R_k & \Rightarrow \color{red}{观测方程}
\end{cases}</script><p>从上式中我们可以发现，过程噪声 $Q_k$ 和观测噪声 $R_k$ 是以线性可加项的形式存在于系统状态方程和观测方程中的，这种形式的表述基于这样的前提假设：过程噪声 $Q_k$ 对系统状态转移过程的影响是线性的，观测噪声 $R_k$ 对系统观测过程的影响也是线性的。很明显，此种情况下，$Q_k$ 与 $X_k$ 是同维的，$R_k$ 与 $Y_k$ 是同维的。</p>
<p>由此引申出可加性噪声条件下的无迹卡尔曼滤波算法，《概率机器人》第 3.4 节 P53 对算法流程有着很好的描述。假设有如下已知条件：</p>
<ul>
<li>高斯的状态量随机向量 $X$，$n_X$ 维，记 $n_X = n$</li>
<li>$k - 1$ 时刻 $X$ 的后验均值与后验协方差：$\mu_{X_{k-1}}^+$，$\Sigma_{X_{k-1}}^+$</li>
<li>$k$ 时刻的外部控制量输入 $u_k$</li>
<li>高斯的过程噪声随机向量：$Q\sim\mathcal{N}(0, \Sigma_Q)$</li>
<li>状态转移函数：$f(X_{k-1}, u_k)$</li>
<li>高斯的观测量随机向量 $Z$，$n_Z$ 维</li>
<li>$k$ 时刻 $Z$ 的观测取值 $z_k$</li>
<li>高斯的观测噪声随机向量：$R\sim\mathcal{N}(0, \Sigma_R)$</li>
<li>观测函数：$h(X_k)$</li>
</ul>
<p>基于以上已知条件与符号定义，我们总结一下可加性噪声条件下的无迹卡尔曼滤波算法步骤（使用比例无迹变换）。</p>
<p><strong>步骤一：初始化</strong></p>
<p>初始化步骤需要做三件事：</p>
<p><strong>选定滤波初值</strong></p>
<p>根据观测量初值 $z_0$及观测函数 $h(·)$ 计算对应的状态量初始均值 $\mu_{X_0}^+$，设定状态量协方差初值 $\Sigma_{X_0}^+$。</p>
<p><strong>选定无迹变换参数</strong></p>
<p>设定比例无迹变换参数 $\alpha$、$\beta$、$\kappa$ 和 $\lambda$ 的参数值，若使用一般形式的无迹变换，仅需设定 $\kappa$ 的取值。</p>
<p><strong>sigma 点权重计算</strong></p>
<p>根据无迹变换参数取值及权重计算公式计算各 sigma 点权重。</p>
<script type="math/tex; mode=display">
W_m^{(i)} =
\begin{cases}
    \frac{\lambda}{n+\lambda} & i = 0 \\
    \frac{1}{2(n+\lambda)} & i = 1, ··· , 2n
\end{cases}</script><script type="math/tex; mode=display">
W_c^{(i)} =
\begin{cases}
    \frac{\lambda}{n+\lambda} + 1 -\alpha^2 + \beta  & i = 0 \\
    \frac{1}{2(n+\lambda)} & i = 1, ··· , 2n
\end{cases}</script><p>对 $k = 1, 2, 3, ··· ,$ 执行：</p>
<p><strong>步骤二：对 $k-1$ 时刻状态量 $X_{k-1}$ 的后验概率分布进行 sigma 采样</strong></p>
<script type="math/tex; mode=display">
\mathcal{X}_{k-1}^{+(i)} =
\begin{cases}
    \mu_{X_{k-1}}^+ &  i = 0 \\
    \mu_{X_{k-1}}^+ + \gamma(\sqrt{\Sigma_{X_{k-1}}^+})^{(i-1)} & i = 1, ··· , n \\
    \mu_{X_{k-1}}^+ - \gamma(\sqrt{\Sigma_{X_{k-1}}^+})^{(i-n-1)} & i = n + 1, ··· , 2n
\end{cases}</script><p>其中，$\gamma = \sqrt{(n + \lambda)}$。</p>
<p><strong>步骤三：状态转移非线性变换</strong></p>
<script type="math/tex; mode=display">
\mathcal{X}_k^{-*(i)} = f(\mathcal{X}_{k-1}^{+(i)}, u_k), \quad i = 0, 1, 2, ··· , 2n</script><p><strong>步骤四：加权计算 $k$ 时刻状态量 $X_k$ 的先验概率分布</strong></p>
<script type="math/tex; mode=display">
\mu_{X_k}^- = \sum_{i=0}^{i=2n}W_m^{(i)}\mathcal{X}_k^{-*(i)}</script><script type="math/tex; mode=display">
\Sigma_{X_k}^- = \sum_{i=0}^{i=2n}W_c^{(i)}[\mathcal{X}_k^{-*(i)}-\mu_{X_k}^-][\mathcal{X}_k^{-*(i)}-\mu_{X_k}^-]^T+\Sigma_Q</script><p>由于过程噪声是线性可加的，所以此处 $\Sigma_Q$ 直接加在了加权协方差的末尾。</p>
<p><strong>步骤五：对 $k$ 时刻状态量 $X_k$ 的先验概率分布进行 sigma 采样</strong></p>
<script type="math/tex; mode=display">
\mathcal{X}_k^{-(i)} =
\begin{cases}
    \mu_{X_k}^- &  i = 0 \\
    \mu_{X_k}^- + \gamma(\sqrt{\Sigma_{X_k}^-})^{(i-1)} & i = 1, ··· , n \\
    \mu_{X_k}^- - \gamma(\sqrt{\Sigma_{X_k}^-})^{(i-n-1)} & i = n + 1, ··· , 2n
\end{cases}</script><p>某些时候，为降低运算量会省略此步，而在下一步骤中直接使用步骤三中的 sigma 点集 $\mathcal{X}_k^{-*(i)}$，这样做在一定程度上会降低精度。</p>
<p><strong>步骤六：观测非线性变换</strong></p>
<script type="math/tex; mode=display">
\mathcal{Z}_k^{(i)} = h(\mathcal{X}_k^{-(i)}), \quad i = 0, 1, 2, ··· , 2n</script><p><strong>步骤七：加权计算 $k$ 时刻观测量 $Z_k$ 的概率分布</strong></p>
<script type="math/tex; mode=display">
\mu_{Z_k} = \sum_{i=0}^{i=2n}W_m^{(i)}\mathcal{Z}_k^{(i)}</script><script type="math/tex; mode=display">
\Sigma_{Z_k} = \sum_{i=0}^{i=2n}W_c^{(i)}[\mathcal{Z}_k^{(i)}-\mu_{Z_k}][\mathcal{Z}_k^{(i)}-\mu_{Z_k}]^T+\Sigma_R</script><p>由于观测噪声是线性可加的，所以此处 $\Sigma_R$ 直接加在了加权协方差的末尾。</p>
<p><strong>步骤八：计算状态量与观测量的互协方差</strong></p>
<script type="math/tex; mode=display">
\Sigma_{X_kZ_k} = \sum_{i=0}^{i=2n}W_c^{(i)}[\mathcal{X}_k^{-(i)}-\mu_{X_k}^-][\mathcal{Z}_k^{(i)}-\mu_{Z_k}]^T</script><p><strong>步骤九：计算卡尔曼增益</strong></p>
<script type="math/tex; mode=display">
K_k = \Sigma_{X_kZ_k}\Sigma_{Z_k}^{-1}</script><p><strong>步骤十：计算 $k$ 时刻状态量 $X_k$ 的后验概率分布</strong></p>
<script type="math/tex; mode=display">
\mu_{X_k}^+ = \mu_{X_k}^- + K_k(z_k-\mu_{Z_k})</script><script type="math/tex; mode=display">
\Sigma_{X_k}^+ = \Sigma_{X_k}^- - K_k\Sigma_{Z_k}K_k^T</script><p>步骤三、四构成了可加性噪声条件下的无迹卡尔曼滤波算法的预测步，步骤六、七、八、九、十则构成了更新步。可加性噪声条件下的无迹卡尔曼滤波算法流程可总结为：</p>
<p><img data-src="https://image.shipengx.com/%E5%8F%AF%E5%8A%A0%E6%80%A7%E5%99%AA%E5%A3%B0%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9A%84%E6%97%A0%E8%BF%B9%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="可加性噪声条件下的无迹卡尔曼滤波算法流程图"></p>
<h2 id="3-2-非可加性噪声条件下的无迹卡尔曼滤波" class="heading-control"><a href="#3-2-非可加性噪声条件下的无迹卡尔曼滤波" class="headerlink" title="3.2 非可加性噪声条件下的无迹卡尔曼滤波"></a>3.2 非可加性噪声条件下的无迹卡尔曼滤波<a class="heading-anchor" href="#3-2-非可加性噪声条件下的无迹卡尔曼滤波" aria-hidden="true"></a></h2><p>很多时候，噪声对系统的状态转移和观测的影响并非线性的，此种情况下，$Q_k$ 与 $X_k$ 不一定是同维的，$R_k$ 与 $Y_k$ 也不一定是同维的。此时，系统的状态方程和观测方程演变为：</p>
<script type="math/tex; mode=display">
\begin{cases}
    X_k=f(X_{k-1}, Q_k) & \Rightarrow \color{red}{状态方程} \\
    Y_k=h(X_k, R_k) & \Rightarrow \color{red}{观测方程}
\end{cases}</script><p>过程噪声协方差和观测噪声协方差便不能像 3.1 节中描述的那样直接加在加权协方差的末尾。非可加性噪声条件下的无迹卡尔曼滤波算法的处理方法是<strong>对原始状态量作增广（augment）处理</strong>：</p>
<script type="math/tex; mode=display">
\mu_{X_k}^a =
\begin{bmatrix}
    \mu_{X_k} \\
    \mathbf{0} \\
    \mathbf{0}
\end{bmatrix}, \quad
\Sigma_{X_k}^a =
\begin{bmatrix}
    \Sigma_{X_k} & \mathbf{0} & \mathbf{0} \\
    \mathbf{0} & \Sigma_Q & \mathbf{0}\\
    \mathbf{0} & \mathbf{0} & \Sigma_R
\end{bmatrix}</script><p>注意，上式中的 $\mathbf{0}$ 表示元素均为 $0$ 的块向量或块矩阵，故作了粗体显示，应与常值 $0$ 作区分。增广处理的方式并非只此一种，也可分步增广：在预测步开始前先对上一时刻状态量的后验概率分布作过程噪声增广，再在更新步开始前对当前时刻状态量的先验概率分布作观测噪声增广，《机器人学中的状态估计》一书中使用的便是分步增广的方式，两种增广处理方式实则是等效的。</p>
<p>记过程噪声随机向量 $Q$ 的维度为 $q$，观测噪声随机向量 $R$ 的维度为 $r$，增广状态量 $X_k^a$ 的维度为 $L = n + q + r$。下面我们基于 3.1 节中的已知条件和符号定义，阐述非可加性噪声条件下的无迹卡尔曼滤波算法的流程步骤。</p>
<p><strong>步骤一：初始化</strong></p>
<p>初始化步骤需要做三件事：</p>
<p><strong>选定滤波初值</strong></p>
<p>根据观测量初值 $z_0$及观测函数 $h(·)$ 计算对应的状态量初始均值 $\mu_{X_0}^+$，设定状态量协方差初值 $\Sigma_{X_0}^+$。</p>
<p><strong>选定无迹变换参数</strong></p>
<p>设定比例无迹变换参数 $\alpha$、$\beta$、$\kappa$ 和 $\lambda$ 的参数值，若使用一般形式的无迹变换，仅需设定 $\kappa$ 的取值。</p>
<p><strong>sigma 点权重计算</strong></p>
<p>根据无迹变换参数取值及权重计算公式计算各 sigma 点权重。</p>
<script type="math/tex; mode=display">
W_m^{(i)} =
\begin{cases}
    \frac{\lambda}{L+\lambda} & i = 0 \\
    \frac{1}{2(L+\lambda)} & i = 1, ··· , 2L
\end{cases}</script><script type="math/tex; mode=display">
W_c^{(i)} =
\begin{cases}
    \frac{\lambda}{L+\lambda} + 1 -\alpha^2 + \beta  & i = 0 \\
    \frac{1}{2(L+\lambda)} & i = 1, ··· , 2L
\end{cases}</script><p>对 $k = 1, 2, 3, ··· ,$ 执行：</p>
<p><strong>步骤二：对 $k-1$ 时刻状态量 $X_{k-1}$ 的后验概率分布进行增广处理</strong></p>
<script type="math/tex; mode=display">
\mu_{X_{k-1}}^{+a} =
\begin{bmatrix}
    \mu_{X_{k-1}}^+ \\
    \mathbf{0} \\
    \mathbf{0}
\end{bmatrix}, \quad
\Sigma_{X_{k-1}}^{+a} =
\begin{bmatrix}
    \Sigma_{X_{k-1}}^+ & \mathbf{0} & \mathbf{0} \\
    \mathbf{0} & \Sigma_Q & \mathbf{0}\\
    \mathbf{0} & \mathbf{0} & \Sigma_R
\end{bmatrix}</script><p><strong>步骤三：对 $k-1$ 时刻状态量 $X_{k-1}$ 增广的后验概率分布进行 sigma 采样</strong></p>
<script type="math/tex; mode=display">
\mathcal{X}_{k-1}^{+a(i)} =
\begin{cases}
    \mu_{X_{k-1}}^{+a} &  i = 0 \\
    \mu_{X_{k-1}}^{+a} + \gamma(\sqrt{\Sigma_{X_{k-1}}^{+a}})^{(i-1)} & i = 1, ··· , L \\
    \mu_{X_{k-1}}^{+a} - \gamma(\sqrt{\Sigma_{X_{k-1}}^{+a}})^{(i-L-1)} & i = L + 1, ··· , 2L
\end{cases}</script><p>其中，$\gamma = \sqrt{(L + \lambda)}$，且</p>
<script type="math/tex; mode=display">
\mathcal{X}_{k-1}^{+a(i)} =
\begin{bmatrix}
    \mathcal{X}_{k-1}^{+aX(i)} \\
    \mathcal{X}_{k-1}^{+aQ(i)} \\
    \mathcal{X}_{k-1}^{+aR(i)}
\end{bmatrix},
\quad i = 0, 1, 2, ··· , 2L</script><ul>
<li>$\mathcal{X}_{k-1}^{+a(i)}$ 我们读作 $k-1$ 时刻状态量增广的后验概率分布的 sigma 点集的第 $i$ 列。$\mathcal{X}_{k-1}^{+a}$ 的维度为 $L \times 2L$</li>
<li>$\mathcal{X}_{k-1}^{+aX(i)}$ 我们读作 $k-1$ 时刻状态量增广的后验概率分布的 sigma 点集的状态量分量的第 $i$ 列</li>
<li>$\mathcal{X}_{k-1}^{+aQ(i)}$ 我们读作 $k-1$ 时刻状态量增广的后验概率分布的 sigma 点集的过程噪声分量的第 $i$ 列</li>
<li>$\mathcal{X}_{k-1}^{+aR(i)}$ 我们读作 $k-1$ 时刻状态量增广的后验概率分布的 sigma 点集的观测噪声分量的第 $i$ 列</li>
</ul>
<p><strong>步骤四：状态转移非线性变换</strong></p>
<script type="math/tex; mode=display">
\mathcal{X}_k^{-(i)} = f(\mathcal{X}_{k-1}^{+aX(i)}, u_k, \mathcal{X}_{k-1}^{+aQ(i)}), \quad i = 0, 1, 2, ··· , 2L</script><p>$\mathcal{X}_k^-$ 表示 $k$ 时刻状态量先验概率分布的 sigma 点集，维度为 $n \times 2L$ （这一点需要注意）。再计算 $\mathcal{X}_k^-$ 时，我们只将 $\mathcal{X}_{k-1}^{+aX}$、$u_k$ 和 $\mathcal{X}_{k-1}^{+aQ}$ 传入了状态转移函数 $f(·)$，因为观测噪声对系统的状态转移过程无影响。</p>
<p><strong>步骤五：加权计算 $k$ 时刻状态量 $X_k$ 的先验概率分布</strong></p>
<script type="math/tex; mode=display">
\mu_{X_k}^- = \sum_{i=0}^{i=2L}W_m^{(i)}\mathcal{X}_k^{-(i)}</script><script type="math/tex; mode=display">
\Sigma_{X_k}^- = \sum_{i=0}^{i=2L}W_c^{(i)}[\mathcal{X}_k^{-(i)}-\mu_{X_k}^-][\mathcal{X}_k^{-(i)}-\mu_{X_k}^-]^T</script><p>很明显，步骤四中得到的 $\mathcal{X}_k^-$ 中已包含过程噪声信息，故此处在计算 $\Sigma_{X_k}^-$ 时并未像 3.1 节中那样在等式末尾添加了 $\Sigma_Q$ 项。</p>
<p><strong>步骤六：观测非线性变换</strong></p>
<script type="math/tex; mode=display">
\mathcal{Z}_k^{(i)} = h(\mathcal{X}_k^{-(i)}, \mathcal{X}_{k-1}^{+aR(i)}), \quad i = 0, 1, 2, ··· , 2L</script><p>正如步骤五中所说的，$\mathcal{X}_k^-$ 中已包含过程噪声信息，所以此处我们直接将 $\mathcal{X}_k^-$ 和 $\mathcal{X}_{k-1}^{+aR(i)}$ 传入了观测函数 $h(·)$ 来计算 $k$ 时刻观测量 $Z_k$ 的概率分布对应的 sigma 点集 $\mathcal{Z}_k$，而未像 3.1 节中那样对 $X_k$ 的先验概率分布进行了单独的采样。</p>
<p><strong>步骤七：加权计算 $k$ 时刻观测量 $Z_k$ 的概率分布</strong></p>
<script type="math/tex; mode=display">
\mu_{Z_k} = \sum_{i=0}^{i=2L}W_m^{(i)}\mathcal{Z}_k^{(i)}</script><script type="math/tex; mode=display">
\Sigma_{Z_k} = \sum_{i=0}^{i=2L}W_c^{(i)}[\mathcal{Z}_k^{(i)}-\mu_{Z_k}][\mathcal{Z}_k^{(i)}-\mu_{Z_k}]^T</script><p>很明显，步骤六中得到的 $\mathcal{Z}_k$ 中已包含观测噪声信息，故此处在计算 $\Sigma_{Z_k}$ 时并未像 3.1 节中那样在等式末尾添加了 $\Sigma_R$ 项。</p>
<p><strong>步骤八：计算状态量与观测量的互协方差</strong></p>
<script type="math/tex; mode=display">
\Sigma_{X_kZ_k} = \sum_{i=0}^{i=2L}W_c^{(i)}[\mathcal{X}_k^{-(i)}-\mu_{X_k}^-][\mathcal{Z}_k^{(i)}-\mu_{Z_k}]^T</script><p><strong>步骤九：计算卡尔曼增益</strong></p>
<script type="math/tex; mode=display">
K_k = \Sigma_{X_kZ_k}\Sigma_{Z_k}^{-1}</script><p><strong>步骤十：计算 $k$ 时刻状态量 $X_k$ 的后验概率分布</strong></p>
<script type="math/tex; mode=display">
\mu_{X_k}^+ = \mu_{X_k}^- + K_k(z_k-\mu_{Z_k})</script><script type="math/tex; mode=display">
\Sigma_{X_k}^+ = \Sigma_{X_k}^- - K_k\Sigma_{Z_k}K_k^T</script><p>步骤四、五构成了非可加性噪声条件下的无迹卡尔曼滤波算法的预测步，步骤六、七、八、九、十则构成了更新步。非可加性噪声条件下的无迹卡尔曼滤波算法流程可总结为：</p>
<p><img data-src="https://image.shipengx.com/%E9%9D%9E%E5%8F%AF%E5%8A%A0%E6%80%A7%E5%99%AA%E5%A3%B0%E6%9D%A1%E4%BB%B6%E4%B8%8B%E7%9A%84%E6%97%A0%E8%BF%B9%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="非可加性噪声条件下的无迹卡尔曼滤波算法流程图"></p>
<p>在某些系统中，过程噪声和观测噪声可能其中一个对系统的影响是线性的（可加性噪声），而另一个对系统的影响是非线性的（非可加性噪声），这时需要结合 3.1 节与 3.2 节的方法来进行无迹卡尔曼滤波算法的设计，在下面的应用示例中你会看到具体是如何做的。</p>
<h1 id="4-应用实例——基于毫米波雷达与无迹卡尔曼滤波的目标跟踪" class="heading-control"><a href="#4-应用实例——基于毫米波雷达与无迹卡尔曼滤波的目标跟踪" class="headerlink" title="4 应用实例——基于毫米波雷达与无迹卡尔曼滤波的目标跟踪"></a>4 应用实例——基于毫米波雷达与无迹卡尔曼滤波的目标跟踪<a class="heading-anchor" href="#4-应用实例——基于毫米波雷达与无迹卡尔曼滤波的目标跟踪" aria-hidden="true"></a></h1><h2 id="4-1-系统分析" class="heading-control"><a href="#4-1-系统分析" class="headerlink" title="4.1 系统分析"></a>4.1 系统分析<a class="heading-anchor" href="#4-1-系统分析" aria-hidden="true"></a></h2><h3 id="4-1-1-状态转移过程分析" class="heading-control"><a href="#4-1-1-状态转移过程分析" class="headerlink" title="4.1.1 状态转移过程分析"></a>4.1.1 状态转移过程分析<a class="heading-anchor" href="#4-1-1-状态转移过程分析" aria-hidden="true"></a></h3><p>在<a href="https://blog.shipengx.com/archives/ea375326.html">《从贝叶斯滤波到扩展卡尔曼滤波》</a>中，我们讲解了毫米波雷达的检测原理，并基于扩展卡尔曼滤波算法实现了 CV 运动模型下的目标跟踪。此处，我们仍以毫米波雷达传感器为例，来讲解基于无迹卡尔曼滤波算法的目标跟踪过程。</p>
<p>不同的是，此次我们假设被跟踪目标近似地作匀速圆周运动，即运动模型为<strong>恒定转率和速度模型（Constant Turn Rate and Velocity，CTRV）</strong>，如下图所示（图片来自 Udacity）。</p>
<p><img data-src="https://image.shipengx.com/CTRV%20%E8%BF%90%E5%8A%A8%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="CTRV 运动模型示意图"></p>
<p>在 CTRV 模型中，我们通常对目标在笛卡尔坐标系内的横坐标 $p_x$、纵坐标 $p_y$、线速率 $v$、航向角 $\psi$ 和航向角速率 $\omega$ 进行跟踪，其中 $\omega = \dot{\psi}$。状态量可设为：</p>
<script type="math/tex; mode=display">
X=
\begin{bmatrix}
    p_x \\
    p_y \\
    v \\
    \psi \\
    \omega
\end{bmatrix}</script><p>我们先暂不考虑过程噪声的影响，则系统的状态方程（未计入噪声的）可表示为：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    X_k
    & = X_{k-1} + \int_{t_{k-1}}^{t_k}
        \begin{bmatrix}
            \dot{p_x}(t) \\
            \dot{p_y}(t) \\
            \dot{v}(t) \\
            \dot{\psi}(t) \\
            \dot{\omega}(t)
        \end{bmatrix}\mathrm{d}t \\
    & = X_{k-1} +
        \begin{bmatrix}
            \int_{t_{k-1}}^{t_k}v·\mathrm{cos}(\psi(t))\mathrm{d}t \\
            \int_{t_{k-1}}^{t_k}v·\mathrm{sin}(\psi(t))\mathrm{d}t \\
            0 \\
            \omega \Delta t \\
            0
        \end{bmatrix} \\
    & = X_{k-1} +
        \begin{bmatrix}
            v\int_{t_{k-1}}^{t_k}\mathrm{cos}(\psi_{k-1}+\omega·(t-t_{k-1}))\mathrm{d}t \\
            v\int_{t_{k-1}}^{t_k}\mathrm{sin}(\psi_{k-1}+\omega·(t-t_{k-1}))\mathrm{d}t \\
            0 \\
            \omega \Delta t \\
            0
        \end{bmatrix} \\
\end{aligned}</script><p>由换元法求复合函数定积分，容易得到：</p>
<script type="math/tex; mode=display">
\int_{t_{k-1}}^{t_k}\mathrm{cos}(\psi_{k-1}+\omega·(t-t_{k-1}))\mathrm{d}t = \frac{\mathrm{sin}(\psi_{k-1}+\omega\Delta t)-\mathrm{sin}(\psi_{k-1})}{\omega}, \quad \omega \neq 0</script><script type="math/tex; mode=display">
\int_{t_{k-1}}^{t_k}\mathrm{sin}(\psi_{k-1}+\omega·(t-t_{k-1}))\mathrm{d}t = \frac{-\mathrm{cos}(\psi_{k-1}+\omega\Delta t)+\mathrm{cos}(\psi_{k-1})}{\omega}, \quad \omega \neq 0</script><p>故，求得系统的状态方程（未计入噪声的）为：</p>
<script type="math/tex; mode=display">
X_k = X_{k-1} +
\begin{bmatrix}
    \frac{v}{\omega} \bigl(\mathrm{sin}(\psi_{k-1}+\omega\Delta t)-\mathrm{sin}(\psi_{k-1}) \bigr) \\
    \frac{v}{\omega} \bigl(-\mathrm{cos}(\psi_{k-1}+\omega\Delta t)+\mathrm{cos}(\psi_{k-1}) \bigr) \\
    0 \\
    \omega \Delta t \\
    0
\end{bmatrix}, \quad \omega \neq 0</script><p>CTRV 是 CV 的一般形式，当 $\omega = 0$ 时，CTRV 便退化为 CV：</p>
<script type="math/tex; mode=display">
X_k = X_{k-1} +
\begin{bmatrix}
    v·\mathrm{cos}(\psi_{k-1})\Delta t \\
    v·\mathrm{sin}(\psi_{k-1})\Delta t \\
    0 \\
    0 \\
    0
\end{bmatrix}</script><p>在上面的推导中，我们暂时忽略了过程噪声的干扰，但现实情况是，系统状态转移的过程中，目标的线速率 $v$ 和航向角速率 $\omega$ 并非一成不变，都存在微小扰动。假设 $v$ 受线加速度噪声 $q_a$ 的影响，$\omega$ 受角加速度噪声 $q_{\dot{\omega}}$ 的影响，$q_a$ 和 $q_{\dot{\omega}}$ 均为零均值的高斯白噪声：</p>
<script type="math/tex; mode=display">
q_a \sim \mathcal{N} (0, \sigma_a^2)</script><script type="math/tex; mode=display">
q_{\dot{\omega}} \sim \mathcal{N} (0, \sigma_{\dot{\omega}}^2)</script><p>则系统状态转移过程中总的过程噪声 $Q$ 可表示为：</p>
<script type="math/tex; mode=display">
Q =
\begin{bmatrix}
    q_a \\
    q_{\dot{\omega}}
\end{bmatrix}</script><p>$Q$ 的协方差 $\Sigma_Q$ 为：</p>
<script type="math/tex; mode=display">
\Sigma_Q =
\begin{bmatrix}
    \sigma_a^2 & 0 \\
    0 & \sigma_{\dot{\omega}}^2
\end{bmatrix}</script><p>$q_a$ 和 $q_{\dot{\omega}}$ 都对 $p_x$ 和 $p_y$ 存在影响，但此处我们忽略 $q_{\dot{\omega}}$ 对位移的影响，由运动学公式容易得到系统最终的状态方程：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    X_k
    & = f(X_{k-1}, Q_k) \\
    & = X_{k-1} +
        \begin{bmatrix}
            \frac{v_{k-1} }{\omega_{k-1} } \bigl(\mathrm{sin}(\psi_{k-1}+\omega_{k-1}\Delta t)-\mathrm{sin}(\psi_{k-1}) \bigr) \\
            \frac{v_{k-1} }{\omega_{k-1} } \bigl(-\mathrm{cos}(\psi_{k-1}+\omega_{k-1}\Delta t)+\mathrm{cos}(\psi_{k-1}) \bigr) \\
            0 \\
            \omega_{k-1} \Delta t \\
            0
        \end{bmatrix} +
        \begin{bmatrix}
            \frac{1}{2} (\Delta t)^2 · q_{a, k} · \mathrm{cos}(\psi_{k-1}) \\
            \frac{1}{2} (\Delta t)^2 · q_{a, k} · \mathrm{sin}(\psi_{k-1}) \\
            \Delta t · q_{a, k} \\
            \frac{1}{2} (\Delta t)^2 · q_{\dot{\omega}, k} \\
            \Delta t · q_{\dot{\omega}, k}
        \end{bmatrix}
\end{aligned}</script><h3 id="4-1-2-观测过程分析" class="heading-control"><a href="#4-1-2-观测过程分析" class="headerlink" title="4.1.2 观测过程分析"></a>4.1.2 观测过程分析<a class="heading-anchor" href="#4-1-2-观测过程分析" aria-hidden="true"></a></h3><p>观测量仍然是毫米波雷达极坐标系下目标的径向距离 $\rho$、方向角 $\varphi$ 和径向距离变化率（径向速度）$\dot{\rho}$：</p>
<script type="math/tex; mode=display">
Z=
\begin{bmatrix}
    \rho \\
    \varphi \\
    \dot{\rho}
\end{bmatrix}</script><p>各观测量分量 $\rho$、$\varphi$、$\dot{\varphi}$ 对应的观测噪声分别为 $r_{\rho}$、$r_{\varphi}$、$r_{\dot{\varphi}}$，同样都是零均值的高斯白噪声：</p>
<script type="math/tex; mode=display">
r_{\rho} \sim \mathcal{N} (0, \sigma_{\rho}^2)</script><script type="math/tex; mode=display">
r_{\varphi} \sim \mathcal{N} (0, \sigma_{\varphi}^2)</script><script type="math/tex; mode=display">
r_{\dot{\varphi}} \sim \mathcal{N} (0, \sigma_{\dot{\varphi}}^2)</script><p>则观测过程中总的观测噪声 $R$ 可表示为：</p>
<script type="math/tex; mode=display">
R =
\begin{bmatrix}
    r_{\rho} \\
    r_{\varphi} \\
    r_{\dot{\varphi}}
\end{bmatrix}</script><p>$R$ 的协方差 $\Sigma_R$ 为：</p>
<script type="math/tex; mode=display">
\Sigma_R =
\begin{bmatrix}
    \sigma_{\rho}^2 & 0 & 0 \\
    0 & \sigma_{\varphi}^2 & 0 \\
    0 & 0 & \sigma_{\dot{\varphi}}^2
\end{bmatrix}</script><p>观测方程与<a href="https://blog.shipengx.com/archives/ea375326.html">《从贝叶斯滤波到扩展卡尔曼滤波》</a>中相似，我们直接给出：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    Z_k
    & = h(X_k) + R_k \\
    & = \begin{bmatrix}
            \sqrt{p_{x,k}^2+p_{y,k}^2} \\
            \mathrm{arctan}(\frac{p_{y,k} }{p_{x,k} }) \\
            \frac{v_k·\mathrm{cos}(\psi_k)·p_{x,k}+v_k·\mathrm{sin}(\psi_k)·p_{y,k} }{\sqrt{p_{x,k}^2+p_{y,k}^2} }
        \end{bmatrix} +
        \begin{bmatrix}
            r_{\rho,k} \\
            r_{\varphi,k} \\
            r_{\dot{\varphi},k}
        \end{bmatrix}
\end{aligned}</script><h2 id="4-2-代码实现" class="heading-control"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现<a class="heading-anchor" href="#4-2-代码实现" aria-hidden="true"></a></h2><p>从上面的分析中我们可以知道，过程噪声对系统的状态转移过程具有非线性影响，而观测噪声对系统的观测过程具有线性影响，因此需要结合 3.1 节与 3.2 节的内容进行无迹卡尔曼滤波算法的设计：</p>
<ul>
<li>实现 3.2 节的步骤二时，只需将过程噪声 $Q$ 增广到 $X_{k-1}$ 的后验概率分布</li>
</ul>
<script type="math/tex; mode=display">
\mu_{X_{k-1}}^{+a} =
\begin{bmatrix}
    \mu_{X_{k-1}}^+ \\
    \mathbf{0}
\end{bmatrix}, \quad
\Sigma_{X_{k-1}}^{+a} =
\begin{bmatrix}
    \Sigma_{X_{k-1}}^+ & \mathbf{0} \\
    \mathbf{0} & \Sigma_Q
\end{bmatrix}</script><ul>
<li>实现 3.2 节的步骤六时，只需将预测步 sigma 点集 $\mathcal{X}_k^-$ 传入观测函数 $h(·)$</li>
</ul>
<script type="math/tex; mode=display">
\mathcal{Z}_k^{(i)} = h(\mathcal{X}_k^{-(i)}), \quad i = 0, 1, 2, ··· , 2L</script><ul>
<li>实现 3.2 节的步骤七时，直接将观测噪声 $R$ 协方差 $\Sigma_R$ 添加至 $Z_k$ 协方差 $\Sigma_{Z_k}$ 的末尾</li>
</ul>
<script type="math/tex; mode=display">
\Sigma_{Z_k} = \sum_{i=0}^{i=2L}W_c^{(i)}[\mathcal{Z}_k^{(i)}-\mu_{Z_k}][\mathcal{Z}_k^{(i)}-\mu_{Z_k}]^T+\Sigma_R</script><p>下面给出具体的 C++ 代码实现，为简便起见，实现过程中使用的无迹变换为一般形式的无迹变换，UT 参数只有 $\kappa$。代码框架比较清晰，完全遵循了 3.2 节的算法流程图，但没有去跑数据看仿真效果，工程实践中需要调节噪声协方差以及 UT 参数来获得较好的滤波结果。</p>
<p><strong>UnscentedKalmanFilter.h</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNSCENTED_KALMAN_FILTER_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNSCENTED_KALMAN_FILTER_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Eigen/Dense"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UnscentedKalmanFilter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> is_inited;          <span class="comment">// flag of initialization</span></span><br><span class="line">    <span class="keyword">bool</span> just_begin_filt;    <span class="comment">// flag of just begining filt data</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_last; <span class="comment">// timestamp of last frame: us</span></span><br><span class="line">    <span class="keyword">double</span> dt;               <span class="comment">// delta time: s</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> n_x;     <span class="comment">// dimension of state vector X</span></span><br><span class="line">    <span class="keyword">int</span> n_x_aug; <span class="comment">// dimension of augmented state vector X</span></span><br><span class="line">    <span class="keyword">int</span> n_z;     <span class="comment">// dimension of measurement vector Z</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> std_a;         <span class="comment">// standard deviation of longitudinal acceleration process noise: m/s^2</span></span><br><span class="line">    <span class="keyword">double</span> std_omega_dot; <span class="comment">// standard deviation of yaw acceleration process noise: rad/s^2</span></span><br><span class="line">    Eigen::MatrixXd Q;    <span class="comment">// process noise covariance matrix</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> std_rho;     <span class="comment">// standard deviation of range measurement noise: m</span></span><br><span class="line">    <span class="keyword">double</span> std_phi;     <span class="comment">// standard deviation of bearing measurement noise: rad</span></span><br><span class="line">    <span class="keyword">double</span> std_rho_dot; <span class="comment">// standard deviation of range rate measurement noise: m/s</span></span><br><span class="line">    Eigen::MatrixXd R;  <span class="comment">// measurement noise covariance matrix</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> kappa;            <span class="comment">// unscented transform parameter κ</span></span><br><span class="line">    Eigen::VectorXd weights; <span class="comment">// weights vector of sigma points</span></span><br><span class="line"></span><br><span class="line">    Eigen::VectorXd X;   <span class="comment">// state vector</span></span><br><span class="line">    Eigen::MatrixXd P_x; <span class="comment">// state covariance matrix</span></span><br><span class="line"></span><br><span class="line">    Eigen::VectorXd X_aug;         <span class="comment">// augmented state vector</span></span><br><span class="line">    Eigen::MatrixXd P_x_aug;       <span class="comment">// augmented state covariance matrix</span></span><br><span class="line">    Eigen::MatrixXd Sigmas_x_aug;  <span class="comment">// sigma points of augmented posterior probability distribution of X(k-1)</span></span><br><span class="line">    Eigen::MatrixXd Sigmas_x_pred; <span class="comment">// sigma points of prior probability distribution of X(k)</span></span><br><span class="line"></span><br><span class="line">    Eigen::MatrixXd Sigmas_z_pred; <span class="comment">// sigma points of probability distribution of Z(k)</span></span><br><span class="line"></span><br><span class="line">    Eigen::VectorXd Z;   <span class="comment">// measurement vector</span></span><br><span class="line">    Eigen::MatrixXd P_z; <span class="comment">// measurement covariance matrix</span></span><br><span class="line"></span><br><span class="line">    Eigen::MatrixXd P_xz; <span class="comment">// cross covariance matrix of X and Z</span></span><br><span class="line">    Eigen::MatrixXd K;    <span class="comment">// kalman gain coefficient: K = P_xz * P_z.inverse()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Eigen::VectorXd Z_meas; <span class="comment">// measurement value vector</span></span><br><span class="line">    <span class="keyword">uint64_t</span> timestamp_now; <span class="comment">// timestamp of current frame: us</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Construct a new Unscented Kalman Filter object</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UnscentedKalmanFilter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Destroy the Unscented Kalman Filter object</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~UnscentedKalmanFilter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Return the initialization status of the ukf instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @return bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> &amp;<span class="title">IsInited</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> is_inited; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Reset the ukf instance.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Reset</span><span class="params">()</span> </span>&#123; is_inited = <span class="literal">false</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Normalize the input angle to [-PI, PI].</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * @param angle</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NormalizeAngle</span><span class="params">(<span class="keyword">double</span> &amp;angle)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (angle &gt; M_PI)</span><br><span class="line">            angle -= <span class="number">2.0</span> * M_PI;</span><br><span class="line">        <span class="keyword">while</span> (angle &lt; -M_PI)</span><br><span class="line">            angle += <span class="number">2.0</span> * M_PI;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief To update measurement value vector and timestamp.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">RecvRawData</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Z_meas[0] = rho_new;</span></span><br><span class="line">        <span class="comment">// Z_meas[1] = phi_new;</span></span><br><span class="line">        <span class="comment">// Z_meas[2] = rho_dot_new;</span></span><br><span class="line">        <span class="comment">// timestamp_now = timestamp_new;</span></span><br><span class="line"></span><br><span class="line">        dt = (timestamp_now - timestamp_last) / <span class="number">1E6</span>;</span><br><span class="line">        timestamp_last = timestamp_now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Initialization step.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Augment posterior probability distribution of X(k-1).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AugmentLastPosteriorPDF</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Sample the augmented posterior probability distribution of X(k-1).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SigmaSample</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Prediction step.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Predict</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief Update step.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>UnscentedKalmanFilter.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"math.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"UnscentedKalmanFilter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Construct a new Unscented Kalman Filter object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UnscentedKalmanFilter::UnscentedKalmanFilter()</span><br><span class="line">    : is_inited(<span class="literal">false</span>),</span><br><span class="line">      just_begin_filt(<span class="literal">false</span>),</span><br><span class="line">      timestamp_last(<span class="number">0</span>),</span><br><span class="line">      dt(<span class="number">0.0</span>),</span><br><span class="line">      n_x(<span class="number">5</span>),</span><br><span class="line">      n_x_aug(<span class="number">7</span>),</span><br><span class="line">      n_z(<span class="number">3</span>),</span><br><span class="line">      std_a(<span class="number">1.5</span>),         <span class="comment">// need to be tuned according to the performance of the ukf</span></span><br><span class="line">      std_omega_dot(<span class="number">0.8</span>), <span class="comment">// need to be tuned according to the performance of the ukf</span></span><br><span class="line">      Q(<span class="number">2</span>, <span class="number">2</span>),</span><br><span class="line">      std_rho(<span class="number">0.3</span>),</span><br><span class="line">      std_phi(<span class="number">0.03</span>),</span><br><span class="line">      std_rho_dot(<span class="number">0.3</span>),</span><br><span class="line">      R(n_z, n_z),</span><br><span class="line">      kappa(<span class="number">0.0</span>),</span><br><span class="line">      weights(<span class="number">2</span> * n_x_aug + <span class="number">1</span>),</span><br><span class="line">      X(n_x),</span><br><span class="line">      P_x(n_x, n_x),</span><br><span class="line">      X_aug(n_x_aug),</span><br><span class="line">      P_x_aug(n_x_aug, n_x_aug),</span><br><span class="line">      Sigmas_x_aug(n_x_aug, <span class="number">2</span> * n_x_aug + <span class="number">1</span>),</span><br><span class="line">      Sigmas_x_pred(n_x, <span class="number">2</span> * n_x_aug + <span class="number">1</span>),</span><br><span class="line">      Sigmas_z_pred(n_z, <span class="number">2</span> * n_x_aug + <span class="number">1</span>),</span><br><span class="line">      Z(n_z),</span><br><span class="line">      P_z(n_z, n_z),</span><br><span class="line">      P_xz(n_x, n_z),</span><br><span class="line">      K(n_x, n_z),</span><br><span class="line">      Z_meas(n_z),</span><br><span class="line">      timestamp_now(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Destroy the Unscented Kalman Filter object</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">UnscentedKalmanFilter::~UnscentedKalmanFilter() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Initialize the unscented kalman filter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnscentedKalmanFilter::Init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsInited())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> rho = Z_meas(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">double</span> phi = Z_meas(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">double</span> rho_dot = Z_meas(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> px = rho * <span class="built_in">cos</span>(phi);</span><br><span class="line">        <span class="keyword">double</span> py = rho * <span class="built_in">sin</span>(phi);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the initial value of X(2) confused me: 0, a small value or the initial</span></span><br><span class="line">        <span class="comment">// measurement value of rho_dot?</span></span><br><span class="line">        X &lt;&lt; px, py, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">        P_x &lt;&lt; <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>;</span><br><span class="line"></span><br><span class="line">        Q &lt;&lt; std_a * std_a, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, std_omega_dot * std_omega_dot;</span><br><span class="line"></span><br><span class="line">        R &lt;&lt; std_rho * std_rho, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, std_phi * std_phi, <span class="number">0.0</span>,</span><br><span class="line">            <span class="number">0.0</span>, <span class="number">0.0</span>, std_rho_dot * std_rho_dot;</span><br><span class="line"></span><br><span class="line">        kappa = <span class="number">3</span> - n_x_aug;</span><br><span class="line"></span><br><span class="line">        weights.fill(<span class="number">1</span> / (<span class="number">2</span> * (n_x_aug + kappa)));</span><br><span class="line">        weights(<span class="number">0</span>) = kappa / (n_x_aug + kappa);</span><br><span class="line"></span><br><span class="line">        is_inited = <span class="literal">true</span>;</span><br><span class="line">        just_begin_filt = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        just_begin_filt = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Augment posterior probability distribution of X(k-1).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnscentedKalmanFilter::AugmentLastPosteriorPDF</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (just_begin_filt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// augment mean</span></span><br><span class="line">    X_aug.head(<span class="number">5</span>) = X;</span><br><span class="line">    X_aug(<span class="number">5</span>) = <span class="number">0.0</span>;</span><br><span class="line">    X_aug(<span class="number">6</span>) = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// augment covariance</span></span><br><span class="line">    P_x_aug.fill(<span class="number">0.0</span>);</span><br><span class="line">    P_x_aug.topLeftCorner(<span class="number">5</span>, <span class="number">5</span>) = P_x;</span><br><span class="line">    P_x_aug(<span class="number">5</span>, <span class="number">5</span>) = Q(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    P_x_aug(<span class="number">6</span>, <span class="number">6</span>) = Q(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Sample the augmented posterior probability distribution of X(k-1).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnscentedKalmanFilter::SigmaSample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (just_begin_filt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> gamma = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(n_x_aug + kappa);</span><br><span class="line">    Eigen::MatrixXd chol_root = P_x_aug.llt().matrixL();</span><br><span class="line"></span><br><span class="line">    Sigmas_x_aug.col(<span class="number">0</span>) = X_aug;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">2</span> * n_x_aug + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n_x_aug + <span class="number">1</span>)</span><br><span class="line">            Sigmas_x_aug.col(i) = X_aug + gamma * chol_root.col(i - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            Sigmas_x_aug.col(i) = X_aug - gamma * chol_root.col(i - n_x_aug - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Prediction step.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnscentedKalmanFilter::Predict</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (just_begin_filt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predict sigma points of prior probability distribution of X(k)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n_x_aug + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> px = Sigmas_x_aug(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">double</span> py = Sigmas_x_aug(<span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">double</span> v = Sigmas_x_aug(<span class="number">2</span>, i);</span><br><span class="line">        <span class="keyword">double</span> psi = Sigmas_x_aug(<span class="number">3</span>, i);</span><br><span class="line">        <span class="keyword">double</span> omega = Sigmas_x_aug(<span class="number">4</span>, i);</span><br><span class="line">        <span class="keyword">double</span> a = Sigmas_x_aug(<span class="number">5</span>, i);</span><br><span class="line">        <span class="keyword">double</span> omega_dot = Sigmas_x_aug(<span class="number">6</span>, i);</span><br><span class="line"></span><br><span class="line">        <span class="function">Eigen::VectorXd <span class="title">state_trans_item_motion</span><span class="params">(n_x)</span></span>;</span><br><span class="line">        <span class="function">Eigen::VectorXd <span class="title">state_trans_item_noise</span><span class="params">(n_x)</span></span>;</span><br><span class="line"></span><br><span class="line">        state_trans_item_noise &lt;&lt; 0.5 * a * cos(psi) * dt * dt,</span><br><span class="line">            0.5 * a * sin(psi) * dt * dt,</span><br><span class="line">            a * dt,</span><br><span class="line">            <span class="number">0.5</span> * a * omega_dot * dt * dt,</span><br><span class="line">            omega_dot * dt;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">fabs</span>(omega_dot) &gt; <span class="number">0.001</span>) <span class="comment">// CTRV model</span></span><br><span class="line">        &#123;</span><br><span class="line">            state_trans_item_motion &lt;&lt; v / omega * (<span class="built_in">sin</span>(psi + omega * dt) - <span class="built_in">sin</span>(psi)),</span><br><span class="line">                v / omega * (-<span class="built_in">cos</span>(psi + omega * dt) + <span class="built_in">cos</span>(psi)),</span><br><span class="line">                <span class="number">0.0</span>,</span><br><span class="line">                omega * dt,</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// approximate CV model</span></span><br><span class="line">        &#123;</span><br><span class="line">            state_trans_item_motion &lt;&lt; v * <span class="built_in">cos</span>(psi) * dt,</span><br><span class="line">                v * <span class="built_in">sin</span>(psi) * dt,</span><br><span class="line">                <span class="number">0.0</span>,</span><br><span class="line">                omega * dt,</span><br><span class="line">                <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Sigmas_x_pred.col(i) = Sigmas_x_aug.head(<span class="number">5</span>) + state_trans_item_motion + state_trans_item_noise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate approximate mean of prior PDF of X(k)</span></span><br><span class="line">    X.fill(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n_x_aug + <span class="number">1</span>; ++i)</span><br><span class="line">        X += weights(i) * Sigmas_x_pred.col(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate approximate covariance of prior PDF of X(k)</span></span><br><span class="line">    P_x.fill(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n_x_aug + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::VectorXd x_diff = Sigmas_x_pred.col(i) - X;</span><br><span class="line">        NormalizeAngle(x_diff(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        P_x += weights(i) * x_diff * x_diff.transpose();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Update step.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnscentedKalmanFilter::Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (just_begin_filt)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predict sigma points of probability distribution of Z(k)</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n_x_aug + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> px = Sigmas_x_pred(<span class="number">0</span>, i);</span><br><span class="line">        <span class="keyword">double</span> py = Sigmas_x_pred(<span class="number">1</span>, i);</span><br><span class="line">        <span class="keyword">double</span> v = Sigmas_x_pred(<span class="number">2</span>, i);</span><br><span class="line">        <span class="keyword">double</span> psi = Sigmas_x_pred(<span class="number">3</span>, i);</span><br><span class="line"></span><br><span class="line">        Sigmas_z_pred(<span class="number">0</span>, i) = <span class="built_in">std</span>::<span class="built_in">sqrt</span>(px * px + py * py);</span><br><span class="line">        Sigmas_z_pred(<span class="number">1</span>, i) = <span class="built_in">atan2</span>(py, px);</span><br><span class="line">        Sigmas_z_pred(<span class="number">2</span>, i) = (v * <span class="built_in">cos</span>(psi) * px + v * <span class="built_in">sin</span>(psi) * py) / Sigmas_z_pred(<span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate approximate mean of PDF of Z(k)</span></span><br><span class="line">    Z.fill(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n_x_aug + <span class="number">1</span>; ++i)</span><br><span class="line">        Z += weights(i) * Sigmas_z_pred.col(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate approximate covariance of PDF of Z(k)</span></span><br><span class="line">    P_z.fill(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n_x_aug + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::VectorXd z_diff = Sigmas_z_pred.col(i) - Z;</span><br><span class="line">        NormalizeAngle(z_diff(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        P_z += weights(i) * z_diff * z_diff.transpose();</span><br><span class="line">    &#125;</span><br><span class="line">    P_z += R;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate cross covariance of X(k) and Z(k)</span></span><br><span class="line">    P_xz.fill(<span class="number">0.0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n_x_aug + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        Eigen::VectorXd x_diff = Sigmas_x_pred.col(i) - X;</span><br><span class="line">        NormalizeAngle(x_diff(<span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">        Eigen::VectorXd z_diff = Sigmas_z_pred.col(i) - Z;</span><br><span class="line">        NormalizeAngle(z_diff(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        P_xz += weights(i) * x_diff * z_diff.transpose();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate kalman gain</span></span><br><span class="line">    K = P_xz * P_z.inverse();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate mean of posterior PDF of X(k)</span></span><br><span class="line">    Eigen::VectorXd z_diff = Z_meas - Z;</span><br><span class="line">    NormalizeAngle(z_diff(<span class="number">1</span>));</span><br><span class="line">    X += K * z_diff;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate covariance of posterior PDF of X(k)</span></span><br><span class="line">    P_x -= K * P_z * K.inverse();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"UnscentedKalmanFilter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UnscentedKalmanFilter ukf;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ukf.RecvRawData();</span><br><span class="line"></span><br><span class="line">        ukf.Init();</span><br><span class="line">        ukf.AugmentLastPosteriorPDF();</span><br><span class="line">        ukf.SigmaSample();</span><br><span class="line">        ukf.Predict();</span><br><span class="line">        ukf.Update();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击<a href="/download/UnscentedKalmanFilter.zip">这里</a>下载完整工程。</p>
<h1 id="5-总结" class="heading-control"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结<a class="heading-anchor" href="#5-总结" aria-hidden="true"></a></h1><p>EKF 与 UKF 代表了处理非线性高斯问题的两种思路（UKF 同样适用于非线性非高斯系统）。EKF 利用一阶泰勒级数展开对非线性的状态转移函数 $f(·)$、观测函数 $h(·)$ 进行线性近似；而 UKF 利用确定性采样的方法对随机变量的概率密度函数进行近似。标准 UKF 的计算量与 EKF 相当，但滤波精度要优于 EKF。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9pZWVleHBsb3JlLmllZWUub3JnL2llbDMvMzkyMC8xMTM1Mi8wMDUyOTc4My5wZGY=" title="https://ieeexplore.ieee.org/iel3/3920/11352/00529783.pdf">A New Approach for Filtering Nonlinear Systems<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZ2F0c2J5LnVjbC5hYy51ay9+Ynlyb24vbmxkcy9tZXJ3ZTIwMDNhLnBkZg==" title="https://www.gatsby.ucl.ac.uk/~byron/nlds/merwe2003a.pdf">Sigma-Point Kalman Filters for Probabilistic Inference in Dynamic State-Space Models<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudW5jLmVkdS9+d2VsY2gva2FsbWFuL21lZGlhL3BkZi9KdWxpZXIxOTk3X1NQSUVfS0YucGRm" title="https://www.cs.unc.edu/~welch/kalman/media/pdf/Julier1997_SPIE_KF.pdf">A New Extension of the Kalman Filter to Nonlinear Systems<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY3MudW5jLmVkdS9+d2VsY2gva2FsbWFuL21lZGlhL3BkZi9BQ0MwMi1JRUVFMTM1Ny5QREY=" title="https://www.cs.unc.edu/~welch/kalman/media/pdf/ACC02-IEEE1357.PDF">The Scaled Unscented Transformation<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JsYWJiZS9LYWxtYW4tYW5kLUJheWVzaWFuLUZpbHRlcnMtaW4tUHl0aG9u" title="https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python">Kalman-and-Bayesian-Filters-in-Python<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9maWx0ZXJweS5yZWFkdGhlZG9jcy5pby9lbi9sYXRlc3Qv" title="https://filterpy.readthedocs.io/en/latest/">FilterPy Documentation<i class="fa fa-external-link"></i></span></li>
<li>《概率机器人》</li>
<li>《机器人学中的状态估计》</li>
<li>《最优状态估计——卡尔曼，$H_∞$ 及非线性滤波》</li>
<li>《卡尔曼滤波与组合导航原理》（第 3 版）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tYXguYm9vazExOC5jb20vaHRtbC8yMDE5LzEyMjIvNjEzNTE1NTIxMjAwMjEzMy5zaHRt" title="https://max.book118.com/html/2019/1222/6135155212002133.shtm">EKF 与 UKF<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZW5rdS5iYWlkdS5jb20vdmlldy9kMWVmMmM2YmVmZmRjOGQzNzZlZWFlYWFkMWYzNDY5M2RiZWYxMDc5Lmh0bWwj" title="https://wenku.baidu.com/view/d1ef2c6beffdc8d376eeaeaad1f34693dbef1079.html#">扩展 Kalman 滤波(EKF)和无迹卡尔曼滤波(ukf)分析<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9hZGFtc2hhbi5ibG9nLmNzZG4ubmV0L2FydGljbGUvZGV0YWlscy83ODM1OTA0OA==" title="https://adamshan.blog.csdn.net/article/details/78359048">无人驾驶汽车系统入门（三）——无损卡尔曼滤波，目标追踪，C++<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L09fTU1NTV9PL2FydGljbGUvZGV0YWlscy8xMDYxNDA4NTM=" title="https://blog.csdn.net/O_MMMM_O/article/details/106140853">无迹（损）卡尔曼滤波（UKF）理论讲解与实例<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDIxNTQ0My9hcnRpY2xlL2RldGFpbHMvODc2OTM2ODA=" title="https://blog.csdn.net/weixin_40215443/article/details/87693680">P6_无损卡尔曼滤波器_udacity 无人驾驶<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dpbGxpYW1oeWluL2FydGljbGUvZGV0YWlscy8xMDYyMDg5MDg=" title="https://blog.csdn.net/williamhyin/article/details/106208908">自动驾驶感知融合-无迹卡尔曼滤波(Lidar&amp;Radar)<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2RqZmprajUyL2FydGljbGUvZGV0YWlscy8xMDQ4OTczMTQ=" title="https://blog.csdn.net/djfjkj52/article/details/104897314">CV,CA,CTRV 等运动模型，EKF，UKF 在运动模型下的分析与实践<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>多传感器信息融合</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>数学</tag>
        <tag>滤波</tag>
        <tag>无迹卡尔曼滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 clang-format 进行 C++ 代码风格管理</title>
    <url>/archives/ed6ff3ad.html</url>
    <content><![CDATA[<p><img data-src="https://image.shipengx.com/%E4%BD%BF%E7%94%A8%20clang-format%20%E8%BF%9B%E8%A1%8C%20C%2B%2B%20%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC%E7%AE%A1%E7%90%86.png" alt="使用 clang-format 进行 C++ 代码风格管理"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>良好统一的代码风格在多人协同开发中至关重要，不统一的代码风格会在代码版本管理中引入由于格式修改而带来的代码变更，使版本维护变得困难且容易出错。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbGFuZy5sbHZtLm9yZy9kb2NzL0NsYW5nRm9ybWF0Lmh0bWw=" title="https://clang.llvm.org/docs/ClangFormat.html">clang-format<i class="fa fa-external-link"></i></span> 是 LLVM 开发的用于格式化 C/C++/Java/JavaScript/Objective-C/Objective-C++/Protobuf 等多种语言代码的工具，借助 clang-format 可以实现代码仓库的风格统一，提升开发效率，本文将阐述使用该工具进行代码风格管理的基本步骤。</p>
<h1 id="1-操作步骤" class="heading-control"><a href="#1-操作步骤" class="headerlink" title="1 操作步骤"></a>1 操作步骤<a class="heading-anchor" href="#1-操作步骤" aria-hidden="true"></a></h1><h2 id="1-1-安装-clang-format" class="heading-control"><a href="#1-1-安装-clang-format" class="headerlink" title="1.1 安装 clang-format"></a>1.1 安装 clang-format<a class="heading-anchor" href="#1-1-安装-clang-format" aria-hidden="true"></a></h2><p>clang-format 有诸多版本可供使用，目前最新版本为 clang-format 15。不同版本所支持的格式化选项不尽相同，但向后兼容。实际开发中，我们应统一所使用的 clang-format 版本，这里我们选择 clang-format 10。对于 Windows 平台，可以<span class="exturl" data-url="aHR0cHM6Ly9yZWxlYXNlcy5sbHZtLm9yZy8=" title="https://releases.llvm.org/">下载<i class="fa fa-external-link"></i></span>预编译的二进制文件进行安装；对于 Linux 平台（以 Ubuntu 为例），可以通过命令行直接安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install clang-format-10</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>⚠</strong> 这里应注意，不能通过 <code>sudo apt install clang-format</code> 命令进行安装，因为对于不同的 Ubuntu 发行版而言，通过该命令安装得到的 clang-format 版本是不同的。</p>
</blockquote>
<p>安装完成后，我们能够使用的命令名是 <code>clang-format-10</code>，我们将其提级为 <code>clang-format</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo update-alternatives --install /usr/bin/clang-format clang-format /usr/bin/clang-format-10 100</span><br></pre></td></tr></table></figure>
<p>后面当我们使用 <code>clang-format</code> 命令时，指代的即为 <code>clang-format-10</code>。</p>
<p>通过 vscode 进行 C++ 开发时，我们一般会安装微软官方的 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPW1zLXZzY29kZS5jcHB0b29scw==" title="https://marketplace.visualstudio.com/items?itemName=ms-vscode.cpptools">C/C++<i class="fa fa-external-link"></i></span> 插件，打开该插件的安装目录我们会发现，该插件已经封装了一个内置的 clang-format：</p>
<p><img data-src="https://image.shipengx.com/vscode%20C%2B%2B%20%E6%8F%92%E4%BB%B6%E5%86%85%E7%BD%AE%E7%9A%84%20LLVM%20clang-format.png" alt="vscode C++ 插件内置的 LLVM clang-format"></p>
<p>那为什么不直接使用这个 C/C++ 插件内置的 clang-format 呢？两个原因：</p>
<ul>
<li>不同版本的 C/C++ 插件内置的 clang-format 版本往往不同，统一 clang-format 版本间接需要统一 C/C++ 插件版本；</li>
<li>C/C++ 插件内置的 clang-format 只能应用于 C/C++ 代码，而实际开发中，可能包含了其它语言代码，例如 Protobuf。</li>
</ul>
<p>直接在系统中安装 clang-format 则可以避免这两个问题。</p>
<h2 id="1-2-安装-vscode-clang-format-插件" class="heading-control"><a href="#1-2-安装-vscode-clang-format-插件" class="headerlink" title="1.2 安装 vscode clang-format 插件"></a>1.2 安装 vscode clang-format 插件<a class="heading-anchor" href="#1-2-安装-vscode-clang-format-插件" aria-hidden="true"></a></h2><p>完成步骤 1.1 后，我们已经可以在终端中通过 <code>clang-format</code> 命令来对代码文件进行格式化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-format -style=google -i demo.cpp</span><br></pre></td></tr></table></figure>
<p>上面的命令表示：使用 Google 编码风格对 demo.cpp 文件进行格式化。但使用 vscode 进行 C++ 开发时，我们一般并不会使用终端去格式化代码，而是会在 vscode 设置中为 C++ 指定一个默认的 formatter，并开启设置中的 <code>autoSave</code> 选项和 <code>formatOnSave</code> 选项，实现代码修改后的自动格式化保存：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"files.autoSave"</span>: <span class="string">"afterDelay"</span>,</span><br><span class="line">  <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"[cpp]"</span>: &#123;</span><br><span class="line">    <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"ms-vscode.cpptools"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>&quot;editor.defaultFormatter&quot;: &quot;ms-vscode.cpptools&quot;</code> 表示使用 C++ 插件作为默认的 formatter。为了使用步骤 1.1 中为系统安装的 clang-format，这里我们为 vscode 安装 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPXhhdmVyLmNsYW5nLWZvcm1hdA==" title="https://marketplace.visualstudio.com/items?itemName=xaver.clang-format">Clang-Format 插件<i class="fa fa-external-link"></i></span>：</p>
<p><img data-src="https://image.shipengx.com/vscode%20%E7%9A%84%20Clang-Format%20%E6%8F%92%E4%BB%B6.png" alt="vscode 的 Clang-Format 插件"></p>
<p>可以在插件商店中搜索 Clang-Format 并点击安装，或直接通过命令行进行安装（例如当我们要实现流程自动化时）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">code --install-extension xaver.clang-format</span><br></pre></td></tr></table></figure>
<p>安装完成后将其指定为默认的 formatter：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"files.autoSave"</span>: <span class="string">"afterDelay"</span>,</span><br><span class="line">  <span class="attr">"editor.formatOnSave"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"[cpp]"</span>: &#123;</span><br><span class="line">    <span class="attr">"editor.defaultFormatter"</span>: <span class="string">"xaver.clang-format"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后每次修改完代码保存时，vscode 的 clang-format 插件会调用系统中的 clang-format（默认从 <code>PATH</code> 环境变量中查找，也可以单独指定路径）对代码进行格式化。</p>
<h2 id="1-3-编写-clang-format-文件" class="heading-control"><a href="#1-3-编写-clang-format-文件" class="headerlink" title="1.3 编写 .clang-format 文件"></a>1.3 编写 .clang-format 文件<a class="heading-anchor" href="#1-3-编写-clang-format-文件" aria-hidden="true"></a></h2><p>完成步骤 1.2 后，每次对代码进行格式化时使用的将是 clang-format 默认的风格，clang-format 支持包括 LLVM、Google、Chromium、Mozilla、WebKit 等在内的多种风格。我们可以在已有风格的基础上自定义一个名为 <code>.clang-format</code> 的代码风格文件放在仓库根目录下，以后保存代码时 clang-format 将根据文件中定义的规则对代码进行格式化。</p>
<p>这里我们首先生成 Google 风格的 <code>.clang-format</code> 模板文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">clang-format -style=google -dump-config &gt; .clang-format</span><br></pre></td></tr></table></figure>
<p>然后根据团队开发规范或个人喜好对生成的 <code>.clang-format</code> 进行自定义。下面是笔者常用的风格，注释掉的部分与 Google style 相同，其它部分经过了自定义：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">BasedOnStyle:</span> <span class="string">Google</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">Language:</span> <span class="string">Cpp</span></span><br><span class="line"><span class="attr">AccessModifierOffset:</span> <span class="number">-4</span></span><br><span class="line"><span class="comment"># AlignAfterOpenBracket: Align</span></span><br><span class="line"><span class="comment"># AlignConsecutiveMacros: false</span></span><br><span class="line"><span class="comment"># AlignConsecutiveAssignments: false</span></span><br><span class="line"><span class="comment"># AlignConsecutiveDeclarations: false</span></span><br><span class="line"><span class="comment"># AlignEscapedNewlines: Left</span></span><br><span class="line"><span class="comment"># AlignOperands: true</span></span><br><span class="line"><span class="comment"># AlignTrailingComments: true</span></span><br><span class="line"><span class="comment"># AllowAllArgumentsOnNextLine: true</span></span><br><span class="line"><span class="attr">AllowAllConstructorInitializersOnNextLine:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># AllowAllParametersOfDeclarationOnNextLine: true</span></span><br><span class="line"><span class="comment"># AllowShortBlocksOnASingleLine: Never</span></span><br><span class="line"><span class="attr">AllowShortCaseLabelsOnASingleLine:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># AllowShortFunctionsOnASingleLine: All</span></span><br><span class="line"><span class="comment"># AllowShortLambdasOnASingleLine: All</span></span><br><span class="line"><span class="comment"># AllowShortIfStatementsOnASingleLine: WithoutElse</span></span><br><span class="line"><span class="comment"># AllowShortLoopsOnASingleLine: true</span></span><br><span class="line"><span class="comment"># AlwaysBreakAfterDefinitionReturnType: None</span></span><br><span class="line"><span class="comment"># AlwaysBreakAfterReturnType: None</span></span><br><span class="line"><span class="attr">AlwaysBreakBeforeMultilineStrings:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># AlwaysBreakTemplateDeclarations: Yes</span></span><br><span class="line"><span class="comment"># BinPackArguments: true</span></span><br><span class="line"><span class="comment"># BinPackParameters: true</span></span><br><span class="line"><span class="attr">BraceWrapping:</span></span><br><span class="line">  <span class="comment"># AfterCaseLabel: false</span></span><br><span class="line">  <span class="attr">AfterClass:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">AfterControlStatement:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">AfterEnum:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">AfterFunction:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># AfterNamespace: false</span></span><br><span class="line">  <span class="comment"># AfterObjCDeclaration: false</span></span><br><span class="line">  <span class="attr">AfterStruct:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">AfterUnion:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">AfterExternBlock:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">BeforeCatch:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">BeforeElse:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># IndentBraces: false</span></span><br><span class="line">  <span class="comment"># SplitEmptyFunction: true</span></span><br><span class="line">  <span class="comment"># SplitEmptyRecord: true</span></span><br><span class="line">  <span class="comment"># SplitEmptyNamespace: true</span></span><br><span class="line"><span class="comment"># BreakBeforeBinaryOperators: None</span></span><br><span class="line"><span class="attr">BreakBeforeBraces:</span> <span class="string">Custom</span></span><br><span class="line"><span class="comment"># BreakBeforeInheritanceComma: false</span></span><br><span class="line"><span class="comment"># BreakInheritanceList: BeforeColon</span></span><br><span class="line"><span class="comment"># BreakBeforeTernaryOperators: true</span></span><br><span class="line"><span class="comment"># BreakConstructorInitializersBeforeComma: false</span></span><br><span class="line"><span class="comment"># BreakConstructorInitializers: BeforeColon</span></span><br><span class="line"><span class="comment"># BreakAfterJavaFieldAnnotations: false</span></span><br><span class="line"><span class="comment"># BreakStringLiterals: true</span></span><br><span class="line"><span class="comment"># ColumnLimit: 80</span></span><br><span class="line"><span class="attr">CommentPragmas:</span> <span class="string">"^ NOLINT:"</span></span><br><span class="line"><span class="comment"># CompactNamespaces: false</span></span><br><span class="line"><span class="comment"># ConstructorInitializerAllOnOneLineOrOnePerLine: true</span></span><br><span class="line"><span class="comment"># ConstructorInitializerIndentWidth: 4</span></span><br><span class="line"><span class="comment"># ContinuationIndentWidth: 4</span></span><br><span class="line"><span class="comment"># Cpp11BracedListStyle: true</span></span><br><span class="line"><span class="comment"># DeriveLineEnding: true</span></span><br><span class="line"><span class="comment"># DerivePointerAlignment: true</span></span><br><span class="line"><span class="comment"># DisableFormat: false</span></span><br><span class="line"><span class="comment"># ExperimentalAutoDetectBinPacking: false</span></span><br><span class="line"><span class="comment"># FixNamespaceComments: true</span></span><br><span class="line"><span class="comment"># ForEachMacros:</span></span><br><span class="line"><span class="comment">#   - foreach</span></span><br><span class="line"><span class="comment">#   - Q_FOREACH</span></span><br><span class="line"><span class="comment">#   - BOOST_FOREACH</span></span><br><span class="line"><span class="comment"># IncludeBlocks: Regroup</span></span><br><span class="line"><span class="comment"># IncludeCategories:</span></span><br><span class="line"><span class="comment">#   - Regex: '^&lt;ext/.*\.h&gt;'</span></span><br><span class="line"><span class="comment">#     Priority: 2</span></span><br><span class="line"><span class="comment">#     SortPriority: 0</span></span><br><span class="line"><span class="comment">#   - Regex: '^&lt;.*\.h&gt;'</span></span><br><span class="line"><span class="comment">#     Priority: 1</span></span><br><span class="line"><span class="comment">#     SortPriority: 0</span></span><br><span class="line"><span class="comment">#   - Regex: "^&lt;.*"</span></span><br><span class="line"><span class="comment">#     Priority: 2</span></span><br><span class="line"><span class="comment">#     SortPriority: 0</span></span><br><span class="line"><span class="comment">#   - Regex: ".*"</span></span><br><span class="line"><span class="comment">#     Priority: 3</span></span><br><span class="line"><span class="comment">#     SortPriority: 0</span></span><br><span class="line"><span class="comment"># IncludeIsMainRegex: "([-_](test|unittest))?$"</span></span><br><span class="line"><span class="comment"># IncludeIsMainSourceRegex: ""</span></span><br><span class="line"><span class="comment"># IndentCaseLabels: true</span></span><br><span class="line"><span class="comment"># IndentGotoLabels: true</span></span><br><span class="line"><span class="comment"># IndentPPDirectives: None</span></span><br><span class="line"><span class="attr">IndentWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="comment"># IndentWrappedFunctionNames: false</span></span><br><span class="line"><span class="comment"># JavaScriptQuotes: Leave</span></span><br><span class="line"><span class="comment"># JavaScriptWrapImports: true</span></span><br><span class="line"><span class="comment"># KeepEmptyLinesAtTheStartOfBlocks: false</span></span><br><span class="line"><span class="comment"># MacroBlockBegin: ""</span></span><br><span class="line"><span class="comment"># MacroBlockEnd: ""</span></span><br><span class="line"><span class="comment"># MaxEmptyLinesToKeep: 1</span></span><br><span class="line"><span class="comment"># NamespaceIndentation: None</span></span><br><span class="line"><span class="comment"># ObjCBinPackProtocolList: Never</span></span><br><span class="line"><span class="comment"># ObjCBlockIndentWidth: 2</span></span><br><span class="line"><span class="comment"># ObjCSpaceAfterProperty: false</span></span><br><span class="line"><span class="comment"># ObjCSpaceBeforeProtocolList: true</span></span><br><span class="line"><span class="comment"># PenaltyBreakAssignment: 2</span></span><br><span class="line"><span class="comment"># PenaltyBreakBeforeFirstCallParameter: 1</span></span><br><span class="line"><span class="comment"># PenaltyBreakComment: 300</span></span><br><span class="line"><span class="comment"># PenaltyBreakFirstLessLess: 120</span></span><br><span class="line"><span class="comment"># PenaltyBreakString: 1000</span></span><br><span class="line"><span class="comment"># PenaltyBreakTemplateDeclaration: 10</span></span><br><span class="line"><span class="comment"># PenaltyExcessCharacter: 1000000</span></span><br><span class="line"><span class="comment"># PenaltyReturnTypeOnItsOwnLine: 200</span></span><br><span class="line"><span class="attr">PointerAlignment:</span> <span class="string">Right</span></span><br><span class="line"><span class="comment"># RawStringFormats:</span></span><br><span class="line"><span class="comment">#   - Language: Cpp</span></span><br><span class="line"><span class="comment">#     Delimiters:</span></span><br><span class="line"><span class="comment">#       - cc</span></span><br><span class="line"><span class="comment">#       - CC</span></span><br><span class="line"><span class="comment">#       - cpp</span></span><br><span class="line"><span class="comment">#       - Cpp</span></span><br><span class="line"><span class="comment">#       - CPP</span></span><br><span class="line"><span class="comment">#       - "c++"</span></span><br><span class="line"><span class="comment">#       - "C++"</span></span><br><span class="line"><span class="comment">#     CanonicalDelimiter: ""</span></span><br><span class="line"><span class="comment">#     BasedOnStyle: google</span></span><br><span class="line"><span class="comment">#   - Language: TextProto</span></span><br><span class="line"><span class="comment">#     Delimiters:</span></span><br><span class="line"><span class="comment">#       - pb</span></span><br><span class="line"><span class="comment">#       - PB</span></span><br><span class="line"><span class="comment">#       - proto</span></span><br><span class="line"><span class="comment">#       - PROTO</span></span><br><span class="line"><span class="comment">#     EnclosingFunctions:</span></span><br><span class="line"><span class="comment">#       - EqualsProto</span></span><br><span class="line"><span class="comment">#       - EquivToProto</span></span><br><span class="line"><span class="comment">#       - PARSE_PARTIAL_TEXT_PROTO</span></span><br><span class="line"><span class="comment">#       - PARSE_TEST_PROTO</span></span><br><span class="line"><span class="comment">#       - PARSE_TEXT_PROTO</span></span><br><span class="line"><span class="comment">#       - ParseTextOrDie</span></span><br><span class="line"><span class="comment">#       - ParseTextProtoOrDie</span></span><br><span class="line"><span class="comment">#     CanonicalDelimiter: ""</span></span><br><span class="line"><span class="comment">#     BasedOnStyle: google</span></span><br><span class="line"><span class="comment"># ReflowComments: true</span></span><br><span class="line"><span class="attr">SortIncludes:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">SortUsingDeclarations:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># SpaceAfterCStyleCast: false</span></span><br><span class="line"><span class="comment"># SpaceAfterLogicalNot: false</span></span><br><span class="line"><span class="comment"># SpaceAfterTemplateKeyword: true</span></span><br><span class="line"><span class="comment"># SpaceBeforeAssignmentOperators: true</span></span><br><span class="line"><span class="comment"># SpaceBeforeCpp11BracedList: false</span></span><br><span class="line"><span class="comment"># SpaceBeforeCtorInitializerColon: true</span></span><br><span class="line"><span class="comment"># SpaceBeforeInheritanceColon: true</span></span><br><span class="line"><span class="comment"># SpaceBeforeParens: ControlStatements</span></span><br><span class="line"><span class="comment"># SpaceBeforeRangeBasedForLoopColon: true</span></span><br><span class="line"><span class="comment"># SpaceInEmptyBlock: false</span></span><br><span class="line"><span class="comment"># SpaceInEmptyParentheses: false</span></span><br><span class="line"><span class="attr">SpacesBeforeTrailingComments:</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># SpacesInAngles: false</span></span><br><span class="line"><span class="comment"># SpacesInConditionalStatement: false</span></span><br><span class="line"><span class="attr">SpacesInContainerLiterals:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># SpacesInCStyleCastParentheses: false</span></span><br><span class="line"><span class="comment"># SpacesInParentheses: false</span></span><br><span class="line"><span class="comment"># SpacesInSquareBrackets: false</span></span><br><span class="line"><span class="comment"># SpaceBeforeSquareBrackets: false</span></span><br><span class="line"><span class="attr">Standard:</span> <span class="string">Cpp11</span></span><br><span class="line"><span class="comment"># StatementMacros:</span></span><br><span class="line"><span class="comment">#   - Q_UNUSED</span></span><br><span class="line"><span class="comment">#   - QT_REQUIRE_VERSION</span></span><br><span class="line"><span class="attr">TabWidth:</span> <span class="number">4</span></span><br><span class="line"><span class="comment"># UseCRLF: false</span></span><br><span class="line"><span class="comment"># UseTab: Never</span></span><br></pre></td></tr></table></figure>
<p>每个选项的具体含义可以在<span class="exturl" data-url="aHR0cHM6Ly9jbGFuZy5sbHZtLm9yZy9kb2NzL0NsYW5nRm9ybWF0U3R5bGVPcHRpb25zLmh0bWw=" title="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">官方文档<i class="fa fa-external-link"></i></span>中找到。</p>
<p>如果希望某个代码段不要参与格式化，可使用 <code>// clang-format off</code> 和 <code>// clang-format on</code> 注释对该代码段进行限定，像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// clang-format off</span></span><br><span class="line">    Eigen::MatrixXd ref_mat = Eigen::MatrixXd::Zero(<span class="number">6</span>, <span class="number">6</span>);</span><br><span class="line">    ref_mat &lt;&lt;</span><br><span class="line">         <span class="number">1</span>,        <span class="number">0</span>,        <span class="number">0</span>,        <span class="number">0</span>,        <span class="number">0</span>,        <span class="number">0</span>,</span><br><span class="line">         <span class="number">1</span>,      <span class="number">0.5</span>,     <span class="number">0.25</span>,    <span class="number">0.125</span>,   <span class="number">0.0625</span>,  <span class="number">0.03125</span>,</span><br><span class="line">         <span class="number">1</span>,        <span class="number">1</span>,        <span class="number">1</span>,        <span class="number">1</span>,        <span class="number">1</span>,        <span class="number">1</span>,</span><br><span class="line">        <span class="number">-1</span>,       <span class="number">-0</span>,       <span class="number">-0</span>,       <span class="number">-0</span>,       <span class="number">-0</span>,       <span class="number">-0</span>,</span><br><span class="line">        <span class="number">-1</span>,     <span class="number">-0.5</span>,    <span class="number">-0.25</span>,   <span class="number">-0.125</span>,  <span class="number">-0.0625</span>, <span class="number">-0.03125</span>,</span><br><span class="line">        <span class="number">-1</span>,       <span class="number">-1</span>,       <span class="number">-1</span>,       <span class="number">-1</span>,       <span class="number">-1</span>,       <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// clang-format on</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbGFuZy5sbHZtLm9yZy9kb2NzL0NsYW5nRm9ybWF0Lmh0bWw=" title="https://clang.llvm.org/docs/ClangFormat.html">ClangFormat<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbGFuZy5sbHZtLm9yZy9kb2NzL0NsYW5nRm9ybWF0U3R5bGVPcHRpb25zLmh0bWw=" title="https://clang.llvm.org/docs/ClangFormatStyleOptions.html">ClangFormatStyleOptions<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0tyYW50ei1YUkYvQ2xhbmdGb3JtYXRDb25maWcvYmxvYi9tYXN0ZXIvLmNsYW5nLWZvcm1hdA==" title="https://github.com/Krantz-XRF/ClangFormatConfig/blob/master/.clang-format">ClangFormatConfig<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dvZG90ZW5naW5lL2dvZG90L2Jsb2IvbWFzdGVyLy5jbGFuZy1mb3JtYXQ=" title="https://github.com/godotengine/godot/blob/master/.clang-format">godot<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>Clang-Format</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 gperftools 进行 C++ 代码性能分析</title>
    <url>/archives/19236f69.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E4%BD%BF%E7%94%A8%20gperftools%20%E8%BF%9B%E8%A1%8C%20C%2B%2B%20%E4%BB%A3%E7%A0%81%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90.png" alt="使用 gperftools 进行 C++ 代码性能分析"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>在进行模块的负载优化时，使用到了 Google 开发的 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dwZXJmdG9vbHMvZ3BlcmZ0b29scw==" title="https://github.com/gperftools/gperftools">gperftools<i class="fa fa-external-link"></i></span> 工具来进行代码性能分析。正如 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dwZXJmdG9vbHMvZ3BlcmZ0b29scw==" title="https://github.com/gperftools/gperftools">gperftools wiki<i class="fa fa-external-link"></i></span> 中所描述的：</p>
<blockquote>
<p>gperftools is a collection of a high-performance multi-threaded <code>malloc()</code> implementation, plus some pretty nifty performance analysis tools.</p>
<p>gperftools 是一系列高性能多线程 <code>malloc()</code> 实现的集合，同时添加了一些精巧的性能分析工具。</p>
</blockquote>
<p>gperftools 性能分析工具主要包含五部分：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9ncGVyZnRvb2xzLmdpdGh1Yi5pby9ncGVyZnRvb2xzL3RjbWFsbG9jLmh0bWw=" title="https://gperftools.github.io/gperftools/tcmalloc.html">TC Malloc<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ncGVyZnRvb2xzLmdpdGh1Yi5pby9ncGVyZnRvb2xzL2hlYXBfY2hlY2tlci5odG1s" title="https://gperftools.github.io/gperftools/heap_checker.html">Heap Checker<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ncGVyZnRvb2xzLmdpdGh1Yi5pby9ncGVyZnRvb2xzL2hlYXBwcm9maWxlLmh0bWw=" title="https://gperftools.github.io/gperftools/heapprofile.html">Heap Profiler<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ncGVyZnRvb2xzLmdpdGh1Yi5pby9ncGVyZnRvb2xzL2NwdXByb2ZpbGUuaHRtbA==" title="https://gperftools.github.io/gperftools/cpuprofile.html">CPU Profiler<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ncGVyZnRvb2xzLmdpdGh1Yi5pby9ncGVyZnRvb2xzL3Bwcm9mX3JlbW90ZV9zZXJ2ZXJzLmh0bWw=" title="https://gperftools.github.io/gperftools/pprof_remote_servers.html">pprof<i class="fa fa-external-link"></i></span></li>
</ul>
<p>本文中将使用 CPU Profiler 和 pprof 进行代码性能分析。其中，CPU Profiler 用于生成后缀为 <code>.prof</code> 的 profile 性能描述文件，pprof 是用于解析 profile 文件的 perl 脚本工具。</p>
<h1 id="1-安装" class="heading-control"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装<a class="heading-anchor" href="#1-安装" aria-hidden="true"></a></h1><h2 id="1-1-基础软件" class="heading-control"><a href="#1-1-基础软件" class="headerlink" title="1.1 基础软件"></a>1.1 基础软件<a class="heading-anchor" href="#1-1-基础软件" aria-hidden="true"></a></h2><p>在命令行中通过 <code>apt</code> 安装 autoconf、automake、libtool：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install autoconf automake libtool</span><br></pre></td></tr></table></figure>
<h2 id="1-2-libunwind" class="heading-control"><a href="#1-2-libunwind" class="headerlink" title="1.2 libunwind"></a>1.2 libunwind<a class="heading-anchor" href="#1-2-libunwind" aria-hidden="true"></a></h2><p>gperftools 在 64 位操作系统下需要 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYnVud2luZC9saWJ1bndpbmQ=" title="https://github.com/libunwind/libunwind">libunwind<i class="fa fa-external-link"></i></span> 库的支持，libunwind 提供了可用于分析程序调用栈的 API，可直接执行下述命令行进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://github.com/libunwind/libunwind/releases/download/v1.6.2/libunwind-1.6.2.tar.gz</span><br><span class="line">tar -zxvf libunwind-1.6.2.tar.gz</span><br><span class="line"><span class="built_in">cd</span> libunwind-1.6.2</span><br><span class="line">./configure</span><br><span class="line">make -j8</span><br><span class="line">sudo make install</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">rm -rf libunwind-1.6.2.tar.gz libunwind-1.6.2</span><br></pre></td></tr></table></figure>
<h2 id="1-3-graphviz" class="heading-control"><a href="#1-3-graphviz" class="headerlink" title="1.3 graphviz"></a>1.3 graphviz<a class="heading-anchor" href="#1-3-graphviz" aria-hidden="true"></a></h2><p>gperftools 使用 <span class="exturl" data-url="aHR0cDovL3d3dy5ncmFwaHZpei5vcmcv" title="http://www.graphviz.org/">graphviz<i class="fa fa-external-link"></i></span> 将代码性能分析结果进行图形化显示。graphviz 是一个由 AT&amp;T 实验室开发的开源工具包，用于绘制 DOT 语言脚本描述的图形，Ubuntu 中可通过 <code>apt</code> 直接安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install graphviz</span><br></pre></td></tr></table></figure>
<h2 id="1-4-gperftools" class="heading-control"><a href="#1-4-gperftools" class="headerlink" title="1.4 gperftools"></a>1.4 gperftools<a class="heading-anchor" href="#1-4-gperftools" aria-hidden="true"></a></h2><p>gperftools 可直接执行下述命令行进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">wget https://github.com/gperftools/gperftools/releases/download/gperftools-2.10/gperftools-2.10.tar.gz</span><br><span class="line">tar -zxvf gperftools-2.10.tar.gz</span><br><span class="line"><span class="built_in">cd</span> gperftools-2.10</span><br><span class="line">./configure</span><br><span class="line">make -j8</span><br><span class="line">sudo make install</span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">rm -rf gperftools-2.10.tar.gz gperftools-2.10</span><br></pre></td></tr></table></figure>
<h1 id="2-使用" class="heading-control"><a href="#2-使用" class="headerlink" title="2 使用"></a>2 使用<a class="heading-anchor" href="#2-使用" aria-hidden="true"></a></h1><p>下文中将使用的 C++ 工程 Demo 可点击<a href="/download/cpp_demo.zip">这里</a>下载。</p>
<h2 id="2-1-代码插桩" class="heading-control"><a href="#2-1-代码插桩" class="headerlink" title="2.1 代码插桩"></a>2.1 代码插桩<a class="heading-anchor" href="#2-1-代码插桩" aria-hidden="true"></a></h2><p>在使用 gperftools 进行代码性能分析前，需要进行代码插桩：</p>
<ul>
<li><p>插入头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/profiler.h&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在待分析的代码块前插入 Profiler 开始语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ProfilerStart(<span class="string">"file_name.prof"</span>);</span><br></pre></td></tr></table></figure>
<p><code>file_name.prof</code> 表示 <code>.prof</code> 文件的文件名。</p>
</li>
<li><p>在待分析的代码块后插入 Profiler 结束语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ProfilerStop();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>完整的插桩示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"inc/func.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gperftools/profiler.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ProfilerStart(<span class="string">"cpp_demo_perf.prof"</span>);</span><br><span class="line"></span><br><span class="line">    PrintString(<span class="string">"This's a demo."</span>);</span><br><span class="line">    Func();</span><br><span class="line"></span><br><span class="line">    ProfilerStop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-2-编译链接" class="heading-control"><a href="#2-2-编译链接" class="headerlink" title="2.2 编译链接"></a>2.2 编译链接<a class="heading-anchor" href="#2-2-编译链接" aria-hidden="true"></a></h2><p>编译时我们需要将 profiler 库和 libunwind 库链接到可执行程序，对应的 CMakeLists 文件中的语句为：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">target_link_libraries</span>(<span class="variable">$&#123;PROJECT_NAME&#125;</span> profiler unwind)</span><br></pre></td></tr></table></figure>
<h2 id="2-3-运行可执行程序" class="heading-control"><a href="#2-3-运行可执行程序" class="headerlink" title="2.3 运行可执行程序"></a>2.3 运行可执行程序<a class="heading-anchor" href="#2-3-运行可执行程序" aria-hidden="true"></a></h2><p>找到编译得到的可执行程序，并在终端中运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./cpp_demo</span><br></pre></td></tr></table></figure>
<p>正常情况下，会生成一个我们上文中所提到的 <code>.prof</code> 文件，如果报动态链接库找不到的问题，手动执行下动态链接库的管理命令 <code>ldconfig</code> 即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>
<p><code>ldconfig</code> 可执行程序存放在 <code>/sbin</code> 目录下，通常在系统启动时运行，而当用户安装了一个新的动态链接库时，需要手动运行这个命令。运行 <code>ldconfig</code> 会刷新动态装入程序 <code>ld.so</code> 所需的链接和缓存文件 <code>/etc/ld.so.cache</code>（此文件保存了已排好序的动态链接库名字列表），实现动态链接库为系统所共享。</p>
<h2 id="2-4-生成图形化分析报告" class="heading-control"><a href="#2-4-生成图形化分析报告" class="headerlink" title="2.4 生成图形化分析报告"></a>2.4 生成图形化分析报告<a class="heading-anchor" href="#2-4-生成图形化分析报告" aria-hidden="true"></a></h2><p>最后，通过上文提到的 pprof 解析 <code>.prof</code> 文件。pprof 有多种使用方法，下面的命令行将 <code>.prof</code> 文件解析为 <code>.pdf</code> 文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pprof --pdf cpp_demo cpp_demo_perf.prof &gt; cpp_demo_perf.pdf</span><br></pre></td></tr></table></figure>
<p>解析得到的 <code>.pdf</code> 文件中保存了图形化的代码性能分析结果，从中我们可以查找代码的性能瓶颈：</p>
<p><img data-src="https://image.shipengx.com/%E5%9B%BE%E5%BD%A2%E5%8C%96%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E6%8A%A5%E5%91%8A.png" alt="图形化性能分析报告"></p>
<p>每一个方框表示一个进程，有向边表示进程间的调用关系。方框越大，表示该进程耗时越高，这里我们可以发现，<code>Func2</code> 函数占了程序总耗时的 67%，是程序的性能瓶颈。需要注意的是，gperftools 的 CPU Profiler 是通过采样的方式工作的，如果程序运行时间太短，会导致样本不足从而造成分析结果不准确。</p>
<p>关于图形化分析结果更详细的解释，可以参考<span class="exturl" data-url="aHR0cHM6Ly9ncGVyZnRvb2xzLmdpdGh1Yi5pby9ncGVyZnRvb2xzL2NwdXByb2ZpbGUuaHRtbA==" title="https://gperftools.github.io/gperftools/cpuprofile.html">这里<i class="fa fa-external-link"></i></span>。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2dwZXJmdG9vbHMvZ3BlcmZ0b29scw==" title="https://github.com/gperftools/gperftools">gperftools wiki<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ncGVyZnRvb2xzLmdpdGh1Yi5pby9ncGVyZnRvb2xzL2NwdXByb2ZpbGUuaHRtbA==" title="https://gperftools.github.io/gperftools/cpuprofile.html">gperftools CPU profiler<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2xpYnVud2luZC9saWJ1bndpbmQ=" title="https://github.com/libunwind/libunwind">libunwind<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5ncmFwaHZpei5vcmcv" title="http://www.graphviz.org/">graphviz<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9saW51eDI2NS5jb20vY291cnNlL2xpbnV4LWNvbW1hbmQtbGRjb25maWcuaHRtbA==" title="https://linux265.com/course/linux-command-ldconfig.html">ldconfig 命令<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 vscode + Remote-SSH 插件 + vscode-server 进行远程开发</title>
    <url>/archives/ef5b128d.html</url>
    <content><![CDATA[<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>疫情期间居家办公，手头一台 Windows 工作本，由于连接的是自己的外网，需要借助 VPN 才能登陆到内网环境下的远程服务器进行开发工作。此前一直使用 VNC 来做远程桌面可视化，但由于 VPN 带宽有限，此时再使用 VNC 会遇到明显的画面卡顿问题。</p>
<p>为解决上述开发流程的痛点，我们可以使用本地 vscode + Remote-SSH 插件 + 远程 vscode-server 搭建一个远程开发环境，将代码可视化放到本地，无需再借助 VNC。</p>
<h1 id="1-准备" class="heading-control"><a href="#1-准备" class="headerlink" title="1 准备"></a>1 准备<a class="heading-anchor" href="#1-准备" aria-hidden="true"></a></h1><p>在开始环境配置前，需要满足一些基础前提条件：</p>
<ul>
<li>已安装 SSH（Git 自带，最好直接安装 Git）</li>
<li>本地电脑已连接网络</li>
<li>本地电脑已连接 VPN（若远程服务器在内网下）</li>
<li>远程服务器已连接网络</li>
</ul>
<h1 id="2-环境配置" class="heading-control"><a href="#2-环境配置" class="headerlink" title="2 环境配置"></a>2 环境配置<a class="heading-anchor" href="#2-环境配置" aria-hidden="true"></a></h1><p>本文中所使用的本地操作系统环境为 Windows 10，远程操作系统环境 Linux Ubuntu 18.04。</p>
<h2 id="2-1-配置本地环境" class="heading-control"><a href="#2-1-配置本地环境" class="headerlink" title="2.1 配置本地环境"></a>2.1 配置本地环境<a class="heading-anchor" href="#2-1-配置本地环境" aria-hidden="true"></a></h2><ul>
<li>安装 <span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v" title="https://code.visualstudio.com/">vscode<i class="fa fa-external-link"></i></span></li>
<li>安装 <span class="exturl" data-url="aHR0cHM6Ly9tYXJrZXRwbGFjZS52aXN1YWxzdHVkaW8uY29tL2l0ZW1zP2l0ZW1OYW1lPW1zLXZzY29kZS1yZW1vdGUucmVtb3RlLXNzaA==" title="https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh">Remote-SSH 插件<i class="fa fa-external-link"></i></span></li>
</ul>
<p>可以将其它 Windows 环境中已安装好的 vscode、扩展及相应的 settings.json 配置文件直接拷贝到本地对应目录下，实现免安装即开即用。vscode 放置路径随意，扩展放到本地 <code>C:\Users\你的用户名</code> 目录下，即 Windows 的 <code>~</code> 目录，settings.json 配置文件放到 <code>C:\Users\你的用户名\AppData\Roaming\Code\User</code> 目录下。</p>
<h2 id="2-2-配置远程环境" class="heading-control"><a href="#2-2-配置远程环境" class="headerlink" title="2.2 配置远程环境"></a>2.2 配置远程环境<a class="heading-anchor" href="#2-2-配置远程环境" aria-hidden="true"></a></h2><ol>
<li><p>查看 vscode commit id 并下载对应版本的 vscode-server</p>
<p><img data-src="https://image.shipengx.com/%E6%9F%A5%E7%9C%8B%20vscode%20%E6%9E%84%E5%BB%BA%E4%BF%A1%E6%81%AF.png" alt="查看 vscode 构建信息"></p>
<p><img data-src="https://image.shipengx.com/%E6%8F%90%E5%8F%96%20vscode%20commit%20id.png" alt="提取 vscode commit id"></p>
<p>下载链接的形式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;update.code.visualstudio.com&#x2F;commit:commit_id&#x2F;server-linux-x64&#x2F;stable</span><br></pre></td></tr></table></figure>
<p>本文中使用的 vscode 的 commit id 为 <code>e18005f0f1b33c29e81d732535d8c0e47cafb0b5</code>，故对应下载链接为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;update.code.visualstudio.com&#x2F;commit:e18005f0f1b33c29e81d732535d8c0e47cafb0b5&#x2F;server-linux-x64&#x2F;stable</span><br></pre></td></tr></table></figure>
<p>下载将得到 <code>vscode-server-linux-x64.tar.gz</code> 文件。</p>
</li>
<li><p>将 vscode-server 部署到远程服务器</p>
<p>登陆远程服务器，在 <code>~</code> 目录下创建 <code>.vscode-server/bin</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/.vscode-server/bin</span><br></pre></td></tr></table></figure>
<p>将下载得到的 <code>vscode-server-linux-x64.tar.gz</code> 文件上传至上述新建的 <code>~/.vscode-server/bin</code> 目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp vscode-server-linux-x64.tar.gz user_name@server_ip:~/.vscode-server/bin</span><br></pre></td></tr></table></figure>
<p>登陆远程服务器，解压 <code>vscode-server-linux-x64.tar.gz</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vscode-server/bin</span><br><span class="line">tar -zxvf vscode-server-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压后将在 <code>~/.vscode-server/bin</code> 目录下生成 <code>vscode-server-linux-x64</code> 目录，将其改名为上文中得到的 vscode 的 commit id，并删除 <code>vscode-server-linux-x64.tar.gz</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv vscode-server-linux-x64 e18005f0f1b33c29e81d732535d8c0e47cafb0b5</span><br><span class="line">rm vscode-server-linux-x64.tar.gz</span><br></pre></td></tr></table></figure>
<p>在这个以 vscode commit id 命名的目录中创建名为 <code>0</code> 的文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.vscode-server/bin/e18005f0f1b33c29e81d732535d8c0e47cafb0b5</span><br><span class="line">touch 0</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>vscode-server 完成远程部署后不包含扩展，可将其它已安装有 vscode 的 Ubuntu 机器的 <code>~/.vscode</code> 目录下的 <code>extensions</code> 目录放到上文中创建的远程服务器的 <code>~/.vscode-server</code> 目录下，实现扩展离线安装，或通过下文中将提到的方法直接将本地扩展全部或部分在线安装到远程服务器。</p>
<h2 id="2-3-配置本地连接远程" class="heading-control"><a href="#2-3-配置本地连接远程" class="headerlink" title="2.3 配置本地连接远程"></a>2.3 配置本地连接远程<a class="heading-anchor" href="#2-3-配置本地连接远程" aria-hidden="true"></a></h2><ol>
<li><p>打开本地 vscode，点击左下角黄色图标打开远程窗口</p>
<p><img data-src="https://image.shipengx.com/%E6%89%93%E5%BC%80%E8%BF%9C%E7%A8%8B%E7%AA%97%E5%8F%A3.png" alt="打开远程窗口"></p>
</li>
<li><p>连接到主机</p>
<p><img data-src="https://image.shipengx.com/%E8%BF%9E%E6%8E%A5%E5%88%B0%E4%B8%BB%E6%9C%BA.png" alt="连接到主机"></p>
</li>
<li><p>配置 SSH 主机</p>
<p><img data-src="https://image.shipengx.com/%E9%85%8D%E7%BD%AE%20SSH%20%E4%B8%BB%E6%9C%BA.png" alt="配置 SSH 主机"></p>
</li>
<li><p>编辑配置文件</p>
<p><img data-src="https://image.shipengx.com/%E7%BC%96%E8%BE%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%201.png" alt="编辑配置文件 1"></p>
<p><img data-src="https://image.shipengx.com/%E7%BC%96%E8%BE%91%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%202.png" alt="编辑配置文件 2"></p>
</li>
<li><p>重复执行步骤 1 和步骤 2，并连接到已配置好的远程服务器</p>
<p><img data-src="https://image.shipengx.com/%E8%BF%9E%E6%8E%A5%E5%88%B0%E5%B7%B2%E9%85%8D%E7%BD%AE%E5%A5%BD%E7%9A%84%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="连接到已配置好的远程服务器"></p>
</li>
<li><p>在新弹出的窗口中选择远程服务器操作系统类型</p>
<p><img data-src="https://image.shipengx.com/%E9%80%89%E6%8B%A9%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B.png" alt="选择远程服务器操作系统类型"></p>
</li>
<li><p>输入远程服务器密码并回车，若弹出失败窗口，点击 retry 重试，再次输入密码并回车</p>
<p><img data-src="https://image.shipengx.com/%E8%BE%93%E5%85%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%86%E7%A0%81%E5%B9%B6%E5%9B%9E%E8%BD%A6.png" alt="输入远程服务器密码并回车"></p>
<p><img data-src="https://image.shipengx.com/%E5%B7%B2%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8.png" alt="已成功连接远程服务器"></p>
</li>
<li><p>将本地扩展安装到远程服务器</p>
<p><img data-src="https://image.shipengx.com/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%89%A9%E5%B1%95%E5%AE%89%E8%A3%85%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%201.png" alt="将本地扩展安装到远程服务器 1"></p>
<p><img data-src="https://image.shipengx.com/%E5%B0%86%E6%9C%AC%E5%9C%B0%E6%89%A9%E5%B1%95%E5%AE%89%E8%A3%85%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%202.png" alt="将本地扩展安装到远程服务器 2"></p>
</li>
<li><p>打开远程工作目录</p>
<p><img data-src="https://image.shipengx.com/%E6%89%93%E5%BC%80%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%201.png" alt="打开远程工作目录 1"></p>
<p><img data-src="https://image.shipengx.com/%E6%89%93%E5%BC%80%E8%BF%9C%E7%A8%8B%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%202.png" alt="打开远程工作目录 2"></p>
<p><img data-src="https://image.shipengx.com/%E5%86%8D%E6%AC%A1%E8%BE%93%E5%85%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AF%86%E7%A0%81%E5%B9%B6%E5%9B%9E%E8%BD%A6.png" alt="再次输入远程服务器密码并回车"></p>
<p><img data-src="https://image.shipengx.com/%E4%BF%A1%E4%BB%BB%E6%89%93%E5%BC%80%E7%9A%84%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95.png" alt="信任打开的工作目录"></p>
<p><img data-src="https://image.shipengx.com/%E5%B7%B2%E6%88%90%E5%8A%9F%E8%BF%9E%E6%8E%A5%E5%88%B0%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B9%B6%E6%89%93%E5%BC%80%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BC%80%E5%A7%8B%E8%BF%9C%E7%A8%8B%E5%BC%80%E5%8F%91.png" alt="已成功连接到远程服务器并打开工作目录，可以开始远程开发"></p>
</li>
</ol>
<h2 id="2-4-配置-SSH-免密登陆" class="heading-control"><a href="#2-4-配置-SSH-免密登陆" class="headerlink" title="2.4 配置 SSH 免密登陆"></a>2.4 配置 SSH 免密登陆<a class="heading-anchor" href="#2-4-配置-SSH-免密登陆" aria-hidden="true"></a></h2><p>完成上述步骤后，我们已经可以实现快速远程开发的需求，但每次登陆远程或由于网络不稳定导致重连都会要求我们输入远程的登陆密码，不免麻烦。由于本地 vscode 与远程 vscode-server 的连接走的是 SSH 协议，因此我们可以通过配置 SSH 免密登陆来省去所有要求输入密码的过程。</p>
<ol>
<li><p>生成 SSH 密钥对（若不存在得话）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -C <span class="string">"your email address"</span></span><br></pre></td></tr></table></figure>
<p>生成的密钥对被保存在本地的 <code>C:\Users\你的用户名\.ssh</code> 目录下，生成的密钥对包括私钥 <code>id_rsa</code> 和公钥 <code>id_rsa.pub</code>，我们需要将公钥中的内容添加到远程服务器。</p>
</li>
<li><p>将 SSH 公钥添加到远程服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-copy-id user_name@server_ip</span><br></pre></td></tr></table></figure>
<p>输入上述命令以及远程服务器的登陆密码，将在远程服务器的 <code>~/.ssh</code> 目录下创建 <code>authorized_keys</code> 文件（若不存在得话），并将本地 SSH 公钥中的内容添加到该文件中。此后，任何从本地发起的指向远程服务器的 SSH 连接请求（如登陆、scp 文件传输等）将不再需要输入登陆密码。</p>
</li>
</ol>
<h1 id="后记" class="heading-control"><a href="#后记" class="headerlink" title="后记"></a>后记<a class="heading-anchor" href="#后记" aria-hidden="true"></a></h1><blockquote>
<p>效率为王！</p>
</blockquote>
]]></content>
      <categories>
        <category>效率</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>VS Code</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python + Matplotlib绘制双柱状图</title>
    <url>/archives/208a7c66.html</url>
    <content><![CDATA[<p><img data-src="https://image.shipengx.com/demo.png" alt="demo"></p>
<blockquote>
<p>在实际工作中，发现上游软件组件（SWC）发送的 Mobileye 前向视觉数据存在丢帧情况，需要对丢帧情况进行统计量化，想到的方法是将实车录得的 LCM log 文件进行 x86 离线回放，x86 应用程序中通过 easylogging++打印关键信息（是否是一帧数据报文，以及数据报文中是否存在部分信息丢失）的 Flag 到日志文件中，通过统计日志文件中关键信息对应的 Flag 数量，计算数据丢帧率并绘制双柱状图。</p>
</blockquote>
<h1 id="环境依赖" class="heading-control"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖<a class="heading-anchor" href="#环境依赖" aria-hidden="true"></a></h1><ul>
<li>windows 7, 8, 10</li>
<li>Python 3+</li>
</ul>
<p>Linux 系统理论上也是可行的，但博主在 Ubuntu 上安装相关的 Python 依赖时遇到了问题，未作进一步的探究。</p>
<h1 id="Python-依赖" class="heading-control"><a href="#Python-依赖" class="headerlink" title="Python 依赖"></a>Python 依赖<a class="heading-anchor" href="#Python-依赖" aria-hidden="true"></a></h1><p>通过<code>pip</code>包管理工具安装<code>numpy</code> <code>matplotlib</code> 这两个库依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install numpy</span><br><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure>
<p>若安装过程因网络问题很难成功，可尝试更换至国内镜像源进行安装，如使用清华镜像源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple numpy</span><br><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple matplotlib</span><br></pre></td></tr></table></figure>
<h1 id="代码实现" class="heading-control"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现<a class="heading-anchor" href="#代码实现" aria-hidden="true"></a></h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GroupedBarChart</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.path_current = os.path.dirname(__file__)</span><br><span class="line">        print(self.path_current)</span><br><span class="line">        self.path_logs = [</span><br><span class="line">            (self.path_current + <span class="string">"/"</span> + i)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> os.listdir(self.path_current)</span><br><span class="line">            <span class="keyword">if</span> (os.path.isfile(os.path.join(self.path_current, i))</span><br><span class="line">                <span class="keyword">and</span> i.endswith(<span class="string">'.txt'</span>))</span><br><span class="line">        ]</span><br><span class="line">        self.num_frames_total = <span class="number">0</span></span><br><span class="line">        self.num_frames_lost = <span class="number">0</span></span><br><span class="line">        self.list_valid_log_name = []</span><br><span class="line">        self.list_frame_lost_percent = []</span><br><span class="line">        self.list_frame_normal_percent = []</span><br><span class="line">        <span class="comment"># 字体设置，若不将'family'设置为中文相关字体，则无法正常显示中文</span></span><br><span class="line">        self.font = &#123;</span><br><span class="line">            <span class="string">'family'</span>: <span class="string">'Microsoft YaHei'</span>,</span><br><span class="line">            <span class="string">'style'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'weight'</span>: <span class="string">'normal'</span>,</span><br><span class="line">            <span class="string">'size'</span>: <span class="number">16</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.title = <span class="string">'标题'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Parse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> path_log <span class="keyword">in</span> self.path_logs:</span><br><span class="line">            log_name = path_log.split(<span class="string">'/'</span>)[<span class="number">-1</span>]</span><br><span class="line">            log = open(path_log)</span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> log.readlines():</span><br><span class="line">                <span class="keyword">if</span> <span class="string">'Flag_DataFrame'</span> <span class="keyword">in</span> line:</span><br><span class="line">                    self.num_frames_total += <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> <span class="string">'Flag_FrameLost'</span> <span class="keyword">in</span> line:</span><br><span class="line">                    self.num_frames_lost += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> self.num_frames_total <span class="keyword">is</span> <span class="keyword">not</span> <span class="number">0</span>:</span><br><span class="line">                self.list_valid_log_name.append(log_name.split(<span class="string">'_'</span>)[<span class="number">-1</span>].split(<span class="string">'.'</span>)[<span class="number">0</span>])</span><br><span class="line">                self.frame_lost_ratio = format(self.num_frames_lost / self.num_frames_total * <span class="number">100</span>, <span class="string">'.2f'</span>) <span class="keyword">if</span> self.num_frames_total <span class="keyword">is</span> <span class="keyword">not</span> <span class="number">0</span> <span class="keyword">else</span> <span class="string">'#NA'</span></span><br><span class="line">                self.list_frame_lost_percent.append(float(self.frame_lost_ratio))</span><br><span class="line">                self.list_frame_normal_percent.append(<span class="number">100</span> - float(self.frame_lost_ratio))</span><br><span class="line"></span><br><span class="line">            print(<span class="string">'\nlog file: &#123;&#125;'</span>.format(log_name))</span><br><span class="line">            print(<span class="string">'--------------------------------------------------------'</span>)</span><br><span class="line">            print(<span class="string">'num_frames_total: &#123;&#125;'</span>.format(self.num_frames_total))</span><br><span class="line">            print(<span class="string">' num_frames_lost: &#123;&#125;'</span>.format(self.num_frames_lost))</span><br><span class="line">            print(<span class="string">'frame_lost_ratio: &#123;&#125;%'</span>.format(self.frame_lost_ratio))</span><br><span class="line">            print(<span class="string">'--------------------------------------------------------\n'</span>)</span><br><span class="line"></span><br><span class="line">            self.num_frames_total = <span class="number">0</span></span><br><span class="line">            self.num_frames_lost = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">PlotSet</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(self.list_valid_log_name) <span class="keyword">is</span> <span class="keyword">not</span> <span class="number">0</span>:</span><br><span class="line">            ind = np.arange(len(self.list_valid_log_name))</span><br><span class="line">            <span class="comment"># bar的宽度</span></span><br><span class="line">            width = <span class="number">0.35</span></span><br><span class="line">            self.fig, self.ax = plt.subplots()</span><br><span class="line">            <span class="comment"># bar1</span></span><br><span class="line">            self.rects_frame_lost = self.ax.bar(</span><br><span class="line">                ind - width / <span class="number">2</span>,</span><br><span class="line">                self.list_frame_lost_percent,</span><br><span class="line">                width,</span><br><span class="line">                color=<span class="string">"tomato"</span>,</span><br><span class="line">                label=<span class="string">"label1"</span>)</span><br><span class="line">            <span class="comment"># bar2</span></span><br><span class="line">            self.rects_frame_normal = self.ax.bar(</span><br><span class="line">                ind + width / <span class="number">2</span>,</span><br><span class="line">                self.list_frame_normal_percent,</span><br><span class="line">                width,</span><br><span class="line">                color=<span class="string">"steelblue"</span>,</span><br><span class="line">                label=<span class="string">"label2"</span>)</span><br><span class="line">            <span class="comment"># 设置纵坐标标签</span></span><br><span class="line">            self.ax.set_ylabel(<span class="string">'百分比 (%)'</span>, fontdict=self.font)</span><br><span class="line">            <span class="comment"># 设置坐标轴刻度大小</span></span><br><span class="line">            plt.tick_params(labelsize=<span class="number">18</span>)</span><br><span class="line">            <span class="comment"># 设置标题</span></span><br><span class="line">            self.ax.set_title(self.title, fontdict=self.font)</span><br><span class="line">            <span class="comment"># 设置横坐标刻度</span></span><br><span class="line">            self.ax.set_xticks(ind)</span><br><span class="line">            <span class="comment"># 设置横坐标刻度标签</span></span><br><span class="line">            self.ax.set_xticklabels(self.list_valid_log_name, fontdict=self.font)</span><br><span class="line">            <span class="comment"># 设置图例：位置，字体</span></span><br><span class="line">            self.ax.legend(loc=<span class="string">'upper left'</span>, prop=self.font)</span><br><span class="line">            print(<span class="string">'average_frame_lost_ratio: &#123;&#125;%'</span>.format(round(np.mean(self.list_frame_lost_percent), <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AutoLabel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        为每一个bar打上标注</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">for</span> rects <span class="keyword">in</span> (self.rects_frame_lost, self.rects_frame_normal):</span><br><span class="line">            <span class="keyword">for</span> rect <span class="keyword">in</span> rects:</span><br><span class="line">                height = rect.get_height()</span><br><span class="line">                self.ax.text(</span><br><span class="line">                    rect.get_x() + rect.get_width() / <span class="number">2.</span>,</span><br><span class="line">                    height + <span class="number">1</span>,</span><br><span class="line">                    <span class="string">'%.2f'</span> % height,</span><br><span class="line">                    ha=<span class="string">'center'</span>,</span><br><span class="line">                    va=<span class="string">'bottom'</span>,</span><br><span class="line">                    fontsize=<span class="number">12</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    obj = GroupedBarChart()</span><br><span class="line">    obj.Parse()</span><br><span class="line">    obj.PlotSet()</span><br><span class="line">    obj.AutoLabel()</span><br><span class="line"></span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>运行上述 Python 代码，弹出 Figure 窗口，适当调整格式，调整并保存统计结果，如文首所示。点击<a href="/download/DEMO_GroupedBarChart.zip">这里</a>下载完整的工程 demo。</p>
<h1 id="后记" class="heading-control"><a href="#后记" class="headerlink" title="后记"></a>后记<a class="heading-anchor" href="#后记" aria-hidden="true"></a></h1><p>本文中使用 matplotlib 绘制双柱状图的 demo 具体结合了博主工作中的应用场景，更简洁纯粹的代码示例请查看 matplotlib 官网上的样例<span class="exturl" data-url="aHR0cHM6Ly9tYXRwbG90bGliLm9yZy9nYWxsZXJ5L2xpbmVzX2JhcnNfYW5kX21hcmtlcnMvYmFyY2hhcnQuaHRtbCNncm91cGVkLWJhci1jaGFydC13aXRoLWxhYmVscw==" title="https://matplotlib.org/gallery/lines_bars_and_markers/barchart.html#grouped-bar-chart-with-labels">Grouped bar chart with labels<i class="fa fa-external-link"></i></span>，官网上还给出了 matplotlib 所有绘图的<span class="exturl" data-url="aHR0cHM6Ly9tYXRwbG90bGliLm9yZy9nYWxsZXJ5L2luZGV4Lmh0bWw=" title="https://matplotlib.org/gallery/index.html">example<i class="fa fa-external-link"></i></span>以及详细的<span class="exturl" data-url="aHR0cHM6Ly9tYXRwbG90bGliLm9yZy90dXRvcmlhbHMvaW5kZXguaHRtbA==" title="https://matplotlib.org/tutorials/index.html">tutorial<i class="fa fa-external-link"></i></span>。</p>
<p>本文中 bar 的颜色分别是番茄红<code>tomato</code>和钢铁蓝<code>steelblue</code>，更多的颜色示例可以到<span class="exturl" data-url="aHR0cHM6Ly90b29sLm9zY2hpbmEubmV0L2NvbW1vbnM/dHlwZT0z" title="https://tool.oschina.net/commons?type=3">这里<i class="fa fa-external-link"></i></span>选择。</p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>Python</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Hexo + GitHub Pages搭建个人博客站点</title>
    <url>/archives/208e6058.html</url>
    <content><![CDATA[<h1 id="1-环境安装" class="heading-control"><a href="#1-环境安装" class="headerlink" title="1 环境安装"></a>1 环境安装<a class="heading-anchor" href="#1-环境安装" aria-hidden="true"></a></h1><h2 id="1-1-Node-js" class="heading-control"><a href="#1-1-Node-js" class="headerlink" title="1.1 Node.js"></a>1.1 Node.js<a class="heading-anchor" href="#1-1-Node-js" aria-hidden="true"></a></h2><p>Windows 平台直接到<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2VuLw==" title="https://nodejs.org/en/">Node.js 官网<i class="fa fa-external-link"></i></span>下载安装包进行安装（本文中所使用版本为 v12.14.1，为避免出现版本兼容性问题，请直接安装<span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2Rvd25sb2FkL3JlbGVhc2UvdjEyLjE0LjEv" title="https://nodejs.org/download/release/v12.14.1/">该版本<i class="fa fa-external-link"></i></span>）；Linux 平台未实操，请自行查询相关方法，也很简单。</p>
<h2 id="1-2-Git" class="heading-control"><a href="#1-2-Git" class="headerlink" title="1.2 Git"></a>1.2 Git<a class="heading-anchor" href="#1-2-Git" aria-hidden="true"></a></h2><p>Windows 平台直接到到<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZHM=" title="https://git-scm.com/downloads">Git 官网<i class="fa fa-external-link"></i></span>下载最新安装包进行安装（本文中所使用版本为 v2.20.1），安装完成后需配置 Git 相关环境变量，不再赘述；Linux 平台（以 Ubuntu 为例）直接通过终端命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<h2 id="1-3-Hexo" class="heading-control"><a href="#1-3-Hexo" class="headerlink" title="1.3 Hexo"></a>1.3 Hexo<a class="heading-anchor" href="#1-3-Hexo" aria-hidden="true"></a></h2><p>直接通过终端命令进行安装（本文中所使用版本为 v4.2，为避免出现版本兼容性问题，请直接安装该版本）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo@4.2.0</span><br></pre></td></tr></table></figure>
<h1 id="2-初始化" class="heading-control"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化<a class="heading-anchor" href="#2-初始化" aria-hidden="true"></a></h1><p>新建博客目录，进入该目录后通过终端命令进行初始化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<h1 id="3-主题安装" class="heading-control"><a href="#3-主题安装" class="headerlink" title="3 主题安装"></a>3 主题安装<a class="heading-anchor" href="#3-主题安装" aria-hidden="true"></a></h1><p>安装<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0" title="https://github.com/theme-next/hexo-theme-next">NexT 主题<i class="fa fa-external-link"></i></span>（本文中所使用版本为 v7.7.1，不同版本间往往差异较大，请直接使用该版本。此外，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3p0aHh4eC9oZXhvLXRoZW1lLVdpa2l0dGVu" title="https://github.com/zthxxx/hexo-theme-Wikitten">Wikitten 主题<i class="fa fa-external-link"></i></span>也很不错），两种方式：</p>
<ul>
<li>方法 1 - 直接下载主题 zip 压缩包，解压到 hexo/themes 目录下</li>
<li>方法 2 - 进入 hexo/themes 目录，直接克隆 GitHub 上的 NexT 主题（速度可能稍慢）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next</span><br></pre></td></tr></table></figure>
<blockquote>
<p>将解压或克隆后的主题目录修改为 next（其它名称也可，与 hexo/_config.yml 中的配置保持一致）</p>
</blockquote>
</li>
</ul>
<h1 id="4-配置" class="heading-control"><a href="#4-配置" class="headerlink" title="4 配置"></a>4 配置<a class="heading-anchor" href="#4-配置" aria-hidden="true"></a></h1><h2 id="4-1-站点配置" class="heading-control"><a href="#4-1-站点配置" class="headerlink" title="4.1 站点配置"></a>4.1 站点配置<a class="heading-anchor" href="#4-1-站点配置" aria-hidden="true"></a></h2><p>先配置站点配置文件 hexo/_config.yml 中的<code>Site</code> <code>URL</code> <code>Writing</code> <code>Extensions</code>相关项，后面涉及到主题配置时还需要配置其它内容：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">朝花夕拾</span> <span class="comment"># 站点标题</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">输出倒逼思考</span> <span class="comment"># 站点子标题</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">Stay</span> <span class="string">hungry,</span> <span class="string">stay</span> <span class="string">foolish.</span> <span class="comment"># 站点描述</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">ShiPeng</span> <span class="comment"># 站点作者</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span> <span class="comment"># 站点语言</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://blog.shipengx.com</span> <span class="comment"># 配置为你的GitHub Pages仓库地址或绑定的个人域名地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span> <span class="comment"># 新建文章时会生成同名文件夹，可以用于存放文章图片等素材</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">hexo-theme-next</span> <span class="comment"># 主题名称</span></span><br></pre></td></tr></table></figure>
<h2 id="4-2-主题配置" class="heading-control"><a href="#4-2-主题配置" class="headerlink" title="4.2 主题配置"></a>4.2 主题配置<a class="heading-anchor" href="#4-2-主题配置" aria-hidden="true"></a></h2><p>NexT 主题的可配置项非常丰富，配置文件为 hexo/themes/next/_config.yml，<span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZy9kb2NzLw==" title="https://theme-next.org/docs/">官方文档<i class="fa fa-external-link"></i></span>是非常好的参考资料。</p>
<h3 id="4-2-1-使能主题更新提醒" class="heading-control"><a href="#4-2-1-使能主题更新提醒" class="headerlink" title="4.2.1 使能主题更新提醒"></a>4.2.1 使能主题更新提醒<a class="heading-anchor" href="#4-2-1-使能主题更新提醒" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Console reminder if new version released.</span></span><br><span class="line"><span class="attr">reminder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-2-配置网站图标" class="heading-control"><a href="#4-2-2-配置网站图标" class="headerlink" title="4.2.2 配置网站图标"></a>4.2.2 配置网站图标<a class="heading-anchor" href="#4-2-2-配置网站图标" aria-hidden="true"></a></h3><p>将自己的网站图标（大小为 16x16 和 32x32）放到 hexo/themes/next/source/images 目录下，并修改主题配置文件<code>favicon</code>项的<code>small</code>和<code>medium</code>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/myfavicon-16x16.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/myfavicon-32x32.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<p>我的图标文件来自<span class="exturl" data-url="aHR0cHM6Ly93d3cuZWFzeWljb24ubmV0Lw==" title="https://www.easyicon.net/">这里<i class="fa fa-external-link"></i></span>。</p>
<h3 id="4-2-3-配置网站页脚" class="heading-control"><a href="#4-2-3-配置网站页脚" class="headerlink" title="4.2.3 配置网站页脚"></a>4.2.3 配置网站页脚<a class="heading-anchor" href="#4-2-3-配置网站页脚" aria-hidden="true"></a></h3><ul>
<li><p>设置显示内容</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="comment"># Specify the date when the site was setup. If not defined, current year will be used.</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2020</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Icon between year and copyright info.</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="comment"># Icon name in Font Awesome. See: https://fontawesome.com/v4.7.0/icons/</span></span><br><span class="line">    <span class="comment"># `heart` is recommended with animation in red (#ff0000).</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heart</span></span><br><span class="line">    <span class="comment"># If you want to animate the icon, set it to true.</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Change the color of icon, using Hex Code.</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">"#ff0000"</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># If not defined, `author` from Hexo `_config.yml` will be used.</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="comment"># Hexo link (Powered by Hexo).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of Hexo after Hexo link (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="comment"># Theme &amp; scheme info link (Theme - NexT.scheme).</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Version info of NexT after scheme info (vX.X.X).</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Beian ICP and gongan information for Chinese users. See: http://www.beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">icp:</span></span><br><span class="line">    <span class="comment"># The digit in the num of gongan beian.</span></span><br><span class="line">    <span class="attr">gongan_id:</span></span><br><span class="line">    <span class="comment"># The full num of gongan beian.</span></span><br><span class="line">    <span class="attr">gongan_num:</span></span><br><span class="line">    <span class="comment"># The icon for gongan beian. See: http://www.beian.gov.cn/portal/download</span></span><br><span class="line">    <span class="attr">gongan_icon_url:</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置 footer 居中（仅针对 Mist Scheme）<br>找到 hexo/themes/next/source/css/_schemes/Mist/_layout.styl，搜索<code>.footer-inner</code>，将其里面<code>text-align</code>的值设置为<code>center</code>：</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.footer-inner</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line"></span><br><span class="line">  +mobile() &#123;</span><br><span class="line">    <span class="attribute">text-align</span>: center;</span><br><span class="line">    <span class="attribute">width</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-4-添加-CC-License" class="heading-control"><a href="#4-2-4-添加-CC-License" class="headerlink" title="4.2.4 添加 CC License"></a>4.2.4 添加 CC License<a class="heading-anchor" href="#4-2-4-添加-CC-License" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-5-选择主题风格" class="heading-control"><a href="#4-2-5-选择主题风格" class="headerlink" title="4.2.5 选择主题风格"></a>4.2.5 选择主题风格<a class="heading-anchor" href="#4-2-5-选择主题风格" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="comment"># scheme: Gemini</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-6-为-menu-添加分类按钮" class="heading-control"><a href="#4-2-6-为-menu-添加分类按钮" class="headerlink" title="4.2.6 为 menu 添加分类按钮"></a>4.2.6 为 menu 添加<code>分类</code>按钮<a class="heading-anchor" href="#4-2-6-为-menu-添加分类按钮" aria-hidden="true"></a></h3><ul>
<li>新建 categories 对应的 page，在博客目录下执行终端命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n page categories</span><br></pre></td></tr></table></figure></li>
<li>设置 categories 页面类型，编辑 hexo/source/categories/index.md 为以下内容：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2020-01-30 15:03:34</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>comments: false</code>是为关闭本页面的评论系统（若配置了的话）</p>
</blockquote>
</li>
<li>修改主题配置文件的<code>menu</code>项，打开<code>categories</code>：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="comment">#about: /about/ || user</span></span><br><span class="line">  <span class="comment">#tags: /tags/ || tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || heartbeat</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以调换 menu 顺序，会直接反应到站点侧边栏的显示上</p>
</blockquote>
</li>
</ul>
<h3 id="4-2-7-使能-menu-icons-和-item-badges" class="heading-control"><a href="#4-2-7-使能-menu-icons-和-item-badges" class="headerlink" title="4.2.7 使能 menu icons 和 item badges"></a>4.2.7 使能 menu icons 和 item badges<a class="heading-anchor" href="#4-2-7-使能-menu-icons-和-item-badges" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Enable / Disable menu icons / item badges.</span></span><br><span class="line"><span class="attr">menu_settings:</span></span><br><span class="line">  <span class="attr">icons:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">badges:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-8-侧边栏、头像、社交相关" class="heading-control"><a href="#4-2-8-侧边栏、头像、社交相关" class="headerlink" title="4.2.8 侧边栏、头像、社交相关"></a>4.2.8 侧边栏、头像、社交相关<a class="heading-anchor" href="#4-2-8-侧边栏、头像、社交相关" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position.</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">left</span></span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Manual define the sidebar width. If commented, will be default for:</span></span><br><span class="line">  <span class="comment"># Muse | Mist: 320</span></span><br><span class="line">  <span class="comment"># Pisces | Gemini: 240</span></span><br><span class="line">  <span class="comment">#width: 300</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display (only for Muse | Mist), available values:</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically.</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  totally remove sidebar including sidebar toggle.</span></span><br><span class="line">  <span class="attr">display:</span> <span class="string">post</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar padding in pixels.</span></span><br><span class="line">  <span class="attr">padding:</span> <span class="number">18</span></span><br><span class="line">  <span class="comment"># Sidebar offset from top menubar in pixels (only for Pisces | Gemini).</span></span><br><span class="line">  <span class="attr">offset:</span> <span class="number">12</span></span><br><span class="line">  <span class="comment"># Enable sidebar on narrow view (only for Muse | Mist).</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/avatar.jpg</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Posts / Categories / Tags in sidebar.</span></span><br><span class="line"><span class="attr">site_state:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social Links</span></span><br><span class="line"><span class="comment"># Usage: `Key: permalink || icon`</span></span><br><span class="line"><span class="comment"># Key is the link label showing to end users.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target permalink, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/RocShi</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:RocShi@outlook.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="comment">#Weibo: https://weibo.com/yourname || weibo</span></span><br><span class="line">  <span class="comment">#Google: https://plus.google.com/yourname || google</span></span><br><span class="line">  <span class="comment">#Twitter: https://twitter.com/yourname || twitter</span></span><br><span class="line">  <span class="comment">#FB Page: https://www.facebook.com/yourname || facebook</span></span><br><span class="line">  <span class="comment">#StackOverflow: https://stackoverflow.com/yourname || stack-overflow</span></span><br><span class="line">  <span class="comment">#YouTube: https://youtube.com/yourname || youtube</span></span><br><span class="line">  <span class="comment">#Instagram: https://instagram.com/yourname || instagram</span></span><br><span class="line">  <span class="comment">#Skype: skype:yourname?call|chat || skype</span></span><br><span class="line">  <span class="comment">#RSS: /atom.xml || rss</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">transition:</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-9-配置侧边栏目录" class="heading-control"><a href="#4-2-9-配置侧边栏目录" class="headerlink" title="4.2.9 配置侧边栏目录"></a>4.2.9 配置侧边栏目录<a class="heading-anchor" href="#4-2-9-配置侧边栏目录" aria-hidden="true"></a></h3><p>修改主题配置文件的<code>toc</code>项：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc.</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-10-打赏" class="heading-control"><a href="#4-2-10-打赏" class="headerlink" title="4.2.10 打赏"></a>4.2.10 打赏<a class="heading-anchor" href="#4-2-10-打赏" aria-hidden="true"></a></h3><p>将 hexo/themes/hexo-theme-next/source/images 下的 wechatpay.png 和 alipay.png 分别替换为自己的微信收钱码与支付宝收钱码，并修改主题配置文件的<code>reward</code>项：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reward:</span></span><br><span class="line">  <span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.png</span></span><br><span class="line">  <span class="attr">alipay:</span> <span class="string">/images/alipay.jpg</span></span><br><span class="line"><span class="comment">#bitcoin: /images/bitcoin.png</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-11-相关文章推荐" class="heading-control"><a href="#4-2-11-相关文章推荐" class="headerlink" title="4.2.11 相关文章推荐"></a>4.2.11 相关文章推荐<a class="heading-anchor" href="#4-2-11-相关文章推荐" aria-hidden="true"></a></h3><ul>
<li>安装<code>hexo-related-popular-posts</code>插件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure></li>
<li>配置主题配置文件 hexo/themes/next/_config.yml 中的 related_posts<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">猜你喜欢</span> <span class="comment"># Custom header, leave empty to use the default one</span></span><br><span class="line"><span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">params:</span></span><br><span class="line">  <span class="attr">maxCount:</span> <span class="number">5</span></span><br><span class="line">  <span class="comment">#PPMixingRate: 0.0</span></span><br><span class="line">  <span class="comment">#isDate: false</span></span><br><span class="line">  <span class="comment">#isImage: false</span></span><br><span class="line">  <span class="comment">#isExcerpt: false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-12-代码块" class="heading-control"><a href="#4-2-12-代码块" class="headerlink" title="4.2.12 代码块"></a>4.2.12 代码块<a class="heading-anchor" href="#4-2-12-代码块" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line"><span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> <span class="string">solarized</span> <span class="string">dark</span></span><br><span class="line"><span class="comment"># Add copy button on codeblock</span></span><br><span class="line"><span class="attr">copy_button:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Show text copy result.</span></span><br><span class="line">  <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">  <span class="attr">style:</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-13-返回顶部" class="heading-control"><a href="#4-2-13-返回顶部" class="headerlink" title="4.2.13 返回顶部"></a>4.2.13 返回顶部<a class="heading-anchor" href="#4-2-13-返回顶部" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-14-阅读进度" class="heading-control"><a href="#4-2-14-阅读进度" class="headerlink" title="4.2.14 阅读进度"></a>4.2.14 阅读进度<a class="heading-anchor" href="#4-2-14-阅读进度" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">reading_progress:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available values: top | bottom</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">top</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">"#37c6c0"</span></span><br><span class="line">  <span class="attr">height:</span> <span class="string">3px</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-15-添加-GitHub-角标" class="heading-control"><a href="#4-2-15-添加-GitHub-角标" class="headerlink" title="4.2.15 添加 GitHub 角标"></a>4.2.15 添加 GitHub 角标<a class="heading-anchor" href="#4-2-15-添加-GitHub-角标" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">github_banner:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">permalink:</span> <span class="string">https://github.com/rocshi</span></span><br><span class="line">  <span class="attr">title:</span> <span class="string">Follow</span> <span class="string">me</span> <span class="string">on</span> <span class="string">GitHub</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-16-字体优化" class="heading-control"><a href="#4-2-16-字体优化" class="headerlink" title="4.2.16 字体优化"></a>4.2.16 字体优化<a class="heading-anchor" href="#4-2-16-字体优化" aria-hidden="true"></a></h3><p>本小节参考自<span class="exturl" data-url="aHR0cHM6Ly9ndWFucXIuY29tL3RlY2gvd2Vic2l0ZS93ZWItZm9udC1ndWlkZS8=" title="https://guanqr.com/tech/website/web-font-guide/">网站字体优化方案<i class="fa fa-external-link"></i></span>。</p>
<ul>
<li><p>配置主题配置文件 hexo/themes/next/_config.yml 中的 font 相关项，注意全局字体应设定为英文字体，避免设置为中文字体导致英文字体也被覆盖，中文字体稍后设置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Uri of fonts host, e.g. //fonts.googleapis.com (Default).</span></span><br><span class="line"><span class="attr">host:</span> <span class="string">fonts.loli.net</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Font options:</span></span><br><span class="line"><span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line"><span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line"><span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line"><span class="attr">global:</span></span><br><span class="line">  <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">family:</span> <span class="string">EB</span> <span class="string">Garamond</span></span><br><span class="line">  <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line"><span class="attr">title:</span></span><br><span class="line">  <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">family:</span> <span class="string">Cinzel</span> <span class="string">Decorative</span></span><br><span class="line">  <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line"><span class="attr">headings:</span></span><br><span class="line">  <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span></span><br><span class="line">  <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Font settings for posts (.post-body).</span></span><br><span class="line"><span class="attr">posts:</span></span><br><span class="line">  <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Font settings for &lt;code&gt; and code blocks.</span></span><br><span class="line"><span class="attr">codes:</span></span><br><span class="line">  <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">family:</span> <span class="string">Source</span> <span class="string">Code</span> <span class="string">Pro</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 hexo/themes/next/source/css/_variables/base.styl 中的中文字体</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// Font families.</span><br><span class="line"><span class="deletion">- $font-family-chinese      = "PingFang SC", "Microsoft YaHei";</span></span><br><span class="line"><span class="addition">+ $font-family-chinese      = "Noto Serif SC";</span></span><br></pre></td></tr></table></figure></li>
<li><p>在 hexo/source/_data/head.swig 中添加中文字体<code>Noto Serif SC</code>的<code>&lt;link&gt;</code>代码段<br>进入<span class="exturl" data-url="aHR0cHM6Ly9mb250cy5nb29nbGUuY29tLw==" title="https://fonts.google.com/">Google Fonts<i class="fa fa-external-link"></i></span>，搜索<code>Noto Serif SC</code>，按照下面动图中所示获取字体的<code>&lt;link&gt;</code>代码，其它字体操作相同</p>
<p><img data-src="https://image.shipengx.com/%E5%9C%A8Google%20Fonts%E4%B8%8A%E6%9F%A5%E6%89%BE%E5%96%9C%E6%AC%A2%E7%9A%84%E5%AD%97%E4%BD%93.gif" alt="在Google Fonts上查找喜欢的字体"></p>
<p>将<code>&lt;link&gt;</code>代码中的将<code>googleapis.com</code>修改为<code>loli.net</code>后添加到 hexo/source/_data/head.swig 中</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="addition">+ &lt;link href="https://fonts.loli.net/css2?family=Noto+Serif+SC:wght@400;500;700&amp;display=swap" rel="stylesheet"&gt;</span></span><br></pre></td></tr></table></figure>
<p>若 hexo/source/_data/head.swig 文件不存在，需要开启 hexo/themes/next/_config.yml 中<code>custom_file_path</code>的相关选项，默认是注释掉的</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.swig</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑到宋体的笔画要比黑体细，编辑 hexo/source/_data/styles.styl，自定义 CSS 将字体颜色加深</p>
<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 hexo/source/_data/styles.styl 文件不存在，需要开启 hexo/themes/next/_config.yml 中<code>custom_file_path</code>的相关选项，默认也是注释掉的</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">head:</span> <span class="string">source/_data/head.swig</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.swig</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.swig</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.swig</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.swig</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.swig</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.swig</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-17-使能顶部加载条" class="heading-control"><a href="#4-2-17-使能顶部加载条" class="headerlink" title="4.2.17 使能顶部加载条"></a>4.2.17 使能顶部加载条<a class="heading-anchor" href="#4-2-17-使能顶部加载条" aria-hidden="true"></a></h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">pace:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Themes list:</span></span><br><span class="line">  <span class="comment"># big-counter | bounce | barber-shop | center-atom | center-circle | center-radar | center-simple</span></span><br><span class="line">  <span class="comment"># corner-indicator | fill-left | flat-top | flash | loading-bar | mac-osx | material | minimal</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">minimal</span></span><br></pre></td></tr></table></figure>
<h3 id="4-2-18-添加-sitemap" class="heading-control"><a href="#4-2-18-添加-sitemap" class="headerlink" title="4.2.18 添加 sitemap"></a>4.2.18 添加 sitemap<a class="heading-anchor" href="#4-2-18-添加-sitemap" aria-hidden="true"></a></h3><ul>
<li>安装<code>hexo-generator-sitemap</code>插件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure></li>
<li>在站点配置文件 hexo/_config.yml 中添加<code>plugins</code>配置项<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/</span></span><br><span class="line"><span class="attr">plugins:</span> <span class="string">hexo-generator-sitemap</span></span><br></pre></td></tr></table></figure></li>
<li>配置主题配置文件 hexo/themes/next/_config.yml 中的 sitemap menu<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">/sitemap.xml</span> <span class="string">||</span> <span class="string">sitemap</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-19-开启站内搜索" class="heading-control"><a href="#4-2-19-开启站内搜索" class="headerlink" title="4.2.19 开启站内搜索"></a>4.2.19 开启站内搜索<a class="heading-anchor" href="#4-2-19-开启站内搜索" aria-hidden="true"></a></h3><ul>
<li>安装<code>hexo-generator-searchdb</code>插件，在博客目录下执行终端命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure></li>
<li>在站点配置文件 hexo/_config.yml 中添加如下代码：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure></li>
<li>配置主题配置文件 hexo/themes/next/_config.yml 中的<code>local_search</code>项<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Local Search</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/hexo-generator-searchdb</span></span><br><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If auto, trigger search by changing input.</span></span><br><span class="line">  <span class="comment"># If manual, trigger search by pressing enter key or search button.</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span></span><br><span class="line">  <span class="comment"># Show top n results per article, show all results by setting to -1</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span></span><br><span class="line">  <span class="comment"># Unescape html strings to the readable one.</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Preload the search data when the page loads.</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-20-SEO-优化" class="heading-control"><a href="#4-2-20-SEO-优化" class="headerlink" title="4.2.20 SEO 优化"></a>4.2.20 SEO 优化<a class="heading-anchor" href="#4-2-20-SEO-优化" aria-hidden="true"></a></h3><ul>
<li><p>SEO 优化较为复杂，可参考<span class="exturl" data-url="aHR0cHM6Ly9ob3hpcy5naXRodWIuaW8vSGV4bytOZXh0JTIwU0VPJUU0JUJDJTk4JUU1JThDJTk2Lmh0bWw=" title="https://hoxis.github.io/Hexo+Next%20SEO%E4%BC%98%E5%8C%96.html">这篇文章<i class="fa fa-external-link"></i></span>，HTML 元标记中的 content 直接添加至主题配置文件对应位置即可完成站点验证，无需添加至 head.swig；也可以参考<span class="exturl" data-url="aHR0cHM6Ly9mbHVuZ2dnLmNuL2FyY2hpdmVzLzZiMTA0YjRlLmh0bWw=" title="https://flunggg.cn/archives/6b104b4e.html">这篇文章<i class="fa fa-external-link"></i></span>：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># SEO Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable Baidu transformation on mobile devices.</span></span><br><span class="line"><span class="attr">disable_baidu_transformation:</span> <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set a canonical link tag for your Hexo site.</span></span><br><span class="line"><span class="comment"># See: https://support.google.com/webmasters/answer/139066</span></span><br><span class="line"><span class="comment"># Remember to set up your URL in Hexo `_config.yml` (e.g. url: http://yoursite.com)</span></span><br><span class="line"><span class="attr">canonical:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Change headers hierarchy on site-subtitle (will be main site description) and on all post / page titles for better SEO-optimization.</span></span><br><span class="line"><span class="attr">seo:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># If true, site-subtitle will be added to index page.</span></span><br><span class="line"><span class="comment"># Remember to set up your site-subtitle in Hexo `_config.yml` (e.g. subtitle: Subtitle)</span></span><br><span class="line"><span class="attr">index_with_subtitle:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically add external URL with Base64 encrypt &amp; decrypt.</span></span><br><span class="line"><span class="attr">exturl:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters</span></span><br><span class="line"><span class="attr">google_site_verification:</span> <span class="comment"># 向Google提交网站时将HTML元标记content填到此处</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Bing Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://www.bing.com/webmaster</span></span><br><span class="line"><span class="attr">bing_site_verification:</span> <span class="comment"># 向百度提交网站时将HTML元标记content填到此处</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Yandex Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://webmaster.yandex.ru</span></span><br><span class="line"><span class="attr">yandex_site_verification:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Webmaster tools verification.</span></span><br><span class="line"><span class="comment"># See: https://ziyuan.baidu.com/site</span></span><br><span class="line"><span class="attr">baidu_site_verification:</span> <span class="comment"># 向必应提交网站时将HTML元标记content填到此处</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEO.</span></span><br><span class="line"><span class="attr">baidu_push:</span> <span class="literal">true</span> <span class="comment"># 开启自动向百度提交URL</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>文章 URL 优化<br>首先，安装<code>hexo-abbrlink</code>插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>
<p>然后，站点配置文件的<code>permalink</code>项，并添加<code>abbrlink</code>项</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">archives/:abbrlink.html</span></span><br><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span> <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span> <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-21-开启图片灯箱" class="heading-control"><a href="#4-2-21-开启图片灯箱" class="headerlink" title="4.2.21 开启图片灯箱"></a>4.2.21 开启图片灯箱<a class="heading-anchor" href="#4-2-21-开启图片灯箱" aria-hidden="true"></a></h3><ul>
<li>在主题配置文件中使能该功能<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.</span></span><br><span class="line"><span class="comment"># For more information: https://fancyapps.com/fancybox</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></li>
<li>配置 CDN<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># FancyBox</span></span><br><span class="line"><span class="comment"># jquery: //cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js</span></span><br><span class="line"><span class="comment"># fancybox: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js</span></span><br><span class="line"><span class="comment"># fancybox_css: //cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css</span></span><br><span class="line"><span class="attr">jquery:</span> <span class="string">//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="string">//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js</span></span><br><span class="line"><span class="attr">fancybox_css:</span> <span class="string">//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css</span></span><br></pre></td></tr></table></figure></li>
<li>设置图片居中（仅针对 Mist Scheme）<br>参考了<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLnNpbmdlZS5tZS8yMDE3LzEyLzA3L21pc3QtaW1nLWNlbnRlci8=" title="https://blog.singee.me/2017/12/07/mist-img-center/">这篇文章<i class="fa fa-external-link"></i></span>，找到 hexo/themes/next/source/css/_schemes/Mist/_posts-expend.styl，搜索<code>.post-body img</code>，将其里面<code>margin-left</code>的值设置为<code>0 auto</code>：<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-body</span> <span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-22-修改文章内链接的样式" class="heading-control"><a href="#4-2-22-修改文章内链接的样式" class="headerlink" title="4.2.22 修改文章内链接的样式"></a>4.2.22 修改文章内链接的样式<a class="heading-anchor" href="#4-2-22-修改文章内链接的样式" aria-hidden="true"></a></h3><p>参考<span class="exturl" data-url="aHR0cDovL2plZmZ5YW5nLnRvcC9IZXhvL0hleG8lRTQlQjglQkIlRTklQTIlOThOZXh0JUU3JUJFJThFJUU1JThDJTk2Lw==" title="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/">这篇文章<i class="fa fa-external-link"></i></span>，v7.7.1 版本的 NexT 主题中的添加位置为 hexo/themes/next/source/css/main.styl</p>
<h3 id="4-2-23-添加-valine-评论系统" class="heading-control"><a href="#4-2-23-添加-valine-评论系统" class="headerlink" title="4.2.23 添加 valine 评论系统"></a>4.2.23 添加 valine 评论系统<a class="heading-anchor" href="#4-2-23-添加-valine-评论系统" aria-hidden="true"></a></h3><ul>
<li>参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9mNDY1OGRmNjZhMTU=" title="https://www.jianshu.com/p/f4658df66a15">这篇文章<i class="fa fa-external-link"></i></span>添加 valine 评论系统</li>
<li>为 valine 开启 CDN<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Valine</span></span><br><span class="line"><span class="comment"># valine: //cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js</span></span><br><span class="line"><span class="comment"># valine: //cdnjs.cloudflare.com/ajax/libs/valine/1.3.10/Valine.min.js</span></span><br><span class="line"><span class="attr">valine:</span> <span class="string">//cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js</span></span><br></pre></td></tr></table></figure></li>
<li>通过<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3poYW9qdW4xOTk4L1ZhbGluZS1BZG1pbg==" title="https://github.com/zhaojun1998/Valine-Admin">Valine 扩展应用<i class="fa fa-external-link"></i></span>增强 Valine 的邮件通知功能，实践中将邮件发送方指定为了个人 QQ 邮箱，将邮件接收方指定为了个人 outlook 邮箱，功能测试正常。如果评论收不到邮件通知，请检查 Leancloud 云引擎的的环境变量是否正确设置，尤其是 <code>SMTP_PASS</code> 参数（一般为邮件服务商的授权码）</li>
</ul>
<h3 id="4-2-24-配置-canvas-nest-背景效果" class="heading-control"><a href="#4-2-24-配置-canvas-nest-背景效果" class="headerlink" title="4.2.24 配置 canvas_nest 背景效果"></a>4.2.24 配置 canvas_nest 背景效果<a class="heading-anchor" href="#4-2-24-配置-canvas-nest-背景效果" aria-hidden="true"></a></h3><ul>
<li>在主题配置文件中使能该选项<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">canvas_nest:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">onmobile:</span> <span class="literal">true</span> <span class="comment"># Display on mobile or not</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">"0,0,255"</span> <span class="comment"># RGB values, use `,` to separate</span></span><br><span class="line">  <span class="attr">opacity:</span> <span class="number">0.5</span> <span class="comment"># The opacity of line: 0~1</span></span><br><span class="line">  <span class="attr">zIndex:</span> <span class="number">-1</span> <span class="comment"># z-index property of the background</span></span><br><span class="line">  <span class="attr">count:</span> <span class="number">99</span> <span class="comment"># The number of lines</span></span><br></pre></td></tr></table></figure></li>
<li>配置 CDN<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Internal version: 1.0.0</span></span><br><span class="line"><span class="comment"># canvas_nest: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js</span></span><br><span class="line"><span class="comment"># canvas_nest_nomobile: //cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js</span></span><br><span class="line"><span class="attr">canvas_nest:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest.min.js</span></span><br><span class="line"><span class="attr">canvas_nest_nomobile:</span> <span class="string">//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1/canvas-nest-nomobile.min.js</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-25-配置标题锚点" class="heading-control"><a href="#4-2-25-配置标题锚点" class="headerlink" title="4.2.25 配置标题锚点"></a>4.2.25 配置标题锚点<a class="heading-anchor" href="#4-2-25-配置标题锚点" aria-hidden="true"></a></h3><ul>
<li>在博客目录下安装<code>hexo-theme-next-anchor</code>插件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next-anchor</span><br></pre></td></tr></table></figure></li>
<li>在主题配置文件中添加如下内容：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">anchor:</span></span><br><span class="line"><span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">color:</span> <span class="string">"#0e83cd"</span></span><br><span class="line"><span class="attr">position:</span> <span class="string">right</span> <span class="comment"># If left, anchors will always be visible.</span></span><br><span class="line"><span class="attr">margin:</span> <span class="string">7px</span></span><br><span class="line"><span class="attr">text:</span> <span class="string">"#"</span></span><br><span class="line"><span class="attr">icon:</span></span><br><span class="line">  <span class="comment"># If true, the `text` option will be ignored.</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># By default, NexT has built-in FontAwesome support.</span></span><br><span class="line">  <span class="comment"># This option means `font-family: FontAwesome`, so DO Not change it.</span></span><br><span class="line">  <span class="comment"># Also you can choose ForkAwesome, but that's another story.</span></span><br><span class="line">  <span class="attr">font:</span> <span class="string">FontAwesome</span></span><br><span class="line">  <span class="attr">content:</span> <span class="string">\f0c1</span> <span class="comment"># CSS content for FontAwesome &amp; ForkAwesome.</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-26-为归档页面添加十二生肖图标" class="heading-control"><a href="#4-2-26-为归档页面添加十二生肖图标" class="headerlink" title="4.2.26 为归档页面添加十二生肖图标"></a>4.2.26 为归档页面添加十二生肖图标<a class="heading-anchor" href="#4-2-26-为归档页面添加十二生肖图标" aria-hidden="true"></a></h3><ul>
<li>首先，点击<a href="/download/chinese-zodiac.zip">这里</a>下载十二生肖字体。下载后将解压的三个字体文件全部放在 hexo/source/fonts/目录下（若无 fonts 文件夹需要自行创建）</li>
<li>然后，编辑 hexo/themes/next/layout/_macro/post-collapse.swig 文件<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &lt;&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125; class="collection-header"&gt;&#123;&#123; current_year &#125;&#125;&lt;/&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125;&gt;</span></span><br><span class="line"><span class="addition">+ &lt;&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125; class="collection-header"&gt;&#123;&#123; current_year &#125;&#125;</span></span><br><span class="line"><span class="addition">+   &lt;div class="chinese-zodiac"&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 0 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-monkey"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 1 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-rooster"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 2 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-dog"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 3 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-pig"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 4 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-rat"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 5 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-ox"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 6 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-tiger"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 7 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-rabbit"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 8 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-dragon"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 9 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-snake"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 10 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-horse"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+     &#123;%- if current_year % 12 == 11 %&#125;</span></span><br><span class="line"><span class="addition">+       &lt;i class="symbolic-animals icon-goat"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="addition">+     &#123;%- endif %&#125;</span></span><br><span class="line"><span class="addition">+   &lt;/div&gt;</span></span><br><span class="line"><span class="addition">+ &lt;/&#123;%- if theme.seo %&#125;h2&#123;% else %&#125;h1&#123;%- endif %&#125;&gt;</span></span><br></pre></td></tr></table></figure>
最后，编辑 hexo/source/_data/styles.styl，添加自定义样式<figure class="highlight styl"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.chinese-zodiac</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">&#125;</span><br><span class="line">@font-face &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'chinese-zodiac'</span>;</span><br><span class="line">  <span class="attribute">font</span>-display: swap;</span><br><span class="line">  src: url('/fonts/chinese-zodiac.eot');</span><br><span class="line">  src: url(<span class="string">'/fonts/chinese-zodiac.eot'</span>) format(<span class="string">'embedded-opentype'</span>),</span><br><span class="line">       url(<span class="string">'/fonts/chinese-zodiac.woff2'</span>) format(<span class="string">'woff2'</span>),</span><br><span class="line">       url('/fonts/chinese-zodiac.woff') format('woff');</span><br><span class="line">  <span class="attribute">font-weight</span>: normal;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.symbolic-animals</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">font</span>: normal normal normal <span class="number">14px</span>/<span class="number">1</span> chinese-zodiac;</span><br><span class="line">  <span class="attribute">font-size</span>: inherit;</span><br><span class="line">  <span class="attribute">text-rendering</span>: auto;</span><br><span class="line">  -webkit-<span class="attribute">font</span>-smoothing: antialiased;</span><br><span class="line">  -moz-osx-<span class="attribute">font</span>-smoothing: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.icon-dragon</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e806'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-tiger</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e809'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-pig</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e810'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-horse</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e813'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-rat</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e816'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-goat</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e818'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-snake</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e820'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-ox</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e822'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-dog</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e825'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-rabbit</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e826'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-monkey</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e829'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br><span class="line"><span class="selector-class">.icon-rooster</span>:before &#123; <span class="attribute">content</span>: <span class="string">'\e82f'</span>; <span class="attribute">font-size</span>: <span class="number">35px</span>;&#125;</span><br></pre></td></tr></table></figure>
若 hexo/source/_data/styles.styl 文件不存在，需要开启 hexo/themes/next/_config.yml 中<code>custom_file_path</code>的相关选项，默认是注释掉的<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
添加后的效果请查看<a href="https://blog.shipengx.com/archives/">这里</a>，还是很有意思的。</li>
</ul>
<h3 id="4-2-27-添加数学公式渲染支持" class="heading-control"><a href="#4-2-27-添加数学公式渲染支持" class="headerlink" title="4.2.27 添加数学公式渲染支持"></a>4.2.27 添加数学公式渲染支持<a class="heading-anchor" href="#4-2-27-添加数学公式渲染支持" aria-hidden="true"></a></h3><p>Hexo 默认使用<code>hexo-render-marked</code>渲染引擎将 markdown 文件渲染为静态 HTML 文件，但该引擎会把一些特殊的 markdown 符号转换为相应的 HTML 标签，因为类 LaTex 格式书写的数学公式下划线’_‘表示下标，有特殊的含义，如果被强制转换为<code>&lt;em&gt;</code>标签，那么 MathJax 引擎在渲染数学公式的时候就会出错。例如，$x_i$在开始被渲染的时候，处理为$x<em>i</em>$，这样 MathJax 引擎就认为该公式有语法错误，不会渲染。解决办法：</p>
<ul>
<li>将渲染引擎更换为<code>hexo-renderer-kramed</code><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure></li>
<li>编辑 hexo/node_modules/kramed/lib/rules/inline.js，解决<code>hexo-renderer-kramed</code>引擎语义冲突造成的行内公式渲染问题<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">var inline = &#123;</span><br><span class="line"><span class="deletion">- escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line"><span class="addition">+ escape: /^\\([`*\[\]()#$+\-.!_&gt;])/,</span></span><br><span class="line">  autolink: /^&lt;([^ &gt;]+(@|:\/)[^ &gt;]+)&gt;/,</span><br><span class="line">  url: noop,</span><br><span class="line">  html: /^&lt;!--[\s\S]*?--&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)*?(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;([\s\S]*?)?&lt;\/\1&gt;|^&lt;(\w+(?!:\/|[^\w\s@]*@)\b)(?:"[^"]*"|'[^']*'|[^'"&gt;])*?&gt;/,</span><br><span class="line">  link: /^!?\[(inside)\]\(href\)/,</span><br><span class="line">  reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,</span><br><span class="line">  nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,</span><br><span class="line">  reffn: /^!?\[\^(inside)\]/,</span><br><span class="line">  strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,</span><br><span class="line"><span class="deletion">- em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line"><span class="addition">+ em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span></span><br><span class="line">  code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,</span><br><span class="line">  br: /^ &#123;2,&#125;\n(?!\s*$)/,</span><br><span class="line">  del: noop,</span><br><span class="line">  text: /^[\s\S]+?(?=[\\&lt;!\[_*`$]| &#123;2,&#125;\n|$)/,</span><br><span class="line">  math: /^\$\$\s*([\s\S]*?[^\$])\s*\$\$(?!\$)/,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>配置主题配置文件中的 MathJax 配置项</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Math Formulas Render Support</span></span><br><span class="line"><span class="attr">math:</span></span><br><span class="line">  <span class="comment"># Default (true) will load mathjax / katex script on demand.</span></span><br><span class="line">  <span class="comment"># That is it only render those page which has `mathjax: true` in Front-matter.</span></span><br><span class="line">  <span class="comment"># If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-pandoc (or hexo-renderer-kramed) required for full MathJax support.</span></span><br><span class="line">  <span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) required for full Katex support.</span></span><br><span class="line">  <span class="attr">katex:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># See: https://github.com/KaTeX/KaTeX/tree/master/contrib/copy-tex</span></span><br><span class="line">    <span class="attr">copy_tex:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置主题配置文件中的 MathJax CDN 加速</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># MathJax</span></span><br><span class="line"><span class="comment"># mathjax: //cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line"><span class="comment"># mathjax: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML</span></span><br><span class="line"><span class="comment"># mhchem: //cdn.jsdelivr.net/npm/mathjax-mhchem@3</span></span><br><span class="line"><span class="comment"># mhchem: //cdnjs.cloudflare.com/ajax/libs/mathjax-mhchem/3.3.0</span></span><br><span class="line"><span class="attr">mathjax:</span> <span class="string">//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML</span></span><br><span class="line"><span class="attr">mhchem:</span> <span class="string">//cdn.jsdelivr.net/npm/mathjax-mhchem@3</span></span><br></pre></td></tr></table></figure></li>
<li>为需要公式渲染的文章的 Front-matter 里打开 mathjax 开关，之所以要在文章头里设置开关，是因为考虑只有在用到公式的页面才加载 Mathjax，这样不需要渲染数学公式的页面的访问速度就不会受到影响了<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">  ---</span><br><span class="line">  title: C++ Primer - 第2章 变量和基本类型</span><br><span class="line">  categories:</span><br><span class="line">  - 技术</span><br><span class="line">  - 程序语言</span><br><span class="line">  - C/C++</span><br><span class="line">  - 《C++ Primer》</span><br><span class="line">  tags:</span><br><span class="line">  - C/C++</span><br><span class="line">  - C++ Primer</span><br><span class="line">  description: 本系列文章为阅读《C++ Primer》过程中的书摘与学习笔记，持续更新。</span><br><span class="line">  abbrlink: e005f4cb</span><br><span class="line"><span class="addition">+ mathjax: true</span></span><br><span class="line">  ---</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-28-添加豆瓣读书" class="heading-control"><a href="#4-2-28-添加豆瓣读书" class="headerlink" title="4.2.28 添加豆瓣读书"></a>4.2.28 添加豆瓣读书<a class="heading-anchor" href="#4-2-28-添加豆瓣读书" aria-hidden="true"></a></h3><ul>
<li>在博客目录下安装<code>hexo-douban</code>插件，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL215dGhzbWFuL2hleG8tZG91YmFu" title="https://github.com/mythsman/hexo-douban">这里<i class="fa fa-external-link"></i></span>是插件的 git 仓库<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-douban --save</span><br></pre></td></tr></table></figure></li>
<li>在站点配置文件 hexo/_config.yml 中增加如下配置<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">douban:</span></span><br><span class="line">  <span class="attr">user:</span> <span class="string">mythsman</span></span><br><span class="line">  <span class="attr">builtin:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">book:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">"读书"</span></span><br><span class="line">    <span class="attr">quote:</span> <span class="string">"那些你读过的书"</span></span><br><span class="line">  <span class="comment"># movie:</span></span><br><span class="line">  <span class="comment"># title: 'This is my movie title'</span></span><br><span class="line">  <span class="comment"># quote: 'This is my movie quote'</span></span><br><span class="line">  <span class="comment"># game:</span></span><br><span class="line">  <span class="comment"># title: 'This is my game title'</span></span><br><span class="line">  <span class="comment"># quote: 'This is my game quote'</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<strong>user</strong>: 你的豆瓣 ID。打开豆瓣，登入账户，然后在右上角点击 “个人主页” ，这时候地址栏的 URL 大概是这样：”<span class="exturl" data-url="aHR0cHM6Ly93d3cuZG91YmFuLmNvbS9wZW9wbGUveHh4eHh4Lw==" title="https://www.douban.com/people/xxxxxx/">https://www.douban.com/people/xxxxxx/<i class="fa fa-external-link"></i></span>“ ，其中的”xxxxxx”就是你的个人 ID；<br><strong>builtin</strong>: 是否将生成页面的功能嵌入<code>hexo s</code>和<code>hexo g</code>中，默认是 false,另一可选项为 true(1.x.x 版本新增配置项)；<br><strong>title</strong>: 该页面的标题；<br><strong>quote</strong>: 写在页面开头的一段话,支持 html 语法；<br><strong>timeout</strong>: 爬取数据的超时时间，默认是 10000ms，如果在使用时发现报了超时的错(ETIMEOUT)可以把这个数据设置的大一点。</li>
<li>在主题配置文件 hexo/themes/next/_config.yml 中添加 books 的菜单按钮<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">home</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">th</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">tags</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">archive</span></span><br><span class="line">  <span class="attr">books:</span> <span class="string">/books/</span> <span class="string">||</span> <span class="string">book</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">/about/</span> <span class="string">||</span> <span class="string">user</span></span><br></pre></td></tr></table></figure></li>
<li>中文化 books 菜单按钮，修改 hexo/themes/hexo-theme-next/languages/zh-CN.yml<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">首页</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">归档</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">分类</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">标签</span></span><br><span class="line">  <span class="attr">about:</span> <span class="string">关于</span></span><br><span class="line">  <span class="attr">search:</span> <span class="string">搜索</span></span><br><span class="line">  <span class="attr">schedule:</span> <span class="string">日程表</span></span><br><span class="line">  <span class="attr">sitemap:</span> <span class="string">站点地图</span></span><br><span class="line">  <span class="attr">commonweal:</span> <span class="string">公益</span> <span class="number">404</span></span><br><span class="line">  <span class="attr">books:</span> <span class="string">读书</span></span><br></pre></td></tr></table></figure></li>
<li>在主题配置文件 hexo/themes/next/_config.yml 中开启 lazyload 选项<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Vanilla JavaScript plugin for lazyloading images.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/ApoorvSaxena/lozad.js</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
配置 lazyload 的 CDN 加速<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Lazyload</span></span><br><span class="line"><span class="comment"># lazyload: //cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js</span></span><br><span class="line"><span class="comment"># lazyload: //cdnjs.cloudflare.com/ajax/libs/lozad.js/1.9.0/lozad.min.js</span></span><br><span class="line"><span class="attr">lazyload:</span> <span class="string">//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js</span></span><br></pre></td></tr></table></figure></li>
<li>在主题配置文件 hexo/themes/next/_config.yml 中关闭 pjax 选项（若开启了的话）<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Easily enable fast Ajax navigation on your website.</span></span><br><span class="line"><span class="comment"># Dependencies: https://github.com/theme-next/theme-next-pjax</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
关闭了 pjax 后，在博客站点页面间互相访问时每次都会刷新页面，会稍微降低访问速度，但影响不大。</li>
</ul>
<p>若未开启 lazyload 且未关闭 pjax，则会出现如下情况：<br><img data-src="https://blog.shipengx.com/archives/208e6058/%E6%97%A0%E6%B3%95%E6%8C%81%E7%BB%AD%E6%AD%A3%E5%B8%B8%E6%98%BE%E7%A4%BA%E8%B1%86%E7%93%A3%E8%AF%BB%E4%B9%A6%E9%A1%B5%E9%9D%A2.gif" alt="无法持续正常显示豆瓣读书页面"></p>
<p>此外，使用中发现，新版的 Node.js（v14.16.1）会导致豆瓣插件抓不到个人数据，所以请务必使用上文中指定版本的 Node.js。</p>
<h3 id="4-2-29-在博客中隐藏指定文章" class="heading-control"><a href="#4-2-29-在博客中隐藏指定文章" class="headerlink" title="4.2.29 在博客中隐藏指定文章"></a>4.2.29 在博客中隐藏指定文章<a class="heading-anchor" href="#4-2-29-在博客中隐藏指定文章" aria-hidden="true"></a></h3><p>有时，我们可能面临这样一种应用场景：同时在写多篇文章，其中某篇文章尚未完成，而其它文章已完成，我们希望将已完成的文章呈现在我们的 hexo 博客中，而暂时隐藏尚未完成的文章。这个需求可以通过 <code>hexo-hide-posts</code> 插件完成，步骤如下：</p>
<ul>
<li><p>在博客目录下安装 <code>hexo-hide-posts</code> 插件，<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3ByaW50ZW1wdy9oZXhvLWhpZGUtcG9zdHMvYmxvYi9tYXN0ZXIvUkVBRE1FX1pILm1k" title="https://github.com/printempw/hexo-hide-posts/blob/master/README_ZH.md">这里<i class="fa fa-external-link"></i></span>是插件的 git 仓库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-hide-posts --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在站点配置文件 hexo/_config.yml 中增加如下配置</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexo-hide-posts</span></span><br><span class="line"><span class="attr">hide_posts:</span></span><br><span class="line">  <span class="comment"># 可以改成其他你喜欢的名字</span></span><br><span class="line">  <span class="attr">filter:</span> <span class="string">hidden</span></span><br><span class="line">  <span class="comment"># 指定你想要传递隐藏文章的 generator，比如让所有隐藏文章在存档页面可见</span></span><br><span class="line">  <span class="comment"># 常见的 generators 有：index, tag, category, archive, sitemap, feed, etc.</span></span><br><span class="line">  <span class="attr">public_generators:</span> <span class="string">[]</span></span><br><span class="line">  <span class="comment"># 为隐藏的文章添加 noindex meta 标签，阻止搜索引擎收录</span></span><br><span class="line">  <span class="attr">noindex:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>例如，如果设置 <code>filter: hide</code> 后，就可以通过在 front-matter 中添加 <code>hide: true</code> 字段来隐藏文章了；<code>public_generators</code> 字段指定的是隐藏的文章在博客的哪些页面可见，例如，如果设置了 <code>public_generators: [archive]</code> 后，隐藏的文章将只在存档页面可见，在首页等其它页面不可见。</p>
</li>
<li><p>在文章的 front-matter 中添加 <code>filter</code> 相关控制字段</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hide: true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>值得注意的是，隐藏的文章仍可通过链接访问，前提是访问者知道文章对应链接。</p>
<h1 id="5-新建文章" class="heading-control"><a href="#5-新建文章" class="headerlink" title="5 新建文章"></a>5 新建文章<a class="heading-anchor" href="#5-新建文章" aria-hidden="true"></a></h1><p>先将 post 模板 hexo/scaffolds/post.md 中的内容修改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: &#123;&#123; title &#125;&#125;</span><br><span class="line">date: &#123;&#123; date &#125;&#125;</span><br><span class="line">categories:</span><br><span class="line">tags:</span><br><span class="line">keywords:</span><br><span class="line">description:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>再进入到博客目录下通过终端命令新建文章：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo n post postName</span><br></pre></td></tr></table></figure>
<h1 id="6-生成静态页面" class="heading-control"><a href="#6-生成静态页面" class="headerlink" title="6 生成静态页面"></a>6 生成静态页面<a class="heading-anchor" href="#6-生成静态页面" aria-hidden="true"></a></h1><ul>
<li>如果仅修改或增删了文章，请在博客目录下执行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g</span><br></pre></td></tr></table></figure></li>
<li>如果主题配置或样式等也做了修改，请在博客目录下执行：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="7-本地启动" class="heading-control"><a href="#7-本地启动" class="headerlink" title="7 本地启动"></a>7 本地启动<a class="heading-anchor" href="#7-本地启动" aria-hidden="true"></a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>
<h1 id="8-部署到-GitHub-Pages" class="heading-control"><a href="#8-部署到-GitHub-Pages" class="headerlink" title="8 部署到 GitHub Pages"></a>8 部署到 GitHub Pages<a class="heading-anchor" href="#8-部署到-GitHub-Pages" aria-hidden="true"></a></h1><ul>
<li>申请 GitHub 账号并进行配置 SSH Key 等，不再赘述</li>
<li>创建 GitHub Pages 项目</li>
<li>部署<br>首先修改站点配置文件的<code>deploy</code>项，将<code>repository</code>修改为个人的 GitHub Pages 仓库地址（仅第一次部署时需要）：<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">"git"</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:RocShi/rocshi.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
然后在博客目录下安装<code>hexo-deployer-git</code>插件（第一次部署时）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
最后在博客目录下进行部署：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="9-GitHub-Pages-绑定到个人域名" class="heading-control"><a href="#9-GitHub-Pages-绑定到个人域名" class="headerlink" title="9 GitHub Pages 绑定到个人域名"></a>9 GitHub Pages 绑定到个人域名<a class="heading-anchor" href="#9-GitHub-Pages-绑定到个人域名" aria-hidden="true"></a></h1><ul>
<li><p>购买域名（以<span class="exturl" data-url="aHR0cHM6Ly9kbnNwb2QuY2xvdWQudGVuY2VudC5jb20v" title="https://dnspod.cloud.tencent.com/">腾讯云<i class="fa fa-external-link"></i></span>为例）</p>
</li>
<li><p>添加 CNAME 解析记录<br>主机记录设置为<code>blog</code>（以二级域名为例，其它也可），记录值设置为 GitHub Pages 仓库名<code>rocshi.github.io</code></p>
</li>
<li><p>设置 GitHub Pages 项目<br><code>Custom domain</code>添加待绑定域名，我的是二级域名 blog.shipengx.com，开启<code>Enforce HTTPS</code>。可能会遇到以下问题：</p>
<ul>
<li><strong>问题 1 - 绑定到二级域名浏览器提示不安全，绑定到一级域名安全</strong><br>起初绑定的为一级域名 shipengx.com，后改为了二级域名 blog.shipengx.com，出现此问题的原因为浏览器缓存了绑定一级域名时的 SSL 证书，关闭浏览器并清理浏览器缓存即可解决</li>
<li><strong>问题 2 - 绑定域名后 valine 评论系统不可用</strong><br>绑定域名后评论框下方提示：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Code 403: 访问被api域名白名单拒绝,请检查你的安全域名设置.</span><br></pre></td></tr></table></figure>
原因为未将所绑定域名添加至 LeanCloud 的 Web 安全域名白名单，添加即可解决</li>
</ul>
</li>
<li>在 hexo/source 目录下创建无扩展名的 CNAME 文件，内容为待绑定域名，我的是二级域名 blog.shipengx.com</li>
</ul>
<h1 id="10-参考" class="heading-control"><a href="#10-参考" class="headerlink" title="10 参考"></a>10 参考<a class="heading-anchor" href="#10-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cDovL2licnVjZS5pbmZvLzIwMTMvMTEvMjIvaGV4by15b3VyLWJsb2c=" title="http://ibruce.info/2013/11/22/hexo-your-blog">hexo 你的博客<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlvL2RvY3Mv" title="https://hexo.io/docs/">Hexo Docs<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90aGVtZS1uZXh0Lm9yZy9kb2NzLw==" title="https://theme-next.org/docs/">Theme next docs<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2plZmZ5YW5nLnRvcC9IZXhvL0hleG8lRTQlQjglQkIlRTklQTIlOThOZXh0JUU3JUJFJThFJUU1JThDJTk2Lw==" title="http://jeffyang.top/Hexo/Hexo%E4%B8%BB%E9%A2%98Next%E7%BE%8E%E5%8C%96/">Hexo 博客设置以及 Next 主题美化<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucXRtdW5pYW8uY29tLzIwMTkvMTAvMTYvaGV4by10aGVtZS1sYW5kc2NhcGluZy8=" title="https://www.qtmuniao.com/2019/10/16/hexo-theme-landscaping/">Hexo Next 主题进阶设置<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ndWFucXIuY29tL3N0dWR5L2Jsb2cvaGV4by10aGVtZS1uZXh0LWN1c3RvbWl6YXRpb24v" title="https://guanqr.com/study/blog/hexo-theme-next-customization/">Hexo-NexT 主题个性优化<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly92YWxpbmUuanMub3JnLw==" title="https://valine.js.org/">Valine Docs<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9mNDY1OGRmNjZhMTU=" title="https://www.jianshu.com/p/f4658df66a15">Hexo 博客使用 valine 评论系统无效果及终极解决方案<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3llYXJpdG8uY24vY2F0ZWdvcmllcy8lRTYlOEElODAlRTYlOUMlQUYvJUU1JThEJTlBJUU1JUFFJUEyLw==" title="http://yearito.cn/categories/%E6%8A%80%E6%9C%AF/%E5%8D%9A%E5%AE%A2/">yearito 的系列文章<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9mbHVuZ2dnLmNuL2NhdGVnb3JpZXMvaGV4by8=" title="https://flunggg.cn/categories/hexo/">flunggg 的系列文章<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cudjJleC5jb20vYW1wL3QvMzQ3MTc2LzM=" title="https://www.v2ex.com/amp/t/347176/3">用 Hexo 做个人 Wiki 知识管理系统<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbnppMTIyNTYyNy9hcnRpY2xlL2RldGFpbHMvNzc3NjE0ODg=" title="https://blog.csdn.net/yanzi1225627/article/details/77761488">hexo 链接持久化终极解决之道<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9hMWY0ZmJiMTEwZmQ=" title="https://www.jianshu.com/p/a1f4fbb110fd">Next 主题配置文件详解<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9sYW5sYW4yMDE3LmdpdGh1Yi5pby9ibG9nLzI0MmY1ZDU1Lw==" title="https://lanlan2017.github.io/blog/242f5d55/">Hexo NexT 7 谷歌收录 必应收录 百度收录<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iZXN0enVvLmNuLw==" title="https://bestzuo.cn/">Sanarous 得个人博客<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC83YWIyMWM3ZjA2NzQ=" title="https://www.jianshu.com/p/7ab21c7f0674">在 Hexo 中渲染 MathJax 数学公式<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>关于make、makefile、cmake、cmakelist、qmake等的区别</title>
    <url>/archives/e3f2e7f0.html</url>
    <content><![CDATA[<h1 id="1-结论" class="heading-control"><a href="#1-结论" class="headerlink" title="1 结论"></a>1 结论<a class="heading-anchor" href="#1-结论" aria-hidden="true"></a></h1><p>首先，开发人员根据项目目录结构编写 cmakelist 文件；然后，cmake 根据编写的 cmakelist 文件生成 makefile 文件；最后，make 根据生成的 makefile 文件对代码进行预处理、编译、汇编、链接等操作，生成可执行文件或共享库。流程如下图所示：</p>
<p><img data-src="https://image.shipengx.com/cmake%E5%B7%A5%E4%BD%9C%E6%B5%81.png" alt="cmake工作流"></p>
<p>qmake——与 cmake 同等地位的工具。<br>综上，<strong>重点是 cmakelist 文件的编写</strong>。</p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC94dW54dW4vYmxvZy84Njc4MQ==" title="https://my.oschina.net/xunxun/blog/86781">CMake 与 Make<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FpeWFuZ2hvbmcvYXJ0aWNsZS9kZXRhaWxzLzg2NTAxNzIw" title="https://blog.csdn.net/Aiyanghong/article/details/86501720">make、makefile、cmake 之间的区别与联系<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppYW5nX3hpbnhpbmcvYXJ0aWNsZS9kZXRhaWxzLzcyODI3NjY0" title="https://blog.csdn.net/jiang_xinxing/article/details/72827664">编译过程，make,makefile,cmake,qmake,cmakelist 总结<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2oyMDE0L3AvNjExMTYzNC5odG1s" title="https://www.cnblogs.com/cj2014/p/6111634.html">make makefile cmake qmake 都是什么，有什么区别<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编译</category>
        <category>make</category>
      </categories>
      <tags>
        <tag>make</tag>
      </tags>
  </entry>
  <entry>
    <title>在腾讯云上搭建个人Git服务器</title>
    <url>/archives/296a9967.html</url>
    <content><![CDATA[<h1 id="1-背景" class="heading-control"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景<a class="heading-anchor" href="#1-背景" aria-hidden="true"></a></h1><blockquote>
<p>在腾讯云搭建Git服务器，托管个人工程代码，实现多地协同开发。</p>
</blockquote>
<h1 id="2-最佳实践" class="heading-control"><a href="#2-最佳实践" class="headerlink" title="2 最佳实践"></a>2 最佳实践<a class="heading-anchor" href="#2-最佳实践" aria-hidden="true"></a></h1><h2 id="2-1-安装Git" class="heading-control"><a href="#2-1-安装Git" class="headerlink" title="2.1 安装Git"></a>2.1 安装Git<a class="heading-anchor" href="#2-1-安装Git" aria-hidden="true"></a></h2><p>以Linux Ubuntu为例：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure></p>
<h2 id="2-2-创建证书登录" class="heading-control"><a href="#2-2-创建证书登录" class="headerlink" title="2.2 创建证书登录"></a>2.2 创建证书登录<a class="heading-anchor" href="#2-2-创建证书登录" aria-hidden="true"></a></h2><p>收集所有需要登录的用户的公钥，即个人主机<code>~/.ssh</code>目录中id_rsa.pub公钥文件中的内容，把所有公钥导入到服务器<code>~/.ssh/authorized_keys</code>文件里，一行一个，id_rsa.pub公钥文件不存在的话使用<code>ssh-keygen</code>命令生成：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -C “your email address”</span><br></pre></td></tr></table></figure></p>
<h2 id="2-3-初始化Git仓库" class="heading-control"><a href="#2-3-初始化Git仓库" class="headerlink" title="2.3 初始化Git仓库"></a>2.3 初始化Git仓库<a class="heading-anchor" href="#2-3-初始化Git仓库" aria-hidden="true"></a></h2><p>选定一个目录作为Git仓库目录，例如~/Code/example，<code>cd</code>到该目录，输入命令：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init --bare example.git</span><br></pre></td></tr></table></figure></p>
<h2 id="2-4-在client端克隆仓库，并向远程仓库贡献代码" class="heading-control"><a href="#2-4-在client端克隆仓库，并向远程仓库贡献代码" class="headerlink" title="2.4 在client端克隆仓库，并向远程仓库贡献代码"></a>2.4 在client端克隆仓库，并向远程仓库贡献代码<a class="heading-anchor" href="#2-4-在client端克隆仓库，并向远程仓库贡献代码" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> server_username@server_addr:~/Code/example/example.git</span><br></pre></td></tr></table></figure>
<p>server_username是你登录腾讯云服务器的用户名，server_addr是服务器IP地址或域名。</p>
<h1 id="3-参考" class="heading-control"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考<a class="heading-anchor" href="#3-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAwLzg5OTk5ODg3MDkyNTY2NA==" title="https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664">搭建Git服务器<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>初识 Docker</title>
    <url>/archives/c97041d4.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E5%88%9D%E8%AF%86%20Docker.png" alt="初识 Docker"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>最近交叉编译域控制器（ARM 架构）中的模块可执行文件时使用到了 <span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9ja2VyLmNvbS8=" title="https://www.docker.com/">Docker<i class="fa fa-external-link"></i></span>，发现其很多设计理念与 Git 都有着相似之处，本文旨在记录 Docker 的一些基本概念与常用操作。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20v" title="https://docs.docker.com/">Docker 官方文档<i class="fa fa-external-link"></i></span>，尤其是其中的 <span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9jbGkv" title="https://docs.docker.com/engine/reference/commandline/cli/">Docker 命令行<i class="fa fa-external-link"></i></span>是很全面的参考。</p>
<h1 id="1-概览" class="heading-control"><a href="#1-概览" class="headerlink" title="1 概览"></a>1 概览<a class="heading-anchor" href="#1-概览" aria-hidden="true"></a></h1><h2 id="1-1-Docker-是什么" class="heading-control"><a href="#1-1-Docker-是什么" class="headerlink" title="1.1 Docker 是什么"></a>1.1 Docker 是什么<a class="heading-anchor" href="#1-1-Docker-是什么" aria-hidden="true"></a></h2><p>来看下<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvRG9ja2Vy" title="https://zh.wikipedia.org/wiki/Docker">维基百科<i class="fa fa-external-link"></i></span>中对 Docker 的定义：</p>
<blockquote>
<p>Docker 是一个开放源代码软件，是一个开放平台，用于开发应用、交付（shipping）应用、运行应用。 Docker 允许用户将基础设施（Infrastructure）中的应用单独分割出来，形成更小的颗粒（容器），从而提高交付软件的速度。</p>
</blockquote>
<p>简言之，Docker 是与虚拟机（Virtual Machine，例如 VMWare）类似的虚拟化技术，但更加轻量而不臃肿，便于快速地构建、打包并分发我们的应用程序及其依赖的运行环境。</p>
<p>一个纯净的 Ubuntu 18.04 Docker 镜像（类似系统安装盘，下文将介绍）仅仅 63.1MB，在里面安装 Git 后也才只有 196MB，将 Docker 镜像拷贝至另一台同样安装有 Docker 环境的机器上开箱即用！</p>
<p><img data-src="https://image.shipengx.com/%E5%B0%8F%E5%B7%A7%E7%9A%84%20Docker%20%E9%95%9C%E5%83%8F.png" alt="小巧的 Docker 镜像"></p>
<h2 id="1-2-几个重要概念" class="heading-control"><a href="#1-2-几个重要概念" class="headerlink" title="1.2 几个重要概念"></a>1.2 几个重要概念<a class="heading-anchor" href="#1-2-几个重要概念" aria-hidden="true"></a></h2><p>在开始安装并使用 Docker 前，首先应该感性地了解下几个重要的基本概念。</p>
<h3 id="1-2-1-镜像" class="heading-control"><a href="#1-2-1-镜像" class="headerlink" title="1.2.1 镜像"></a>1.2.1 镜像<a class="heading-anchor" href="#1-2-1-镜像" aria-hidden="true"></a></h3><p><strong>镜像</strong>（Image）是一个只读的文件系统模板，用于生成供用户使用的系统运行环境实例（容器，下文将提到），可以类比成安装 Ubuntu 操作系统时的那个 <code>.iso</code> 格式的镜像文件：</p>
<p><img data-src="https://image.shipengx.com/Ubuntu%20%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E9%95%9C%E5%83%8F%E6%96%87%E4%BB%B6.png" alt="Ubuntu 系统安装镜像文件"></p>
<p>一些资料中将 Docker 镜像比作 Git 分支（Branch），我觉得并不合适，一个 Git 分支是 Git 仓库中一组历史提交（Commit）的组合，而 Docker 镜像则更像是某个 Git 分支上当前的最新提交。</p>
<h3 id="1-2-2-容器" class="heading-control"><a href="#1-2-2-容器" class="headerlink" title="1.2.2 容器"></a>1.2.2 容器<a class="heading-anchor" href="#1-2-2-容器" aria-hidden="true"></a></h3><p><strong>容器</strong>（Container）是运行 Docker 镜像后生成的供用户使用的系统运行环境实例，可以类比成使用 Ubuntu 操作系统镜像文件安装好的操作系统，我们可以在操作系统（Docker 容器）中执行预定义好的各种动作，比如安装软件、修改文件等，被修改过的操作系统（Docker 容器）可以被打包为新的操作系统安装文件（Docker 镜像）。</p>
<p>类比 Git，运行 Docker 镜像生成 Docker 容器的过程相当于在 Git 分支的某个提交上检出（<code>checkout</code>）新分支的过程（此时容器拥有和镜像相同的提交），我们在容器中做了某些修改并提交（<code>docker commit</code>）生成新镜像的过程相当于在刚刚检出的这个分支上做了一次新的提交。</p>
<p>Docker 镜像与容器的关系还可以类比面向对象中类与对象的关系，即，容器是镜像的一个实例（Instance）。</p>
<h3 id="1-2-3-仓库" class="heading-control"><a href="#1-2-3-仓库" class="headerlink" title="1.2.3 仓库"></a>1.2.3 仓库<a class="heading-anchor" href="#1-2-3-仓库" aria-hidden="true"></a></h3><p><strong>仓库</strong>（Repository）是一系列 Docker 镜像的集合，可以类比成一个 Git 代码仓库，仓库中的每个 Docker 镜像都拥有一个唯一的标签（<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS90YWcvI2V4YW1wbGVz" title="https://docs.docker.com/engine/reference/commandline/tag/#examples">TAG<i class="fa fa-external-link"></i></span>）。Git 中也有标签的概念，Git 仓库中的一个标签与某次提交相对应，再次说明了 Docker 镜像是与 Git 提交同层级的概念，而非 Git 分支。</p>
<h3 id="1-2-4-注册中心" class="heading-control"><a href="#1-2-4-注册中心" class="headerlink" title="1.2.4 注册中心"></a>1.2.4 注册中心<a class="heading-anchor" href="#1-2-4-注册中心" aria-hidden="true"></a></h3><p><strong>注册中心</strong>（Registry）是一系列 Docker 仓库的集合，<span class="exturl" data-url="aHR0cHM6Ly9odWIuZG9ja2VyLmNvbQ==" title="https://hub.docker.com">Docker Hub<i class="fa fa-external-link"></i></span>（类似 GitHub 或 GitLab）是 Docker 官方的公共注册中心，上面存放了大量的 Docker 镜像供下载使用，默认配置下，<code>docker pull</code> 命令会从 Docker Hub 拉取镜像。此外，我们可以搭建私有的注册中心，可以类比搭建私有的 GitLab 服务器。</p>
<h1 id="2-安装" class="heading-control"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装<a class="heading-anchor" href="#2-安装" aria-hidden="true"></a></h1><p>在终端中直接执行下述命令即可完成 Docker 社区版的安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://get.docker.com | sh</span><br><span class="line">sudo systemctl start docker &amp;&amp; sudo systemctl <span class="built_in">enable</span> docker</span><br></pre></td></tr></table></figure>
<p>重启 Docker 守护进程以使改动生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>
<p>完成 Docker 安装后，在终端中执行下述命令并重启系统，这样可以免去每次执行 Docker 命令时需要添加 <code>sudo</code> 的繁琐：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo groupadd docker</span><br><span class="line">sudo usermod -aG docker USER_NAME</span><br></pre></td></tr></table></figure>
<h1 id="3-常用命令" class="heading-control"><a href="#3-常用命令" class="headerlink" title="3 常用命令"></a>3 常用命令<a class="heading-anchor" href="#3-常用命令" aria-hidden="true"></a></h1><h2 id="3-1-拉取-Docker-Hub-中的远程镜像" class="heading-control"><a href="#3-1-拉取-Docker-Hub-中的远程镜像" class="headerlink" title="3.1 拉取 Docker Hub 中的远程镜像"></a>3.1 拉取 Docker Hub 中的远程镜像<a class="heading-anchor" href="#3-1-拉取-Docker-Hub-中的远程镜像" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull REPO_NAME:TAG</span><br></pre></td></tr></table></figure>
<p>例如，要拉取 Ubuntu 18.04 镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure>
<h2 id="3-2-加载镜像-tar-压缩文件" class="heading-control"><a href="#3-2-加载镜像-tar-压缩文件" class="headerlink" title="3.2 加载镜像 tar 压缩文件"></a>3.2 加载镜像 tar 压缩文件<a class="heading-anchor" href="#3-2-加载镜像-tar-压缩文件" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i IMAGE_TAR_FILENAME.tar</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load &lt; IMAGE_TAR_FILENAME.tar</span><br></pre></td></tr></table></figure>
<p>若空间不够，需修改 <code>/etc/docker/dameon.json</code> 文件（不存在得话需新建），指定新的镜像加载目录，例如：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"data-root"</span>: <span class="string">"/home/shipeng/docker_images"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成修改后需要重启 Docker 服务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure>
<h2 id="3-3-查看已经加载的镜像" class="heading-control"><a href="#3-3-查看已经加载的镜像" class="headerlink" title="3.3 查看已经加载的镜像"></a>3.3 查看已经加载的镜像<a class="heading-anchor" href="#3-3-查看已经加载的镜像" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>
<p>可以得到镜像的仓库、标签、ID、创建日期、大小等信息。</p>
<h2 id="3-4-使用已经加载的镜像运行一个新的容器" class="heading-control"><a href="#3-4-使用已经加载的镜像运行一个新的容器" class="headerlink" title="3.4 使用已经加载的镜像运行一个新的容器"></a>3.4 使用已经加载的镜像运行一个新的容器<a class="heading-anchor" href="#3-4-使用已经加载的镜像运行一个新的容器" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it IMAGE_ID</span><br></pre></td></tr></table></figure>
<p>其中，</p>
<ul>
<li><code>i</code> 表示 <code>interactive</code>，即保持开启标准输入</li>
<li><code>t</code> 表示 <code>tty</code>，即分配一个终端</li>
</ul>
<p>执行完上述命令后将进入容器终端：<code>root@CONTAINER_ID</code></p>
<h2 id="3-5-退出当前容器终端" class="heading-control"><a href="#3-5-退出当前容器终端" class="headerlink" title="3.5 退出当前容器终端"></a>3.5 退出当前容器终端<a class="heading-anchor" href="#3-5-退出当前容器终端" aria-hidden="true"></a></h2><p>假如现在处于某个容器的终端中，输入下述命令来退出终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<h2 id="3-6-列举正在运行的容器" class="heading-control"><a href="#3-6-列举正在运行的容器" class="headerlink" title="3.6 列举正在运行的容器"></a>3.6 列举正在运行的容器<a class="heading-anchor" href="#3-6-列举正在运行的容器" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.docker.com/engine/reference/commandline/ps/" target="_blank" rel="noopener"><code>ps</code></a> 是 <code>container ls</code> 的别名，所以上述命令等价于：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure>
<h2 id="3-7-停止某个正在运行的容器" class="heading-control"><a href="#3-7-停止某个正在运行的容器" class="headerlink" title="3.7 停止某个正在运行的容器"></a>3.7 停止某个正在运行的容器<a class="heading-anchor" href="#3-7-停止某个正在运行的容器" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker stop CONTAINER_ID</span><br></pre></td></tr></table></figure>
<h2 id="3-8-删除容器" class="heading-control"><a href="#3-8-删除容器" class="headerlink" title="3.8 删除容器"></a>3.8 删除容器<a class="heading-anchor" href="#3-8-删除容器" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm CONTAINER_ID</span><br></pre></td></tr></table></figure>
<p>容器能够被删除的前提是该容器已经被停止。</p>
<h2 id="3-9-列举所有容器（包括已经停止的容器）" class="heading-control"><a href="#3-9-列举所有容器（包括已经停止的容器）" class="headerlink" title="3.9 列举所有容器（包括已经停止的容器）"></a>3.9 列举所有容器（包括已经停止的容器）<a class="heading-anchor" href="#3-9-列举所有容器（包括已经停止的容器）" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<p><code>ps</code> 的 <code>-f</code> 选项用于根据提供的条件过滤输出，<code>-q</code> 选项用于只显示容器 ID。下面的组合命令用于删除所有已经停止的容器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rm $(docker ps -f status=exited -q)</span><br></pre></td></tr></table></figure>
<h2 id="3-10-向正在运行的容器中拷入文件" class="heading-control"><a href="#3-10-向正在运行的容器中拷入文件" class="headerlink" title="3.10 向正在运行的容器中拷入文件"></a>3.10 向正在运行的容器中拷入文件<a class="heading-anchor" href="#3-10-向正在运行的容器中拷入文件" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker cp LOCAL_FILE_OR_DIR CONTAINER_ID:CONTAINER_DIR</span><br></pre></td></tr></table></figure>
<p>与 Linux 中的 <code>cp</code> 指令不同的是，即使拷贝目录，这里的 <code>docker cp</code> 后面也不需要添加 <code>-R</code> 选项。</p>
<h2 id="3-11-为正在运行的容器开启一个新的-bash-终端" class="heading-control"><a href="#3-11-为正在运行的容器开启一个新的-bash-终端" class="headerlink" title="3.11 为正在运行的容器开启一个新的 bash 终端"></a>3.11 为正在运行的容器开启一个新的 bash 终端<a class="heading-anchor" href="#3-11-为正在运行的容器开启一个新的-bash-终端" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it CONTAINER_ID /bin/bash</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker attach CONTAINER_ID</span><br></pre></td></tr></table></figure>
<p>需要<strong>注意</strong>的是：在 <code>docker exec</code> 开启的新终端中执行 <code>exit</code> 指令只会退出终端，对容器无影响；而在 <code>docker attach</code> 开启的新终端中执行 <code>exit</code> 指令则会导致容器直接停止，而非仅仅退出终端。</p>
<h2 id="3-12-将容器提交为新的镜像" class="heading-control"><a href="#3-12-将容器提交为新的镜像" class="headerlink" title="3.12 将容器提交为新的镜像"></a>3.12 将容器提交为新的镜像<a class="heading-anchor" href="#3-12-将容器提交为新的镜像" aria-hidden="true"></a></h2><p>假如我们对运行的容器做了一些修改，可以将其提交为新的镜像：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit -a <span class="string">"AUTHOR"</span> -m <span class="string">"MESSAHE"</span> CONTAINER_ID REPO_NAME:TAG</span><br></pre></td></tr></table></figure>
<h2 id="3-13-将镜像保存为-tar-压缩文件" class="heading-control"><a href="#3-13-将镜像保存为-tar-压缩文件" class="headerlink" title="3.13 将镜像保存为 tar 压缩文件"></a>3.13 将镜像保存为 tar 压缩文件<a class="heading-anchor" href="#3-13-将镜像保存为-tar-压缩文件" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o IMAGE_TAR_FILENAME.tar CONTAINER_ID</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o IMAGE_TAR_FILENAME.tar REPO_NAME:TAG</span><br></pre></td></tr></table></figure>
<h2 id="3-14-删除镜像" class="heading-control"><a href="#3-14-删除镜像" class="headerlink" title="3.14 删除镜像"></a>3.14 删除镜像<a class="heading-anchor" href="#3-14-删除镜像" aria-hidden="true"></a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker rmi CONTAINER_ID</span><br></pre></td></tr></table></figure>
<p>注意，在删除容器前，需要保证依附于该镜像的所有容器都已删除。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvRG9ja2Vy" title="https://zh.wikipedia.org/wiki/Docker">Docker<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamI1MS5uZXQvYXJ0aWNsZS8yMTU5MzYuaHRt" title="https://www.jb51.net/article/215936.htm">Docker 镜像加载原理<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yMzU5OTIyOT91dG1fc291cmNlPXdlY2hhdF9zZXNzaW9uJmFtcDt1dG1fbWVkaXVtPXNvY2lhbCZhbXA7dXRtX29pPTMzNTYyODU0MTYyNDMyJmFtcDt1dG1fY2FtcGFpZ249c2hhcmVvcG4=" title="https://zhuanlan.zhihu.com/p/23599229?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=33562854162432&amp;utm_campaign=shareopn">只要一小时，零基础入门 Docker<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20v" title="https://docs.docker.com/">docker docs<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmRvY2tlci5jb20vZW5naW5lL3JlZmVyZW5jZS9jb21tYW5kbGluZS9jbGkv" title="https://docs.docker.com/engine/reference/commandline/cli/">Docker command line<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucnVub29iLmNvbS9kb2NrZXIvZG9ja2VyLXR1dG9yaWFsLmh0bWw=" title="https://www.runoob.com/docker/docker-tutorial.html">Docker 教程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubXlmcmVheC5jb20vaG93LXRvLWxpc3QtZG9ja2VyLWNvbnRhaW5lcnMv" title="https://www.myfreax.com/how-to-list-docker-containers/">如何在 Docker 中列出容器<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>效率</category>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Hexo的个人博客站点高级自定义设置——使用NexT主题</title>
    <url>/archives/31218470.html</url>
    <content><![CDATA[<blockquote>
<p>在此前的两篇文章<a href="https://blog.shipengx.com/archives/208e6058.html">《使用Hexo + GitHub Pages搭建个人博客站点》</a>和<a href="https://blog.shipengx.com/archives/3955f5ec.html">《将Hexo搭建的博客站点从GitHub Pages迁移到腾讯云VPS》</a>中，我们分别讲述了如何通过Hexo + NexT主题搭建炫酷的个人博客站点，并通过将站点由GitHub Pages迁移至腾讯云VPS来提升访问速度。本文以此为基础，通过对CSS样式的深度定制，实现了Hexo NexT主题Mist风格视觉感受的提升，最终呈现出你所看到的样子。</p>
</blockquote>
<p>对CSS样式的自定义依赖hexo/source/_data/styles.styl文件，需要开启hexo/themes/next/_config.xml中<code>custom_file_path</code>的相关选项，默认是注释掉的<br><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="attr">style:</span> <span class="string">source/_data/styles.styl</span></span><br></pre></td></tr></table></figure><br>styles.styl中的CSS样式编辑用到了一些前端知识，点击<a href="/download/styles.zip">这里</a>下载我的styles.styl文件，要善用浏览器的<code>F12</code>快捷键进行调试才能达到理想效果，遇到不懂的样式通过网络获取相关知识。</p>
<hr>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title>如何检出git仓库中最新的tag号</title>
    <url>/archives/732ab93b.html</url>
    <content><![CDATA[<h1 id="1-背景" class="heading-control"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景<a class="heading-anchor" href="#1-背景" aria-hidden="true"></a></h1><blockquote>
<p>在搭建某项目CI环境过程中遇到这样一个需求：需要根据最新的tag号提取其中的版本信息。如何获取代码仓库中的最新tag号？</p>
</blockquote>
<h1 id="2-结论" class="heading-control"><a href="#2-结论" class="headerlink" title="2 结论"></a>2 结论<a class="heading-anchor" href="#2-结论" aria-hidden="true"></a></h1><p>通过如下命令行获取git仓库中的最新tag号：<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">LatestTag=$(git describe --tags `git rev-list --tags --max-count=1`)</span><br></pre></td></tr></table></figure></p>
<h1 id="3-参考" class="heading-control"><a href="#3-参考" class="headerlink" title="3 参考"></a>3 参考<a class="heading-anchor" href="#3-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC85NmE0NGE2MmU4MDY=" title="https://www.jianshu.com/p/96a44a62e806">不知道 tag 名的情况，如何检出 git 仓库中最新的 tag 号及切换代码<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>如何删除本地 Git 仓库和远程 Git 仓库的 tag</title>
    <url>/archives/a38a4de1.html</url>
    <content><![CDATA[<blockquote>
<p>使用 Git 进行代码仓库的版本控制时，定期会为仓库打上 tag，有时会有删除 tag 的操作。本文以 tag <code>v1.1.4</code> 为例，分别描述了删除本地仓库 tag 和删除远程仓库 tag 的方法。</p>
</blockquote>
<h1 id="删除本地仓库-tag" class="heading-control"><a href="#删除本地仓库-tag" class="headerlink" title="删除本地仓库 tag"></a>删除本地仓库 tag<a class="heading-anchor" href="#删除本地仓库-tag" aria-hidden="true"></a></h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git tag -d v1.1.4</span><br></pre></td></tr></table></figure>
<h1 id="删除远程仓库-tag" class="heading-control"><a href="#删除远程仓库-tag" class="headerlink" title="删除远程仓库 tag"></a>删除远程仓库 tag<a class="heading-anchor" href="#删除远程仓库-tag" aria-hidden="true"></a></h1><p>假设本地仓库与远程仓库 <code>orgin</code> 相关联：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin :refs/tags/v1.1.4</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>安装第三方python库过程中的egg-info与dist-info文件夹</title>
    <url>/archives/42095346.html</url>
    <content><![CDATA[<h1 id="结论" class="heading-control"><a href="#结论" class="headerlink" title="结论"></a>结论<a class="heading-anchor" href="#结论" aria-hidden="true"></a></h1><p>在安装第三方python库过程中，在site-packages目录中与安装结果同时生成的后缀名为egg-info或dist-info的文件夹：<br>用应用程序安装生成egg-info文件夹，用whl或tar安装生成dist-info文件夹。</p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>Python</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>实用 Shell 脚本：自动拉取 Git 仓库所有远程分支代码到本地</title>
    <url>/archives/17c6bb1a.html</url>
    <content><![CDATA[<p>在使用 Git 进行代码版本管理时，有时我们需要合并某个远程分支到本地当前分支，手动操作时，流程是这样的：</p>
<ol>
<li><code>git checkout</code> 到远程分支对应的本地分支</li>
<li><code>git pull</code> 拉取远程分支并合并到其对应的本地分支</li>
<li><code>git checkout</code> 回到我们的本地目标分支</li>
<li><code>git merge</code> 合并远程分支对应的本地分支到本地目标分支</li>
</ol>
<p>未免过于繁琐了，尤其是要处理多个远程分支时，而且有可能我们还没有创建远程分支对应的本地分支，或者合并前忘记拉取远程分支最新状态。</p>
<p>本着“效率为王”的理念，必须要自动化，下面这个 Shell 脚本即可实现：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># clean remote branches history</span></span><br><span class="line">git remote prune origin</span><br><span class="line"></span><br><span class="line">current_local_branch=$(git branch | awk <span class="string">'/\*/ &#123; print $2; &#125;'</span>)</span><br><span class="line">all_remote_branches=$(git branch --remotes | sed <span class="string">'s/origin\///g'</span> | sed <span class="string">'s/HEAD -&gt; master//g'</span>)</span><br><span class="line">current_dir=$(<span class="built_in">pwd</span>)</span><br><span class="line">repo_dir=$(git rev-parse --show-toplevel)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$repo_dir</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> remote_branch <span class="keyword">in</span> <span class="variable">$&#123;all_remote_branches[*]&#125;</span>; <span class="keyword">do</span></span><br><span class="line">    git checkout <span class="variable">$remote_branch</span></span><br><span class="line">    git pull</span><br><span class="line"><span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">git checkout <span class="variable">$current_local_branch</span></span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$current_dir</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>git remote prune origin</code> 用于清理远程仓库已删除分支在本地仓库残留的追踪记录；</p>
<p><code>git rev-parse --show-toplevel</code> 可以获取本地仓库的绝对路径。</p>
</blockquote>
<p>具体使用时，将该脚本提交到我们的本地目标分支，不定期手动执行一下脚本，简单快捷（执行脚本前需要确保本地仓库的 working tree 是干净的，即工作区和暂存区没有未提交的修改）。</p>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>导航定位领域里的一些基本概念</title>
    <url>/archives/8ddff8f2.html</url>
    <content><![CDATA[<h1 id="正文" class="heading-control"><a href="#正文" class="headerlink" title="正文"></a>正文<a class="heading-anchor" href="#正文" aria-hidden="true"></a></h1><p><strong>GPS</strong><br>Global Positioning System，全球定位系统，美国，可获取定位信息和速度信息，测量结果受树木、隧道、建筑物等环境信息影响。</p>
<p><strong>INS</strong><br>Inertial Navigation System，惯性导航系统，可获取三轴加速度和三轴角速度信息，测量结果受陀螺漂移和车辆振动等的影响。</p>
<p><strong>IMU</strong><br>Inertial Measurement Unit，惯性测量单元，INS 里的传感元件，平衡车经常使用的 MPU6050/9050 就属于很常用的 IMU 元件。</p>
<p><strong>GNSS</strong><br>Global Navigation Satellite System，全球导航卫星系统，我国的北斗，美国的 GPS，欧洲的 Galileo，俄罗斯的 Glonass，都属于 GNSS 的具体实现。</p>
<p><strong>组合导航定位</strong><br>使用 GNSS/INS 的组合导航定位技术。GNSS 测量结果准确，但更新周期长；INS 更新频率高，瞬时结果精确，但存在累积误差。GNSS/INS 组合导航定位则综合了两者的优点：GNSS 长时间范围内的准确性和 INS 的高频特性。</p>
<p><strong>RTK</strong><br>Real Time Kinematic，实时动态，载波相位差分技术，是实时处理两个测量站载波相位观测量的差分方法，将基准站采集的载波相位发给用户接收机，进行求差解算坐标。分为单参考站 RTK 测量和网络 RTK 测量。</p>
<p>MathWorks 官网上也有很清晰的描述：<span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0aHdvcmtzLmNvbS9jb250ZW50L2RhbS9tYXRod29ya3MvZmFjdC1zaGVldC9zZW5zb3ItZnVzaW9uLWNoZWF0LXNoZWV0LXF1aWNrLXN0YXJ0LWd1aWRlLnBkZg==" title="https://www.mathworks.com/content/dam/mathworks/fact-sheet/sensor-fusion-cheat-sheet-quick-start-guide.pdf">Sensor Fusion and Tracking Toolbox™ 快速入门指南<i class="fa fa-external-link"></i></span></p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0tZSkw4ODgvYXJ0aWNsZS9kZXRhaWxzLzgwNjIzMzUz" title="https://blog.csdn.net/KYJL888/article/details/80623353">【自动驾驶】RTK（高精度的 GPS 测量）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9iYWlqaWFoYW8uYmFpZHUuY29tL3M/aWQ9MTYwMzEzNjc1MzA5Mjg3Nzg0OCZhbXA7d2ZyPXNwaWRlciZhbXA7Zm9yPXBj" title="https://baijiahao.baidu.com/s?id=1603136753092877848&amp;wfr=spider&amp;for=pc">GPS RTK 测量定位原理<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0aHdvcmtzLmNvbS9jb250ZW50L2RhbS9tYXRod29ya3MvZmFjdC1zaGVldC9zZW5zb3ItZnVzaW9uLWNoZWF0LXNoZWV0LXF1aWNrLXN0YXJ0LWd1aWRlLnBkZg==" title="https://www.mathworks.com/content/dam/mathworks/fact-sheet/sensor-fusion-cheat-sheet-quick-start-guide.pdf">Sensor Fusion and Tracking Toolbox™ 快速入门指南<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>导航定位</tag>
      </tags>
  </entry>
  <entry>
    <title>将Hexo搭建的博客站点从GitHub Pages迁移到腾讯云VPS</title>
    <url>/archives/3955f5ec.html</url>
    <content><![CDATA[<h1 id="1-背景" class="heading-control"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景<a class="heading-anchor" href="#1-背景" aria-hidden="true"></a></h1><blockquote>
<p>在上一篇文章<a href="https://blog.shipengx.com/archives/208e6058.html">《使用 Hexo + GitHub Pages 搭建个人博客站点》</a>中我们介绍了如何使用 Hexo 搭建自己的个人博客站点并部署到 GitHub Pages。将个人站点部署到 GitHub Pages 的显著优点是便捷、免费，但由于 GitHub 服务器位于国外，所以多数情况下，你访问你的 GitHub Pages 的速度将非常缓慢。为提升访问速度，将个人站点部署到腾讯云、阿里云或其它国内云服务提供商的云服务器上是一个很好的选择。当然，你也可以通过树莓派 + 内网穿透搭建自己的私有云服务器。</p>
</blockquote>
<h1 id="2-原理" class="heading-control"><a href="#2-原理" class="headerlink" title="2 原理"></a>2 原理<a class="heading-anchor" href="#2-原理" aria-hidden="true"></a></h1><p>使用 VPS 部署博客的原理如下图所示（图片来自<span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAxNjEwNjU4NA==" title="https://segmentfault.com/a/1190000016106584">这里<i class="fa fa-external-link"></i></span>）：</p>
<p><img data-src="https://image.shipengx.com/VPS%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="VPS搭建Hexo博客原理示意图"></p>
<p>使用 VPS 部署博客的主要思路分为四步：</p>
<ul>
<li><code>hexo -g</code>将 source/_posts 目录下的 markdown 文件渲染为静态资源，并将静态资源放置到 public 目录下；</li>
<li><code>hexo deploy</code>通过 git 将 public 目录下的博客静态资源推送到 VPS 的远程仓库中；</li>
<li>推送更新触发 Git Hooks 将仓库内的静态资源克隆到网站根目录下；</li>
<li>使用 nginx 作为 Web 服务器提供对博客的 HTTP 或 HTTPS 访问。</li>
</ul>
<p>本文基于腾讯云 Ubuntu 18.04 实现 Hexo 静态博客的 VPS 自动部署。</p>
<h1 id="3-配置" class="heading-control"><a href="#3-配置" class="headerlink" title="3 配置"></a>3 配置<a class="heading-anchor" href="#3-配置" aria-hidden="true"></a></h1><h2 id="3-1-VPS-端配置——Git" class="heading-control"><a href="#3-1-VPS-端配置——Git" class="headerlink" title="3.1 VPS 端配置——Git"></a>3.1 VPS 端配置——Git<a class="heading-anchor" href="#3-1-VPS-端配置——Git" aria-hidden="true"></a></h2><h3 id="3-1-1-安装" class="heading-control"><a href="#3-1-1-安装" class="headerlink" title="3.1.1 安装"></a>3.1.1 安装<a class="heading-anchor" href="#3-1-1-安装" aria-hidden="true"></a></h3><p>通常情况下，购买了 VPS 后 Git 是默认已经安装的，若未安装，可通过终端命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>
<h3 id="3-1-2-配置本地端-SSH-登录-VPS" class="heading-control"><a href="#3-1-2-配置本地端-SSH-登录-VPS" class="headerlink" title="3.1.2 配置本地端 SSH 登录 VPS"></a>3.1.2 配置本地端 SSH 登录 VPS<a class="heading-anchor" href="#3-1-2-配置本地端-SSH-登录-VPS" aria-hidden="true"></a></h3><p>关于 SSH 登录配置，主要包含两步：SSH key 的本地生成和远端添加，可参考<a href="https://blog.shipengx.com/archives/296a9967.html">《在腾讯云上搭建个人 Git 服务器》</a>的<strong>2.2 创建证书登录</strong>，此处不再赘述。</p>
<h3 id="3-1-3-创建-Git-仓库" class="heading-control"><a href="#3-1-3-创建-Git-仓库" class="headerlink" title="3.1.3 创建 Git 仓库"></a>3.1.3 创建 Git 仓库<a class="heading-anchor" href="#3-1-3-创建-Git-仓库" aria-hidden="true"></a></h3><p>创建适当的目录并将其初始化为 Git 裸库，用于存放 Hexo 博客静态资源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p ~/blog/shipengx.git</span><br><span class="line"><span class="built_in">cd</span> ~/blog/shipengx.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<h3 id="3-1-4-配置-Git-Hooks" class="heading-control"><a href="#3-1-4-配置-Git-Hooks" class="headerlink" title="3.1.4 配置 Git Hooks"></a>3.1.4 配置 Git Hooks<a class="heading-anchor" href="#3-1-4-配置-Git-Hooks" aria-hidden="true"></a></h3><p>此时 VPS 上的远程仓库只是一个裸仓库，无法用于搭建站点服务器，需要在推送更新的同时触发 Git Hooks，以将远程仓库中的博客资源放到 Nginx Web 服务器根目录下。</p>
<ul>
<li><p>创建 Nginx Web 根目录，并修改属主与属组</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /var/wwww/blog</span><br><span class="line">sudo chown ubuntu:ubuntu -R /var/wwww/blog</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建钩子文件，并添加可执行权限<br>进入远程仓库的 hook 目录下，新建钩子文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/blog/shipengx.git/hooks</span><br><span class="line">vim post-receive</span><br></pre></td></tr></table></figure>
<p>添加如下代码并保存，注意，<code>GIT_REPO</code> <code>TMP_GIT_CLONE</code> <code>PUBLIC_WWW</code> 的值视个人情况而定：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"post-receive hook is running..."</span></span><br><span class="line"></span><br><span class="line">GIT_REPO=/home/ubuntu/blog/shipengx.git</span><br><span class="line">TMP_GIT_CLONE=/tmp/blog.shipengx</span><br><span class="line">PUBLIC_WWW=/var/www/blog</span><br><span class="line"></span><br><span class="line">rm -rf <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line">git <span class="built_in">clone</span> <span class="variable">$GIT_REPO</span> <span class="variable">$TMP_GIT_CLONE</span></span><br><span class="line">rm -rf <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/*</span><br><span class="line">cp -rf <span class="variable">$&#123;TMP_GIT_CLONE&#125;</span>/* <span class="variable">$&#123;PUBLIC_WWW&#125;</span>/</span><br></pre></td></tr></table></figure>
<p>为钩子文件添加可执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-2-VPS-端配置——Nginx" class="heading-control"><a href="#3-2-VPS-端配置——Nginx" class="headerlink" title="3.2 VPS 端配置——Nginx"></a>3.2 VPS 端配置——Nginx<a class="heading-anchor" href="#3-2-VPS-端配置——Nginx" aria-hidden="true"></a></h2><h3 id="3-2-1-安装-Nginx" class="heading-control"><a href="#3-2-1-安装-Nginx" class="headerlink" title="3.2.1 安装 Nginx"></a>3.2.1 安装 Nginx<a class="heading-anchor" href="#3-2-1-安装-Nginx" aria-hidden="true"></a></h3><p>直接通过终端命令进行安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>
<p>安装完成后，在浏览器中输入 VPS 公网 IP，出现如下页面即表示安装成功：</p>
<p><img data-src="https://image.shipengx.com/Welcome%20to%20nginx!.png" alt="Welcome to nginx!"></p>
<p>安装成功后，可通过<code>nginx -v</code>命令查看版本信息，本文中所使用版本为 1.14.0；可通过 <code>service nginx status</code>或<code>systemctl status nginx</code>命令来查看 Nginx 运行状态；可通过<code>nginx -V</code>命令查看安装的 Nginx 所包含组件。</p>
<h3 id="3-1-2-配置-Nginx" class="heading-control"><a href="#3-1-2-配置-Nginx" class="headerlink" title="3.1.2 配置 Nginx"></a>3.1.2 配置 Nginx<a class="heading-anchor" href="#3-1-2-配置-Nginx" aria-hidden="true"></a></h3><p>Nginx 安装成功后，所有配置文件将位于/etc/nginx 目录下，/etc/nginx/nginx.conf 是主配置文件。本文中对 Nginx 的配置主要做了以下五件事：</p>
<ul>
<li>监听 80 端口，以提供正常的 http 访问；</li>
<li>配置 SSL，以开启网站对 https 访问的支持（需进行 SSL 证书申请与工信部 ICP 备案）；</li>
<li>IP 访问重定向到域名访问；</li>
<li>http 访问重定向到 https 访问；</li>
<li>自定义 404 页面。</li>
</ul>
<blockquote>
<p>购买了 VPS 后一般可申请免费的 SSL 证书，若你的 VPS 是在腾讯云购买的，可以到<span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLnRlbmNlbnQuY29tL3NzbC9hcHBseQ==" title="https://console.cloud.tencent.com/ssl/apply">这里<i class="fa fa-external-link"></i></span>申请有效期一年的免费 SSL 证书，快到期时需要提前重新申请，证书下发速度很快；对于配置 SSL，工信部 ICP 备案也是必要的，若一级域名未进行备案，则极有可能出现配置做好了域名 http 访问也正常但 https 访问总是被重置的情况，所以最好在购得域名后马上进行 ICP 备案以作备用（对于个人博客站点，网安备案不是必须的），若你的 VPS 是在腾讯云购买的，可以到<span class="exturl" data-url="aHR0cHM6Ly9jb25zb2xlLmNsb3VkLnRlbmNlbnQuY29tL2JlaWFu" title="https://console.cloud.tencent.com/beian">这里<i class="fa fa-external-link"></i></span>进行 ICP 备案申请，备案地与身份证相同的话一般速度比较快，完成备案后记得将备案号填写至站点配置文件的相应位置，以在网页底部展示备案状态（强制要求）。</p>
</blockquote>
<p>下面进行具体的配置操作（假设你已经完成 SSL 证书的申请与下载）。</p>
<p><strong>首先</strong>，在/etc/nginx 目录下创建 ssl 目录用于存放 SSL 证书与配置文件，并将对应 Nginx 的 SSL 证书通过<span class="exturl" data-url="aHR0cHM6Ly93aW5zY3AubmV0L2VuZy9kb2NzL2xhbmc6Y2hz" title="https://winscp.net/eng/docs/lang:chs">WinSCP<i class="fa fa-external-link"></i></span>工具传输至/etc/nginx/ssl 目录下；</p>
<p><strong>然后</strong>，在本地博客目录 hexo/source 下新建 404.html 文件，粘贴以下腾讯公益 404 页面代码后保存（homepageurl 修改为你的站点域名。更多的 404 模板可以到<span class="exturl" data-url="aHR0cHM6Ly80MDQubGlmZQ==" title="https://404.life">这里<i class="fa fa-external-link"></i></span>查看）：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>404 - Page Not Found<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"404错误，页面不存在！"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"content-type"</span> <span class="attr">content</span>=<span class="string">"text/html;charset=utf-8;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge,chrome=1"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"robots"</span> <span class="attr">content</span>=<span class="string">"index,follow"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">"text/javascript"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">charset</span>=<span class="string">"utf-8"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">homepageurl</span>=<span class="string">"https://blog.shipengx.com"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">homepagename</span>=<span class="string">"返回到博客首页"</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">      !(<span class="function"><span class="keyword">function</span> <span class="params">(o)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> i = <span class="built_in">Array</span>.prototype.slice.call(</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.querySelectorAll(<span class="string">"img[data-original]"</span>)</span></span><br><span class="line">        );</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">c</span><span class="params">(t, e)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">var</span> n = <span class="keyword">new</span> Image(),</span></span><br><span class="line"><span class="actionscript">            o = t.getAttribute(<span class="string">"data-original"</span>);</span></span><br><span class="line"><span class="actionscript">          (n.onload = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">            (t.src = o), e &amp;&amp; e();</span><br><span class="line">          &#125;),</span><br><span class="line">            (n.src = o);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">n</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">for</span> (<span class="keyword">var</span> t = <span class="number">0</span>; t &lt; i.length; t++)</span></span><br><span class="line">            (e = i[t]),</span><br><span class="line"><span class="actionscript">              <span class="keyword">void</span> <span class="number">0</span>,</span></span><br><span class="line"><span class="handlebars"><span class="xml">              0 <span class="tag">&lt;<span class="name">=</span> (<span class="attr">n</span> = <span class="string">e.getBoundingClientRect()).top</span> &amp;&amp;</span></span></span></span><br><span class="line">                0 &lt;= n.left &amp;&amp;</span><br><span class="line">                n.top &lt;=</span><br><span class="line"><span class="javascript">                  (o.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight) &amp;&amp;</span></span><br><span class="line"><span class="actionscript">                c(i[t], <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">                  i.splice(t, t);</span><br><span class="line">                &#125;);</span><br><span class="line"><span class="actionscript">          <span class="keyword">var</span> e, n;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">"trigger"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line">        n(),</span><br><span class="line"><span class="actionscript">          o.addEventListener(<span class="string">"scroll"</span>, <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> t, e;</span></span><br><span class="line">            (t = n),</span><br><span class="line">              (e = o),</span><br><span class="line">              clearTimeout(t.tId),</span><br><span class="line"><span class="actionscript">              (t.tId = setTimeout(<span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line">                t.call(e);</span><br><span class="line">              &#125;, 500));</span><br><span class="line">          &#125;);</span><br><span class="line"><span class="actionscript">      &#125;)(<span class="keyword">this</span>);</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>其次</strong>，在/etc/nginx/ssl 目录下通过<code>sudo vim ssl.conf</code>命令新建 SSL 配置文件，添加如下内容（对于不同版本的 Nginx，SSL 配置内容稍有区别）后保存并退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">     #SSL 访问端口号为 443</span><br><span class="line">     listen 443;</span><br><span class="line">     #填写绑定证书的域名</span><br><span class="line">     server_name blog.shipengx.com;</span><br><span class="line">     #开启ssl</span><br><span class="line">     ssl on;</span><br><span class="line">     #证书文件名称</span><br><span class="line">     ssl_certificate ssl&#x2F;1_blog.shipengx.com_bundle.crt;</span><br><span class="line">     #私钥文件名称</span><br><span class="line">     ssl_certificate_key ssl&#x2F;2_blog.shipengx.com.key;</span><br><span class="line">     ssl_session_timeout 5m;</span><br><span class="line">     #请按照以下协议配置</span><br><span class="line">     ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">     #请按照以下套件配置，配置加密套件，写法遵循 openssl 标准。</span><br><span class="line">     ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE;</span><br><span class="line">     ssl_prefer_server_ciphers on;</span><br><span class="line">     #自定义404页面</span><br><span class="line">     error_page 404 &#x2F;404.html;</span><br><span class="line">     location &#x2F; &#123;</span><br><span class="line">         #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。</span><br><span class="line">         root &#x2F;var&#x2F;www&#x2F;blog;</span><br><span class="line">         index  index.html index.htm;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编辑主配置文件/etc/nginx/nginx.conf 为以下内容后保存并退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">user www-data;</span><br><span class="line">worker_processes auto;</span><br><span class="line">pid &#x2F;run&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">  worker_connections  768;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line">  include  mime.types;</span><br><span class="line">  default_type  application&#x2F;octet-stream;</span><br><span class="line"></span><br><span class="line">  sendfile on;</span><br><span class="line">  server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name blog.shipengx.com;</span><br><span class="line">    #自定义404页面</span><br><span class="line">    error_page 404 &#x2F;404.html;</span><br><span class="line">    root &#x2F;var&#x2F;www&#x2F;blog;</span><br><span class="line">    #IP访问强制定向到域名访问</span><br><span class="line">    rewrite ^(.*)$ https:&#x2F;&#x2F;blog.shipengx.com;</span><br><span class="line">    #http访问强制定向到https访问</span><br><span class="line">    return 301 https:&#x2F;&#x2F;blog.shipengx.com$request_uri;</span><br><span class="line">  &#125;</span><br><span class="line">  #加载ssl配置文件</span><br><span class="line">  include &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>最后</strong>，通过重新加载配置文件，并设置 Nginx 开机启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo nginx -s reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> nginx</span><br></pre></td></tr></table></figure>
<h2 id="3-3-本地端-Hexo-站点配置" class="heading-control"><a href="#3-3-本地端-Hexo-站点配置" class="headerlink" title="3.3 本地端 Hexo 站点配置"></a>3.3 本地端 Hexo 站点配置<a class="heading-anchor" href="#3-3-本地端-Hexo-站点配置" aria-hidden="true"></a></h2><p>将站点配置文件中的<code>deploy</code>项修改为如下内容，实现本地端向 GitHub 和 VPS 的双远端推送：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">"git"</span></span><br><span class="line">  <span class="attr">repository:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:RocShi/rocshi.github.io.git</span></span><br><span class="line">    <span class="attr">vps:</span> <span class="string">ubuntu@118.25.111.221:/home/ubuntu/blog/shipengx.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>
<p>github 对应着你的 GitHub Pages 项目地址，vps 对应着你的 VPS 远程仓库的地址，记得修改！</p>
<p><strong>假如你已经完成了域名 ICP 备案，并完成了本文第 3 章节的所有配置，在本地端的博客目录下执行常规的部署操作后在浏览器中输入域名应该就可以成功访问了，而且是支持 https 的！</strong></p>
<h1 id="4-参考" class="heading-control"><a href="#4-参考" class="headerlink" title="4 参考"></a>4 参考<a class="heading-anchor" href="#4-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9mbHVuZ2dnLmNuL2FyY2hpdmVzL2Y0MTg1M2M0Lmh0bWw=" title="https://flunggg.cn/archives/f41853c4.html">快速搭建博客：优化博客<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTgwMDg4NC9hcnRpY2xlL2RldGFpbHMvMTAzNTQ1MTMw" title="https://blog.csdn.net/weixin_41800884/article/details/103545130">服务器部署网站后，公网 ip 可以访问，域名不能访问问题<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3llYXJpdG8uY24vcG9zdHMvaGV4by1kZXBsb3ktdG8tVlBTLmh0bWw=" title="http://yearito.cn/posts/hexo-deploy-to-VPS.html">Hexo 搭建个人博客系列：部署上线篇<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kb2N1bWVudC9wcm9kdWN0LzQwMC8zNTI0NA==" title="https://cloud.tencent.com/document/product/400/35244">Nginx 服务器证书安装<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>建站</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Blog</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title>工作中一些简单的 Git 应用实践</title>
    <url>/archives/4511dcad.html</url>
    <content><![CDATA[<h1 id="前言" class="heading-control"><a href="#前言" class="headerlink" title="前言"></a>前言<a class="heading-anchor" href="#前言" aria-hidden="true"></a></h1><p>最近笔者在整理项目开发文档，深知代码版本管理的重要性，而 Git 作为代码版本管理的扛把子工具深受广大猿类喜爱。本篇文章旨在记录笔者日常开发工作中一些常用的 Git 应用实践。</p>
<h1 id="常用命令" class="heading-control"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令<a class="heading-anchor" href="#常用命令" aria-hidden="true"></a></h1><p>下面是笔者常用的一些 Git 命令：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>git add --all</code></td>
<td>将当前工作区（working directory）修改添加到暂存区（stage），只有添加到暂存区的修改才能被提交（commit）</td>
</tr>
<tr>
<td><code>git checkout branch_name</code></td>
<td>切换到名为 branch_name 分支</td>
</tr>
<tr>
<td><code>git checkout -b branch_name</code></td>
<td>创建名为 branch_name 的新分支</td>
</tr>
<tr>
<td><code>git checkout commit_id</code></td>
<td>切换到 id 为 commit_id 对应的提交</td>
</tr>
<tr>
<td><code>git checkout tag_number</code></td>
<td>切换到 tag 号 为 tag_number 对应的提交</td>
</tr>
<tr>
<td><code>git commit -m &quot;comment&quot;</code></td>
<td>向本地仓库提交修改，comment 代表本次提交的注释内容</td>
</tr>
<tr>
<td><code>git push</code></td>
<td>向远程仓库推送更新本地提交</td>
</tr>
<tr>
<td><code>git push --tags</code></td>
<td>向远程仓库推送本地仓库的所有 tag 信息</td>
</tr>
<tr>
<td><code>git stash</code></td>
<td>将工作区与暂存区中的修改临时保存到 git 栈（需要时可以恢复），并将工作区与暂存区恢复至上一次提交的状态</td>
</tr>
<tr>
<td><code>git stash save -u &quot;message&quot;</code></td>
<td>将工作区与暂存区中的修改以及未被追踪的修改（-u）临时保存到 git 栈（需要时可以恢复），并将工作区与暂存区恢复至上一次提交的状态，message 表示此次操作的备注信息</td>
</tr>
<tr>
<td><code>git stash list</code></td>
<td>列举当前 git 栈中所有被临时保存的修改，每一次临时修改都对应唯一的 stash_id，从 0 开始，依次往后追加</td>
</tr>
<tr>
<td><code>git stash pop</code></td>
<td>将 git 栈栈顶（即最新的）的临时修改弹出并恢复至当前分支</td>
</tr>
<tr>
<td><code>git stash apply stash@{stash_id}</code></td>
<td>将 git 栈中 stash_id 对应的临时修改恢复至当前分支，但不会删除 git 栈中的对应内容</td>
</tr>
<tr>
<td><code>git stash drop stash@{stash_id}</code></td>
<td>将 git 栈中 stash_id 对应的临时修改删除</td>
</tr>
<tr>
<td><code>git stash clear</code></td>
<td>删除 git 栈中所有的临时修改</td>
</tr>
<tr>
<td><code>git tag tag_number</code></td>
<td>为最新提交打上名为 tag_number 的 tag 号</td>
</tr>
<tr>
<td><code>git tag tag_number commit_id</code></td>
<td>为 id 为 commit_id 对应的提交打上名为 tag_number 的 tag 号</td>
</tr>
<tr>
<td><code>git tag -d tag_number</code></td>
<td>删除本地仓库名为 tag_number 的 tag 号</td>
</tr>
<tr>
<td><code>git push origin :refs/tags/tag_number</code></td>
<td>删除远程仓库名为 tag_number 的 tag 号</td>
</tr>
<tr>
<td><code>git reset --hard HEAD</code></td>
<td>丢弃工作区与暂存区中的修改（未被跟踪的修改需要先添加至暂存区），并恢复至最新提交的状态</td>
</tr>
<tr>
<td><code>git reset --hard commit_id</code></td>
<td>丢弃工作区与暂存区中的修改（未被跟踪的修改需要先添加至暂存区），并恢复至 id 为 commit_id 对应的提交的状态</td>
</tr>
<tr>
<td><code>git branch -a</code></td>
<td>查看本地及远程的所有分支</td>
</tr>
<tr>
<td><code>git branch -D branch_name</code></td>
<td>删除本地仓库名为 branch_name 的分支</td>
</tr>
<tr>
<td><code>git push origin --delete branch_name</code></td>
<td>删除远程仓库仓库名为 branch_name 的分支</td>
</tr>
<tr>
<td><code>git log</code></td>
<td>查看提交日志</td>
</tr>
<tr>
<td><code>git status</code></td>
<td>查看工作树状态，分别列举工作区和暂存区中的修改</td>
</tr>
<tr>
<td><code>git diff</code></td>
<td>详细展现工作树与上次提交间的变更</td>
</tr>
<tr>
<td><code>git diff branch1 branch2</code></td>
<td>详细展现 branch2 分支相比 branch1 分支的修改</td>
</tr>
<tr>
<td><code>git config --list</code></td>
<td>查看本地仓库的 git 配置</td>
</tr>
</tbody>
</table>
</div>
<p>善用每一个命令的 <code>--help</code> 选项可以帮助你快速地了解该命令。</p>
<h1 id="alias-别名" class="heading-control"><a href="#alias-别名" class="headerlink" title="alias 别名"></a>alias 别名<a class="heading-anchor" href="#alias-别名" aria-hidden="true"></a></h1><p>为常用命令设置 alias 别名可提升工作效率，具体设置在 <code>~/.gitconfig</code> 文件中，下面是笔者常用的一些 git alias 别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[alias]</span><br><span class="line">	co &#x3D; checkout</span><br><span class="line">	st &#x3D; status</span><br><span class="line">	br &#x3D; branch</span><br><span class="line">	ci &#x3D; commit</span><br><span class="line">	lg &#x3D; log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit</span><br><span class="line">	go &#x3D; reset --hard</span><br></pre></td></tr></table></figure>
<p>其中，<code>lg</code> 别名可以很好地美化提交历史显示，例如下图清晰地展示了 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fwb2xsb0F1dG8vYXBvbGxv" title="https://github.com/ApolloAuto/apollo">Apollo<i class="fa fa-external-link"></i></span> 本地仓库 master 分支上两周内的提交历史：</p>
<p><img data-src="https://image.shipengx.com/%E7%BE%8E%E5%8C%96%E8%BF%87%E7%9A%84%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2.png" alt="美化过的提交历史"></p>
<h1 id="配置-Ubuntu-终端默认显示所在-Git-仓库的当前分支" class="heading-control"><a href="#配置-Ubuntu-终端默认显示所在-Git-仓库的当前分支" class="headerlink" title="配置 Ubuntu 终端默认显示所在 Git 仓库的当前分支"></a>配置 Ubuntu 终端默认显示所在 Git 仓库的当前分支<a class="heading-anchor" href="#配置-Ubuntu-终端默认显示所在-Git-仓库的当前分支" aria-hidden="true"></a></h1><p>Ubuntu 环境中，在一个 Git 仓库下打开终端无法显示当前所处分支，很不方便，可以按照如下步骤进行配置解决该问题：</p>
<p>（1）在终端中打开 bash shell 的配置文件 <code>.bashrc</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>（2）在文件末尾添加如下 shell 代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># These shell commands block are for the purpose of displaying the</span></span><br><span class="line"><span class="comment"># current branch name of the current repository.</span></span><br><span class="line">find_git_branch ()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">local</span> dir=. head</span><br><span class="line">  until [ <span class="string">"<span class="variable">$dir</span>"</span> -ef / ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$dir</span>/.git/HEAD"</span> ]; <span class="keyword">then</span></span><br><span class="line">      head=$(&lt; <span class="string">"<span class="variable">$dir</span>/.git/HEAD"</span>)</span><br><span class="line">      <span class="keyword">if</span> [[ <span class="variable">$head</span> = ref:\ refs/heads/* ]]; <span class="keyword">then</span></span><br><span class="line">        git_branch=<span class="string">"(*<span class="variable">$&#123;head#*/*/&#125;</span>)"</span></span><br><span class="line">      <span class="keyword">elif</span> [[ <span class="variable">$head</span> != <span class="string">''</span> ]]; <span class="keyword">then</span></span><br><span class="line">        git_branch=<span class="string">"(*(detached))"</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        git_branch=<span class="string">"(*(unknow))"</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">      <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">    dir=<span class="string">"../<span class="variable">$dir</span>"</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  git_branch=<span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">PROMPT_COMMAND=<span class="string">"find_git_branch; <span class="variable">$PROMPT_COMMAND</span>"</span></span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">"\[\e]0;\u@\h: \w\a\]<span class="variable">$&#123;debian_chroot:+($debian_chroot)&#125;</span>\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\[\033[0;32m\]\$git_branch\[\033[0m\] \$ "</span></span><br></pre></td></tr></table></figure>
<p>（3）使更改立即生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>作者发表在独立博客的几篇 <a href="https://blog.shipengx.com/tags/Git/">Git 系列小文章</a> 可提供一些其它有益参考，此外，廖雪峰的 <span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAw" title="https://www.liaoxuefeng.com/wiki/896043488029600">Git 系列教程<i class="fa fa-external-link"></i></span> 是不错的 Git 学习资料。如果读者朋友有哪些其它的可提升工作效率的 Git 命令或应用技巧也请不吝赐教。</p>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>工作中关于 CI 持续集成的一些总结</title>
    <url>/archives/9b577a68.html</url>
    <content><![CDATA[<h1 id="0-背景" class="heading-control"><a href="#0-背景" class="headerlink" title="0 背景"></a>0 背景<a class="heading-anchor" href="#0-背景" aria-hidden="true"></a></h1><p>持续集成（Continuous Integration，简称 CI）、持续交付（Continuous Delivery）和持续部署（Continuous Deployment）都是互联网领域优秀且成熟的软件工程实践。关于 CI，可以参考阮一峰老师的文章<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTUvMDkvY29udGludW91cy1pbnRlZ3JhdGlvbi5odG1s" title="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html">《持续集成是什么？》<i class="fa fa-external-link"></i></span>进行大致的了解。</p>
<p>在自动驾驶软件开发过程中，也曾有过一段时间实践了 CI 平台的搭建，下图是基于 GitLab + Jenkins 的 CI 平台工作流程图，基于 GitLab + GitLab CI + GitLab Runner 的 CI 平台流程与之类似，博主工作中采用的是后者的方式，两者差别不大。</p>
<p><img data-src="https://image.shipengx.com/%E5%9F%BA%E4%BA%8EGitLab%20%2B%20Jenkins%E7%9A%84CI%E5%B9%B3%E5%8F%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="基于GitLab + Jenkins的CI平台工作流程"></p>
<h1 id="1-基础概念" class="heading-control"><a href="#1-基础概念" class="headerlink" title="1 基础概念"></a>1 基础概念<a class="heading-anchor" href="#1-基础概念" aria-hidden="true"></a></h1><h2 id="1-1-GitLab" class="heading-control"><a href="#1-1-GitLab" class="headerlink" title="1.1 GitLab"></a>1.1 GitLab<a class="heading-anchor" href="#1-1-GitLab" aria-hidden="true"></a></h2><ul>
<li>GitLab 用于代码托管和版本控制</li>
</ul>
<h3 id="1-1-1-搭建-GitLab-服务器" class="heading-control"><a href="#1-1-1-搭建-GitLab-服务器" class="headerlink" title="1.1.1 搭建 GitLab 服务器"></a>1.1.1 搭建 GitLab 服务器<a class="heading-anchor" href="#1-1-1-搭建-GitLab-服务器" aria-hidden="true"></a></h3><ul>
<li>安装依赖</li>
<li>安装 gitlab-ce</li>
<li>配置服务器 IP 和端口</li>
<li>启动各项服务</li>
<li>web 页面设置 root 用户密码</li>
</ul>
<h3 id="1-1-2-创建-Group" class="heading-control"><a href="#1-1-2-创建-Group" class="headerlink" title="1.1.2 创建 Group"></a>1.1.2 创建 Group<a class="heading-anchor" href="#1-1-2-创建-Group" aria-hidden="true"></a></h3><ul>
<li>web 页面操作（可见性选择“内部”）</li>
<li>向 Group 内添加 user，并为其分配角色：<code>Reporter</code> <code>Developer</code> <code>Owner</code>等</li>
</ul>
<h3 id="1-1-3-在-Group-下创建-Project" class="heading-control"><a href="#1-1-3-在-Group-下创建-Project" class="headerlink" title="1.1.3 在 Group 下创建 Project"></a>1.1.3 在 Group 下创建 Project<a class="heading-anchor" href="#1-1-3-在-Group-下创建-Project" aria-hidden="true"></a></h3><ul>
<li>web 页面操作（可见性选择“私有”）</li>
</ul>
<h3 id="1-1-4-完成-Project-创建后的设置" class="heading-control"><a href="#1-1-4-完成-Project-创建后的设置" class="headerlink" title="1.1.4 完成 Project 创建后的设置"></a>1.1.4 完成 Project 创建后的设置<a class="heading-anchor" href="#1-1-4-完成-Project-创建后的设置" aria-hidden="true"></a></h3><ul>
<li>web 页面修改 clone 地址，形如：<br>UserName@ServerIP_OR_ServerDomain:GroupName/ProjectName.git</li>
</ul>
<h3 id="1-1-5-GitLab-CI" class="heading-control"><a href="#1-1-5-GitLab-CI" class="headerlink" title="1.1.5 GitLab CI"></a>1.1.5 GitLab CI<a class="heading-anchor" href="#1-1-5-GitLab-CI" aria-hidden="true"></a></h3><ul>
<li>内建 CI，GitLab 的一部分，如果由 GitLab CI 来执行构建任务，会降低 GitLab 性能，更适合用于管理构建任务</li>
<li>在 GitLab 工程仓库根目录下创建持续集成流程模板<code>yaml</code>脚本文件：.gitlab-ci.yml，即可开启 GitLab CI</li>
</ul>
<h3 id="1-1-6-GitLab-Runner" class="heading-control"><a href="#1-1-6-GitLab-Runner" class="headerlink" title="1.1.6 GitLab Runner"></a>1.1.6 GitLab Runner<a class="heading-anchor" href="#1-1-6-GitLab-Runner" aria-hidden="true"></a></h3><ul>
<li>使用 GitLab CI 时，用于执行构建任务的脚本命令</li>
<li>需在集成服务器上单独安装，并进行注册和配置，在 GitLab 服务器通过 web 页面为各个 Project 激活 Runner，配合 GitLab CI 使用，存在三种形式：<ul>
<li>本地服务器 Runner</li>
<li>远程服务器 Runner</li>
<li>Docker Runner</li>
</ul>
</li>
<li>按照 Runner 与 GitLab Project 间的映射关系，可以在安装 Runner 时将其注册为以下三种形式中的一种：<ul>
<li>Specific Runner</li>
<li>Shared Runner</li>
<li>Group Runner（新版的 GitLab 才支持）</li>
</ul>
</li>
</ul>
<h3 id="1-1-7-GitLab-Webhook" class="heading-control"><a href="#1-1-7-GitLab-Webhook" class="headerlink" title="1.1.7 GitLab Webhook"></a>1.1.7 GitLab Webhook<a class="heading-anchor" href="#1-1-7-GitLab-Webhook" aria-hidden="true"></a></h3><ul>
<li>向 GitLab Project 发起的<code>push</code> <code>merge</code> <code>tag</code>等事件可以触发 GitLab Webhook 访问一个或多个 Jenkins 回调地址（创建的 Jenkins Job），通知 Jenkins 拉取代码，并执行自动构建、打包等操作</li>
</ul>
<h3 id="1-1-8-如何配置-GitLab-Project-与-Jenkins-Job-间的联系" class="heading-control"><a href="#1-1-8-如何配置-GitLab-Project-与-Jenkins-Job-间的联系" class="headerlink" title="1.1.8 如何配置 GitLab Project 与 Jenkins Job 间的联系"></a>1.1.8 如何配置 GitLab Project 与 Jenkins Job 间的联系<a class="heading-anchor" href="#1-1-8-如何配置-GitLab-Project-与-Jenkins-Job-间的联系" aria-hidden="true"></a></h3><ul>
<li>开放允许外发请求：管理中心 -&gt; 设置 -&gt; 网络 -&gt; 外发请求</li>
<li>创建 Personal Access Token</li>
<li>创建 Private Token</li>
<li>添加 Jenkins 回调地址 GitLab Webhook URL 和 Jenkins 创建的 Secret Token</li>
</ul>
<h3 id="1-1-9-如何配置-GitLab-服务器与集成服务器间的联系" class="heading-control"><a href="#1-1-9-如何配置-GitLab-服务器与集成服务器间的联系" class="headerlink" title="1.1.9 如何配置 GitLab 服务器与集成服务器间的联系"></a>1.1.9 如何配置 GitLab 服务器与集成服务器间的联系<a class="heading-anchor" href="#1-1-9-如何配置-GitLab-服务器与集成服务器间的联系" aria-hidden="true"></a></h3><ul>
<li>集成服务器上生成 SSH key，将公钥添加至 GitLab 服务器，用于 clone 代码</li>
</ul>
<h2 id="1-2-Jenkins" class="heading-control"><a href="#1-2-Jenkins" class="headerlink" title="1.2 Jenkins"></a>1.2 Jenkins<a class="heading-anchor" href="#1-2-Jenkins" aria-hidden="true"></a></h2><ul>
<li>用于多台集成服务器间构建任务的调度</li>
</ul>
<h3 id="1-2-1-搭建-Jenkins-服务器" class="heading-control"><a href="#1-2-1-搭建-Jenkins-服务器" class="headerlink" title="1.2.1 搭建 Jenkins 服务器"></a>1.2.1 搭建 Jenkins 服务器<a class="heading-anchor" href="#1-2-1-搭建-Jenkins-服务器" aria-hidden="true"></a></h3><ul>
<li>安装 JDK</li>
<li>安装 Jenkins</li>
<li>配置服务器端口</li>
</ul>
<h3 id="1-2-2-新建-Job" class="heading-control"><a href="#1-2-2-新建-Job" class="headerlink" title="1.2.2 新建 Job"></a>1.2.2 新建 Job<a class="heading-anchor" href="#1-2-2-新建-Job" aria-hidden="true"></a></h3><ul>
<li>web 页面操作</li>
</ul>
<h3 id="1-2-3-pipeline" class="heading-control"><a href="#1-2-3-pipeline" class="headerlink" title="1.2.3 pipeline"></a>1.2.3 pipeline<a class="heading-anchor" href="#1-2-3-pipeline" aria-hidden="true"></a></h3><ul>
<li>Jenkins 可以创建多种形式的构建 Job，自由风格的和流水线（Pipeline）式的最为常用，流水线式的构建 Job 所使用的构建脚本被称为 Pipeline Script，使用<code>Groovy</code>语法</li>
</ul>
<h3 id="1-2-4-节点的定义" class="heading-control"><a href="#1-2-4-节点的定义" class="headerlink" title="1.2.4 节点的定义"></a>1.2.4 节点的定义<a class="heading-anchor" href="#1-2-4-节点的定义" aria-hidden="true"></a></h3><ul>
<li>Jenkins 服务器与集成服务器都是节点，Jenkins 服务器是<code>master</code>节点，集成服务器是<code>slave</code>节点</li>
<li>每个<code>slave</code>节点需配置节点名、最大任务数、远程根目录、用法（尽量运行或仅构建指定 Job）、Jenkins 服务器登录节点的方式（Launch method）：SSH、节点 IP、凭据（Username + Password）</li>
</ul>
<h3 id="1-2-5-如何配置多节点分布式构建" class="heading-control"><a href="#1-2-5-如何配置多节点分布式构建" class="headerlink" title="1.2.5 如何配置多节点分布式构建"></a>1.2.5 如何配置多节点分布式构建<a class="heading-anchor" href="#1-2-5-如何配置多节点分布式构建" aria-hidden="true"></a></h3><ul>
<li>Pipeline Script 中不要指定节点名即可</li>
</ul>
<h3 id="1-2-6-如何配置-Jenkins-Pipeline-Job-与-GitLab-Project-间的联系" class="heading-control"><a href="#1-2-6-如何配置-Jenkins-Pipeline-Job-与-GitLab-Project-间的联系" class="headerlink" title="1.2.6 如何配置 Jenkins Pipeline Job 与 GitLab Project 间的联系"></a>1.2.6 如何配置 Jenkins Pipeline Job 与 GitLab Project 间的联系<a class="heading-anchor" href="#1-2-6-如何配置-Jenkins-Pipeline-Job-与-GitLab-Project-间的联系" aria-hidden="true"></a></h3><ul>
<li>Jenkins 安装 GitLab 插件、GitLab Hook 插件</li>
<li>配置构建触发器<ul>
<li>创建 Jenkins 回调地址 GitLab Webhook URL</li>
<li>创建 Sercret Token</li>
</ul>
</li>
<li>配置构建执行脚本</li>
</ul>
<h3 id="1-2-7-如何配置-Jenkins-FreeStyle-Job-与-GitLab-Project-间的联系" class="heading-control"><a href="#1-2-7-如何配置-Jenkins-FreeStyle-Job-与-GitLab-Project-间的联系" class="headerlink" title="1.2.7 如何配置 Jenkins FreeStyle Job 与 GitLab Project 间的联系"></a>1.2.7 如何配置 Jenkins FreeStyle Job 与 GitLab Project 间的联系<a class="heading-anchor" href="#1-2-7-如何配置-Jenkins-FreeStyle-Job-与-GitLab-Project-间的联系" aria-hidden="true"></a></h3><ul>
<li>Jenkins 安装 GitLab 插件、GitLab Hook 插件</li>
<li>配置 GitLab 连接<ul>
<li>添加 GitLab 创建的 GitLab API token</li>
</ul>
</li>
<li>配置源码管理<ul>
<li>设置 GitLab Project 代码仓库 URL</li>
<li>配置凭据</li>
</ul>
</li>
<li>配置构建触发器<ul>
<li>创建 Jenkins 回调地址 GitLab Webhook URL</li>
<li>创建 Sercret Token</li>
</ul>
</li>
<li>配置构建执行脚本</li>
</ul>
<h3 id="1-2-8-如何配置-Jenkins-服务器与集成服务器间的联系" class="heading-control"><a href="#1-2-8-如何配置-Jenkins-服务器与集成服务器间的联系" class="headerlink" title="1.2.8 如何配置 Jenkins 服务器与集成服务器间的联系"></a>1.2.8 如何配置 Jenkins 服务器与集成服务器间的联系<a class="heading-anchor" href="#1-2-8-如何配置-Jenkins-服务器与集成服务器间的联系" aria-hidden="true"></a></h3><ul>
<li>配置 Jenkins 服务器登录节点的方式（Launch method）：SSH、节点 IP、凭据（Username + Password）</li>
</ul>
<h3 id="1-2-9-Jenkins-与-GitLab-服务器、集成服务器间的三种认证-授权方式" class="heading-control"><a href="#1-2-9-Jenkins-与-GitLab-服务器、集成服务器间的三种认证-授权方式" class="headerlink" title="1.2.9 Jenkins 与 GitLab 服务器、集成服务器间的三种认证/授权方式"></a>1.2.9 Jenkins 与 GitLab 服务器、集成服务器间的三种认证/授权方式<a class="heading-anchor" href="#1-2-9-Jenkins-与-GitLab-服务器、集成服务器间的三种认证-授权方式" aria-hidden="true"></a></h3><ul>
<li>Username with password</li>
<li>GitLab API Token<ul>
<li>GitLab Private Token</li>
<li>GitLab Personal Access Token</li>
</ul>
</li>
<li>SSH Username with private key</li>
</ul>
<h2 id="1-3-Jfrog-Artifactory" class="heading-control"><a href="#1-3-Jfrog-Artifactory" class="headerlink" title="1.3 Jfrog Artifactory"></a>1.3 Jfrog Artifactory<a class="heading-anchor" href="#1-3-Jfrog-Artifactory" aria-hidden="true"></a></h2><ul>
<li>用于环境、存放库、软件包、集成版本等二进制文件</li>
</ul>
<h3 id="1-3-1-搭建-Artifactory-服务器" class="heading-control"><a href="#1-3-1-搭建-Artifactory-服务器" class="headerlink" title="1.3.1 搭建 Artifactory 服务器"></a>1.3.1 搭建 Artifactory 服务器<a class="heading-anchor" href="#1-3-1-搭建-Artifactory-服务器" aria-hidden="true"></a></h3><h3 id="1-3-2-基本操作（如何进行二进制文件版本管理）" class="heading-control"><a href="#1-3-2-基本操作（如何进行二进制文件版本管理）" class="headerlink" title="1.3.2 基本操作（如何进行二进制文件版本管理）"></a>1.3.2 基本操作（如何进行二进制文件版本管理）<a class="heading-anchor" href="#1-3-2-基本操作（如何进行二进制文件版本管理）" aria-hidden="true"></a></h3><ul>
<li>web 页面操作</li>
</ul>
<h3 id="1-3-3-安装插件" class="heading-control"><a href="#1-3-3-安装插件" class="headerlink" title="1.3.3 安装插件"></a>1.3.3 安装插件<a class="heading-anchor" href="#1-3-3-安装插件" aria-hidden="true"></a></h3><h2 id="1-4-集成服务器" class="heading-control"><a href="#1-4-集成服务器" class="headerlink" title="1.4 集成服务器"></a>1.4 集成服务器<a class="heading-anchor" href="#1-4-集成服务器" aria-hidden="true"></a></h2><ul>
<li>用于执行具体的集成任务脚本命令。于 GitLab CI 而言，集成服务器是 Runner；于 Jenkins 而言，集成服务器是 node。</li>
</ul>
<h1 id="2-GitLab-GitLab-CI-GitLab-Runner-实现-CI" class="heading-control"><a href="#2-GitLab-GitLab-CI-GitLab-Runner-实现-CI" class="headerlink" title="2 GitLab + GitLab CI + GitLab Runner 实现 CI"></a>2 GitLab + GitLab CI + GitLab Runner 实现 CI<a class="heading-anchor" href="#2-GitLab-GitLab-CI-GitLab-Runner-实现-CI" aria-hidden="true"></a></h1><p>一些关键点：</p>
<ul>
<li><code>yaml</code>脚本中<code>before_script</code> <code>after_script</code>及普通 job scripts 在 Runner 服务器的路径入口</li>
<li>将 job 配置为<code>tag</code>触发</li>
<li>获取 Project 最新的<code>tag</code>信息，可参考此前的文章<a href="https://blog.shipengx.com/archives/732ab93b.html">《如何检出 git 仓库中最新的 tag 号》</a></li>
</ul>
<h1 id="3-GitLab-Jenkins-Node-实现-CI" class="heading-control"><a href="#3-GitLab-Jenkins-Node-实现-CI" class="headerlink" title="3 GitLab + Jenkins + Node 实现 CI"></a>3 GitLab + Jenkins + Node 实现 CI<a class="heading-anchor" href="#3-GitLab-Jenkins-Node-实现-CI" aria-hidden="true"></a></h1><p>当时未进行此类实践。</p>
<h1 id="4-总结" class="heading-control"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结<a class="heading-anchor" href="#4-总结" aria-hidden="true"></a></h1><h2 id="4-1-GitLab-CI-与-Jenkins-非常相似" class="heading-control"><a href="#4-1-GitLab-CI-与-Jenkins-非常相似" class="headerlink" title="4.1 GitLab CI 与 Jenkins 非常相似"></a>4.1 GitLab CI 与 Jenkins 非常相似<a class="heading-anchor" href="#4-1-GitLab-CI-与-Jenkins-非常相似" aria-hidden="true"></a></h2><ul>
<li>GitLab CI 的 gitlab-ci.yml 相当于 Jenkins job 的构建脚本</li>
<li>GitLab Runner 相当于 Jenkins 的 node</li>
<li>GitLab Runner 注册时的 tags 相当于 Jenkins node 的节点名</li>
<li>GitLab CI 会将 gitlab-ci.yml 中定义的各个子 job 分配到指定 Runner 执行（通过 tags 关键字进行指定，如未指定则随机分配），Jenkins job 构建脚本（脚本式 pipeline）可以通过在 node 块中指定 node 名来选定 node 服务器执行脚本命令</li>
</ul>
<h1 id="5-参考" class="heading-control"><a href="#5-参考" class="headerlink" title="5 参考"></a>5 参考<a class="heading-anchor" href="#5-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGxhYi5jb20v" title="https://docs.gitlab.com/">GitLab Docs<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qZW5raW5zLmlvL2RvYy8=" title="https://jenkins.io/doc/">Jenkins Docs<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbXljb2dub3MvcC8xMDE1NTk3OC5odG1s" title="https://www.cnblogs.com/mycognos/p/10155978.html">Git Hooks、GitLab CI 持续集成以及使用 Jenkins 实现自动化任务<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9mZW5uYXkuZ2l0aHViLmlvL2dpdGxhYi1jaS1jbi9naXRsYWItY2kteWFtbC5odG1s" title="https://fennay.github.io/gitlab-ci-cn/gitlab-ci-yaml.html">通过.gitlab-ci.yml 配置任务<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2VudG9zLmJ6LzIwMTgvMDUvZ2l0bGFiJUU5JTgwJTlBJUU4JUJGJTg3d2ViaG9vayVFNSVBRSU5RSVFNyU4RSVCMHB1c2glRTQlQkIlQTMlRTclQTAlODElRTUlOTAlOEVqZW5raW5zJUU4JTg3JUFBJUU1JThBJUE4JUU2JTlFJTg0JUU1JUJCJUJBLw==" title="https://www.centos.bz/2018/05/gitlab%E9%80%9A%E8%BF%87webhook%E5%AE%9E%E7%8E%B0push%E4%BB%A3%E7%A0%81%E5%90%8Ejenkins%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA/">Gitlab 通过 Webhook 实现 Push 代码后 Jenkins 自动构建<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbm55bGVlL3AvMTEzODk4MDMuaHRtbA==" title="https://www.cnblogs.com/nnylee/p/11389803.html">Gitlab + Jenkins 的 CI 实践<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vYmlnZGV2aWxraW5nL3AvOTU0MzA5Mi5odG1s" title="https://www.cnblogs.com/bigdevilking/p/9543092.html">CentOS 7 部署 Gitlab+Jenkins 持续集成 (CI) 环境<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMzI2NTMy" title="https://cloud.tencent.com/developer/article/1326532">利用 Gitlab 和 Jenkins 做 CI(持续集成)<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk1NDkyMTUvd2hhdC1pcy10aGUtZGlmZmVyZW5jZS1iZXR3ZWVuLWEtbm9kZS1zdGFnZS1hbmQtc3RlcC1pbi1qZW5raW5zLXBpcGVsaW5lcw==" title="https://stackoverflow.com/questions/39549215/what-is-the-difference-between-a-node-stage-and-step-in-jenkins-pipelines">What is the difference between a node, stage, and step in Jenkins pipelines?<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly90cmlwbGVjYy5naXRodWIuaW8vMjAxOC8wNi8yMy8yMDE4LTA2LTIzLWppLWdpdGxhYmNpZGUtY2ktc2hpLWppYW4v" title="https://triplecc.github.io/2018/06/23/2018-06-23-ji-gitlabcide-ci-shi-jian/">火掌柜 iOS 团队 GitLab CI 集成实践<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>效率</category>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title>工作中的一点关于C++有符号数/无符号数类型转换的思考</title>
    <url>/archives/80d5496e.html</url>
    <content><![CDATA[<h1 id="1-背景" class="heading-control"><a href="#1-背景" class="headerlink" title="1 背景"></a>1 背景<a class="heading-anchor" href="#1-背景" aria-hidden="true"></a></h1><p>工作中需要向下游规划（Planning）模块发送视觉检测到的车道线线型与颜色数据，但软件总体使用的是旧有架构，只有<code>uint8_t</code>的线型结构没有颜色接口。</p>
<h1 id="2-问题" class="heading-control"><a href="#2-问题" class="headerlink" title="2 问题"></a>2 问题<a class="heading-anchor" href="#2-问题" aria-hidden="true"></a></h1><p>实际上，颜色对应一个最大取值为3的枚举，线型对应一个最大取值为34的枚举，自然而然想到是使用线型接口的低六位存储线型值，使用线型接口的高两位存储颜色值，下游使用时，直接将线型接口位与<code>0x3f</code>获取真实线型值，将线型接口右移6位获取真实颜色值：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint8_t</span> line_type_interface = <span class="number">0b11100010</span>;</span><br><span class="line"><span class="keyword">uint8_t</span> line_type = line_type_interface &amp; <span class="number">0x3f</span>;</span><br><span class="line"><span class="keyword">uint8_t</span> line_color = line_type_interface &gt;&gt; <span class="number">6</span>;</span><br></pre></td></tr></table></figure><br>这在iECU（intelligent ECU） RTE（Run-Time Environment，AUTOSAR架构中VFB的接口实现）层上的表现是顺理成章的。</p>
<p>问题出现在离线调试阶段。我们的调试手段是将iECU中的运行时RTE数据转换为<span class="exturl" data-url="aHR0cDovL2xjbS1wcm9qLmdpdGh1Yi5pby8=" title="http://lcm-proj.github.io/">LCM<i class="fa fa-external-link"></i></span>数据并通过LCM UDP组播的形式向外发送，通过x86的日志上位机实时接收并存储LCM UDP报文，离线调试时将存储的LCM日志文件进行回放。RTE的线型接口为<code>uint8_t</code>类型，但LCM消息中对应的线型接口被定义成了<code>int8_t</code>类型。</p>
<p>我在为LCM消息赋值时，直接将RTE的线型接口的值赋给了LCM消息中的对应接口，这就造成了<code>uint8_t</code>向<code>int8_t</code>的隐式类型转换，我没有在意这一点，下游规划模块同样没有在意这一点，下游模块离线调试时直接将LCM日志文件中<code>int8_t</code>线型接口值做了向<code>uint8_t</code>的显式强制类型转换，然后进行了线型值和颜色值的提取操作，并且没有出过问题，直到同样需要接收相同信息的HMI（Human Machine Interface）下游模块遇到了问题：他在右移提取颜色值时出现了异常大的值。原来，HMI模块在进行颜色值的提取操作时直接将LCM日志中的接口值进行了右移操作，而<strong>LCM消息中对应的接口被定义成了<code>int8_t</code>类型，当接口取值为形如<code>0b11100010</code>的符号位为1的值时，右移操作会将空出位补1，从而造成提取的颜色数值异常</strong>。</p>
<p>当然，像规划模块那样，先将<code>int8_t</code>值向<code>uint8_t</code>做强制类型转换，再进行右移提取操作就不会有问题了，但这引发了我的思考：<strong>从原始RTE数据到离线注入数据，发生了<code>uint8_t</code> -&gt; <code>int8_t</code> -&gt; <code>uint8_t</code>的两次类型转换，为什么没有问题？</strong>我隐约地觉得应该会有问题。HMI模块还提了一个很基础但具有迷惑性的问题：<strong>当LCM日志中接口数据为<code>0b10000000</code>时，它对应的十进制是什么<code>-0</code>吗？</strong>（答案：-128。<code>int8_t</code>的取值范围是[-128, 127]，<code>0b10000000</code>即<code>int8_t</code>的取值下限。）</p>
<h1 id="3-知识点" class="heading-control"><a href="#3-知识点" class="headerlink" title="3 知识点"></a>3 知识点<a class="heading-anchor" href="#3-知识点" aria-hidden="true"></a></h1><ul>
<li>在计算机系统中，数值一律用补码来表示（存储），在程序调试时，所观察到的变量的十六进制均代表变量的补码。使用补码主要原因是可以将符号位和其它位统一处理；同时，减法也可按加法来处理；</li>
<li>两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。<strong>正数的补码与其原码一致；负数的补码为该数绝对值求反码（原码按位取反）后整体加1</strong>；</li>
<li><strong>所谓有符号数与无符号数间的类型转换，数据在内存中的补码表示并未发生改变，改变的是该补码在类型转换前后所对应的十进制含义，即计算机理解内存上补码数据的方式。</strong>例如，当RTE原始数据（<code>uint8_t</code>）取值为<code>0b11100010</code>时，计算机认为其代表十进制为：<script type="math/tex; mode=display">
2^7 + 2^6 + 2^5 + 2^1 = 226</script>此时，数据在内存中的补码为<code>11100010</code>。做了向<code>int8_t</code>的类型转换后，数据在内存中的补码依然是<code>11100010</code>，但此时计算机认为其代表十进制为：  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-~(<span class="number">0b1100010</span> - <span class="number">1</span>) = <span class="number">-0b</span>0011110</span><br></pre></td></tr></table></figure>
  即：<script type="math/tex; mode=display">
  -(2^4 + 2^3 + 2^2 + 2^1) = -30</script></li>
<li><strong>当赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数</strong>（《C++ Primer》），反之亦然（博主注）。注意到：<script type="math/tex; mode=display">
226 - 2^8 = -30</script>$2^8$是<code>uint8_t</code>和<code>int8_t</code>类型数据的模。</li>
</ul>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>带有大文件的 GitHub 项目的创建与拉取——使用 Git Large File Storage (LFS)</title>
    <url>/archives/af0e9080.html</url>
    <content><![CDATA[<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>某天下午在远程工作站上装 ROS 把我搞烦了，抽时间写了个开源脚本工具 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1JvY1NoaS9yb3N0YWxsZXI=" title="https://github.com/RocShi/rostaller">rostaller<i class="fa fa-external-link"></i></span>，完全一键安装，自动在线更新 <code>YAML</code> 文件，不用再去应对手动安装时必然会遇到的 <code>rosdep init</code> 报错和 <code>rosdep update</code> 报错。工具最初的版本包含一个 <code>.tar.gz</code> 格式的压缩文件，向 GitHub 进行推送时被拒绝：文件大小超限（100 MB）。对于该问题，可以使用 Git Large File Storage (LFS) 对要上传的大文件进行托管。</p>
<p><img data-src="https://image.shipengx.com/Git%20LFS.gif" alt="Git LFS"></p>
<h1 id="1-准备工作" class="heading-control"><a href="#1-准备工作" class="headerlink" title="1 准备工作"></a>1 准备工作<a class="heading-anchor" href="#1-准备工作" aria-hidden="true"></a></h1><h2 id="1-1-安装-Git-LFS" class="heading-control"><a href="#1-1-安装-Git-LFS" class="headerlink" title="1.1 安装 Git LFS"></a>1.1 安装 Git LFS<a class="heading-anchor" href="#1-1-安装-Git-LFS" aria-hidden="true"></a></h2><p><strong>Windows</strong></p>
<p>直接<span class="exturl" data-url="aHR0cHM6Ly9naXQtbGZzLmdpdGh1Yi5jb20v" title="https://git-lfs.github.com/">官网<i class="fa fa-external-link"></i></span>下载二进制文件进行安装即可。</p>
<p><strong>Ubuntu</strong></p>
<ul>
<li><p>安装 <code>curl</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install curl</span><br></pre></td></tr></table></figure>
</li>
<li><p>请求并执行 Git LFS 前置脚本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装 Git LFS</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install git-lfs</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="1-2-为当前用户配置-Git-LFS" class="heading-control"><a href="#1-2-为当前用户配置-Git-LFS" class="headerlink" title="1.2 为当前用户配置 Git LFS"></a>1.2 为当前用户配置 Git LFS<a class="heading-anchor" href="#1-2-为当前用户配置-Git-LFS" aria-hidden="true"></a></h2><p>每个用户执行一次即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git lfs install</span><br></pre></td></tr></table></figure>
<h2 id="2-创建含有大文件的仓库" class="heading-control"><a href="#2-创建含有大文件的仓库" class="headerlink" title="2 创建含有大文件的仓库"></a>2 创建含有大文件的仓库<a class="heading-anchor" href="#2-创建含有大文件的仓库" aria-hidden="true"></a></h2><p>GitHub 端仓库的创建过程无异，不再赘述，对应的本地仓库的创建过程如下：</p>
<ul>
<li><p>初始化</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置远程仓库地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:your_username/your_repo.git</span><br></pre></td></tr></table></figure>
</li>
<li><p>告诉 Git LFS 需要追踪哪些文件。例如，追踪 <code>.tar.gz</code> 格式的压缩文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git lfs track &quot;*.tar.*&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>上一步骤将自动生成 <code>.gitattributes</code> 文件，将其添加到暂存区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .gitattributes</span><br></pre></td></tr></table></figure>
</li>
<li><p>向暂存区中添加剩余变更、提交、推送</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add --all</span><br><span class="line">git commit -m <span class="string">"first commit"</span></span><br><span class="line">git push orgin main</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="3-拉取含有大文件的-GitHub-仓库" class="heading-control"><a href="#3-拉取含有大文件的-GitHub-仓库" class="headerlink" title="3 拉取含有大文件的 GitHub 仓库"></a>3 拉取含有大文件的 GitHub 仓库<a class="heading-anchor" href="#3-拉取含有大文件的-GitHub-仓库" aria-hidden="true"></a></h1><p>直接 <code>clone</code> 即可。若在安装 Git LFS 前执行了 <code>clone</code>，则拉取下来的仓库中并不包含大文件本体，取而代之的是指向其 LFS 存储对象的文件指针，此种情况下，可通过在本地仓库中执行下述命令来 拉取文件指针所指向的完整对象：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git lfs pull</span><br></pre></td></tr></table></figure>
<h1 id="4-存在的问题" class="heading-control"><a href="#4-存在的问题" class="headerlink" title="4 存在的问题"></a>4 存在的问题<a class="heading-anchor" href="#4-存在的问题" aria-hidden="true"></a></h1><p>Git LFS 免费用户有 1 GB 的免费存储空间和每月 1 GB 的下载带宽，下载使用的总流量超限后会导致仓库无法 <code>clone</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Downloading rosdistro.tar.gz (105 MB)</span><br><span class="line">Error downloading object: rosdistro.tar.gz (2dffd34):</span><br><span class="line">Smudge error: Error downloading rosdistro.tar.gz (2dffd34dccb171115c2fcd4326735780181e0705bba57d502d3bf85538f92740):</span><br><span class="line">batch response: This repository is over its data quota.</span><br><span class="line">Account responsible for LFS bandwidth should purchase more data packs to restore access.</span><br><span class="line"></span><br><span class="line">Errors logged to &#x2F;home&#x2F;shipeng&#x2F;rostaller&#x2F;.git&#x2F;lfs&#x2F;logs&#x2F;20210706T224710.870367616.log</span><br><span class="line">Use &#96;git lfs logs last&#96; to view the log.</span><br><span class="line">error: external filter &#39;git-lfs filter-process&#39; failed</span><br><span class="line">fatal: rosdistro.tar.gz: smudge filter lfs failed</span><br><span class="line">warning: Clone succeeded, but checkout failed.</span><br><span class="line">You can inspect what was checked out with &#39;git status&#39;</span><br><span class="line">and retry the checkout with &#39;git checkout -f HEAD&#39;</span><br></pre></td></tr></table></figure>
<p>大意是，使用的 LFS 下载流量达到带宽限制，需要购买更多数据包。一般使用勉强够了。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXQtbGZzLmdpdGh1Yi5jb20v" title="https://git-lfs.github.com/">Git Large File Storage<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC80OTNiODE1NDRmODA=" title="https://www.jianshu.com/p/493b81544f80">Git LFS 的使用<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZ2l0aHViL2FkbWluaXN0ZXJpbmctYS1yZXBvc2l0b3J5L21hbmFnaW5nLXJlcG9zaXRvcnktc2V0dGluZ3MvbWFuYWdpbmctZ2l0LWxmcy1vYmplY3RzLWluLWFyY2hpdmVzLW9mLXlvdXItcmVwb3NpdG9yeQ==" title="https://docs.github.com/cn/github/administering-a-repository/managing-repository-settings/managing-git-lfs-objects-in-archives-of-your-repository">GitHub Docs - 管理仓库存档中的 Git LFS 对象<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLmdpdGh1Yi5jb20vY24vZ2l0aHViL21hbmFnaW5nLWxhcmdlLWZpbGVzL3ZlcnNpb25pbmctbGFyZ2UtZmlsZXMvYWJvdXQtc3RvcmFnZS1hbmQtYmFuZHdpZHRoLXVzYWdl" title="https://docs.github.com/cn/github/managing-large-files/versioning-large-files/about-storage-and-bandwidth-usage">GitHub Docs - 关于存储和带宽使用情况<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>效率</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>当我们谈融合时我们在谈些什么？</title>
    <url>/archives/e7b86cce.html</url>
    <content><![CDATA[<p>当我们谈融合时我们在谈些什么？</p>
<p>所谓融合，顾名思义，发挥多方输入信息的优势，得到更加可靠的输出信息。谈及融合，又通常会细分为前融合和后融合。</p>
<p>前融合是数据层面的融合，例如 Lidar 点云数据向 Camera 像素图中进行映射，综合利用两个 Sensor 的数据实施感知层面的目标识别。我们姑且可以认为前融合是感知和融合的一个交叉领域。<br>后融合是目标层面的融合，例如 Camera 目标和 Radar 目标的融合，Camera 目标具有类别优势，Radar 目标具有距离和速度优势。</p>
<p>上面所谈及的融合面向的都是外界对象，当讨论的对象是自身时又引申出融合领域的另一个话题——多传感器融合定位：综合利用多方外界信息，得到自身更加精准的位姿信息。</p>
<p>具体来讲，多传感器融合定位又包括组合定位和匹配定位。组合定位往往由 GPS + IMU + 轮速在扩展卡尔曼滤波（Extended Kalman Filter，EKF）框架下来实现（假设自身是一辆无人车）。GPS 提供低频长周期的粗定位结果（为提高精度，通常会引入差分技术，如 RTK）；IMU + 轮速充当航迹推算（Dead Reckoning）的角色，提供短时间的位姿推算结果（EKF 中的预测步）。匹配定位是利用 Camera 的视觉特征或 Lidar 的点云特征与事先建好的高精地图进行配准，达到定位的目的，经典的方法有粒子滤波（Particle Filter，PF）等。谈及匹配定位，似乎又和同步定位与建图（Simultaneous Localization And Mapping，SLAM）扯上了千丝万缕的联系？这个话题就太大了……</p>
<p>融合领域内容浩如烟海，以上仅是午夜时分的一家之言……</p>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>多传感器信息融合</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>多传感器信息融合</tag>
      </tags>
  </entry>
  <entry>
    <title>改变自己，只需要两年时间</title>
    <url>/archives/b9acf5.html</url>
    <content><![CDATA[<iframe src="//player.bilibili.com/player.html?aid=69605207&bvid=BV1NE41197sr&cid=120632352&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<p>Two years is nothing, but at the same time a lot can be accomplished in two years.</p>
<blockquote>
<p>两年的时间不算长，但与此同时，很多事情都能在两年内完成。</p>
</blockquote>
<p>You can try a sport you’ve always wanted to start, and become great at it.</p>
<blockquote>
<p>你可以尝试练习某个一直想要学会的运动，然后成为高手。</p>
</blockquote>
<p>You can start a morning routine and affect your mood and stress at a deep level.</p>
<blockquote>
<p>你可以养成一种晨间习惯，在深层次上改善你的情绪和压力。</p>
</blockquote>
<p>You can meditate for a few minutes per day, become more self-aware and change the way you react to problems.</p>
<blockquote>
<p>你可以每天冥想几分钟，这样会更有自省力，也会改变你处理问题的方式。</p>
</blockquote>
<p>You can start a business and make it a big success.</p>
<blockquote>
<p>你可以开启一项事业，让它走向成功。</p>
</blockquote>
<h2 id="01-Start-something-you’ve-always-wanted-to-do" class="heading-control"><a href="#01-Start-something-you’ve-always-wanted-to-do" class="headerlink" title="01 Start something you’ve always wanted to do"></a>01 Start something you’ve always wanted to do<a class="heading-anchor" href="#01-Start-something-you’ve-always-wanted-to-do" aria-hidden="true"></a></h2><p>Two years is nothing and extremely easy to waste, but with small actions, substantial commitment and consistency, you can make it count a lot.Two years being passive is a blink of an eye. Two years moving towards goals every single day is plenty of time. It’s just a matter of perspective. There is nothing that cannot be accomplished in two years with enough effort.</p>
<blockquote>
<p>两年时间真的不长，浪费起来非常容易。但是，只需小小的行动、切实的付出与坚持，你就可以让它变得意义非凡。如果你消极度日，两年就在眨眼之间飞逝；如果每一天都朝着目标前进，那么这两年就会很充实。这只是看待事情的角度问题。只要你足够努力，没有什么是在两年内无法完成的。</p>
</blockquote>
<p>You’re not too old for the things you were dreaming of doing when you were a kid. You can still do extreme sports if you wish to. You can start playing a musical instrument. You can become a photographer.</p>
<blockquote>
<p>对于实现年少的梦想，你永远都不会太老。如果你想，你还是可以去做极限运动，还是可以去玩乐器，还是可以成为一名摄影师。</p>
</blockquote>
<p>In two years from now, you’ll be great at it if you really want to. Don’t let your past dictate who you are. You don’t have to be the same person you have always been.Don’t let fear control you. Don’t let the social standards conform you. Age is just a number,we should all empower our uniqueness and fight against our own limitations.</p>
<blockquote>
<p>从现在起的两年时间，只要你真心诚意地追求，你就能变得超级厉害。不要让你的过去定义你是谁，你不用做那个一成不变的人。不要被恐惧支配，不要被社会标准束缚。年龄只是一个数字，我们都应该突出自己的独特之处，并与自我设限斗争。</p>
</blockquote>
<p>By doing things you love on a daily basis, even for a few minutes, you’ll learn to enjoy the journey. The days will become more than just a means to an end. You’ll see yourself evolving.</p>
<blockquote>
<p>每天去做你真正喜欢的事情，哪怕只有几分钟，你会爱上这个过程。光阴不再虚度，每天都能看到自己的进步。</p>
</blockquote>
<h2 id="02-Be-in-control" class="heading-control"><a href="#02-Be-in-control" class="headerlink" title="02 Be in control"></a>02 Be in control<a class="heading-anchor" href="#02-Be-in-control" aria-hidden="true"></a></h2><p>If you had the choice between feeling great, energetic and in a positive mood, versus feeling sleepy and moody, what would you choose?</p>
<blockquote>
<p>如果在感觉良好、精力充沛的积极心态，和昏昏欲睡、喜怒无常的消极心态里做选择，你会选哪一个？</p>
</blockquote>
<p>It’s just a choice, which combined with small, even tiny actions like reducing meat or alcohol consumption, or simply drinking more water, walking the stairs or biking to the office, can do wonders. It’s not about the end goal. It’s about daily actions towards it. It’s also the reason why morning routines, or ten minutes daily meditation sessions are bringing such great changes in terms of mood, productivity, stress management, etc.</p>
<blockquote>
<p>这就是个简单的选择，再加上微小的行动，比如少吃肉、少喝酒、或者简单的多喝点水、爬楼梯或者骑自行车去上班等，你就能创造奇迹了。并不是说这样做就能达成终极目标，而是这样做的每一天都会离终点更近。这也可以解释为什么晨间习惯或者每天十分钟的冥想，能给人的情绪、生产力和抗压能力带来巨大的改变。</p>
</blockquote>
<p>Replace TV shows and movies by documentaries and books. Monitor your days more, get in control of how you spend your time.Take back the control of your health, mood and time. Practice gratefulness. See the results in two years.</p>
<blockquote>
<p>把电视节目和电影替换成纪录片和书籍。监督自己的日常，掌控自己的时间分配。拿回你对健康、情绪和时间的掌控权，学会表达感激，你会在两年内看到成果。</p>
</blockquote>
<h2 id="03-Silence-your-ego" class="heading-control"><a href="#03-Silence-your-ego" class="headerlink" title="03 Silence your ego"></a>03 Silence your ego<a class="heading-anchor" href="#03-Silence-your-ego" aria-hidden="true"></a></h2><p>Be kind with people. Start with your family, don’t go mad one more time. Stop judging, see the good in them and remember that you love them more than anything.</p>
<blockquote>
<p>善待他人，从你的家庭开始，不要再对家人发脾气；停止批判，看到他们好的那面，并记住你爱他们超过一切。</p>
</blockquote>
<p>In your working life, being kind and nice can bring you more respect from people who surround you than being bossy and aggressive. Learn to say “No” often (for the right reasons), people will accept it more and value your “Yes” more, because your time’s value will increase.</p>
<blockquote>
<p>职场上，比起发号施令、争强好胜，与人为善会帮助你赢得周围人更多的尊重。在有正当理由的情况下，学会经常说“不”，人们会接受的，并且更看重你说“好”的时候，因为你的单位时间价值会增加。</p>
</blockquote>
<p>You don’t need to be scary to be respected. It’s about building trust and healthy long term relationships. Try this and in two years from now your reality will be so different.</p>
<blockquote>
<p>不是只有变得“凶”才会被尊重，重点是怎样建立彼此信任、健康的长期关系。试试看这样做，从现在起的两年时间里，你的生活将会变得大不一样。</p>
</blockquote>
<p>Silence your ego, love and trust others enough for two years, harvest for ten years or more.</p>
<blockquote>
<p>用两年的时间去压制你的自负，去爱他人，给他们充分的信任，那么在十年甚至更长的时间里你都会因此受益。</p>
</blockquote>
<h2 id="04-Set-long-term-goals-and-do-small-actions-everyday-towards-them" class="heading-control"><a href="#04-Set-long-term-goals-and-do-small-actions-everyday-towards-them" class="headerlink" title="04 Set long term goals and do small actions everyday towards them"></a>04 Set long term goals and do small actions everyday towards them<a class="heading-anchor" href="#04-Set-long-term-goals-and-do-small-actions-everyday-towards-them" aria-hidden="true"></a></h2><p>It has a lot to do with setting goals, but goals without actions are just wishes. The easiest way to reach goals is through daily and consistent small (even tiny) actions. It’s all about consistency, commitment, and regularity.</p>
<blockquote>
<p>这和设定的目标有很大的关系，但是没有行动的目标只是白日做梦。达成目标最简单的方法，就是通过每天坚持的微小行动，这一切在于建立一致性、坚持付出和养成习惯。</p>
</blockquote>
<p>Success is not an event, it’s a process and a mindset. Small actions are putting you in the position of succeeding. Small actions make huge differences. Look at yourself in the mirror in two years and you’ll think “that was quick!”.</p>
<blockquote>
<p>成功并非偶然，它是长久的过程和心态。微小的行动可以让你踏上成功的正轨，微小的行动可以带来巨大的改变。两年后，在镜子里看到自己，你会感叹：“时间过得真快呀！”</p>
</blockquote>
<p>EVERY. DAY. COUNTS.</p>
<blockquote>
<p>每一天都很重要。</p>
</blockquote>
]]></content>
      <categories>
        <category>TED</category>
      </categories>
      <tags>
        <tag>TED</tag>
      </tags>
  </entry>
  <entry>
    <title>最小二乘法多项式曲线拟合数学原理及其C++实现</title>
    <url>/archives/e0ebe48c.html</url>
    <content><![CDATA[<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>自动驾驶开发中经常涉及到多项式曲线拟合，本文详细描述了使用最小二乘法进行多项式曲线拟合的数学原理，通过样本集构造范德蒙德矩阵，将一元 N 次多项式非线性回归问题转化为 N 元一次线性回归问题，并基于线性代数 C++ 模板库——Eigen 进行了实现，最后，比较了几种实现方法在求解速度与求解精度上的差异。</p>
<h1 id="1-最小二乘法概述" class="heading-control"><a href="#1-最小二乘法概述" class="headerlink" title="1 最小二乘法概述"></a>1 最小二乘法概述<a class="heading-anchor" href="#1-最小二乘法概述" aria-hidden="true"></a></h1><p><strong>最小二乘法</strong>（Least Square Method，LSM）通过最小化误差（也叫残差）的平方和寻找数据的最优函数匹配。</p>
<p>假设给定一组样本数据集 $P(x, y)$，$P$ 内各数据点 $P_i(x_i, y_i) (i=1, 2, 3, …, m)$ 来自于对多项式</p>
<script type="math/tex; mode=display">
f(x_i)=θ_0+θ_1x_i+θ_2x_i^2+···+θ_nx_i^n</script><p>的多次采样，其中：</p>
<ul>
<li>$m$ 为样本维度</li>
<li>$n$ 为多项式阶数</li>
<li>$θ_j (j=1, 2, 3, …, n)$ 为多项式的各项系数</li>
</ul>
<p>针对样本数据集 $P$ 内各数据点的误差平方和为：</p>
<script type="math/tex; mode=display">
S=\sum_{i=1}^m[f(x_i)-y_i]^2</script><p>最小二乘法认为，最优函数的各项系数 $θ_j (j=1, 2, 3, …, n)$ 应使得误差平方和 $S$ 取得极小值。最小二乘法与<strong>极大似然估计</strong>有着密切的联系，关于最小二乘法的数学本质可参考文章<span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0b25neHVlLmNvbS9tYWRvY3MvODE4Lmh0bWw=" title="https://www.matongxue.com/madocs/818.html">《如何理解最小二乘法？》<i class="fa fa-external-link"></i></span>。</p>
<h1 id="2-最小二乘法求解多项式曲线系数向量的数学推导" class="heading-control"><a href="#2-最小二乘法求解多项式曲线系数向量的数学推导" class="headerlink" title="2 最小二乘法求解多项式曲线系数向量的数学推导"></a>2 最小二乘法求解多项式曲线系数向量的数学推导<a class="heading-anchor" href="#2-最小二乘法求解多项式曲线系数向量的数学推导" aria-hidden="true"></a></h1><h2 id="2-1-代数法" class="heading-control"><a href="#2-1-代数法" class="headerlink" title="2.1 代数法"></a>2.1 代数法<a class="heading-anchor" href="#2-1-代数法" aria-hidden="true"></a></h2><p>由于最优函数的各项系数 $θ_j (j=1, 2, 3, …, n)$ 使得误差平方和 $S$ 取得极小值，因而，对于最优函数而言，其误差平方和 $S$ 对各多项式系 i 数 $θ_j (j=1, 2, 3, …, n)$ 的偏导数应满足：</p>
<script type="math/tex; mode=display">
\frac{\partial{S}}{\partial{θ_j}}=\sum_{i=1}^{m}[2(θ_0+θ_1x_i+θ_2x_i^2+···+θ_nx_i^n-y_i)x_i^j]=0</script><p>整理上式，$j$ 分别取 $0,1,2,…,n$ 时，有：</p>
<script type="math/tex; mode=display">
\begin{cases}
    mθ_0+(\sum\limits_{i=1}^{m}x_i)θ_1+(\sum\limits_{i=1}^{m}x_i^2)θ_2+\cdots+(\sum\limits_{i=1}^{m}x_i^n)θ_n=\sum\limits_{i=1}^{m}y_i \\
    (\sum\limits_{i=1}^{m}x_i)θ_0+(\sum\limits_{i=1}^{m}x_i^2)θ_1+(\sum\limits_{i=1}^{m}x_i^3)θ_2+\cdots+(\sum\limits_{i=1}^{m}x_i^{n+1})θ_n=\sum\limits_{i=1}^{m}(x_iy_i) \\
    (\sum\limits_{i=1}^{m}x_i^2)θ_0+(\sum\limits_{i=1}^{m}x_i^3)θ_1+(\sum\limits_{i=1}^{m}x_i^4)θ_2+\cdots+(\sum\limits_{i=1}^{m}x_i^{n+2})θ_n=\sum\limits_{i=1}^{m}(x_i^2y_i) \\
    \cdots\cdots \\
    (\sum\limits_{i=1}^{m}x_i^n)θ_0+(\sum\limits_{i=1}^{m}x_i^{n+1})θ_1+(\sum\limits_{i=1}^{m}x_i^{n+2})θ_2+\cdots+(\sum\limits_{i=1}^{m}x_i^{2n})θ_n=\sum\limits_{i=1}^{m}(x_i^ny_i)
\end{cases}</script><p>转化为矩阵形式，令：</p>
<script type="math/tex; mode=display">
X=\begin{bmatrix}
    m & \sum\limits_{i=1}^{m}x_i & \sum\limits_{i=1}^{m}x_i^2 & \cdots & \sum\limits_{i=1}^{m}x_i^n \\
    \sum\limits_{i=1}^{m}x_i & \sum\limits_{i=1}^{m}x_i^2 & \sum\limits_{i=1}^{m}x_i^3 & \cdots & \sum\limits_{i=1}^{m}x_i^{n+1} \\
    \sum\limits_{i=1}^{m}x_i^2 & \sum\limits_{i=1}^{m}x_i^3 & \sum\limits_{i=1}^{m}x_i^4 & \cdots & \sum\limits_{i=1}^{m}x_i^{n+2} \\
    \vdots & \vdots & \vdots &  \ddots & \vdots \\
    \sum\limits_{i=1}^{m}x_i^n & \sum\limits_{i=1}^{m}x_i^{n+1} & \sum\limits_{i=1}^{m}x_i^{n+2} & \cdots & \sum\limits_{i=1}^{m}x_i^{2n}
\end{bmatrix},
\quad
θ=\begin{bmatrix}
    θ_0 \\
    θ_1 \\
    θ_2 \\
    \vdots \\
    θ_n \\
\end{bmatrix},
\quad
Y=\begin{bmatrix}
    \sum\limits_{i=1}^{m}y_i \\
    \sum\limits_{i=1}^{m}(x_iy_i) \\
    \sum\limits_{i=1}^{m}(x_i^2y_i) \\
    \vdots \\
    \sum\limits_{i=1}^{m}(x_i^ny_i)
\end{bmatrix}</script><p>则有：</p>
<script type="math/tex; mode=display">
\begin{gathered}
    Xθ=Y \\
    \Downarrow \\
    θ=X^{-1}Y
\end{gathered}</script><p>使用样本数据集构造出矩阵 $X$ 和矩阵 $Y$ 后，便可由上式解得最优函数的系数向量 $θ$。</p>
<h2 id="2-2-矩阵法" class="heading-control"><a href="#2-2-矩阵法" class="headerlink" title="2.2 矩阵法"></a>2.2 矩阵法<a class="heading-anchor" href="#2-2-矩阵法" aria-hidden="true"></a></h2><p>在代数法中，构造矩阵 $X$ 和矩阵 $Y$ 较为繁琐且计算量大，我们尝试直接将误差平方和 $S$ 拆解为矩阵形式。令：</p>
<script type="math/tex; mode=display">
X_v=\begin{bmatrix}
    1 & x_1 & x_1^2 & \cdots & x_1^n \\
    1 & x_2 & x_2^2 & \cdots & x_2^n \\
    1 & x_3 & x_3^2 & \cdots & x_3^n \\
    \vdots & \vdots & \vdots &  \ddots & \vdots \\
    1 & x_m & x_m^2 & \cdots & x_m^n \\
\end{bmatrix},
\quad
θ=\begin{bmatrix}
    θ_0 \\
    θ_1 \\
    θ_2 \\
    \vdots \\
    θ_n \\
\end{bmatrix},
\quad
Y_r=\begin{bmatrix}
    y_1 \\
    y_2 \\
    y_3 \\
    \vdots \\
    y_m \\
\end{bmatrix}</script><p>则误差平方和 $S$ 可写成：</p>
<script type="math/tex; mode=display">
S=(X_vθ-Y_r)^T(X_vθ-Y_r)</script><p>$X_v$ 是一个<strong>范德蒙矩阵</strong>（Vandermonde Matrix）, $θ$ 仍然是多项式系数构成的系数向量， $Y_r$ 是样本数据集的输出向量。对于最优函数，应满足：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \frac{\partial{S}}{\partial{θ}} & =\frac{\partial{[(X_vθ-Y_r)^T(X_vθ-Y_r)]}}{\partial{θ}} \\
    & =X_v^TX_vθ-X_v^TY_r \\
    & =0 \\
\end{aligned}</script><p>可求得最优函数的多项式系数向量 $θ$ 为：</p>
<script type="math/tex; mode=display">
θ=(X_v^TX_v)^{-1}X_v^TY_r</script><p>相比代数法求解中的矩阵 $X$ 和矩阵 $Y$，矩阵法中的矩阵 $X_v$ 和矩阵 $Y_r$ 构造起来更加简单。仔细观察，可以发现：</p>
<script type="math/tex; mode=display">
\begin{cases}
    X=X_v^TX_v \\
    Y=X_v^TY_r
\end{cases}</script><p>说明两个解法是相通的。</p>
<h1 id="3-代码实现" class="heading-control"><a href="#3-代码实现" class="headerlink" title="3 代码实现"></a>3 代码实现<a class="heading-anchor" href="#3-代码实现" aria-hidden="true"></a></h1><p>通过 C++ <span class="exturl" data-url="aHR0cDovL2VpZ2VuLnR1eGZhbWlseS5vcmcvaW5kZXgucGhwP3RpdGxlPU1haW5fUGFnZQ==" title="http://eigen.tuxfamily.org/index.php?title=Main_Page">Eigen<i class="fa fa-external-link"></i></span>库实现了矩阵法中的求解方式，Eigen 版本为 v3.3.7，运行环境为 Windows10，Eigen 库安装路径为 <code>D:\eigen-3.3.7</code>。</p>
<p><strong>函数声明</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LEAST_SQUARE_METHOD_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LEAST_SQUARE_METHOD_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;D:\eigen-3.3.7\Eigen\Dense&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Fit polynomial using Least Square Method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param X X-axis coordinate vector of sample data.</span></span><br><span class="line"><span class="comment"> * @param Y Y-axis coordinate vector of sample data.</span></span><br><span class="line"><span class="comment"> * @param orders Fitting order which should be larger than zero.</span></span><br><span class="line"><span class="comment"> * @return Eigen::VectorXf Coefficients vector of fitted polynomial.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Eigen::VectorXf <span class="title">FitterLeastSquareMethod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &amp;X, <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &amp;Y, <span class="keyword">uint8_t</span> orders)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>函数实现</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LeastSquareMethod.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Fit polynomial using Least Square Method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param X X-axis coordinate vector of sample data.</span></span><br><span class="line"><span class="comment"> * @param Y Y-axis coordinate vector of sample data.</span></span><br><span class="line"><span class="comment"> * @param orders Fitting order which should be larger than zero.</span></span><br><span class="line"><span class="comment"> * @return Eigen::VectorXf Coefficients vector of fitted polynomial.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Eigen::VectorXf <span class="title">FitterLeastSquareMethod</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &amp;X, <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &amp;Y, <span class="keyword">uint8_t</span> orders)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// abnormal input verification</span></span><br><span class="line">    <span class="keyword">if</span> (X.size() &lt; <span class="number">2</span> || Y.size() &lt; <span class="number">2</span> || X.size() != Y.size() || orders &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map sample data from STL vector to eigen vector</span></span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXf&gt; <span class="title">sampleX</span><span class="params">(X.data(), X.size())</span></span>;</span><br><span class="line">    <span class="function">Eigen::Map&lt;Eigen::VectorXf&gt; <span class="title">sampleY</span><span class="params">(Y.data(), Y.size())</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Eigen::MatrixXf <span class="title">mtxVandermonde</span><span class="params">(X.size(), orders + <span class="number">1</span>)</span></span>;  <span class="comment">// Vandermonde matrix of X-axis coordinate vector of sample data</span></span><br><span class="line">    Eigen::VectorXf colVandermonde = sampleX;              <span class="comment">// Vandermonde column</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// construct Vandermonde matrix column by column</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; orders + <span class="number">1</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> == i)</span><br><span class="line">        &#123;</span><br><span class="line">            mtxVandermonde.col(<span class="number">0</span>) = Eigen::VectorXf::Constant(X.size(), <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == i)</span><br><span class="line">        &#123;</span><br><span class="line">            mtxVandermonde.col(<span class="number">1</span>) = colVandermonde;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        colVandermonde = colVandermonde.<span class="built_in">array</span>()*sampleX.<span class="built_in">array</span>();</span><br><span class="line">        mtxVandermonde.col(i) = colVandermonde;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate coefficients vector of fitted polynomial</span></span><br><span class="line">    Eigen::VectorXf result = (mtxVandermonde.transpose()*mtxVandermonde).inverse()*(mtxVandermonde.transpose())*sampleY;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数实现中使用了一些 Eigen 的小技巧：</p>
<ul>
<li>使用 <code>Eigen::Map</code> 直接将样本数据由 <code>std::vector</code> 映射到 <code>Eigen::VectorXf</code> 参与运算，避免了循环数据读入</li>
<li>通过 <code>array()</code> 方法累乘样本数据的 X 向量，逐列构造范德蒙矩阵，同样避免了大量的循环数据处理</li>
</ul>
<p><strong>拟合测试</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"LeastSquareMethod.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">float</span> y[<span class="number">5</span>] = &#123;<span class="number">7</span>, <span class="number">35</span>, <span class="number">103</span>, <span class="number">229</span>, <span class="number">431</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; <span class="title">X</span><span class="params">(x, x + <span class="keyword">sizeof</span>(x) / <span class="keyword">sizeof</span>(<span class="keyword">float</span>))</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; <span class="title">Y</span><span class="params">(y, y + <span class="keyword">sizeof</span>(y) / <span class="keyword">sizeof</span>(<span class="keyword">float</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Eigen::VectorXf <span class="title">result</span><span class="params">(FitterLeastSquareMethod(X, Y, <span class="number">3</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"\nThe coefficients vector is: \n"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; result.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"theta_"</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; result[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行编译后的可执行程序，得到如下结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ .&#x2F;LSM.exe</span><br><span class="line"></span><br><span class="line">The coefficients vector is:</span><br><span class="line"></span><br><span class="line">theta_0: 1.30698</span><br><span class="line">theta_1: 0.924561</span><br><span class="line">theta_2: 2.0032</span><br><span class="line">theta_3: 2.99976</span><br></pre></td></tr></table></figure>
<p>点击<a href="/download/Demo_LSM.zip">这里</a>下载完整的工程 Demo，工程使用了 <code>cmake</code> 编译链，你也可以下载工程后使用其中的程序文件创建符合自己开发习惯的工程。</p>
<h1 id="4-总结" class="heading-control"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结<a class="heading-anchor" href="#4-总结" aria-hidden="true"></a></h1><p>本文中的矩阵法本质在于，<strong>通过样本集构造范德蒙德矩阵，将一元 N 次多项式非线性回归问题转化为 N 元一次线性回归问题</strong>（即多元线性回归）。对于线性回归问题的求解，Eigen 库中有多种实现：</p>
<ul>
<li>LU 分解</li>
<li>基于 Householder 变换的 QR 分解</li>
<li>完全正交分解（Complete Orthogonal Decomposition，COD）</li>
<li>标准 Cholesky 分解（LLT）</li>
<li>改进型 Cholesky 分解（LDLT）</li>
<li>SVD 分解</li>
</ul>
<p>不同方法在对矩阵 $A$ 的需求、求解速度、求解精度上有所差异，Eigen 官网对几种方法进行了对比总结，查看原文请移步 <span class="exturl" data-url="aHR0cDovL2VpZ2VuLnR1eGZhbWlseS5vcmcvZG94L2dyb3VwX19UdXRvcmlhbExpbmVhckFsZ2VicmEuaHRtbA==" title="http://eigen.tuxfamily.org/dox/group__TutorialLinearAlgebra.html">Linear algebra and decompositions<i class="fa fa-external-link"></i></span> 。</p>
<p><img data-src="https://image.shipengx.com/Eigen%20%E5%BA%93%E4%B8%AD%E7%BA%BF%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%87%A0%E7%A7%8D%E6%B1%82%E8%A7%A3%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94.png" alt="Eigen 库中线性问题的几种求解方法对比"></p>
<p>Eigen 官网在 <span class="exturl" data-url="aHR0cDovL2VpZ2VuLnR1eGZhbWlseS5vcmcvZG94L2dyb3VwX19MZWFzdFNxdWFyZXMuaHRtbA==" title="http://eigen.tuxfamily.org/dox/group__LeastSquares.html">Solving linear least squares systems<i class="fa fa-external-link"></i></span> 章节中讨论了 SVD 分解、QR 分解和正规方程（即使用 LDLT 解法）三种方法在求解线性最小二乘问题上的差异，并指出：SVD 分解通常精度最高但速度最慢，正规方程速度最快但精度最差，QR 分解性能介于两种方法之间。相比 SVD 分解和 QR 分解，当矩阵 $A$ 病态时，正规方程解法所得结果将损失两倍精度。</p>
<p>利用上文所述的工程 Demo 中的小样本（三次多项式 $f(x) = 1 + x + 2x^2 + 3x^3$ 附近的 5 个点）构造出范德蒙德矩阵（即矩阵 $A$）后，对矩阵法（文中方法）、正规方程、householderQr 分解和 bdcSvd 分解进行了拟合实验对比：</p>
<p><img data-src="https://image.shipengx.com/%E5%87%A0%E7%A7%8D%E6%B1%82%E8%A7%A3%E7%BA%BF%E6%80%A7%E6%9C%80%E5%B0%8F%E4%BA%8C%E4%B9%98%E9%97%AE%E9%A2%98%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94.png" alt="几种求解线性最小二乘问题方法的对比"></p>
<p>从结果可以看出，在求解速度方面：</p>
<script type="math/tex; mode=display">
\text{正规方程}>\text{householderQr分解}>\text{矩阵法}>\text{bdcSvd分解}</script><p>在求解精度方面：</p>
<script type="math/tex; mode=display">
\text{bdcSvd分解}>\text{householderQr分解}>\text{正规方程}>\text{矩阵法}</script><p>householderQr 分解综合性能较优，矩阵法综合性能较差，且有 $A^TA$ 可逆的要求。</p>
<p>对于线性回归问题，还可通过<strong>梯度下降法</strong>进行求解，梯度下降法具体使用中还会涉及一些工程细节，例如数据的特征缩放（归一化）、步长 $\alpha$（学习率）的选择、迭代次数的设置等，具体不再展开，后面会另开一篇文章。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0b25neHVlLmNvbS9tYWRvY3MvODE4Lmh0bWw=" title="https://www.matongxue.com/madocs/818.html">如何理解最小二乘法？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xzaF8yMDEzL2FydGljbGUvZGV0YWlscy80NjY5NzYyNQ==" title="https://blog.csdn.net/lsh_2013/article/details/46697625">最小二乘法拟合多项式原理以及 c++实现<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2phaXJ1c2NoYW4vYXJ0aWNsZS9kZXRhaWxzLzc1MTc3NzMvI2NvbW1lbnRCb3g=" title="https://blog.csdn.net/jairuschan/article/details/7517773/#commentBox">最小二乘法多项式曲线拟合原理与实现<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzM4MTI3MTYyL2FydGljbGUvZGV0YWlscy84MjM0ODI4MD91dG1fbWVkaXVtPWRpc3RyaWJ1dGUucGNfcmVsZXZhbnQubm9uZS10YXNrLWJsb2ctQmxvZ0NvbW1lbmRGcm9tTWFjaGluZUxlYXJuUGFpMi0xLmNoYW5uZWxfcGFyYW0mYW1wO2RlcHRoXzEtdXRtX3NvdXJjZT1kaXN0cmlidXRlLnBjX3JlbGV2YW50Lm5vbmUtdGFzay1ibG9nLUJsb2dDb21tZW5kRnJvbU1hY2hpbmVMZWFyblBhaTItMS5jaGFubmVsX3BhcmFt" title="https://blog.csdn.net/baidu_38127162/article/details/82348280?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">最小二乘法多项式曲线拟合原理与实现（数学公式详细推导，代码方面详细注释）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA2MjQxNjYvYXJ0aWNsZS9kZXRhaWxzLzEwMDU0MDEzNw==" title="https://blog.csdn.net/u010624166/article/details/100540137">c++ 曲线拟合的最小二乘法 公式 二次多项式和三次多项式<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0pfQm9vbS9hcnRpY2xlL2RldGFpbHMvODY3NjM4MTY=" title="https://blog.csdn.net/J_Boom/article/details/86763816">最小二乘法<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODEyODc4NQ==" title="https://zhuanlan.zhihu.com/p/38128785">最小二乘法（least sqaure method）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2VpZ2VuLnR1eGZhbWlseS5vcmcvZG94L2dyb3VwX19UdXRvcmlhbExpbmVhckFsZ2VicmEuaHRtbA==" title="http://eigen.tuxfamily.org/dox/group__TutorialLinearAlgebra.html">Linear algebra and decompositions<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2VpZ2VuLnR1eGZhbWlseS5vcmcvZG94L2dyb3VwX19MZWFzdFNxdWFyZXMuaHRtbA==" title="http://eigen.tuxfamily.org/dox/group__LeastSquares.html">Solving linear least squares systems<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzk5Mjk4NQ==" title="https://zhuanlan.zhihu.com/p/33992985">机器学习：用梯度下降法实现线性回归<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2Jsb2cuc2luYS5jb20uY24vcy9ibG9nX2U2YmRiZWIyMDEwMncyZGwuaHRtbA==" title="http://blog.sina.com.cn/s/blog_e6bdbeb20102w2dl.html">机器学习：最小二乘法、最大似然估计、梯度下降法<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwODIyNDgxL2Fuc3dlci85NTcwNzYyNw==" title="https://www.zhihu.com/question/20822481/answer/95707627">最小二乘法和梯度下降法有哪些区别？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20veXV6aGVuMjMzL3AvODUyMDE0Mi5odG1s" title="https://www.cnblogs.com/yuzhen233/p/8520142.html">最小二乘法与梯度下降的区别<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI3NTE0Mjk3L2FydGljbGUvZGV0YWlscy81MzUwODE0OQ==" title="https://blog.csdn.net/qq_27514297/article/details/53508149">最小二乘法与梯度下降法的区别？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC8xYzg2Zjk3NzBhYTc=" title="https://www.jianshu.com/p/1c86f9770aa7">从线性回归到最小二乘法和梯度下降法<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubWF0b25neHVlLmNvbS9tYWRvY3MvMjIy" title="https://www.matongxue.com/madocs/222">如何直观形象的理解方向导数与梯度以及它们之间的关系？<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ieXRlb2ZiaW8uY29tL2FyY2hpdmVzLzEzLmh0bWw=" title="https://byteofbio.com/archives/13.html">使用最小二乘法和梯度下降法进行线性回归分析<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>数学</tag>
        <tag>最小二乘法</tag>
        <tag>多项式曲线拟合</tag>
      </tags>
  </entry>
  <entry>
    <title>深入探索单例设计模式：以百度 Apollo 为例</title>
    <url>/archives/f61b5eee.html</url>
    <content><![CDATA[<p><img data-src="https://image.shipengx.com/%E7%9B%AE%E5%BD%95.png" alt="目录"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p><strong>单例模式</strong>（Singleton Pattern）广泛应用于全局配置参数管理等应用场景，笔者近期在阅读百度 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL0Fwb2xsb0F1dG8vYXBvbGxv" title="https://github.com/ApolloAuto/apollo">Apollo<i class="fa fa-external-link"></i></span> 项目过程中发现其使用了一种优雅、强泛化且线程安全的懒汉式单例实现。首先，本文给出了单例模式的设计要点，并分别实现了饿汉式单例、懒汉式单例（单检锁，双检锁 + 原子变量）、Meyers 单例；随后，以 Apollo 6.0 源码 <code>master</code> 分支上的最新提交 <code>a75f30b697</code>（截至 2021 年 7 月 19 日）为基础，详细分析了其单例模式实现；最后，对其实现方式进行了多线程安全性验证。</p>
<h1 id="1-单例模式的设计要点" class="heading-control"><a href="#1-单例模式的设计要点" class="headerlink" title="1 单例模式的设计要点"></a>1 单例模式的设计要点<a class="heading-anchor" href="#1-单例模式的设计要点" aria-hidden="true"></a></h1><p>单例模式是一种创建型设计模式，能够保证一个类只有唯一的实例存在， 并提供一个访问该实例的全局节点，基于该特性，单例模式广泛应用于线程池管理、日志管理和全局配置参数管理等场景。</p>
<p>单例模式有以下三个设计要点：</p>
<p><strong>(1) 提供对唯一实例的全局访问点</strong></p>
<p>实例的唯一性通过在类内部将实例声明为 <code>private static</code> 来实现，实例访问点的全局性通过将对应方法（通常命名为 <code>GetInstance</code> 或 <code>Instance</code>）声明为 <code>static</code> 来实现。</p>
<p><strong>(2) 多线程安全</strong></p>
<p>单例模式的实现通常分为饿汉式单例和懒汉式单例。饿汉式单例天然地具有多线程安全性，懒汉式单例的单线程版本容易实现，多线程版本需要做些额外措施以确保多线程场景下的安全性。</p>
<p><strong>(3) 防止私自创建实例</strong></p>
<p>因为对单例实例的创建及获取只应通过上述的全局访问点实现，所以应防止用户私自创建实例，通常通过私有化默认构造（default），并禁止拷贝构造（copy）和拷贝赋值（assign）来实现。</p>
<h1 id="2-饿汉式单例" class="heading-control"><a href="#2-饿汉式单例" class="headerlink" title="2 饿汉式单例"></a>2 饿汉式单例<a class="heading-anchor" href="#2-饿汉式单例" aria-hidden="true"></a></h1><p>饿汉式单例在类的加载过程中便迫不及待地（“饿”的体现）为实例指针分配了动态内存，当有多个线程尝试获取实例指针时，获得的将是同一个实体，因此饿汉式单例天然地具有多线程安全性，但也正因为实例的动态内存分配过程未考虑访问时机，因而会降低程序启动速度。下面是典型的饿汉式单例实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> HungrySingleton *pinstance_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    HungrySingleton() &#123;&#125;</span><br><span class="line">    HungrySingleton(<span class="keyword">const</span> HungrySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    HungrySingleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> HungrySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~HungrySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> HungrySingleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HungrySingleton *HungrySingleton::pinstance_ = <span class="keyword">new</span> HungrySingleton;</span><br><span class="line"></span><br><span class="line"><span class="function">HungrySingleton *<span class="title">HungrySingleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> pinstance_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="3-懒汉式单例" class="heading-control"><a href="#3-懒汉式单例" class="headerlink" title="3 懒汉式单例"></a>3 懒汉式单例<a class="heading-anchor" href="#3-懒汉式单例" aria-hidden="true"></a></h1><p>不同于饿汉式单例，懒汉式单例仅在初次执行获取实例的动作时才对实例进行动态内存分配（“懒”的体现），因而程序具有更高的启动速度，但无可避免地会降低初次访问实例时的效率。同时，使用懒汉式单例时需要注意多线程场景的下的安全问题。</p>
<h2 id="3-1-适用于单线程场景的懒汉式单例" class="heading-control"><a href="#3-1-适用于单线程场景的懒汉式单例" class="headerlink" title="3.1 适用于单线程场景的懒汉式单例"></a>3.1 适用于单线程场景的懒汉式单例<a class="heading-anchor" href="#3-1-适用于单线程场景的懒汉式单例" aria-hidden="true"></a></h2><p>单线程场景下的懒汉式单例实现较为简单，将实例动态内存分配过程放到实例访问点 <code>GetInstance</code> 中，通过检查实例指针是否为空来判断是否是初次访问，且仅在初次访问时为实例分配内存即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> LazySingleton *pinstance_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LazySingleton() &#123;&#125;</span><br><span class="line">    LazySingleton(<span class="keyword">const</span> LazySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LazySingleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> LazySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> LazySingleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LazySingleton *LazySingleton::pinstance_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">LazySingleton *<span class="title">LazySingleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == pinstance_)</span><br><span class="line">    &#123;</span><br><span class="line">        pinstance_ = <span class="keyword">new</span> LazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pinstance_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>假设实例指针尚为空时，有多个线程同时调用 <code>GetInstance</code> 方法，则会造成每个线程获取到各自的实例指针，违反了单例模式中的实例唯一性原则。</p>
<h2 id="3-2-多线程安全的懒汉式单例：单检锁实现" class="heading-control"><a href="#3-2-多线程安全的懒汉式单例：单检锁实现" class="headerlink" title="3.2 多线程安全的懒汉式单例：单检锁实现"></a>3.2 多线程安全的懒汉式单例：单检锁实现<a class="heading-anchor" href="#3-2-多线程安全的懒汉式单例：单检锁实现" aria-hidden="true"></a></h2><p>可以通过在 <code>GetInstance</code> 方法中添加互斥锁 <code>mutex</code> 来解决多线程场景下的资源争抢问题，同时，为了实现自解锁，通常使用 <code>mutex</code> 的 RAII（Resource Acquisition Is Initialization）包装器类 <a href="https://en.cppreference.com/w/cpp/thread/lock_guard" target="_blank" rel="noopener"><code>std::lock_guard</code></a>，<code>std::lock_guard</code> 是 C++11 定义于 <code>&lt;mutex&gt;</code> 中的新特性，<code>std::lock_guard</code> 对象可以在生命周期结束前通过析构函数自动对其所管理的 <code>mutex</code> 对象执行 <code>unlock</code> 操作。下面是典型的直接基于互斥锁的懒汉式单例实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> LazySingleton *pinstance_;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LazySingleton() &#123;&#125;</span><br><span class="line">    LazySingleton(<span class="keyword">const</span> LazySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LazySingleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> LazySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> LazySingleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LazySingleton *LazySingleton::pinstance_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::mutex LazySingleton::mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function">LazySingleton *<span class="title">LazySingleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == pinstance_)</span><br><span class="line">    &#123;</span><br><span class="line">        pinstance_ = <span class="keyword">new</span> LazySingleton;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pinstance_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的实现方式我们通常称之为<strong>单检锁</strong>模式，即每次调用 <code>GetInstance</code> 方法尝试获取实例时都会执行加锁操作，并在自析构 <code>std::lock_guard</code> 对象时执行解锁操作，这必然会降低实例访问效率，因为如果已经为实例指针分配了内存得话，显然调用 <code>GetInstance</code> 时直接将实例指针返回即可，意即，只有初次调用 <code>GetInstance</code> 时才有必要执行锁操作。</p>
<h2 id="3-3-多线程安全的懒汉式单例：双检锁-原子变量实现" class="heading-control"><a href="#3-3-多线程安全的懒汉式单例：双检锁-原子变量实现" class="headerlink" title="3.3 多线程安全的懒汉式单例：双检锁 + 原子变量实现"></a>3.3 多线程安全的懒汉式单例：双检锁 + 原子变量实现<a class="heading-anchor" href="#3-3-多线程安全的懒汉式单例：双检锁-原子变量实现" aria-hidden="true"></a></h2><h3 id="3-3-1-使用双检锁确保性能" class="heading-control"><a href="#3-3-1-使用双检锁确保性能" class="headerlink" title="3.3.1 使用双检锁确保性能"></a>3.3.1 使用双检锁确保性能<a class="heading-anchor" href="#3-3-1-使用双检锁确保性能" aria-hidden="true"></a></h3><p>针对单检锁方法中存在的性能问题，有一种所谓的<strong>双检锁</strong>模式（Double-Checked Locking Pattern，DCLP）优化方案，即在 <code>GetInstance</code> 中执行锁操作前，在最外层额外地进行一次实例指针的检查操作（“双检”的体现），这样可以保证实例指针完成内存分配后，单纯的实例访问操作不会再附带锁操作带来的性能开销：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> LazySingleton *pinstance_;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LazySingleton() &#123;&#125;</span><br><span class="line">    LazySingleton(<span class="keyword">const</span> LazySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LazySingleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> LazySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> LazySingleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">LazySingleton *LazySingleton::pinstance_&#123;<span class="literal">nullptr</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::mutex LazySingleton::mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function">LazySingleton *<span class="title">LazySingleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == pinstance_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == pinstance_)</span><br><span class="line">        &#123;</span><br><span class="line">            pinstance_ = <span class="keyword">new</span> LazySingleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pinstance_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>双检锁方法初衷虽好，但却破坏了多线程场景下的安全性，这是由动态内存分配时 <code>new</code> 底层操作的<strong>非原子性</strong>导致的，执行 <code>pinstance_ = new LazySingleton;</code> 语句时，底层其实对应了三个步骤：</p>
<ol>
<li>向系统申请分配内存，大小为 <code>sizeof(LazySingleton)</code></li>
<li>调用 <code>LazySingleton</code> 的默认构造函数在申请的内存上构造出实例</li>
<li>返回申请内存的指针给 <code>pinstance_</code></li>
</ol>
<p>根本问题在于，上面的这三个步骤无法确保执行顺序。例如，出于优化的原因，处理器很可能调整步骤 3 和步骤 2 的执行顺序（按照 1、3、2 的顺序执行）。</p>
<p>假设，现在某个线程执行到了 <code>pinstance_ = new LazySingleton;</code> 语句，底层操作完成了内存申请（步骤 1）和实例指针赋值（步骤 3），但尚未完成申请内存的构造（步骤 2），意即，现在 <code>pinstance_</code> 指向的是一片脏内存。此时，另一个线程恰好执行到双检锁的最外层检查，该线程发现 <code>pinstance_</code> 非空（发生了脏读），检查为 <code>false</code>，因而直接取走了尚未完成构造的实例指针（<code>return pinstance_;</code>），从而可能诱发程序未定义行为（undefined behavior）。</p>
<h3 id="3-3-2-使用原子变量确保多线程安全性" class="heading-control"><a href="#3-3-2-使用原子变量确保多线程安全性" class="headerlink" title="3.3.2 使用原子变量确保多线程安全性"></a>3.3.2 使用原子变量确保多线程安全性<a class="heading-anchor" href="#3-3-2-使用原子变量确保多线程安全性" aria-hidden="true"></a></h3><p>可以通过封装一个单例指针类型的 <a href="https://en.cppreference.com/w/cpp/atomic/atomic" target="_blank" rel="noopener"><code>std::atomic</code></a> 原子对象，将单例指针的读写操作转化为对原子对象的操作，以此来确保双检锁实现的懒汉式单例的多线程安全性。</p>
<p><code>std::atomic</code> 是 C++11 定义于 <code>&lt;atomic&gt;</code> 中的新特性，每个 <code>std::atomic</code> 模板的实例化和全特化定义一个原子类型，若一个线程写入原子对象，同时另一线程从它读取，则行为良好定义。另外，对原子对象的访问可以建立<strong>线程间同步</strong>，并按 <a href="https://en.cppreference.com/w/cpp/atomic/memory_order" target="_blank" rel="noopener"><code>std::memory_order</code></a> 枚举类型中的枚举常量对非原子内存访问定序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> memory_order &#123;</span><br><span class="line">    memory_order_relaxed,</span><br><span class="line">    memory_order_consume,</span><br><span class="line">    memory_order_acquire,</span><br><span class="line">    memory_order_release,</span><br><span class="line">    memory_order_acq_rel,</span><br><span class="line">    memory_order_seq_cst</span><br><span class="line">&#125; memory_order;</span><br></pre></td></tr></table></figure>
<p><code>std::memory_order</code> 涉及到内存模型（memory model）、内存序（memory order）、内存栅栏（memory fence）等诸多复杂概念，此处不予展开。下面给出经典的基于双检锁 + 原子变量的懒汉式单例实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::atomic&lt;LazySingleton *&gt; ainstance_;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::mutex mutex_;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    LazySingleton() &#123;&#125;</span><br><span class="line">    LazySingleton(<span class="keyword">const</span> LazySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    LazySingleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> LazySingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~LazySingleton() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> LazySingleton *<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;LazySingleton *&gt; LazySingleton::ainstance_;</span><br><span class="line"><span class="built_in">std</span>::mutex LazySingleton::mutex_;</span><br><span class="line"></span><br><span class="line"><span class="function">LazySingleton *<span class="title">LazySingleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LazySingleton *tmp = ainstance_.load(<span class="built_in">std</span>::memory_order_acquire);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mutex_)</span></span>;</span><br><span class="line">        tmp = ainstance_.load(<span class="built_in">std</span>::memory_order_relaxed);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">nullptr</span> == tmp)</span><br><span class="line">        &#123;</span><br><span class="line">            tmp = <span class="keyword">new</span> LazySingleton;</span><br><span class="line">            ainstance_.store(tmp, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作两点说明：</p>
<ol>
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic/load" target="_blank" rel="noopener"><code>load</code></a> 方法：原子性地加载并返回原子变量的当前值，类似读操作。唯一形参类型为 <code>std::memory_order</code>，默认值为 <code>memory_order_seq_cst</code></li>
<li><a href="https://en.cppreference.com/w/cpp/atomic/atomic/store" target="_blank" rel="noopener"><code>store</code></a> 方法：根据第一实参原子性地替换原子变量的当前值，类似写操作。第二形参类型为 <code>std::memory_order</code>，默认值为 <code>memory_order_seq_cst</code></li>
</ol>
<p>上面这种原子变量的使用方式称为 <strong>Acquire-Release Semantic</strong> 内存模型，如果保持 <code>load</code> 和 <code>store</code> 的 <code>std::memory_order</code> 参数缺省，则成为 <strong>Sequential Consistency</strong> 内存模型，性能会稍有损失。</p>
<p>百度 Apollo 项目中有用到双检锁 + 原子变量的懒汉式单例实现，例如 Cyber RT 框架中的调度器设计，具体实现在 <code>apollo\cyber\scheduler\scheduler_factory.cc</code> 中，此处不给出具体代码，本文重点在于 Apollo 中的另一种单例实现（第 5 章节）。</p>
<h1 id="4-最优雅的单例：Meyers-单例" class="heading-control"><a href="#4-最优雅的单例：Meyers-单例" class="headerlink" title="4 最优雅的单例：Meyers 单例"></a>4 最优雅的单例：Meyers 单例<a class="heading-anchor" href="#4-最优雅的单例：Meyers-单例" aria-hidden="true"></a></h1><p>Meyers 单例是 Scott Meyers 在《Effective C++》中提出的编程范式，其实现非常优雅：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeyersSingleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MeyersSingleton() &#123;&#125;;</span><br><span class="line">    MeyersSingleton(<span class="keyword">const</span> MeyersSingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    MeyersSingleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MeyersSingleton &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ~MeyersSingleton();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> MeyersSingleton &amp;<span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> MeyersSingleton instance;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Meyers 单例本质上也是一种懒汉式实现，但其在 C++11 及以后的标准中是天然多线程安全的，因为自 C++11 起<span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL3N0b3JhZ2VfZHVyYXRpb24jU3RhdGljX2xvY2FsX3ZhcmlhYmxlcw==" title="https://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables">规定<i class="fa fa-external-link"></i></span>：</p>
<blockquote>
<p>If multiple threads attempt to initialize the same static local variable concurrently, the initialization occurs exactly once (similar behavior can be obtained for arbitrary functions with <span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL3RocmVhZC9jYWxsX29uY2U=" title="https://en.cppreference.com/w/cpp/thread/call_once">std::call_once<i class="fa fa-external-link"></i></span>).</p>
<p>Note: usual implementations of this feature use variants of the double-checked locking pattern, which reduces runtime overhead for already-initialized local statics to a single non-atomic boolean comparison.</p>
</blockquote>
<p>翻译过来就是，<strong>如果多个线程同时尝试初始化相同的静态局部变量，初始化动作只会发生一次</strong>，这个内部特性通常也是通过双检锁模式实现的。</p>
<p>笔者从事自动驾驶行业，在某功能组件的开发过程中，对其全局配置参数及车身实时状态的管理使用的也是 Meyers 单例模式。</p>
<h1 id="5-百度-Apollo-中的懒汉式单例：once-flag-amp-call-once-实现" class="heading-control"><a href="#5-百度-Apollo-中的懒汉式单例：once-flag-amp-call-once-实现" class="headerlink" title="5 百度 Apollo 中的懒汉式单例：once_flag &amp; call_once 实现"></a>5 百度 Apollo 中的懒汉式单例：once_flag &amp; call_once 实现<a class="heading-anchor" href="#5-百度-Apollo-中的懒汉式单例：once-flag-amp-call-once-实现" aria-hidden="true"></a></h1><h2 id="5-1-实现分析" class="heading-control"><a href="#5-1-实现分析" class="headerlink" title="5.1 实现分析"></a>5.1 实现分析<a class="heading-anchor" href="#5-1-实现分析" aria-hidden="true"></a></h2><p>Apollo 中大量地应用了单例设计模式，包括上文中我们提到的双检锁 + 原子变量的懒汉式单例实现，在阅读感知模块 <code>apollo/modules/perception/common/sensor_manager/sensor_manager.h</code> 中的代码时发现另一种实现，一个普通的 <code>SensorManager</code> 类经宏定义 <code>DECLARE_SINGLETON(SensorManager)</code> 修饰成为单例类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SensorManager</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  DECLARE_SINGLETON(SensorManager)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>DECLARE_SINGLETON(classname)</code> 定义在 <code>apollo/cyber/common/macros.h</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CYBER_COMMON_MACROS_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CYBER_COMMON_MACROS_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cyber/base/macros.h"</span></span></span><br><span class="line"></span><br><span class="line">DEFINE_TYPE_TRAIT(HasShutdown, Shutdown)</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(T *instance)</span> </span>&#123;</span><br><span class="line">  instance-&gt;Shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    T *instance)</span> </span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>)instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// There must be many copy-paste versions of these macros which are same</span></span><br><span class="line"><span class="comment">// things, undefine them to avoid conflict.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> UNUSED</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DISALLOW_COPY_AND_ASSIGN</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNUSED(param) (void)param</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line">  classname(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;    \</span><br><span class="line">  classname &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_SINGLETON(classname)                                      \</span></span><br><span class="line"> <span class="keyword">public</span>:                                                                  \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> classname *<span class="title">Instance</span><span class="params">(<span class="keyword">bool</span> create_if_needed = <span class="literal">true</span>)</span> </span>&#123;              \</span><br><span class="line">    <span class="keyword">static</span> classname *instance = <span class="literal">nullptr</span>;                                 \</span><br><span class="line">    <span class="keyword">if</span> (!instance &amp;&amp; create_if_needed) &#123;                                  \</span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">std</span>::once_flag flag;                                         \</span><br><span class="line">      <span class="built_in">std</span>::call_once(flag,                                                \</span><br><span class="line">                     [&amp;] &#123; instance = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) classname(); &#125;); \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">    <span class="keyword">return</span> instance;                                                      \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CleanUp</span><span class="params">()</span> </span>&#123;                                                 \</span><br><span class="line">    <span class="keyword">auto</span> instance = Instance(<span class="literal">false</span>);                                      \</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">nullptr</span>) &#123;                                            \</span><br><span class="line">      CallShutdown(instance);                                             \</span><br><span class="line">    &#125;                                                                     \</span><br><span class="line">  &#125;                                                                       \</span><br><span class="line">                                                                          \</span><br><span class="line"> <span class="keyword">private</span>:                                                                 \</span><br><span class="line">  classname();                                                            \</span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(classname)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// CYBER_COMMON_MACROS_H_</span></span></span><br></pre></td></tr></table></figure>
<p>可以看到，<code>DECLARE_SINGLETON(classname)</code> 在预处理阶段会被替换为：</p>
<ul>
<li>静态方法 <code>Instance</code></li>
<li>私有的泛化默认构造函数和嵌套的宏定义 <code>DISALLOW_COPY_AND_ASSIGN</code></li>
<li>静态方法 <code>CleanUp</code></li>
</ul>
<h3 id="5-1-1-泛化的单例" class="heading-control"><a href="#5-1-1-泛化的单例" class="headerlink" title="5.1.1 泛化的单例"></a>5.1.1 泛化的单例<a class="heading-anchor" href="#5-1-1-泛化的单例" aria-hidden="true"></a></h3><p>我们逐点分析 <code>DECLARE_SINGLETON(classname)</code> 是如何将任意一个类修饰为单例类的：</p>
<p><strong>(1) 提供对唯一实例的全局访问点</strong></p>
<p>实例的唯一性通过局部静态（<code>local static</code>）的实例指针实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> classname *instance = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>
<p>实例访问点的全局性通过静态方法 <code>Instance</code> 实现。</p>
<p><strong>(2) 多线程安全</strong></p>
<p>由于实例指针的动态内存分配放到了访问点中，即延迟加载，所以这是一种懒汉式单例实现。其实现方式的多线程安全性由 <a href="http://www.cplusplus.com/reference/mutex/once_flag/" target="_blank" rel="noopener"><code>std::once_flag</code></a> 和 <a href="http://www.cplusplus.com/reference/mutex/call_once/" target="_blank" rel="noopener"><code>std::call_once</code></a> 保证，两者都是 C++11 定义于 <code>&lt;mutex&gt;</code> 中的新特性，配合使用可以确保多线程场景下可调用对象的唯一执行。</p>
<p><code>std::once_flag</code> 是 <code>std::call_once</code> 的辅助结构体，在 GNU 中的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">once_flag</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">__gthread_once_t</span> __native_type;</span><br><span class="line">  __native_type  _M_once = __GTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">/// Constructor</span></span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> <span class="title">once_flag</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// Deleted copy constructor</span></span><br><span class="line">  once_flag(<span class="keyword">const</span> once_flag&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="comment">/// Deleted assignment operator</span></span><br><span class="line">  once_flag&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> once_flag&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">void</span></span><br><span class="line">    call_once(once_flag&amp; __once, _Callable&amp;&amp; __f, _Args&amp;&amp;... __args);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>call_once</code> 被声明为 <code>once_flag</code> 的友元函数，为的是 <code>call_once</code> 可以修改 <code>once_flag</code> 中的 <code>_M_once</code> 成员（可调用对象的调用状态）。</p>
<p><code>std::call_once</code> 是一个可变参数模板函数，其声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Callable, <span class="keyword">typename</span>... _Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_once</span><span class="params">(once_flag&amp; __once, _Callable&amp;&amp; __f, _Args&amp;&amp;... __args)</span></span>;</span><br></pre></td></tr></table></figure>
<p>可变参数经完美转发传入可调用对象，具体到 Apollo 中，可调用对象指的是为实例指针分配动态内存的 lambda 表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">[&amp;] &#123; instance = <span class="keyword">new</span> (<span class="built_in">std</span>::nothrow) classname(); &#125;</span><br></pre></td></tr></table></figure>
<p><code>std::call_once</code> 通过间接调用 <code>pthread_once</code> 函数来确保传入的可调用对象即使在多线程场景下也只能被执行一次，<code>pthread_once</code> 的底层实现基于互斥锁和条件变量，此处不再展开。</p>
<p><strong>(3) 防止私自创建实例</strong></p>
<p>这一点通过私有化默认构造函数和另一个用于禁止拷贝构造和拷贝赋值的宏定义实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line">  classname(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;    \</span><br><span class="line">  classname &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p>到此为止已经足够将任意一个类泛化为单例类了。</p>
<h3 id="5-1-2-CleanUp-方法" class="heading-control"><a href="#5-1-2-CleanUp-方法" class="headerlink" title="5.1.2 CleanUp 方法"></a>5.1.2 CleanUp 方法<a class="heading-anchor" href="#5-1-2-CleanUp-方法" aria-hidden="true"></a></h3><p>此处我们再稍微分析下 <code>CleanUp</code> 静态方法，该方法允许用户调用时执行一些自定义的清理工作（可选）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">CleanUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> instance = Instance(<span class="literal">false</span>);</span><br><span class="line">  <span class="keyword">if</span> (instance != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CallShutdown(instance);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 <code>CleanUp</code> 方法时，若发现实例指针不为空，则会调用 <code>CallShutdown</code> 模板函数，<code>CallShutdown</code> 模板函数包含两个经类型萃取（type traits）进行重载的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(T *instance)</span> </span>&#123;</span><br><span class="line">  instance-&gt;Shutdown();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;!HasShutdown&lt;T&gt;::value&gt;::<span class="function">type <span class="title">CallShutdown</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    T *instance)</span> </span>&#123;</span><br><span class="line">  (<span class="keyword">void</span>)instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在分析 <code>CallShutdown</code> 前，我们需要先看下其上方的另一个宏定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DEFINE_TYPE_TRAIT(HasShutdown, Shutdown)</span><br></pre></td></tr></table></figure>
<p><code>DEFINE_TYPE_TRAIT</code> 定义在 <code>apollo/cyber/base/macros.h</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_TYPE_TRAIT(name, func)                     \</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                   \</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">name</span> &#123;</span>                                           \</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Class&gt;                             \</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">Test</span><span class="params">(<span class="keyword">decltype</span>(&amp;Class::func)*)</span> </span>&#123; \</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;                                        \</span><br><span class="line">    &#125;                                                     \</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;                                   \</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">Test</span><span class="params">(...)</span> </span>&#123;                     \</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;                                       \</span><br><span class="line">    &#125;                                                     \</span><br><span class="line">                                                          \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> value = Test&lt;T&gt;(<span class="literal">nullptr</span>);       \</span><br><span class="line">  &#125;;                                                      \</span><br><span class="line">                                                          \</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;                                   \</span><br><span class="line">  <span class="keyword">constexpr</span> <span class="keyword">bool</span> name&lt;T&gt;::value;</span><br></pre></td></tr></table></figure>
<p><code>DEFINE_TYPE_TRAIT</code> 会根据宏参数 <code>name</code> 创建一个同名的类型萃取模板类，并检查模板类型参数 <code>T</code> 中是否包含与宏参数 <code>func</code> 同名的方法，若包含，则模板类的 <code>value</code> 成员被置为 <code>true</code>，否则置为 <code>false</code>。应该注意的是，<code>func</code> 在 <code>T</code> 中必须是公有的，否则无法被发现。</p>
<p>所以 <code>DEFINE_TYPE_TRAIT(HasShutdown, Shutdown)</code> 的具体含义是：创建类型萃取模板类 <code>HasShutdown</code>，<code>HasShutdown</code> 可检查模板类型参数 <code>T</code> 中是否包含 <code>Shutdown</code> 方法。</p>
<p>再回到 <code>CallShutdown</code> 模板函数，<code>HasShutdown</code> 检查实例指针所属的类类型中是否包含 <code>Shutdown</code> 方法，若是，则执行下面语句版本的 <code>CallShutdown</code> 会被 <code>CleanUp</code> 调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">instance-&gt;Shutdown();</span><br></pre></td></tr></table></figure>
<p>否则，执行下面语句版本的 <code>CallShutdown</code> 会被 <code>CleanUp</code> 调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">(<span class="keyword">void</span>)instance;</span><br></pre></td></tr></table></figure>
<p><code>(void)instance;</code> 没有实际含义，仅用于避免编译器生成类似“变量定义但未被使用”的警告。</p>
<h2 id="5-2-封装与验证" class="heading-control"><a href="#5-2-封装与验证" class="headerlink" title="5.2 封装与验证"></a>5.2 封装与验证<a class="heading-anchor" href="#5-2-封装与验证" aria-hidden="true"></a></h2><p>笔者将 Apollo 中实现泛化懒汉式单例时用到的宏代码放到了一个文件中，并分别定义了不包含 <code>Shutdown</code> 方法的 <code>SingletonA</code> 类和包含 <code>Shutdown</code> 方法的 <code>SingletonB</code> 类，两个类都通过 <code>DECLARE_SINGLETON</code> 宏泛化成单例类：</p>
<p><strong>singleton_a.hpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_A_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_A_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"macro.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Singleton class without `Shutdown` method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonA</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~SingletonA() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n number of instances of SingletonA: "</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DECLARE_SINGLETON(SingletonA)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SingletonA::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">SingletonA::SingletonA()</span><br><span class="line">&#123;</span><br><span class="line">    ++num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><strong>singleton_b.hpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SINGLETON_B_HPP_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SINGLETON_B_HPP_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"macro.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Singleton class with `Shutdown` method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingletonB</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ~SingletonB() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// `Shutdown` method should be declared as `public` for type traits</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">GetNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n number of instances of SingletonB: "</span> &lt;&lt; num &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DECLARE_SINGLETON(SingletonB)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> SingletonB::num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">SingletonB::SingletonB()</span><br><span class="line">&#123;</span><br><span class="line">    ++num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SingletonB::Shutdown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> instance = Instance(<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> instance;</span><br><span class="line">        num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n SingletonB::Shutdown method was called."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>我们来验证下两个单例类的多线程安全性，并尝试调用各自的 <code>CleanUp</code> 方法：</p>
<p><strong>main.cpp</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"singleton_a.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"singleton_b.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">1000</span>));</span><br><span class="line">    T *p = T::Instance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">tA1</span><span class="params">(ThreadFunc&lt;SingletonA&gt;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">tA2</span><span class="params">(ThreadFunc&lt;SingletonA&gt;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">tB1</span><span class="params">(ThreadFunc&lt;SingletonB&gt;)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::thread <span class="title">tB2</span><span class="params">(ThreadFunc&lt;SingletonB&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line">    tA1.join();</span><br><span class="line">    tA2.join();</span><br><span class="line">    tB1.join();</span><br><span class="line">    tB2.join();</span><br><span class="line"></span><br><span class="line">    SingletonA::GetNum();</span><br><span class="line">    SingletonB::GetNum();</span><br><span class="line"></span><br><span class="line">    SingletonA::CleanUp();</span><br><span class="line">    SingletonB::CleanUp();</span><br><span class="line"></span><br><span class="line">    SingletonA::GetNum();</span><br><span class="line">    SingletonB::GetNum();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译并运行可执行文件，得到下面的输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">number of instances of SingletonA: 1</span><br><span class="line"></span><br><span class="line">number of instances of SingletonB: 1</span><br><span class="line"></span><br><span class="line">SingletonB::Shutdown method was called.</span><br><span class="line"></span><br><span class="line">number of instances of SingletonA: 1</span><br><span class="line"></span><br><span class="line">number of instances of SingletonB: 0</span><br></pre></td></tr></table></figure>
<p>可以发现：</p>
<ul>
<li>在调用 <code>CleanUp</code> 方法前，虽然 <code>SingletonA</code> 和 <code>SingletonB</code> 各自被两个线程调用 <code>Instance</code> 方法，但默认构造均只发生了一次（实例数量均为 1），说明满足多线程安全性；</li>
<li>分别调用 <code>SingletonA</code> 和 <code>SingletonB</code> 的 <code>CleanUp</code> 方法后，<code>SingletonB</code> 的实例数量清零，因为其 <code>Shutdown</code> 方法被间接调用；<code>SingletonA</code> 实例数量仍为 1，因为其 <code>CleanUp</code> 方法什么也没做。</li>
</ul>
<p>点击<a href="https://blog.shipengx.com/download/singleton.zip">这里</a>下载完整工程，通过 <code>#include</code> 工程中的 <code>macro.hpp</code> 头文件，我们可以将任意一个类修饰为多线程安全的单例类。</p>
<h1 id="6-总结" class="heading-control"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结<a class="heading-anchor" href="#6-总结" aria-hidden="true"></a></h1><p>本文首先给出了单例模式的设计要点，并分别实现了饿汉式单例、懒汉式单例（单检锁，双检锁 + 原子变量）、Meyers 单例；随后以 Apollo 6.0 源码为基础，详细分析了其单例模式实现；最后对 Apollo 的实现方式进行了线程安全性验证。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubW9kZXJuZXNjcHAuY29tL2luZGV4LnBocC90aHJlYWQtc2FmZS1pbml0aWFsaXphdGlvbi1vZi1hLXNpbmdsZXRvbg==" title="https://www.modernescpp.com/index.php/thread-safe-initialization-of-a-singleton">下图<i class="fa fa-external-link"></i></span>是几种单例实现方式的性能比较（数值越小，效率越高）：</p>
<p><img data-src="https://image.shipengx.com/%E4%B8%8D%E5%90%8C%E5%8D%95%E4%BE%8B%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83.png" alt="不同单例实现的性能比较"></p>
<p>可以发现：Meyers 单例不仅形式优雅，效率在多线程场景下也是最优的；单检锁的实现方式虽然能保证多线程安全，但性能太差；<code>call_once</code> 的实现方式与双检锁 + 原子变量的实现方式相比，效率低了 2 ~ 3 倍，所以 Apollo 的单例实现也还有优化空间。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubW9kZXJuZXNjcHAuY29tL2luZGV4LnBocC90aHJlYWQtc2FmZS1pbml0aWFsaXphdGlvbi1vZi1kYXRh" title="https://www.modernescpp.com/index.php/thread-safe-initialization-of-data">Thread-Safe Initialization of Data<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cubW9kZXJuZXNjcHAuY29tL2luZGV4LnBocC90aHJlYWQtc2FmZS1pbml0aWFsaXphdGlvbi1vZi1hLXNpbmdsZXRvbg==" title="https://www.modernescpp.com/index.php/thread-safe-initialization-of-a-singleton">Thread-Safe Initialization of a Singleton<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL2xhbmd1YWdlL3N0b3JhZ2VfZHVyYXRpb24jU3RhdGljX2xvY2FsX3ZhcmlhYmxlcw==" title="https://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables">Storage duration - Static local variables<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZGF6aHVhbmxhbi5jb20vMjAxOS8xMS8xOS81ZGQzYzBkN2JiMTgxLw==" title="https://www.dazhuanlan.com/2019/11/19/5dd3c0d7bb181/">C++11 中的内存模型<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9pbmN1YmF0b3ItYnJwYy9ibG9iL21hc3Rlci9kb2NzL2NuL2F0b21pY19pbnN0cnVjdGlvbnMubWQ=" title="https://github.com/apache/incubator-brpc/blob/master/docs/cn/atomic_instructions.md">百度 brpc 框架中文文档之 atomic_instructions<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDY0NzY2NS93aHktY2FzdC1hbi11bnVzZWQtZnVuY3Rpb24tcGFyYW1ldGVyLXZhbHVlLXRvLXZvaWQ=" title="https://stackoverflow.com/questions/4647665/why-cast-an-unused-function-parameter-value-to-void">Why cast an unused function parameter value to void?<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5hcmlzdGVpYS5jb20vUGFwZXJzL0RESl9KdWxfQXVnXzIwMDRfcmV2aXNlZC5wZGY=" title="http://www.aristeia.com/Papers/DDJ_Jul_Aug_2004_revised.pdf">C++ and the Perils of Double-Checked Locking<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2hlbmd5dW5hYmMuZ2l0aHViLmlvL2NwcDExLW9uY2VfZmxhZy1jYWxsX29uY2Uv" title="http://hengyunabc.github.io/cpp11-once_flag-call_once/">C++11 中 once_flag，call_once 实现分析<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3luc2hpNTcvYXJ0aWNsZS9kZXRhaWxzLzEwODMyNDQ1OQ==" title="https://blog.csdn.net/ynshi57/article/details/108324459">Apollo 设计模式分析<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbWFuZ295dWFuL3AvNjQ0NjA0Ni5odG1s" title="https://www.cnblogs.com/mangoyuan/p/6446046.html">C++ traits 技术浅谈<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDE3OTA5MS9hcnRpY2xlL2RldGFpbHMvMTA5MzE4MjM3" title="https://blog.csdn.net/weixin_40179091/article/details/109318237">C++11：std::atomic<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Apollo</tag>
        <tag>C/C++</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Ubuntu下的shell默认显示所在git仓库的当前分支</title>
    <url>/archives/74b2417b.html</url>
    <content><![CDATA[<h1 id="背景" class="heading-control"><a href="#背景" class="headerlink" title="背景"></a>背景<a class="heading-anchor" href="#背景" aria-hidden="true"></a></h1><p>Linux环境下使用Git做某项目代码工程的版本控制时，发现在工程下打开终端后无法显示当前所处分支，很不方便，通过编辑<code>.bashrc</code>配置文件解决这个问题。</p>
<h1 id="解决" class="heading-control"><a href="#解决" class="headerlink" title="解决"></a>解决<a class="heading-anchor" href="#解决" aria-hidden="true"></a></h1><ol>
<li>在终端中打开bash shell的配置文件<code>.bashrc</code>：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo gedit ~/.bashrc</span><br></pre></td></tr></table></figure></li>
<li>在文件末尾添加如下代码：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># These shell commands block are for the purpose of displaying the </span></span><br><span class="line"><span class="comment"># current branch name of the current repository.</span></span><br><span class="line">find_git_branch () </span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">local</span> dir=. head</span><br><span class="line">  until [ <span class="string">"<span class="variable">$dir</span>"</span> -ef / ]; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -f <span class="string">"<span class="variable">$dir</span>/.git/HEAD"</span> ]; <span class="keyword">then</span></span><br><span class="line">      head=$(&lt; <span class="string">"<span class="variable">$dir</span>/.git/HEAD"</span>)</span><br><span class="line">      <span class="keyword">if</span> [[ <span class="variable">$head</span> = ref:\ refs/heads/* ]]; <span class="keyword">then</span></span><br><span class="line">        git_branch=<span class="string">"(*<span class="variable">$&#123;head#*/*/&#125;</span>)"</span></span><br><span class="line">      <span class="keyword">elif</span> [[ <span class="variable">$head</span> != <span class="string">''</span> ]]; <span class="keyword">then</span></span><br><span class="line">        git_branch=<span class="string">"(*(detached))"</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        git_branch=<span class="string">"(*(unknow))"</span></span><br><span class="line">      <span class="keyword">fi</span>  </span><br><span class="line">      <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">fi</span>  </span><br><span class="line">    dir=<span class="string">"../<span class="variable">$dir</span>"</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  git_branch=<span class="string">''</span></span><br><span class="line">&#125;</span><br><span class="line">PROMPT_COMMAND=<span class="string">"find_git_branch; <span class="variable">$PROMPT_COMMAND</span>"</span></span><br><span class="line"><span class="built_in">export</span> PS1=<span class="string">"\[\e]0;\u@\h: \w\a\]<span class="variable">$&#123;debian_chroot:+($debian_chroot)&#125;</span>\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\[\033[0;32m\]\$git_branch\[\033[0m\] \$ "</span></span><br></pre></td></tr></table></figure></li>
<li>使更改立即生效：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI1Mjk1NDA3L2FydGljbGUvZGV0YWlscy83OTUwOTA1Ng==" title="https://blog.csdn.net/qq_25295407/article/details/79509056">linux命令行终端显示git当前所在分支<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title>（七）量产必备的毫米波雷达</title>
    <url>/archives/24a03bff.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDY3NTM5Mg==" title="https://zhuanlan.zhihu.com/p/34675392">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>频率介于10GHz~200GHz的电磁波，其波长为毫米量级，故被称为毫米波，应用于自动驾驶领域的毫米波雷达主要有3个频段：</p>
<ul>
<li>24GHz</li>
<li>77GHz</li>
<li>79GHz</li>
</ul>
<p>24GHz频段的毫米波雷达为<strong>短距离雷达</strong>，处在该频段上的雷达检测距离有限，因此常用于检测近处障碍物（车辆），为换道决策提供感知信息。</p>
<p>77GHz频段的毫米波雷达为<strong>长距离雷达</strong>，性能良好的77GHz雷达的最大检测距离可达160米以上，因此常被安装在前保险杠上，正对汽车的行驶方向。</p>
<p>79GHz频段的毫米波雷达同样为长距离雷达，相比前两种频段的毫米波雷达，其波长更短，分辨率越高，在距离、速度、角度上的测量精度更高。</p>
<p>毫米波雷达的测距和测速原理均基于<strong>多普勒效应</strong>，<strong>与激光雷达的笛卡尔（XYZ）坐标系不同，毫米波雷达的原始数据是基于极坐标系（距离+角度）的</strong>，两种坐标系可根据三角函数相互转换。毫米波雷达发射的电磁波可以穿透汽车的前后保险杠，但是无法穿透汽车底盘的金属，因此遇到金属这类物体时，电磁波就会返回。毫米波雷达的产品提供的功能大同小异，大部分功能都是通过障碍物的回波能量、距离、角度信息推算而来的。实际开发过程中，在自动驾驶领域应用毫米波雷达有三点挑战：</p>
<ul>
<li>数据稳定性差</li>
<li>对金属敏感</li>
<li>高度信息缺失</li>
</ul>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNDY3NTM5Mg==" title="https://zhuanlan.zhihu.com/p/34675392">无人驾驶技术入门（七）| 量产必备的毫米波雷达<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（三）百度无人车传感器GPS深入剖析</title>
    <url>/archives/c870f676.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjYzODYzMw==" title="https://zhuanlan.zhihu.com/p/32638633">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>百度 Apollo 1.0 技术框架如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E7%99%BE%E5%BA%A6Apollo%201.0%E6%8A%80%E6%9C%AF%E6%A1%86%E6%9E%B6.jpg" alt="百度Apollo 1.0技术框架"></p>
<p>GPS 全球定位系统（Global Position System）定位原理为<strong>三角定位法（Triangulation）</strong>，如下图所示，通过测量无人车分别距三颗卫星的距离来对无人车进行唯一定位：</p>
<p><img data-src="https://image.shipengx.com/%E4%B8%89%E8%A7%92%E5%AE%9A%E4%BD%8D%E6%B3%95%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="三角定位法原理图"></p>
<p>为降低天气、云层对定位的影响，引入了差分 GPS 的技术，原理如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E5%B7%AE%E5%88%86GPS%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86%E5%9B%BE.jpg" alt="差分GPS技术原理图"></p>
<p>在地面上建立基站（Base Station），基站在建立时可得到其精确的位置信息（经纬度），同时基站具有接收卫星信号的功能。当基站的 GPS 接收机与车载 GPS 接收机相距较近时（&lt;30km），可以认为两者的 GPS 信号通过的是同一片大气区域，即两者的信号误差基本一致。<strong>根据基站的精确位置和信号传播时间，可反推此时天气原因导致的信号传播误差，之后利用该误差便可修正车载 GPS 信号，从而降低云层、天气情况等对信号传输的影响。</strong>利用差分 GPS 技术，可使无人车定位精度由十米级别提升至米级。<strong>差分 GPS 技术可以解决定位的精度问题，但是无法解决遮挡和反射问题</strong>，当无人车在高楼林立的环境中行驶时，会发生信号丢失和多路径信号（Multi-Path Signal）的问题：</p>
<p><img data-src="https://image.shipengx.com/%E5%A4%9A%E8%B7%AF%E5%BE%84%E4%BF%A1%E5%8F%B7%E9%97%AE%E9%A2%98%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="多路径信号问题示意图"></p>
<p>同时，GPS 定位频率不高，相当于定位实时性较差。</p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjYzODYzMw==" title="https://zhuanlan.zhihu.com/p/32638633">无人驾驶技术入门（三）| 百度无人车传感器 GPS 深入剖析<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（九）与生俱来的VCU信号</title>
    <url>/archives/fde458ab.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjY1NDg3NA==" title="https://zhuanlan.zhihu.com/p/36654874">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p><strong>汽车控制单元（Vehicle Control Unit，VCU）</strong>，通过<strong>CAN 总线</strong>与汽车的发动机、变速器、油门踏板、制动踏板、车身控制器等各种电子设备通信，读取各个控制单元的工作状态，并在需要时对它们进行控制。</p>
<p>VCU 记载了汽车底盘的状态（车速、油门踏板开度、制动踏板状态、方向盘转角等）、汽车车身的状态（车门状态、车窗状态、前照灯状态、转向灯状态等）以及发动机的状态（转速，输出扭矩、燃油消耗等）。</p>
<p>作为上层算法和底盘控制的接口，VCU 不仅承担着控制汽车加减速、转向的工作，还承担着将底盘信息精确且及时传递到算法层的工作。<strong>无人驾驶中常用的 VCU 信号有：汽车车速、汽车方向盘转角、汽车航向角变化率、油门踏板开度、制动踏板开度等。</strong>对 VCU 信号的应用有多种方式，这里主要介绍两种：</p>
<p><strong>(1) 障碍物运动状态计算</strong><br>车载传感器（激光雷达、毫米波雷达、摄像机）检测的障碍物速度都是相对速度，因此需要结合自车车速才能确定障碍物的绝对速度，进而根据绝对速度确定障碍物的运动状态（静止、靠近、远离）；</p>
<p><strong>(2) 航位推算</strong><br><strong>航位推算（Dead reckoning，DR）</strong>是指在丢失定位的情况下，使用自车传感器的信息，推测当前时刻自车所在位置与上一时刻所在位置的相对关系。在进行航位推算时，使用了汽车四轮运动学模型的简化模型——<strong>自行车模型</strong>，如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E8%87%AA%E8%A1%8C%E8%BD%A6%E6%A8%A1%E5%9E%8B%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="自行车模型原理示意图"></p>
<p>汽车的<strong>前轮转角</strong>为$δ_f$，但这并不意味着汽车的运动角度为$δ_f$。分别做垂直于后轮和前轮的射线并交于 O 点，两轮模型会绕 O 点进行运动，在微小时间段 dt 内，认为 O 点静止。连接 O 点和汽车的质心，汽车的实际运动方向$v$垂直于该线段。运动方向$v$与车身方向所成的夹角$β$一般被称为<strong>侧偏角</strong>（<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjY1NDg3NA==" title="https://zhuanlan.zhihu.com/p/36654874">参考 1<i class="fa fa-external-link"></i></span>中表述有误，将$β$称为了偏航角——博主注），车身方向与大地坐标系横轴间的夹角称为<strong>横摆角</strong>。根据几何关系，可推出$β$和$δ_f$的近似关系为：</p>
<script type="math/tex; mode=display">
β=tan^{-1}(\frac{l_r}{l_f+l_r}tan(δ_f))</script><p>假设 t 时刻汽车的状态为$x_t$，$y_t$，经过微小时间段 dt 后的 t+1 时刻，状态为$x_{t+1}$，$y_{t+1}$，根据几何关系，可推出：</p>
<script type="math/tex; mode=display">
\begin{gathered}
    x_{t+1}=x_t+v_t*cos(ψ_t+β)*dt \\
    y_{t+1}=y_t+v_t*sin(ψ_t+β)*dt
\end{gathered}</script><p>根据以上关系即可在丢失定位信息后的短时间内，依靠无人车自身的传感器信息，进行位置和位姿估计。</p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjY1NDg3NA==" title="https://zhuanlan.zhihu.com/p/36654874">无人驾驶技术入门（九）| 与生俱来的 VCU 信号<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0FkYW1TaGFuL2FydGljbGUvZGV0YWlscy83ODY5Njg3NA==" title="https://blog.csdn.net/AdamShan/article/details/78696874">无人驾驶汽车系统入门（五）——运动学自行车模型和动力学自行车模型<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（五）没有视觉传感器，还谈什么无人驾驶</title>
    <url>/archives/c93d22e0.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzA2NzkyMw==" title="https://zhuanlan.zhihu.com/p/33067923">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>应用于无人车上的传感器目前有四大类：摄像机、激光雷达、毫米波雷达和超声波雷达。不同的传感器根据其传感特性，布置在车身的不同位置。摄像机根据镜头和布置方式的不同主要有：</p>
<ul>
<li>单目摄像机</li>
<li>双目摄像机</li>
<li>三目摄像机</li>
<li>环视摄像机</li>
</ul>
<p>单目摄像机的算法成熟度更高，然而单目有着两个先天缺陷：</p>
<ul>
<li>视野完全取决于镜头</li>
<li>物体越远，单目摄像机测距精度较低</li>
</ul>
<p>双目摄像机可得到图像的深度信息，深度信息的加入，不仅能便于障碍物的分类，更能提高高精度地图定位匹配的精度。</p>
<p>三目摄像机三个摄像头的感知范围由远及近，分别为前视窄视野摄像头（最远感知 250 米）、前视主视野摄像头（最远感知 150 米）及前视宽视野摄像头（最远感知 60 米）。<strong>三目的缺点是需要同时标定三个摄像机，因而工作量更大，并且软件部分需要关联三个摄像机的数据，对算法要求也很高。</strong></p>
<p>环视摄像机是安装于车辆前方、车辆左右后视镜下和车辆后方的四个鱼眼镜头，采集到的图像如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E7%8E%AF%E8%A7%86%E7%9B%B8%E6%9C%BA%E9%87%87%E9%9B%86%E5%9B%BE%E5%83%8F%E7%BB%93%E6%9E%9C.jpg" alt="环视相机采集图像结果"></p>
<p>鱼眼摄像机为了获取足够大的视野，代价是图像的畸变严重。<strong>环视摄像机的感知范围并不大，主要用于车身 5~10 米内的障碍物检测、自主泊车时的库位线识别等。</strong></p>
<p>摄像机在无人车上的应用，主要有两大类功能：感知能力和定位能力。摄像机可提供的感知能力有：</p>
<ul>
<li>车道线（lane）</li>
<li>障碍物（Obstacle）</li>
<li>交通标志牌和地面标志（Traffic Sign and Road Sign）</li>
<li>可通行空间（FreeSpace）</li>
<li>交通信号灯（Traffic Light）</li>
</ul>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzA2NzkyMw==" title="https://zhuanlan.zhihu.com/p/33067923">无人驾驶技术入门（五）| 没有视觉传感器，还谈什么无人驾驶？<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（八）被严重低估的传感器超声波雷达</title>
    <url>/archives/1e9849c6.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTE3NzMxMw==" title="https://zhuanlan.zhihu.com/p/35177313">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>常见的超声波雷达有两种：第一种是安装在汽车前后保险杠上的，<strong>用于测量汽车前后障碍物的倒车雷达，称为 UPA</strong>，探测距离一般在 15~250cm 之间，单个 UPA 的探测范围示意图如下图所示：</p>
<p><img data-src="https://image.shipengx.com/UPA%E6%8E%A2%E6%B5%8B%E8%8C%83%E5%9B%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="UPA探测范围示意图"></p>
<p>第二种是安装在汽车侧面的，<strong>用于测量侧方障碍物距离的超声波雷达，称为 APA</strong>，探测距离一般在 30~500cm 之间，<strong>更远的探测范围使得 APA 相比于 UPA 成本更高、功率更大</strong>，单个 APA 的探测范围示意图如下图所示：</p>
<p><img data-src="https://image.shipengx.com/APA%E6%8E%A2%E6%B5%8B%E8%8C%83%E5%9B%B4%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="APA探测范围示意图"></p>
<p>虽然 UPA 和 APA 的探测距离和探测形状区别很大，但是可以用相同的数学模型对二者进行描述，描述一个超声波雷达的状态需要如下四个参数，其数学模型的示意图如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E8%B6%85%E5%A3%B0%E6%B3%A2%E9%9B%B7%E8%BE%BE%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="超声波雷达数学模型示意图"></p>
<ul>
<li><strong>参数 α</strong>：超声波雷达的探测角，一般 UPA 的探测角为 120° 左右，APA 的探测角比 UPA 小，大概为 80°</li>
<li><strong>参数 β</strong>：超声波雷达检测宽度范围的影响因素之一，该角度一般较小，UPA 的 β 角为 20° 左右，APA 的 β 角比较特殊，为 0°</li>
<li><strong>参数 R</strong>：同样是超声波雷达检测宽度范围的影响因素之一，UPA 和 APA 的 R 值差别不大，均在 0.6m 左右</li>
<li><strong>参数 D</strong>：超声波雷达的最大量程，UPA 的最大量程为 2 米~2.5 米，APA 的最大量程至少 5 米，目前已有超过 7m 的 APA 雷达在业内使用</li>
</ul>
<p>超声波雷达的特性：<br><strong>(1) 温度敏感</strong><br>由于超声波雷达的探测介质为声波，因而超声波雷达的测距结果具有温度敏感性。</p>
<p><strong>(2) 无法精确描述障碍物位置</strong><br>超声波雷达在工作时会返回一个探测距离的值，如下图所示。处于 A 处和 B 处的障碍物会返回相同的探测距离 d，在仅知道探测距离 d 的情况下，<strong>通过单个雷达的信息无法确定障碍物所处位置</strong>为 A 还是 B</p>
<p><img data-src="https://image.shipengx.com/%E5%8D%95%E4%B8%AA%E8%B6%85%E5%A3%B0%E6%B3%A2%E9%9B%B7%E8%BE%BE%E6%97%A0%E6%B3%95%E7%B2%BE%E7%A1%AE%E6%8F%8F%E8%BF%B0%E9%9A%9C%E7%A2%8D%E7%89%A9%E4%BD%8D%E7%BD%AE.jpg" alt="单个超声波雷达无法精确描述障碍物位置"></p>
<p>超声波雷达在自动驾驶中可以用于<strong>泊车库位检测</strong>和<strong>高速横向辅助</strong>。</p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTE3NzMxMw==" title="https://zhuanlan.zhihu.com/p/35177313">无人驾驶技术入门（八）| 被严重低估的传感器超声波雷达<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（六）工程师又爱又恨的激光雷达</title>
    <url>/archives/be221b74.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzc5MjQ1MA==" title="https://zhuanlan.zhihu.com/p/33792450">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>激光雷达根据安装位置不同，可分为两类：一类安装在无人车四周，其激光线束一般小于 8，常见的有单线激光雷达和四线激光雷达；另一类安装在无人车车顶，其激光线束一般不小于 16，常见的有 16/32/64 线激光雷达。</p>
<p>单束激光发射器在激光雷达内部匀速旋转，每旋转一个小角度即发射一次激光，轮巡一定角度后，就生成了一帧完整的数据。因此，单线激光雷达的数据可视作同一高度的一排点阵，单线激光雷达的数据缺少一个维度，只能描述线状信息，无法描述面。</p>
<p>四线激光雷达将四个激光发射器进行轮询，一个轮询周期后，得到一帧的激光点云数据，四条点云数据可以组成面状信息，这样就能够获取障碍物的高度信息，根据单帧的点云坐标可得到障碍物的距离信息，根据多帧的点云坐标，对距离信息做微分处理，可得到障碍物的速度信息。16/32/64 线的激光雷达的感知范围为 360°，常被安装在无人车顶部。N 线激光雷达的点云数据结构如下图：</p>
<p><img data-src="https://image.shipengx.com/N%E7%BA%BF%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="N线点云数据的数据结构"></p>
<p>每一线点云的数据结构由点云数量和每一个点云的数据结构组成。由于激光雷达的数据采集频率及单线的点云数量都是可以设置的，因此 1 线点云数据中需要包含点云数量这个信息：</p>
<p><img data-src="https://image.shipengx.com/1%E7%BA%BF%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="1线点云数据的数据结构"></p>
<p>最底层的是单个点云的数据结构。点的表达既可以使用 theta/r 的极坐标表示，也可以使用 x/y/z 的三维坐标表示。每个点云除了坐标外，还有一个很重要的元素，那就是激光的反射强度。<strong>激光在不同材料上的反射强度是不一样的。</strong>以三维坐标的表示方法为例，单个点云的数据结构如下图所示，X/Y/Z 方向的偏移量以激光雷达的安装位置作为原点：</p>
<p><img data-src="https://image.shipengx.com/%E5%8D%95%E4%B8%AA%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="单个点云数据的数据结构"></p>
<p>激光雷达点云数据的一般处理方式是：</p>
<ul>
<li>数据预处理：坐标转换，去噪声等</li>
<li>聚类：根据点云距离或反射强度</li>
<li>特征提取</li>
<li>根据特征进行分类等后处理</li>
</ul>
<p>激光雷达能胜任的工作包括：<br><strong>(1) 障碍物检测与分割</strong></p>
<p><img data-src="https://image.shipengx.com/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E9%9A%9C%E7%A2%8D%E7%89%A9%E6%A3%80%E6%B5%8B%E5%88%86%E5%89%B2%E6%95%88%E6%9E%9C.jpg" alt="激光雷达障碍物检测分割效果"></p>
<p>利用高精度地图限定感兴趣区域（Region of Interest，ROI）后，基于全卷积深度神经网络学习点云特征并预测障碍物的相关属性，得到前景障碍物检测与分割。</p>
<p><strong>(2) 可通行空间检测</strong></p>
<p><img data-src="https://image.shipengx.com/%E6%BF%80%E5%85%89%E9%9B%B7%E8%BE%BE%E5%8F%AF%E9%80%9A%E8%A1%8C%E7%A9%BA%E9%97%B4%E6%A3%80%E6%B5%8B%E6%95%88%E6%9E%9C.jpg" alt="激光雷达可通行空间检测效果"></p>
<p>利用高精度地图限定 ROI 后，可以对 ROI 内部（比如可行驶道路和交叉口）的点云的高度及连续性信息进行判断点云处是否可通行。</p>
<p><strong>(3) 高精度电子地图制图与定位</strong></p>
<p><img data-src="https://image.shipengx.com/%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%E5%88%B6%E5%9B%BE%E4%B8%8E%E5%AE%9A%E4%BD%8D.jpg" alt="高精地图制图与定位"></p>
<p>利用多线激光雷达的点云信息与地图采集车载组合惯导的信息，进行高精地图制作。自动驾驶汽车利用激光点云信息与高精度地图匹配，以此实现高精度定位。</p>
<p><strong>(4) 障碍物轨迹预测</strong></p>
<p><img data-src="https://image.shipengx.com/%E9%9A%9C%E7%A2%8D%E7%89%A9%E8%BD%A8%E8%BF%B9%E9%A2%84%E6%B5%8B.jpg" alt="障碍物轨迹预测"></p>
<p>根据激光雷达的感知数据与障碍物所在车道的拓扑关系（道路连接关系）进行障碍物的轨迹预测，以此作为无人车规划（避障、换道、超车等）的判断依据。</p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMzc5MjQ1MA==" title="https://zhuanlan.zhihu.com/p/33792450">无人驾驶技术入门（六）| 工程师又爱又恨的激光雷达<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（十一）无人驾驶中的CAN消息解析</title>
    <url>/archives/78513fbc.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTYyNDE2Mw==" title="https://zhuanlan.zhihu.com/p/39624163">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>实现一个无人驾驶系统，会有几个层级：感知层 → 融合层 → 规划层 → 控制层。更具体一点为：传感器层 → 驱动层 → 信息融合层 → 决策规划层 → 底层控制层。以百度推出的 Apollo 开源的代码为例做 CAN 消息的讲解，我们先看到每一帧的 CAN 消息是如何被定义的：</p>
<p><img data-src="https://image.shipengx.com/%E5%8D%95%E5%B8%A7CAN%E6%B6%88%E6%81%AF%E7%9A%84%E5%AE%9A%E4%B9%89.jpg" alt="单帧CAN消息的定义"></p>
<p>可以发现，这个名为 CanFrame 的消息结构体中包含 4 个关键信息，分别为：</p>
<p><strong>(1) CAN 消息的 ID 号：uint32_t id</strong><br>由于 CAN 总线上传播着大量 CAN 消息，因此两个节点进行通信时，会先看 id 号，以确保这是节点想要的 CAN 消息。最初 CAN 消息 id 号的范围是 000-7FF（16 进制数），但随着汽车电控信号的增多，需要传递的消息变多，信息不太够用了，工程师在 CAN 消息基础上，扩展了 id 号的范围，大大增加了 id 号的上限，并将改进后的 CAN 消息称为“扩展帧”，旧版 CAN 消息称为“普通帧”。</p>
<p><strong>(2) CAN 消息的有效长度：uint8_t len</strong><br>每一帧 CAN 消息最多能够传递 8 个 8 位无符号整形数据，或者说能够传递 8*8 的<code>bool</code>类型的数据，此处的 len 的最大值为 8。</p>
<p><strong>(3) CAN 消息的实际数据：uint8_t data[8]</strong><br>正如上文所述，每一帧 CAN 消息都至多包含 8*8 个<code>bool</code>类型数据，因此可通过 8*8 的矩阵，可视化 CAN 消息中的 data。如下图所示：</p>
<p><img data-src="https://image.shipengx.com/CAN%E6%95%B0%E6%8D%AE%E7%A4%BA%E4%BE%8B.jpg" alt="CAN数据示例"></p>
<p><strong>(4) CAN 消息的时间戳：timestamp</strong><br>时间戳表示收到该 CAN 消息的时刻。通过连续多帧的时间戳，可计算出 CAN 消息的发送周期，也可用于判断 CAN 消息是否被持续收到。<br>如下图所示，为 Mobileye 提供的车道线的 dbc 文件：</p>
<p><img data-src="https://image.shipengx.com/Mobileye%E8%BD%A6%E9%81%93%E7%BA%BFdbc%E7%89%87%E6%AE%B5.jpg" alt="Mobileye车道线dbc片段"></p>
<p>每个信号的具体描述显示在软件右侧，其中与解析直接相关的三个要素已用<br>绿色框选中：</p>
<ul>
<li>Value Type（Unsigned 或 Signed）<br>某些物理量在描述时是有符号的，例如温度；而有些物理量则是没有符号的，例如曲率。</li>
<li>Factor 和 Offset<br>Factor 是倍率，Offset 是偏移量，二者需要参与实际的物理量运算。例如 Lane_Type 和 Quality 信号的 Factor 为 1，Offset 为 0，而其他信号的 Factor 均为小数。</li>
</ul>
<p>双击 LKA_Left_Lane_A，打开 Layout 页，如下图所示：</p>
<p><img data-src="https://image.shipengx.com/LKA_Left_Lane_A%20layout.jpg" alt="LKA_Left_Lane_A layout"></p>
<p>将上文所述两图进行叠加，将得到如下图所示的 data 图：</p>
<p><img data-src="https://image.shipengx.com/CAN%E6%95%B0%E6%8D%AEdata%E5%9B%BE.jpg" alt="CAN数据data图"></p>
<p>每个信号物理量的计算公式为：</p>
<script type="math/tex; mode=display">
实际值=(十进制值*Factor)+Offset</script><p><strong>对于 Factor 为 1 的物理量：</strong><br>由于 Lane_Type 和 Quality 的 Factor 为 1，Offset 为 0，因此十进制值为多少，实际物理量即为多少。从图中可以看出 Quality 信号占据两个位，二进制数 0011，对应的十进制数为：</p>
<script type="math/tex; mode=display">
(1*2 + 1*1)=3</script><p>Lane_Type 占据四个位，二进制数为 0010，对应的十进制数为：</p>
<script type="math/tex; mode=display">
(0*8 + 0*4 + 1*2 + 0*1)=2</script><p>故此帧信号表示此时的左车道线 Lane_Type 值为 2，Quality 值为 3。对于整数值，通信双方可以约定规则，例如 Mobileye 规定：Quality 为 0 或 1 时表示车道线的置信度较低，不推荐使用此时的值；2 表示置信度中等，3 表示置信度较高，可放心使用。</p>
<p><strong>Factor 为小数的物理量：</strong><br>对于 Factor 不为 1 的物理量，比如 Position，需要使用移位的方法进行解析，但解析公式保持不变。以百度 Apollo 提供的源码为例：</p>
<p><img data-src="https://image.shipengx.com/Apollo%20CAN%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81%E7%A4%BA%E4%BE%8B.jpg" alt="Apollo CAN解析源码示例"></p>
<p>bytes 即为 CAN 消息中的 data，首先将 Position 信号所在的行取出来，将第 1 行的 8 个 bool 值存储在变量 t1 中，将第二行的 8 个 bool 值存储在变量 t0 中。由于在这条 CAN 消息中，Position 同时占据了高 8 位和低 8 位，因此需要将第一行和第二行所有的 bool 位拿来计算，高 8 位存储在 32 位的变量 x 中，低 8 位存储在 32 位的变量 t 中。现在需要将高 8 位和低 8 位拼接，将高 8 位左移 8 位，然后与低 8 位进行求或运算，即可得到 Position 的二进制值。随后进行的左移 16 位，再右移 16 位的操作是为了将 32 位的变量 x 的高 16 位全部初始化为 0（为什么不直接和 0x0000FFFF 进行按位与的操作？）。之后将 x 乘以 Factor 再加上 Offset 即可得到真实的 Position 值，给真实值加上单位 meter，即可获取实际的物理量。<strong>VCU、雷达等通过 CAN 总线传递信号，随着 CAN 的负载越来越高，很多传感器使用了其它通信方式，比如激光雷达的点云数据量太过庞大，使用的是局域网通信，而 GPS 和惯导使用的是串口通信。</strong></p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zOTYyNDE2Mw==" title="https://zhuanlan.zhihu.com/p/39624163">无人驾驶技术入门（十一）| 无人驾驶中的 CAN 消息解析<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（十三）手把手教你写卡尔曼滤波器</title>
    <url>/archives/d3b96bd5.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTIzODY4MQ==" title="https://zhuanlan.zhihu.com/p/45238681">这里<i class="fa fa-external-link"></i></span></p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>简单来讲，卡尔曼滤波器就是根据上一时刻的状态，预测当前时刻的状态，将预测的状态量与当前时刻的观测量进行加权，加权后的结果才认为是当前实际的状态量，而非仅听信当前的观测量。卡尔曼滤波过程可主要概括为以下三步：</p>
<p><strong>(1) 初始化（Initialization）</strong></p>
<p>假设有个小车在道路上向右侧做匀速运动，在左侧安装了一个可以测量小车距离和速度的传感器，传感器每 1 秒测一次小车的位置 $s$ 和速度 $v$，如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E5%B0%8F%E8%BD%A6%E8%BF%90%E5%8A%A8%E7%8A%B6%E6%80%81%E4%BC%B0%E8%AE%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="小车运动状态估计示意图"></p>
<p>用向量 $x_t$ 来表示当前小车的状态，该向量也是最终的输出结果，被称作状态向量（state vector）：</p>
<script type="math/tex; mode=display">
x_t=
\begin{bmatrix}
    s_t \\
    v_t
\end{bmatrix}</script><p>由于测量误差的存在，传感器无法直接获取小车位置的真值，只能获取在真值附近的一个近似值，可以假设测量值在真值附近服从高斯分布。如下图所示，测量值分布在红色区域内的左侧或右侧，真值则在红色区域的波峰处：</p>
<p><img data-src="https://image.shipengx.com/%E5%81%87%E5%AE%9A%E8%A7%82%E6%B5%8B%E5%80%BC%E5%9C%A8%E7%9C%9F%E5%80%BC%E9%99%84%E8%BF%91%E6%9C%8D%E4%BB%8E%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83.jpg" alt="假定观测值在真值附近服从高斯分布"></p>
<p>由于是第一次测量，没有小车的历史信息，认为小车在 $t=1$ 秒时的状态量 $x_1$ 与观测量 $z_1$ 相等：</p>
<script type="math/tex; mode=display">
x_1=z_1=
\begin{bmatrix}
    s_1 \\
    v_1
\end{bmatrix}</script><p><strong>(2) 预测（Prediction）</strong></p>
<p>预测是卡尔曼滤波中很重要的一步，这一步相当于使用历史信息对未来的位置进行推测。根据第 1 秒小车的位置和速度，可以推测第 2 秒时，小车所在的位置应该如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E9%A2%84%E6%B5%8B%E6%94%BE%E5%A4%A7%E4%BA%86%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%80%A7.jpg" alt="预测放大了不确定性"></p>
<p>会发现，图中红色区域的范围变大了，这是因为预测时加入了速度估计的噪声，是一个放大不确定性的过程。根据小车第 1 秒的状态量进行预测，得到预测的第 2 秒的状态量 $x_{pre}$：</p>
<script type="math/tex; mode=display">
x_{pre}=
\begin{bmatrix}
    s_1+v_1 \\
    v_1
\end{bmatrix}</script><p>其中，下脚标 $pre$ 是 prediction 的简称。时间间隔为 1 秒，所以预测位置为<strong>距离+速度*1</strong>，由于小车做匀速运动，因此速度保持不变。</p>
<p><strong>(3) 观测（Measurement）</strong></p>
<p>在第 2 秒时，传感器对小车的位置做了一次观测，认为小车在第 2 秒时的观测量为 $z_2$：</p>
<script type="math/tex; mode=display">
z_2=
\begin{bmatrix}
    s_2 \\
    v_2
\end{bmatrix}</script><p>显然，第二次观测的结果也是存在误差的，将预测的小车位置与实际观测到的小车位置放在同一个图上，即可看到：</p>
<p><img data-src="https://image.shipengx.com/%E9%A2%84%E6%B5%8B%E5%8F%A0%E5%8A%A0%E8%A7%82%E6%B5%8B.jpg" alt="预测叠加观测"></p>
<p>图中红色区域为预测的小车位置，蓝色区域为第 2 秒的观测结果。显然，这两个结果都在真值附近。为得到尽可能接近真值的结果，将这两个区域的结果进行加权，取加权后的值作为第 2 秒的状态量。为了方便理解，可以将第 2 秒的状态量写成：</p>
<script type="math/tex; mode=display">
x_2=w_1*x_{pre}+w_2*z_2</script><p>其中，$w_1$ 为预测结果的权值，$w_2$ 为观测结果的权值。<strong>两个权值的计算是根据预测结果和观测结果的不确定性来的，这个不确定性就是高斯分布中方差的大小，方差越大，波形分布越广，不确定性越高，给的权值越低。</strong>加权后的状态向量的分布可以用下图中绿色区域表示：</p>
<p><img data-src="https://image.shipengx.com/%E9%A2%84%E6%B5%8B%E5%8F%A0%E5%8A%A0%E8%A7%82%E6%B5%8B%E5%BE%97%E5%88%B0%E6%96%B0%E7%9A%84%E5%90%8E%E9%AA%8C%E9%AB%98%E6%96%AF%E5%88%86%E5%B8%83.jpg" alt="预测叠加观测得到新的后验高斯分布"></p>
<p>可以发现，绿色区域的方差均小于红色区域和蓝色区域，原因是<strong>进行加权运算时，需要将两个高斯分布进行乘法运算，得到的新的高斯分布的方差比两个做乘法的高斯分布都小。两个不那么确定的分布，最终得到了一个相对确定的分布</strong>。</p>
<p>第 1 秒的初始化以及第 2 秒的预测、观测，实现了卡尔曼滤波的第一个周期。同样地，根据第 2 秒的状态量做第 3 秒的预测，再与第 3 秒的观测量进行加权，就得到了第 3 秒的状态量；再根据第 3 秒的状态量做第 4 秒的预测，再与第 4 秒的观测量进行加权，就得到了第 4 秒的状态量。以此往复，就实现了一个真正意义上的卡尔曼滤波器。卡尔曼滤波器的理论公式如下所示：</p>
<p><img data-src="https://image.shipengx.com/%E5%8D%A1%E5%B0%94%E6%9B%BC%E6%BB%A4%E6%B3%A2%E7%90%86%E8%AE%BA%E5%85%AC%E5%BC%8F.png" alt="卡尔曼滤波理论公式"></p>
<p>下面结合上面的公式，用 C++代码实现初始化、预测、观测的过程。由于公式中涉及大量的矩阵转置和求逆运算，使用开源的矩阵运算库——Eigen。</p>
<p><strong>代码：初始化（Initialization）</strong></p>
<p>初始化阶段，需要将各个变量初始化，对于不同的运动模型，其状态向量不同，对于上文中小车的例子，只需距离 $s$ 和速度 $v$ 就可以表示小车的状态；再比如一个二维空间中的点，需要 $x$ 方向上的距离和速度及 $y$ 方向上的距离和速度才能表示其状态，这样的状态量就有 4 个变量。因此使用 Eigen 库中非定长的数据结构，下图中的<code>VerctorXd</code>表示 X 维的列向量，其中的元素数据类型为<code>double</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KALMAN_FILTER_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KALMAN_FILTER_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Eigen/Dense"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KalmanFilter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    KalmanFilter()</span><br><span class="line">    &#123;</span><br><span class="line">        is_initialized = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~KalmanFilter();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(Eigen::VectorXd x_in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x_ = x_in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> is_initialized; <span class="comment">//flag of initialization</span></span><br><span class="line">    Eigen::VectorXd x_;   <span class="comment">//state vector</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这里，新建了一个<code>KalmanFilter</code>类，其中定义了一个叫做<code>x_</code>的变量，表示小车的状态向量。</p>
<p><strong>代码：预测（Prediction）</strong></p>
<p>完成初始化后，开始写 Prediction 部分的代码。首先是公式：</p>
<script type="math/tex; mode=display">
x^\prime=Fx+u</script><p>这里的 $x$ 为上一时刻状态量，通过左乘一个<strong>状态转移矩阵</strong>（state transistion matrix）$F$，再加上外部影响 $u$，得到预测的当前时刻的状态量 $x^\prime$。以 2 维的匀速运动为例，$x$ 为：</p>
<script type="math/tex; mode=display">
x=
\begin{bmatrix}
    s_x \\
    s_y \\
    v_x \\
    v_y
\end{bmatrix}</script><p>对于匀速运动模型，经过时间 $\Delta t$ 后的预测状态量为：</p>
<script type="math/tex; mode=display">
x^\prime=
\begin{bmatrix}
    s_x +v_x\Delta t \\
    s_y +v_y\Delta t \\
    v_x \\
    v_y
\end{bmatrix}</script><p>由于假设当前运动为匀速运动，加速度为 0，加速度不会对预测造成影响，即：</p>
<script type="math/tex; mode=display">
u=0</script><p>公式 $x^\prime=Fx+u$ 演变为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
    s_x +v_x\Delta t \\
    s_y +v_y\Delta t \\
    v_x \\
    v_y
\end{bmatrix}=
\begin{bmatrix}
    1 & 0 & \Delta t & 0 \\
    0 & 1 & 0 & \Delta t \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1 \\
\end{bmatrix}
\begin{bmatrix}
    s_x \\
    s_y \\
    v_x \\
    v_y
\end{bmatrix}+
\begin{bmatrix}
    0 \\
    0 \\
    0 \\
    0
\end{bmatrix}</script><p>如果换成匀加速运动模型，就可以引入加速度 $a_x$ 和 $a_y$，$u$ 变为：</p>
<script type="math/tex; mode=display">
u=
\begin{bmatrix}
    \frac{1}{2}a_x\Delta t^2 \\
    \frac{1}{2}a_y\Delta t^2 \\
    a_x\Delta t \\
    a_y\Delta t
\end{bmatrix}</script><p>由于每次预测时，$\Delta t$ 的大小不固定，因此专门写一个函数<code>SetF()</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetF</span><span class="params">(Eigen::MatrixXd F_in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    F_ = F_in;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再看预测模块的第二个公式：</p>
<script type="math/tex; mode=display">
P^\prime=FPF^T+Q</script><p>该公式中，$P$ 被称为<strong>状态协方差矩阵</strong>（state covariance matrix），表示系统的不确定程度，$P$ 在卡尔曼滤波器初始化时会很大，随着越来越多的数据注入滤波器中，不确定程度会逐渐减小；$Q$ 是<strong>过程噪声协方差矩阵</strong>（process noise covariance matrix），即无法用 $x^\prime=Fx+u$ 表示的噪声，比如车辆运动时突然到了上坡，这个影响是无法用之前的状态转移估计的。以激光雷达为例，激光雷达只能测量点的位置，无法测量点的速度，因此对于激光雷达的协方差矩阵来说，对于位置信息，其测量较准确，不确定度较低；对于速度信息，不确定度较高。因此可以认为此处的 $P$ 为：</p>
<script type="math/tex; mode=display">
P=
\begin{bmatrix}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 100 & 0 \\
    0 & 0 & 0 & 100
\end{bmatrix}</script><p>由于 $Q$ 对整个系统存在影响，但又不能确定对系统的影响有多大。工程上，一般将 $Q$ 设置为单位矩阵参与运算，即：</p>
<script type="math/tex; mode=display">
Q=
\begin{bmatrix}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
    0 & 0 & 1 & 0 \\
    0 & 0 & 0 & 1
\end{bmatrix}</script><p>根据以上内容和公式：</p>
<script type="math/tex; mode=display">
\begin{cases}
    x^\prime=Fx+u \\
    P^\prime=FPF^T+Q
\end{cases}</script><p>就可以写出预测模块的代码了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prediction</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    x_ = F_ * x_;</span><br><span class="line">    Eigen::MatrixXd Ft = F_.transpose();</span><br><span class="line">    P_ = F_ * P_ * Ft + Q_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>代码：观测（Measurement）</strong></p>
<p>观测模块的第一个公式是：</p>
<script type="math/tex; mode=display">
y=z-Hx^\prime</script><p>这个公式计算的是实际观测量 $z$ 与状态量预测值 $x^\prime$ 之间的差值 $y$。不同传感器的观测量一般不同，比如激光雷达测量的位置信号为 $x$ 方向和 $y$ 方向上的距离，毫米波雷达测量的是位置和角度信息。因此需要将状态量左乘一个矩阵 $H$，才能与观测量进行相应的运算，$H$ 被称为<strong>测量矩阵</strong>（Measurement Matrix）。激光雷达的观测量为：</p>
<script type="math/tex; mode=display">
z=
\begin{bmatrix}
    x_m \\
    y_m
\end{bmatrix}</script><p>其中 $x_m$ 和 $y_m$ 分别表示 $x$ 方向和 $y$ 方向上的测量值。由于 $x^\prime$ 是一个 4*1 的列向量，如果要与一个 2*1 的列向量 $z$ 进行减运算，需要左乘一个 2*4 的矩阵：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
    \Delta x \\
    \Delta y
\end{bmatrix}=
\begin{bmatrix}
    x_m \\
    y_m
\end{bmatrix}-
\begin{bmatrix}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
\end{bmatrix}
\begin{bmatrix}
    s_x +v_x\Delta t \\
    s_y +v_y\Delta t \\
    v_x \\
    v_y
\end{bmatrix}</script><p>意即，对于激光雷达而言，测量矩阵 $H$ 为：</p>
<script type="math/tex; mode=display">
H=
\begin{bmatrix}
    1 & 0 & 0 & 0 \\
    0 & 1 & 0 & 0 \\
\end{bmatrix}</script><p>求得 $y$ 后，对 $y$ 乘以一个加权量，再加到原来的状态量预测量上去，就可以得到一个既考虑了观测量，又考虑了预测模型位置的状态量了。对于权值 $K$ 的计算，看下面的两个公式：</p>
<script type="math/tex; mode=display">
\begin{cases}
    S=HP^\prime H^T+R \\
    K=P^\prime H^TS^{-1}
\end{cases}</script><p>权值 $K$ 被称为<strong>卡尔曼增益</strong>（Kalman Gain），$R$ 是<strong>测量噪声协方差矩阵</strong>（measurement noise covariance matrix），表示的是测量值与真值之间的差值。一般情况下，传感器厂家会提供该值。$S$ 只是为了简化公式，写的一个临时变量。最后两个公式：</p>
<script type="math/tex; mode=display">
\begin{cases}
    x=x^\prime+Ky \\
    P=(I-KH)P^\prime
\end{cases}</script><p>上述两个公式，实际上完成了卡尔曼滤波器的闭环，第一个公式是完成了当前状态量 $x$ 的更新，不仅考虑了上一时刻状态量的预测量，也考虑了观测量和整个系统的噪声；第二个公式根据卡尔曼增益，更新了系统的不确定度 $P$，用于下一个周期的运算，该公式中的 $I$ 为单位矩阵，维数为状态量的行数。将观测模块的五个公式写成代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> KALMAN_FILTER_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KALMAN_FILTER_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Eigen/Dense"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KalmanFilter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    KalmanFilter()</span><br><span class="line">    &#123;</span><br><span class="line">        is_initialized = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~KalmanFilter();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get state vector</span></span><br><span class="line">    <span class="function">Eigen::VectorXd <span class="title">GetX</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// get flag of initialization</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">IsInitialized</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> is_initialized;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// initialize kalman filter</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Initialization</span><span class="params">(Eigen::VectorXd x_in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x_ = x_in;</span><br><span class="line">        is_initialized = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetF</span><span class="params">(Eigen::MatrixXd F_in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        F_ = F_in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetP</span><span class="params">(Eigen::MatrixXd P_in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        P_ = P_in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetQ</span><span class="params">(Eigen::MatrixXd Q_in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Q_ = Q_in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetH</span><span class="params">(Eigen::MatrixXd H_in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        H_ = H_in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetR</span><span class="params">(Eigen::MatrixXd R_in)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        R_ = R_in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predict state vector and state covariance matrix</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Prediction</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x_ = F_ * x_;</span><br><span class="line">        Eigen::MatrixXd Ft = F_.transpose();</span><br><span class="line">        P_ = F_ * P_ * Ft + Q_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update state vector and state covariance matrix</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">MeasurementUpdate</span><span class="params">(<span class="keyword">const</span> Eigen:: VectorXd &amp;z)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Eigen::VectorXd y = z - H_ * x_;</span><br><span class="line">        Eigen::MatrixXd S = H_ * P_ * H_.transpose() + R_;</span><br><span class="line">        <span class="comment">// Kalman Gain</span></span><br><span class="line">        Eigen::MatrixXd K = P_ * H_.transpose() * S.inverse();</span><br><span class="line">        <span class="comment">// estimate state vector</span></span><br><span class="line">        x_ = x_ + K * y;</span><br><span class="line">        <span class="keyword">int</span> size = x_.size;</span><br><span class="line">        Eigen::Matrix2Xd I = Eigen::MatrixXd::Identity(size, size);</span><br><span class="line">        <span class="comment">// update state covariance matrix</span></span><br><span class="line">        P_ = (I - K * H_) * P_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">bool</span> is_initialized; <span class="comment">// flag of initialization</span></span><br><span class="line">    Eigen::VectorXd x_;  <span class="comment">// state vector</span></span><br><span class="line">    Eigen::MatrixXd F_;  <span class="comment">// state transition matrix</span></span><br><span class="line">    Eigen::MatrixXd P_;  <span class="comment">// state covariance matrix</span></span><br><span class="line">    Eigen::MatrixXd Q_;  <span class="comment">// process noise covariance matrix</span></span><br><span class="line">    Eigen::MatrixXd H_;  <span class="comment">// measurement matrix</span></span><br><span class="line">    Eigen::MatrixXd R_;  <span class="comment">// measurement noise covariance matrix</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>可以发现<code>MeasurementUpdate()</code>函数的形参为“常引用”类型，这样既兼顾了参数传递效率（因为是引用，所以无需为传入的参数申请物理内存用以保存其值），又保证了数据安全（因为参数被<code>const</code>修饰了）。以激光雷达数据为例，使用以上滤波器，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"KalmanFilter.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> Sx = <span class="number">0.0</span>, Sy = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">double</span> last_timestamp = <span class="number">0.0</span>, now_timestamp = <span class="number">0.0</span>;</span><br><span class="line">    KalmanFilter kf;</span><br><span class="line">    <span class="keyword">while</span> (GetLidarData(Sx, Sy, now_timestamp))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// initialize kalman filter</span></span><br><span class="line">        <span class="keyword">if</span> (!kf.IsInitialized())</span><br><span class="line">        &#123;</span><br><span class="line">            last_timestamp = now_timestamp;</span><br><span class="line">            <span class="function">Eigen::VectorXd <span class="title">x_in</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">            x_in &lt;&lt; Sx, Sy, <span class="number">0.0</span>, <span class="number">0.0</span>;</span><br><span class="line">            kf.Initialization(x_in);</span><br><span class="line">            <span class="comment">// set state covariance matrix</span></span><br><span class="line">            <span class="function">Eigen::MatrixXd <span class="title">P_in</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">            P_in &lt;&lt; <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">                    <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">                    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">100.0</span>, <span class="number">0.0</span>,</span><br><span class="line">                    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">100.0</span>;</span><br><span class="line">            kf.SetP(P_in);</span><br><span class="line">            <span class="comment">// set process noise covariance matrix</span></span><br><span class="line">            <span class="function">Eigen::MatrixXd <span class="title">Q_in</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">            Q_in &lt;&lt; <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">                    <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">                    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1</span>, <span class="number">0.0</span>,</span><br><span class="line">                    <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1</span>;</span><br><span class="line">            kf.SetQ(Q_in);</span><br><span class="line">            <span class="comment">// set measurement matrix</span></span><br><span class="line">            <span class="function">Eigen::MatrixXd <span class="title">H_in</span><span class="params">(<span class="number">2</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">            H_in &lt;&lt; <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>,</span><br><span class="line">                    <span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>;</span><br><span class="line">            kf.SetH(H_in);</span><br><span class="line">            <span class="comment">// set measurement noise covariance matrix</span></span><br><span class="line">            <span class="comment">// R is provided by sensor supplier, in datasheet</span></span><br><span class="line">            <span class="function">Eigen::MatrixXd <span class="title">R_in</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">            R_in &lt;&lt; <span class="number">0.0225</span>, <span class="number">0.0</span>,</span><br><span class="line">                    <span class="number">0.0</span>, <span class="number">0.0225</span>;</span><br><span class="line">            kf.SetR(R_in);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// set state transition matrix</span></span><br><span class="line">        <span class="keyword">double</span> dt = now_timestamp - last_timestamp;</span><br><span class="line">        <span class="function">Eigen::MatrixXd <span class="title">F_in</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">        F_in &lt;&lt; <span class="number">1.0</span>, <span class="number">0.0</span>, dt, <span class="number">0.0</span>,</span><br><span class="line">                <span class="number">0.0</span>, <span class="number">1.0</span>, dt, <span class="number">0.0</span>,</span><br><span class="line">                <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1</span>, <span class="number">0.0</span>,</span><br><span class="line">                <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1</span>;</span><br><span class="line">        kf.SetF(F_in);</span><br><span class="line">        <span class="comment">// predict state vector x and state covariance matrix P</span></span><br><span class="line">        kf.Prediction();</span><br><span class="line">        <span class="comment">// update state vector x and state covariance matrix P</span></span><br><span class="line">        <span class="function">Eigen::VectorXd <span class="title">z</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        z &lt;&lt; Sx, Sy;</span><br><span class="line">        kf.MeasurementUpdate(z);</span><br><span class="line">        <span class="function">Eigen::VectorXd <span class="title">x_out</span><span class="params">(<span class="number">4</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// output result</span></span><br><span class="line">        x_out = kf.GetX();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Kalman filter output Sx is: "</span> &lt;&lt; x_out(<span class="number">0</span>)</span><br><span class="line">                   &lt;&lt; <span class="string">", output Sy is: "</span> &lt;&lt; x_out(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>GetLidarData()</code>函数除了获取点的位置信息 $S_x$ 和 $S_y$ 外，还获取了当前时刻的时间戳，用于计算前后两帧的时间差 $\mathrm{d}t$。在经典卡尔曼滤波器基础上，还有扩展卡尔曼滤波器（EKF）和无迹卡尔曼滤波器（UKF），它们与经典卡尔曼滤波器的最大区别是状态转移矩阵 $F$ 和测量矩阵 $H$ 的不同。下图（原图出自<span class="exturl" data-url="aHR0cDovL3d3dy5iemFyZy5jb20vcC9ob3ctYS1rYWxtYW4tZmlsdGVyLXdvcmtzLWluLXBpY3R1cmVzLw==" title="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/">这里<i class="fa fa-external-link"></i></span>）很形象地说明了经典卡尔曼滤波器的原理：</p>
<p><img data-src="https://image.shipengx.com/Kalman%E6%BB%A4%E6%B3%A2%E5%99%A8%E9%80%92%E6%8E%A8%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="Kalman滤波器递推流程示意图"></p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80NTIzODY4MQ==" title="https://zhuanlan.zhihu.com/p/45238681">无人驾驶技术入门（十三）| 手把手教你写卡尔曼滤波器<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5iemFyZy5jb20vcC9ob3ctYS1rYWxtYW4tZmlsdGVyLXdvcmtzLWluLXBpY3R1cmVzLw==" title="http://www.bzarg.com/p/how-a-kalman-filter-works-in-pictures/">How a Kalman filter works, in pictures<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（十二）无人驾驶中的坐标转换</title>
    <url>/archives/b10733db.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTI2MzcwMQ==" title="https://zhuanlan.zhihu.com/p/41263701">这里<i class="fa fa-external-link"></i></span></p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>车辆坐标系的原点在车辆后轮轴的中心，如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E8%BD%A6%E8%BE%86%E5%9D%90%E6%A0%87%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="车辆坐标系示意图"></p>
<p>以安装在无人车左前方的角雷达（Corner radar）为例，角雷达的安装位置和坐标系如下图绿线所示：</p>
<p><img data-src="https://image.shipengx.com/%E8%A7%92%E9%9B%B7%E8%BE%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="角雷达坐标系示意图"></p>
<p>角雷达检测到的障碍物如图中的绿点所示，绿点在雷达坐标系下的坐标为$(x_1, y_1)$，为了便于理解暂不加入$z$方向的坐标，绿点转换到自车坐标系下需要经过一定的数学运算：</p>
<p><strong>(1) 旋转</strong><br>将角雷达坐标系沿着$z$轴进行一定角度的旋转，新坐标系与自车坐标系相平行，</p>
<p><img data-src="https://image.shipengx.com/%E6%97%8B%E8%BD%AC%E8%A7%92%E9%9B%B7%E8%BE%BE%E5%9D%90%E6%A0%87%E7%B3%BB%E4%BD%BF%E4%B9%8B%E4%B8%8E%E8%87%AA%E8%BD%A6%E5%9D%90%E6%A0%87%E7%B3%BB%E5%B9%B3%E8%A1%8C.jpg" alt="旋转角雷达坐标系使之与自车坐标系平行"></p>
<p>障碍物在角雷达坐标系下的坐标为$(x_1, y_1)$，假设障碍物在旋转后的新坐标系下的坐标为$(x_0, y_0)$，安装角度$α$（可测量），做辅助线后如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E5%81%9A%E8%BE%85%E5%8A%A9%E7%BA%BF%E5%90%8E%E5%9D%90%E6%A0%87%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="做辅助线后坐标系示意图"></p>
<p>根据几何关系可得：</p>
<script type="math/tex; mode=display">
x_0=x_1*cosα-y_1*sinα \\
y_0=x_1*sinα+y_1*cosα</script><p>矩阵形式为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x_0 \\
y_0
\end{bmatrix}
=\begin{bmatrix}
cosα & -sinα \\
sinα & cosα
\end{bmatrix}
*\begin{bmatrix}
x_1 \\
y_1
\end{bmatrix}</script><p>由于旋转是绕$z$轴旋转，因此旋转前后$z$值保持不变，即$z_0$=$z_1$，故：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x_0 \\
y_0 \\
z_0
\end{bmatrix}
=\begin{bmatrix}
cosα & -sinα & 0 \\
sinα & cosα & 0 \\
0 & 0 & 1
\end{bmatrix}
*\begin{bmatrix}
x_1 \\
y_1 \\
z_1
\end{bmatrix}
=R_z
*\begin{bmatrix}
x_1 \\
y_1 \\
z_1
\end{bmatrix}</script><p>$R_z$为绕$z$轴的旋转矩阵，同样也有绕$x$轴的旋转矩阵$R_x$和绕$y$轴的旋转矩阵$R_y$，考虑到一般情况，上式变换为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x_0 \\
y_0 \\
z_0
\end{bmatrix}
=R_x*R_y*R_z
*\begin{bmatrix}
x_1 \\
y_1 \\
z_1
\end{bmatrix}</script><p>再加上一个平移矩阵，就能够得到障碍物在自车坐标系中的最终坐标描述：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
x_0 \\
y_0 \\
z_0
\end{bmatrix}
=R_x*R_y*R_z
*\begin{bmatrix}
x_1 \\
y_1 \\
z_1
\end{bmatrix}
+T_{xyz}</script><p>以上过程也称为<strong>欧拉变换</strong>，但是欧拉变换会有一个不可避免的问题——<strong>万向锁</strong>，欧拉变换的过程中在某些特殊情况时，会导致少一个维度。为了解决欧拉变换存在的万向锁问题，引入了<strong>四元数</strong>的概念。四元数除了能够解决万向锁的问题外，还能在一定程度上简化计算，因而百度 Apollo 也选择了四元数作为各个传感器安装位置和角度的存储介质。</p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC80MTI2MzcwMQ==" title="https://zhuanlan.zhihu.com/p/41263701">无人驾驶技术入门（十二）| 无人驾驶中的坐标转换<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（十五）再识图像之高级车道线检测</title>
    <url>/archives/a2ff34db.html</url>
    <content><![CDATA[<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（十四）初识图像之初级车道线检测</title>
    <url>/archives/418d7d6f.html</url>
    <content><![CDATA[<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（十）看不见的“传感器”高精度地图</title>
    <url>/archives/4da6b2e.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzg4NTU3Mw==" title="https://zhuanlan.zhihu.com/p/37885573">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>高精度电子地图也称为高分辨率地图（High Definition Map，<strong>HD Map</strong>），是一种专门用于无人驾驶的地图技术。与传统导航地图不同的是，高精度地图除了能提供道路（Road）级别的导航信息外，还能提供车道（Lane）级别的导航信息，高精度地图所提供信息的丰富度和精度远远高于传统导航地图。高精度地图能够为无人驾驶提供的内容包括：</p>
<p><strong>(1) 车道级道路信息</strong><br>传统导航地图只能提供道路级（Road）导航信息，如下图所示，道路 R1 连接着 R2，R2 同时连接着 R3 和 R4。而高精度地图能够提供车道级（Lane）导航信息，这种导航信息能够精确到车道的连接关系，如下图所示，Lane1 连着 Lane4，Lane4 连着 Lane8，Lane3 连着 Lane6 和 Lane7，Lane7 连着 Lane10。</p>
<p><img data-src="https://image.shipengx.com/%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%E9%81%93%E8%B7%AF%E6%8B%93%E6%89%91%E5%85%B3%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="高精地图道路拓扑关系示意图"></p>
<p>车道级别的道路信息能够解决在路口转弯时，无人车不知道需要转多大的角度和保持多高车速的问题。如下图右侧绿色虚线即为高精度地图为无人车提供的虚拟车道线中心，只要提前变道到正确车道，并沿着虚拟车道线所在的车道行驶，即可顺利通过路口。</p>
<p><img data-src="https://image.shipengx.com/%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3%E5%A4%84%E7%9A%84%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%E9%81%93%E8%B7%AF%E6%8B%93%E6%89%91%E5%85%B3%E7%B3%BB%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="十字路口处的高精地图道路拓扑关系示意图"></p>
<p><strong>(2) 道路先验信息</strong><br>先验信息是指某些可以预先采集且短时间内不会改变的信息。仅依靠传感器的信息很难感知：车辆现在是处在高速公路上，还是处在普通城市道路上；无限速牌的路段，车速最高可以开多快；前方道路的曲率；所处路段的 GPS 信号强弱等。这些都是传感器遇到性能瓶颈时，无法实时得到的信息，而这些信息却都是客观存在的，且短时间内不会随外部事物的变化而变化，因此可以对这些信息预先进行采集，并作为先验信息传给无人车做决策。如下图所示为高精度地图可以为无人车提供的某些先验信息，包括<strong>道路曲率</strong>、<strong>航向</strong>、<strong>坡度</strong>和<strong>横坡角</strong>，这些信息对于无人车的安全性和舒适性都至关重要。</p>
<p><img data-src="https://image.shipengx.com/%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%E6%89%80%E8%83%BD%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%80%E4%BA%9B%E5%85%B3%E9%94%AE%E5%85%88%E9%AA%8C%E4%BF%A1%E6%81%AF.jpg" alt="高精地图所能提供的一些关键先验信息"></p>
<p><strong>(3) 感兴趣点</strong><br>交通场景中能成为感兴趣点（Point of Interest，<strong>POI</strong>）的目标有很多，比如：用中心点和多个外包络点描述的交通标志牌、地面标志、灯杆、红绿灯、收费站等；用一系列连续点所组成的链状信息描述的路沿、护栏、隧道、龙门架、桥等。高精度地图精确记录了这些 POI 的经纬度和高度，只要给定无人车的精确位置（经纬高），即可将各个 POI 相对于自车的位置计算出来。将这些 POI 信息的相对位置逆向投影到车载前视图像上，如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%E6%89%80%E8%83%BD%E6%8F%90%E4%BE%9B%E7%9A%84POI%E4%BF%A1%E6%81%AF.jpg" alt="高精地图所能提供的POI信息"></p>
<p>下图从要素、系统、用途方面更为清晰地囊括了传统地图和高精度地图的侧重点：</p>
<p><img data-src="https://image.shipengx.com/%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%E4%B8%8E%E4%BC%A0%E7%BB%9F%E5%AF%BC%E8%88%AA%E5%9C%B0%E5%9B%BE%E7%9A%84%E4%BE%A7%E9%87%8D%E7%82%B9%E5%B7%AE%E5%BC%82.jpg" alt="高精地图与传统导航地图的侧重点差异"></p>
<p>高精度地图只是一个静态的数据，在实际使用时，不可能一开始就将全国的地图导入到系统中，这样不仅费时，而且会占用系统很多资源。高精度地图的供应商（图商）除了提供高精度地图外，还会提供一个叫做“地图引擎”的软件，由其负责整个高精度地图的资源调度，无人车只需告诉“地图引擎”当前的大致位置及目的地，“地图引擎”便会将这个过程中所要用到的高精度地图数据发布出来，供无人车使用，数据流如下图所示：</p>
<p><img data-src="https://image.shipengx.com/%E9%AB%98%E7%B2%BE%E5%9C%B0%E5%9B%BE%E6%95%B0%E6%8D%AE%E6%B5%81.jpg" alt="高精地图数据流"></p>
<p>高精度地图的应用需要配合高精度的定位。高精度定位，至少包含无人车当前的位置和航向角。位置是指无人车 GPS 天线安装位置所在的经度、纬度、高度；航向角，是指无人车车头的朝向与正北方向的夹角。</p>
<p>无人车的定位算法通常采用<strong>粒子滤波</strong>的方法，需要经过多个计算周期后，定位结果才会收敛，进而提供一个相对稳定的定位结果。高精地图所面临的挑战：<strong>地图众包</strong>与国内政策。</p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNzg4NTU3Mw==" title="https://zhuanlan.zhihu.com/p/37885573">无人驾驶技术入门（十）| 看不见的“传感器”高精度地图<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>（四）百度无人车传感器IMU深入剖析</title>
    <url>/archives/e82e9544.html</url>
    <content><![CDATA[<blockquote>
<p>本文章学习总结自知乎大 V<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3Blb3BsZS9DaGVuR3Vhbmc5MjQ=" title="https://www.zhihu.com/people/ChenGuang924">陈光<i class="fa fa-external-link"></i></span>的<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vY18xNDczMDkzMzk=" title="https://zhuanlan.zhihu.com/c_147309339">《无人驾驶干货铺》<i class="fa fa-external-link"></i></span>专栏，查阅原文请移步<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjY5MzM3Nw==" title="https://zhuanlan.zhihu.com/p/32693377">这里<i class="fa fa-external-link"></i></span>。</p>
</blockquote>
<h1 id="1-正文" class="heading-control"><a href="#1-正文" class="headerlink" title="1 正文"></a>1 正文<a class="heading-anchor" href="#1-正文" aria-hidden="true"></a></h1><p>惯性测量单元（Inertial Measurement Unit，IMU）用于实时测量被测单元的姿态，通常指由 3 个加速度计和 3 个陀螺仪组成的组合单元，之前做平衡车时用到的 MPU6050 即为一种典型的 IMU 芯片。加速度计和陀螺仪安装在互相垂直的测量轴上。低精度的 IMU 可以通过其它方式进行修正，GPS 用于修正位置的长期漂移，气压计用于修正高度，磁力计用于修正姿态。在无人驾驶系统中，GPS 的更新频率一般为 10Hz，IMU 的更新频率一般为 100Hz，<strong>GPS+IMU 的组合定位方式，可以给出频率 100Hz 的定位输出</strong>。下图是两传感器数据融合的原理图：</p>
<p><img data-src="https://image.shipengx.com/GPS%2BIMU%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="GPS+IMU数据融合原理示意图"></p>
<p>运行在控制器上的软件对信息的处理流程在时间维度上类似下图:</p>
<p><img data-src="https://image.shipengx.com/GPS%2BIMU%E6%95%B0%E6%8D%AE%E8%9E%8D%E5%90%88%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="GPS+IMU数据处理流程示意图"></p>
<p>在 0~100ms 的周期中，使用 IMU 进行 9 次位置的估计，待新的 GPS 定位数据进来时，则进行修正，以此实现高频率的定位结果输出。</p>
<h1 id="2-参考" class="heading-control"><a href="#2-参考" class="headerlink" title="2 参考"></a>2 参考<a class="heading-anchor" href="#2-参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMjY5MzM3Nw==" title="https://zhuanlan.zhihu.com/p/32693377">无人驾驶技术入门（四）| 百度无人车传感器 IMU 深入剖析<i class="fa fa-external-link"></i></span></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>无人驾驶技术入门</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 3 章 字符串、向量和数组</title>
    <url>/archives/73015543.html</url>
    <content><![CDATA[<ol>
<li><p><strong>using 声明</strong>（using declaration）。有了 <code>using</code> 声明就无须专门的前缀（形如命名空间::）也能使用所需的名字了。<code>using</code> 声明具有如下的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name;</span><br></pre></td></tr></table></figure>
<p>一旦声明了上述语句，就可以直接访问命名空间中的名字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">// using声明，当我们使用名字cin时，从命名空间std中获取它</span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; i;        <span class="comment">// 正确：cin和std::cin含义相同</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i;       <span class="comment">// 错误：没有对应的using声明，必须使用完整的名字</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i;  <span class="comment">// 正确：显式地从std中使用cout</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>位于头文件的代码一般来说不应该使用 <code>using</code> 声明</strong>。因为头文件的内容会拷贝到所有引用它的文件中去，如果头文件里有某个 <code>using</code> 声明，那么每个使用了该头文件的文件就都会有这个声明。对于某些程序来说，由于不经意间包含了一些名字，反而可能产生始料未及的名字冲突。</p>
</li>
<li><p>标准库类型 <code>string</code> 表示可变长的字符序列，<strong>使用 <code>string</code> 类型必须首先包含 <code>string</code> 头文件。</strong>作为标准库的一部分，<code>string</code> 定义在命名空间 <code>std</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一个类可以定义很多种初始化对象的方式，只不过这些方式之间必须有所区别：或者是初始值的数量不同，或者是初始值的类型不同。下表列出了初始化 <code>string</code> 对象最常用的一些方式：</p>
 <table>
 <tbody>
 <tr>
     <td><b>写法</b></td>
     <td><b>含义</b></td>
 </tr>
 <tr>
     <td>string s1</td>
     <td>默认初始化，s1是一个空串</td>
 </tr>
 <tr>
     <td>string s2(s1)</td>
     <td>s2是s1的副本</td>
 </tr>
 <tr>
     <td>string s2 = s1</td>
     <td>等价于s2(s1)，s2是s1的副本</td>
 </tr>
 <tr>
     <td>string s3("value")</td>
     <td>s3是字面值“value”的副本，除了字面值最后的那个空字符外</td>
 </tr>
 <tr>
     <td>string s3 = "value" </td>
     <td>等价于s3("value")，s3是字面值“value”的副本</td>
 </tr>
 <tr>
     <td>string s4(n, 'c')</td>
     <td>把s4初始化为由连续n个字符c组成的串</td>
 </tr>
 </tbody>
 </table>

<p>下面是几个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;           <span class="comment">// 默认初始化，s1是一个空字符串</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;      <span class="comment">// s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s3 = <span class="string">"hiya"</span>;  <span class="comment">// s3是该字符串字面值的副本</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;  <span class="comment">// s4的内容是cccccccccc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用等号（=）初始化一个变量，实际上执行的是<strong>拷贝初始化</strong>（copy initialization），编译器把等号右侧的初始值拷贝到新创建的对象中去。与之相反，如果不使用等号，则执行的是<strong>直接初始化</strong>（direct initialization）。当初始值只有一个时，使用直接初始化或拷贝初始化都行。如果像上面的 s4 那样初始化要用到的值有多个，一般来说只能使用直接初始化的方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hiya"</span>;  <span class="comment">// 拷贝初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(<span class="string">"hiya"</span>)</span></span>;   <span class="comment">// 直接初始化</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(<span class="number">10</span>, <span class="string">'c'</span>)</span></span>;  <span class="comment">// 直接初始化，s7的内容是cccccccccc</span></span><br></pre></td></tr></table></figure>
<p>对于用多个值进行初始化的情况，也可以使用拷贝初始化的方式，不过需要显式地创建一个（临时）对象用于拷贝：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s8 = <span class="built_in">string</span>(<span class="number">10</span>, <span class="string">'c'</span>);  <span class="comment">// 拷贝初始化，s8的内容是cccccccccc</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>string</code> 对象可进行的大多数操作如下表所示：</p>
<table>
<tbody>
<tr>
    <td colspan="2"><b><center>string的操作</center></b></td>
</tr>
<tr>
    <td>os &lt;&lt; s</td>
    <td>将s写到输出流os当中，返回os</td>
</tr>
<tr>
    <td>is &gt;&gt; s</td>
    <td>从is中读取字符串赋给s，字符串以空白分隔，返回is</td>
</tr>
<tr>
    <td>getline(is, s)</td>
    <td>从is中读取一行赋给s，返回is</td>
</tr>
<tr>
    <td>s.empty()</td>
    <td>s为空返回true，否则返回false</td>
</tr>
<tr>
    <td>s.size()</td>
    <td>返回s中字符的个数</td>
</tr>
<tr>
    <td>s[n]</td>
    <td>返回s中第n个字符的引用，位置n从0计起</td>
</tr>
<tr>
    <td>s1 + s2</td>
    <td>返回s1和s2连接后的结果</td>
</tr>
<tr>
    <td>s1 = s2</td>
    <td>用s2的副本代替s1中原来的字符</td>
</tr>
<tr>
    <td>s1 == s2</td>
    <td rowspan="2">如果s1和s2中所含的字符完全一样，则它们相等；string对象的相等性判断对字母的大小写敏感</td>
</tr>
<tr>
    <td>s1 != s2</td>
</tr>
<tr>
    <td>&lt;, &lt;=, &gt;, &gt;=</td>
    <td>利用字符在字典中的顺序进行比较，且对字母的大小写敏感</td>
</tr>
</tbody>
</table>
</li>
<li><p>观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;           <span class="comment">// 空字符串</span></span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;           <span class="comment">// 将string对象读入s，遇到空白为止</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 输出s</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> s1, s2;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;    <span class="comment">// 把第一个读入到s1中，第二个读入到s2中</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s1 &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在执行读取操作时，<code>string</code> 对象会自动忽略开头的空白（即空格符、换行符、制表符等）并从第一个真正的字符开始读起，直到遇见下一处空白为止。将上述代码编译为可执行程序，在终端中运行可执行程序，输入 <code>Hello World!</code> 后回车，将打印此时 s 的值 <code>Hello</code>，可知输入的空白被忽略了；再输入 <code>ha ya</code> 后回车，将打印 <code>World!ha</code>，这是因为第一次的输入中的 <code>World!</code> 还在键盘缓冲区，在执行</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; s1 &gt;&gt; s2;</span><br></pre></td></tr></table></figure>
<p>时，键盘缓冲区中的内容被读到了 s1，然后第二次输入中的 <code>ha</code> 被读到了 s2，<code>ya</code> 又被暂存在了键盘缓冲区。</p>
</li>
<li><p>观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> word;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; word &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>while</code> 的循环条件负责在读取时检测流的情况，如果流有效，也就是说没遇到文件结束标记或非法输入，那么执行 <code>while</code> 语句内部的操作。此时，循环体将输出刚刚从标准输入读取的内容。重复若干次之后，一旦遇到文件结束标记或非法输入循环也就结束了。<code>cin</code> 读取的内容会被暂存在键盘缓冲区。</p>
</li>
<li><p><code>getline</code> 函数的参数是一个输入流和一个 <code>string</code> 对象，函数从给定的输入流中读入内容，直到遇到换行符为止（注意换行符也被读进来了），然后把所读的内容存入到那个 <code>string</code> 对象中去（注意不存换行符）。<code>getline</code> 只要一遇到换行符就结束读取操作并返回结果，哪怕输入的一开始就是换行符也是如此。如果输入真的一开始就是换行符，那么所得的结果是个空 <code>string</code>。和输入运算符一样，<strong><code>getline</code> 也会返回它的流参数</strong>。因此既然输入运算符能作为判断的条件，也能用 <code>getline</code> 的结果作为条件。观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> line;</span><br><span class="line">    <span class="keyword">while</span> (getline(<span class="built_in">cin</span>, line))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; line &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>触发 <code>getline</code> 函数返回的那个换行符实际上被丢弃掉了，得到的 <code>string</code> 对象中并不包含该换行符。输入完一行的内容后回车，<code>getline</code> 本次读取结束，执行 <code>while</code> 主体中的语句，再开始执行下一次的 <code>getline</code> 读取操作，直至输入 <code>Ctrl + z</code>（Windows 系统下）或 <code>Ctrl + d</code>（类 Unix 系统下）并回车才退出循环。</p>
</li>
<li><p><code>string</code> 类中的 <code>empty</code> 函数根据 <code>string</code> 对象是否为空返回一个对应的布尔值。</p>
</li>
<li><p><code>string</code> 类中的 <code>size</code> 函数返回 <code>string</code> 对象的长度（即 <code>string</code> 对象中字符的个数）。<code>size</code> 函数返回的是一个 <code>string::size_type</code> 类型的值。所有用于存放 <code>string</code> 类的 <code>size</code> 函数返回值的变量，都应该是 <code>string::size_type</code> 类型的。在 C++11 新标准中，允许编译器通过 <code>auto</code> 或者 <code>decltype</code> 来推断变量的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> len = line.size();  <span class="comment">// len 的类型是 string::size_type</span></span><br></pre></td></tr></table></figure>
<p>由于 <code>size</code> 函数返回的是一个无符号整型数，因此切记，<strong>如果在表达式中混用了带符号数和无符号数将可能产生意想不到的结果</strong>。例如，假设 n 是一个具有负值的 <code>int</code>，则表达式 <code>s.size() &lt; n</code> 的判断结果几乎肯定是 <code>true</code>。这是因为负值 n 会自动地转换成一个比较大的无符号值。<strong>如果一条表达式中已经有了 <code>size()</code> 函数就不要再使用 <code>int</code> 了，这样可以避免混用 <code>int</code> 和 <code>unsigned</code> 可能带来的问题。</strong></p>
</li>
<li><p><code>string</code> 类定义了几种用于比较字符串的运算符。这些比较运算符逐一比较 <code>string</code> 对象中的字符，并且对大小写敏感，也就是说，<strong>在比较时同一个字母的大写形式和小写形式是不同的。</strong>相等性运算符（<code>==</code> 和 <code>!=</code>）分别检验两个 <code>string</code> 对象相等或不相等，<strong><code>string</code> 对象相等意味着它们的长度相同而且所包含的字符也全都相同</strong>。关系运算符 <code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code> 分别检验一个 <code>string</code> 对象是否小于、小于等于、大于、大于等于另外一个 <code>string</code> 对象。上述这些运算符都依照（大小写敏感的）字典顺序：</p>
<ul>
<li>规则一：如果两个 <code>string</code> 对象的长度不同，而且较短 <code>string</code> 对象的每个字符都与较长 <code>string</code> 对象对应位置上的字符相同，就说较短 <code>string</code> 对象小于较长 <code>string</code> 对象；</li>
<li>规则二：如果两个 <code>string</code> 对象在某些对应的位置上不一致，则 <code>string</code> 对象比较的结果其实是 <code>string</code> 对象中第一对相异字符比较的结果。<br><br></li>
</ul>
<p>下面是 <code>string</code> 对象比较的一个示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">string</span> phrase = <span class="string">"Hello World"</span>;</span><br><span class="line"><span class="built_in">string</span> slang = <span class="string">"Hiya"</span>;</span><br></pre></td></tr></table></figure>
<p>根据规则一可判断，对象 str 小于对象 phrase；根据规则二可判断，对象 slang 既大于 str 也大于 phrase。</p>
</li>
<li><p>对于 <code>string</code> 类而言，允许把一个对象的值赋给另外一个对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string st1(10,'c'), st2;</span><br><span class="line">st1 = st2;</span><br></pre></td></tr></table></figure>
</li>
<li><p>两个 <code>string</code> 对象相加得到一个新的 <code>string</code> 对象，其内容是把左侧的运算对象与右侧的运算对象串接而成。<strong>复合赋值运算符（<code>+=</code>）负责把右侧 <code>string</code> 对象的内容追加到左侧 <code>string</code> 对象的后面</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello, "</span>, s2 = <span class="string">"world\n"</span>;</span><br><span class="line"><span class="built_in">string</span> s3 = s1 + s2;  <span class="comment">// s3的内容是hello，world\n</span></span><br><span class="line">s1 += s2;             <span class="comment">// 等价于s1 = s1 + s2</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>标准库允许把字符字面值和字符串字面值转换成 <code>string</code> 对象，所以在需要 <code>string</code> 对象的地方就可以使用这两种字面值来替代：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1 = <span class="string">"hello"</span>, s2 = <span class="string">"world"</span>;  <span class="comment">// 在s1和s2中都没有标点符号</span></span><br><span class="line"><span class="built_in">string</span> s3 = s1 + <span class="string">", "</span> + s2 + <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<p><strong>当把 <code>string</code> 对象和字符字面值及字符串字面值混在一条语句中使用时，必须确保每个加法运算符（+）的两侧的运算对象至少有一个是 <code>string</code></strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s4 = s1 + <span class="string">", "</span>;       <span class="comment">// 正确：把一个string对象和一个字面值相加</span></span><br><span class="line"><span class="built_in">string</span> s5 = <span class="string">"hello"</span> + <span class="string">", "</span>;  <span class="comment">// 错误：两个运算对象都不是string</span></span><br><span class="line"><span class="comment">//正确：每个加法运算符都有一个运算对象是string</span></span><br><span class="line"><span class="built_in">string</span> s6 = s1 + <span class="string">", "</span> + <span class="string">"world"</span>;</span><br><span class="line"><span class="built_in">string</span> s7 = <span class="string">"hello"</span> + <span class="string">", "</span> + s2;  <span class="comment">//错误：不能把字面值直接相加</span></span><br></pre></td></tr></table></figure>
<p>s6 的初始化形式的工作机理和连续输入连续输出是一样的，可以用如下的形式分组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s6 = (s1 + <span class="string">", "</span>) + <span class="string">"world"</span>;</span><br></pre></td></tr></table></figure>
<p>其中子表达式 <code>s1 + &quot;, ”</code> 的结果是一个 <code>string</code> 对象，它同时作为第二个加法运算符的左侧运算对象，因此上述语句和下面的两个语句是等价的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> tmp = s1 + <span class="string">", "</span>;  <span class="comment">// 正确：加法运算符有一个运算对象是string</span></span><br><span class="line">s6 = tmp + <span class="string">"world"</span>;      <span class="comment">// 正确：加法运算符有一个运算对象是string</span></span><br></pre></td></tr></table></figure>
<p>另一方面，s7 的初始化是非法的，根据其语义加上括号后就成了下面的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s7 = (<span class="string">"hello"</span> + <span class="string">", "</span>) + s2;  <span class="comment">// 错误：不能把字面值直接相加</span></span><br></pre></td></tr></table></figure>
<p>很容易看到，括号内的子表达式试图把两个字符串字面值加在一起，而编译器根本没法做到这一点，所以这条语句是错误的。</p>
</li>
<li><p><strong>C++ 语言中的字符串字面值并不是标准库类型 <code>string</code> 的对象。切记，字符串字面值与 <code>string</code> 是不同的类型。</strong></p>
</li>
<li><p>在 <code>cctype</code> 头文件中定义了一组标准库函数用于单独处理 <code>string</code> 对象中的字符，其中主要的函数名及其含义如下表所示：</p>
<table>
<tbody>
<tr>
    <td colspan="2"><b><center>cctype头文件中的函数</center></b></td>
</tr>
<tr>
    <td>isalnum(c)</td>
    <td>当c是字母或数字时为真</td>
</tr>
<tr>
    <td>isalpha(c)</td>
    <td>当c是字母时为真</td>
</tr>
<tr>
    <td>iscntrl(c)</td>
    <td>当c是控制字符时为真</td>
</tr>
<tr>
    <td>isdigit(c)</td>
    <td>当c是数字时为真</td>
</tr>
<tr>
    <td>isgraph(c)</td>
    <td>当c不是空格但可打印时为真</td>
</tr>
<tr>
    <td>islower(c)</td>
    <td>当c是小写字母时为真</td>
</tr>
<tr>
    <td>isprint(c)</td>
    <td>当c是可打印字符时为真（即c是空格或c具有可视形式）</td>
</tr>
<tr>
    <td>ispunct(c)</td>
    <td>当c是标点符号时为真（即c不是控制字符、数字、字母、可打印空白中的一种）</td>
</tr>
<tr>
    <td>isspace(c)</td>
    <td>当c是空白时为真（即c是空格、横向制表符、纵向制表符、回车符、换行符、进纸符中的一种）</td>
</tr>
<tr>
    <td>isupper(c)</td>
    <td>当c是大写字母时为真</td>
</tr>
<tr>
    <td>isxdigit(c)</td>
    <td>当c是十六进制数字时为真</td>
</tr>
<tr>
    <td>tolower(c)</td>
    <td>如果c是大写字母，输出对应的小写字母；否则原样输出c</td>
</tr>
<tr>
    <td>toupper(c)</td>
    <td>如果c是小写字母，输出对应的大写字母；否则原样输出c</td>
</tr>
</tbody>
</table>
</li>
<li><p><strong>建议：使用 C++ 版本的 C 标准库头文件。</strong>C++ 标准库中除了定义 C++ 语言特有的功能外，也兼容了 C 语言的标准库。C 语言的头文件形如 <code>name.h</code>，C++ 则将这些文件命名为 <code>cname</code>。也就是去掉了 <code>.h</code> 后缀，而在文件名 name 之前添加了字母 <code>c</code>，这里的 <code>c</code> 表示这是一个属于 C 语言标准库的头文件。因此，cctype 头文件和 ctype.h 头文件的内容是一样的，只不过从命名规范上来讲更符合 C++ 语言的要求。<strong>特别的，在名为 <code>cname</code> 的头文件中定义的名字从属于命名空间 <code>std</code>，而定义在名为 <code>.h</code> 的头文件中的则不然。</strong> 一般来说，C++ 程序应该使用名为<code>cname</code> 的头文件而不使用 <code>name.h</code> 的形式，标准库中的名字总能在命名空间 <code>std</code> 中找到。</p>
</li>
<li><p>如果想对 <code>string</code> 对象中的每个字符做点儿什么操作，使用 C++11 新标准提供的一种语句：<code>范围 for</code>（range for）语句。这种语句遍历给定序列中的每个元素并对序列中的每个值执行某种操作，其语法形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (declaration : expression)</span><br><span class="line">    statement</span><br></pre></td></tr></table></figure>
<p>其中，expression 部分是一个对象，用于表示一个序列。declaration 部分负责定义一个变量，该变量将被用于访问序列中的基础元素。每次迭代，_declaration_ 部分的变量会被初始化为 expression 部分的下一个元素值。一个 <strong>string</strong> 对象表示一个字符的序列，因此 <code>string</code> 对象可以作为<code>范围 for</code> 语句中的 expression 部分。</p>
</li>
<li><p>下面的代码片段通过使用<code>范围 for</code> 语句把 <code>string</code> 对象中的字符每行一个输出出来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; c &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>通过使用 <code>auto</code> 关键字让编译器来决定变量 <code>c</code> 的类型，这里 <code>c</code> 的类型是 <code>char</code>。每次迭代，<code>str</code> 的下一个字符被拷贝给 <code>c</code>，因此该循环可以读作“对于字符串 <code>str</code> 中的每个字符 <code>c</code>，”执行某某操作。</p>
</li>
<li><p>下面的代码片段使用<code>范围 for</code> 语句和 <code>ispunct</code> 函数来统计 <code>string</code> 对象中标点符号的个数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello World!!!"</span>)</span></span>;</span><br><span class="line"><span class="keyword">decltype</span> punct_cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">ispunct</span>(c))</span><br><span class="line">        ++punct_cnt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; punct_cnt</span><br><span class="line">     &lt;&lt; <span class="string">" punctuation characters in "</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用<code>范围 for</code> 语句改变字符串中的字符。</strong>如果想要改变 <code>string</code> 对象中字符的值，必须把循环变量定义成引用类型。记住，所谓引用只是给定对象的一个别名，因此当使用引用作为循环控制变量时，这个变量实际上被依次绑定到了序列的每个元素上。使用这个引用，我们就能改变它绑定的字符。标准库函数 <code>toupper</code> 接收一个字符，然后输出其对应的大写形式。这样，为了把整个 <code>string</code> 对象转换成大写，只要对其中的每个字符调用 <code>toupper</code> 函数并将结果再赋给原字符就可以了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello World!!!"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 转换成大写形式。</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : s)  <span class="comment">// 对于s中的每个字符（注意：c是引用</span></span><br><span class="line">    c = <span class="built_in">toupper</span>(c);    <span class="comment">// c是一个引用，因此赋值语句将改变s中字符的值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>每次迭代时，变量 c 引用<code>string</code>对象 s 的下一个字符，赋值给 c 也就是在改变 s 中对应字符的值。因此当执行下面的语句时，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">c = <span class="built_in">toupper</span>(c);   <span class="comment">// c是一个引用，因此赋值语句将改变s中字符的值</span></span><br></pre></td></tr></table></figure>
<p>实际上改变了 c 绑定的字符的值。整个循环结束后，str 中的所有字符都变成了大写形式。</p>
</li>
<li><p>要想访问 <code>string</code> 对象中的单个字符有两种方式：一种是使用下标，另外一种是使用迭代器。下标运算符（<code>[ ]</code>）接收的输入参数是 <code>string::size type</code> 类型的值，这个参数表示要访问的字符的位置；返回值是该位置上字符的引用。<code>string</code> 对象的下标从 0 计起，<code>s[s.size()-1]</code> 是最后一个字符。<code>string</code> 对象的下标必须大于等于 0 而小于 <code>s.size()</code>。使用超出此范围的下标将引发不可预知的结果，以此推断，使用下标访问空 <code>string</code> 也会引发不可预知的结果。下标的值称作“下标”或“索引”，任何表达式只要它的值是一个整型值就能作为索引。不过，如果某个索引是带符号类型的值将自动转换成 <code>string::size_type</code> 表达的无符号类型。在访问指定字符之前，首先检查 s 是否为空。其实不管什么时候只要对 <code>string</code> 对象使用了下标，都要确认在那个位置上确实有值。如果 s 为空，则 <code>s[0]</code> 的结果将是未定义的。只要字符串不是常量，就能为下标运算符返回的字符赋新值。下面的程序将字符串的首字符改成了大写形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strings(<span class="string">"some string"</span>);</span><br><span class="line"><span class="keyword">if</span> (!s.empty())            <span class="comment">// 确保s[0]的位置确实有字符</span></span><br><span class="line">    s[<span class="number">0</span>] = <span class="built_in">toupper</span>(s[<span class="number">0</span>]);  <span class="comment">// 为s的第一个字符赋一个新值</span></span><br></pre></td></tr></table></figure>
<p>下面的程序把 s 的第一个词改成大写形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依次处理s中的字符直至处理完全部字符或者遇到一个空白</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(s.size()) index = <span class="number">0</span>;</span><br><span class="line">    index != s.size() &amp;&amp; !<span class="built_in">isspace</span>(s[index]);</span><br><span class="line">    ++index)</span><br><span class="line">    s[index] = <span class="built_in">toupper</span>(s[index]); <span class="comment">// 将当前字符改成大写形式</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++ 语言规定<strong>只有当左侧运算对象为真时才会检查右侧运算对象的情况</strong>（C 语言中有着相同规定），这条规定确保了只有当下标取值在合理范围之内时才会真的用此下标去访问字符串。C++ 标准并不要求标准库检测下标是否合法，一旦使用了一个超出范围的下标，就会产生不可预知的结果。</p>
</li>
<li><p>标准库类型 <code>vector</code> 表示对象的集合，其中所有对象的类型都相同。集合中的每个对象都有一个与之对应的索引，索引用于访问对象。<code>vector</code> 常被称作<strong>容器</strong>（container）。要想使用 <code>vector</code>，必须包含适当的头文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++ 语言既有<strong>类模板</strong>（class template），也有函数模板，其中 <code>vector</code> 是一个类模板。模板本身不是类或函数，相反可以将模板看作为编译器生成类或函数编写的一份说明。编译器根据模板创建类或函数的过程称为<strong>实例化</strong>（instantiation），当使用模板时，需要指出编译器应把类或函数实例化成何种类型。对于类模板来说，通过提供一些额外信息来指定模板到底实例化成什么样的类，需要提供哪些信息由模板决定。提供信息的方式总是这样：即在模板名字后面跟一对尖括号，在括号内放上信息。以 <code>vector</code> 为例，提供的额外信息是 <code>vector</code> 内所存放对象的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;              <span class="comment">// ivec保存int类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Sales_item&gt; Sales vec;  <span class="comment">// 保存Sales_item类型的对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; file;   <span class="comment">// 该向量的元素是vector对象</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vector</code> 是模板而非类型，由 <code>vector</code> 生成的类型必须包含 <code>vector</code> 中元素的类型，例如 <code>vector&lt;int&gt;</code>。</p>
</li>
<li><p><code>vector</code> 能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以<strong>不存在包含引用的<code>vector</code></strong>。除此之外，其他大多数（非引用）内置类型和类类型都可以构成 <code>vector</code> 对象，甚至组成 <code>vector</code> 的元素也可以是 <code>vector</code>。</p>
</li>
<li><p>在早期版本的 C++ 标准中，如果 <code>vector</code> 的元素还是 <code>vector</code>（或者其他模板类型），则其定义的形式与现在的 C++11 新标准略有不同。过去，必须在外层 <code>vector</code> 对象的右尖括号和其元素类型之间添加一个空格，如应该写成 <code>vector&lt;vector&lt;int&gt; &gt;</code> 而非 <code>vector&lt;vector&lt;int&gt;&gt;</code>。</p>
</li>
<li><p>定义 <code>vector</code> 对象的常用方法如下表所示：</p>
<table>
<tbody>
<tr>
    <td colspan="2"><b><center>初始化vector对象的方法</center></b></td>
</tr>
<tr>
    <td>vector&lt;T&gt; v1</td>
    <td>v1是一个空vector，它潜在的元素是T类型的，执行默认初始化</td>
</tr>
<tr>
    <td>vector&lt;T&gt; v2(v1)</td>
    <td>v2中包含有v1所有元素的副本</td>
</tr>
<tr>
    <td>vector&lt;T&gt; v2 = v1</td>
    <td>等价于v2(v1)，v2中包含有v1所有元素的副本</td>
</tr>
<tr>
    <td>vector&lt;T&gt; v3(n, val)</td>
    <td>v3包含了n个重复的元素，每个元素的值都是val</td>
</tr>
<tr>
    <td>vector&lt;T&gt; v4(n)</td>
    <td>v4包含了n个重复地执行了值初始化的对象</td>
</tr>
<tr>
    <td>vector&lt;T&gt; v5{a, b, c ...}</td>
    <td>v5包含了初始值个数的元素，每个元素被赋予相应的初始值</td>
</tr>
<tr>
    <td>vector&lt;T&gt; v5 = {a, b, c ...}</td>
    <td>等价于v5{a, b, c...}</td>
</tr>
</tbody>
</table>
</li>
<li><p>可以默认初始化 <code>vector对象</code>，从而创建一个指定类型的空 <code>vector</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec;  <span class="comment">// 默认初始化，svec不含任何元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>允许把一个 <code>vector</code> 对象的元素拷贝给另外一个 <code>vector</code> 对象。此时，新 <code>vector</code> 对象的元素就是原 <code>vector</code> 对象对应元素的副本。注意两个 <code>vector</code> 对象的类型必须相同：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;  <span class="comment">// 初始状态为空</span></span><br><span class="line"><span class="comment">// 在此处给ivec添加一些值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec2</span><span class="params">(ivec)</span></span>;     <span class="comment">// 把ivec的元素拷贝给ivec2</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec3 = ivec;    <span class="comment">// 把ivec的元素拷贝给ivec3</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec</span><span class="params">(ivec2)</span></span>;  <span class="comment">// 错误：svec的元素是string对象，不是int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>C++11 新标准还提供了另外一种为 <code>vector</code> 对象的元素赋初值的方法，即列表初始化。此时，用花括号括起来的 0 个或多个初始元素值被赋给 <code>vector</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; articles = &#123;<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 C++ 中几种不同的初始化方式时的三点要求：</p>
<ul>
<li>其一，使用拷贝初始化时（即使用=时），只能提供一个初始值；</li>
<li>其二，如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化；</li>
<li>其三，如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能放在圆括号里。<br><br></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v1&#123;<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>&#125;;  <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v2</span><span class="params">(<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>)</span></span>;  <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>还可以用 <code>vector</code> 对象容纳的元素数量和所有元素的统一初始值来初始化 <code>vector</code> 对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>, <span class="number">-1</span>)</span></span>;        <span class="comment">// 10个int类型的元素，每个都被初始化为-1</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>, <span class="string">"hi!"</span>)</span></span>;  <span class="comment">// 10个string类型的元素，每个都被初始化为"hi!"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通常情况下，可以只提供 <code>vector</code> 对象容纳的元素数量而略去初始值。此时库会创建一个<strong>值初始化的</strong>（value-initialized）元素初值，并把它赋给容器中的所有元素。这个初值由 <code>vector</code> 对象中元素的类型决定。如果 <code>vector</code> 对象的元素是内置类型，比如 <code>int</code>，则元素初始值自动设为 0。如果元素是某种类类型，比如 <code>string</code>，则元素由类默认初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// 10个元素，每个都初始化为0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 10个元素，每个都是空string对象</span></span><br></pre></td></tr></table></figure>
<p>对这种初始化的方式有两个特殊限制：、</p>
<ul>
<li>其一，有些类要求必须明确地提供初始值，如果 <code>vector</code> 对象中元素的类型不支持默认初始化，就必须提供初始的元素值。对这种类型的对象来说，只提供元素的数量而不设定初始值无法完成初始化工作；</li>
<li>其二，如果只提供了元素的数量而没有设定初始值，只能使用直接初始化：<br><br></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = <span class="number">10</span>;  <span class="comment">// 错误：必须使用直接初始化的形式指定向量大小</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在某些情况下，初始化的真实含义依赖于传递初始值时用的是花括号还是圆括号。</strong> 观察如下代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;     <span class="comment">// v1有10个元素，每个的值都是0</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2&#123;<span class="number">10</span>&#125;;     <span class="comment">// v2有1个元素，该元素的值是10</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;  <span class="comment">// v3有10个元素，每个的值都是1</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>，<span class="number">1</span>&#125;;  <span class="comment">// v4有2个元素，值分别是10和1</span></span><br></pre></td></tr></table></figure>
<p>如果用的是花括号，可以表述成我们想列表初始化（list initialize）该 <code>vector</code> 对象。也就是说，初始化过程会尽可能地把花括号内的值当成是元素初始值的列表来处理，只有在无法执行列表初始化时才会考虑其他初始化方式。另一方面，<strong>如果初始化时使用了花括号的形式但是提供的值又不能用来列表初始化，就要考虑用这样的值来构造 <code>vector</code> 对象了</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v5&#123;<span class="string">"hi"</span>&#125;;      <span class="comment">// 列表初始化：v5有一个元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">v6</span><span class="params">(<span class="string">"hi"</span>)</span></span>;      <span class="comment">// 错误：不能使用字符串字面值构建vector对象</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>&#125;;        <span class="comment">// v7有10个默认初始化的元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v8&#123;<span class="number">10</span>, <span class="string">"hi"</span>&#125;;  <span class="comment">// v8有10个值为“hi”的元素</span></span><br></pre></td></tr></table></figure>
<p>尽管在上面的例子中除了第二条语句之外都用了花括号，但其实只有 v5 是列表初始化。<strong>要想列表初始化 <code>vector</code> 对象，花括号里的值必须与元素类型相同。</strong>显然不能用 <code>int</code> 初始化 <code>string</code> 对象，所以 v7 和 v8 提供的值不能作为元素的初始值。<strong>确认无法执行列表初始化后，编译器会尝试用默认值初始化 <code>vector</code> 对象。</strong></p>
</li>
<li><p>下列的 <code>vector</code> 对象各包含多少个元素？这些元素的值分别是多少？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;               <span class="comment">// （a）：0个元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;           <span class="comment">// （b）：10个0</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>;       <span class="comment">// （c）：10个42</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;<span class="number">10</span>&#125;;           <span class="comment">// （d）：1个10</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v5&#123;<span class="number">10</span>, <span class="number">42</span>&#125;;       <span class="comment">// （e）：2个，10和42</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v6&#123;<span class="number">10</span>&#125;;        <span class="comment">// （f）：10个空字符串</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v7&#123;<span class="number">10</span>, <span class="string">"hi"</span>&#125;;  <span class="comment">// （g）：10个"hi"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vector</code> 的成员函数 <code>push_back</code> 向其中添加元素。<code>push_back</code> 负责把一个值当成 <code>vector</code> 对象的尾元素“压到（push）”<code>vector</code> 对象的“尾端（back）”。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;  <span class="comment">// 空vector对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i != <span class="number">100</span>; ++i)</span><br><span class="line">    v2.push_back(i);  <span class="comment">// 依次把整数值放到v2尾端</span></span><br><span class="line"><span class="comment">// 循环结束后v2有100个元素，值从0到99</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vector</code> 对象能高效地增长，那么<strong>在定义 <code>vector</code> 对象的时候设定其大小也就没什么必要了，事实上如果这么做性能可能更差</strong>。只有一种例外情况，就是所有（all）元素的值都一样。一旦元素的值有所不同，更有效的办法是先定义一个空的 <code>vector</code> 对象，再在运行时向其中添加具体值。</p>
</li>
<li><p><strong>如果循环体内部包含有向 <code>vector</code> 对象添加元素的语句，则不能使用范围 <code>for</code> 循环，范围 <code>for</code> 语句体内不应改变其所遍历序列的大小。</strong></p>
</li>
<li><p>比较重要的一些 <code>vector</code> 支持的操作如下表所示：</p>
<table>
<tbody>
<tr>
    <td colspan="2"><b><center>vector支持的操作</center></b></td>
</tr>
<tr>
    <td>v.empty()</td>
    <td>如果v不含有任何元素，返回真；否则返回假</td>
</tr>
<tr>
    <td>v.size()</td>
    <td>返回v中元素的个数</td>
</tr>
<tr>
    <td>v.push_back(t)</td>
    <td>向v的尾端添加一个值为t的元素</td>
</tr>
<tr>
    <td>v[n]</td>
    <td>返回v中第n个位置上元素的引用</td>
</tr>
<tr>
    <td>v1 = v2</td>
    <td>用v2中元素的拷贝替换v1中的元素</td>
</tr>
<tr>
    <td>v1 = {a, b, c ..}</td>
    <td>用列表中元素的拷贝替换v1中的元素</td>
</tr>
<tr>
    <td>v1 == v2</td>
    <td rowspan="2">v1和v2相等当且仅当它们的元素数量相同且对应位置的元素值都相同</td>
</tr>
<tr>
    <td>v1 != v2</td>
</tr>
<tr>
    <td>&lt;, &lt;=, &gt;, &gt;=</td>
    <td>以字典顺序进行比较</td>
</tr>
</tbody>
</table>
</li>
<li><p>可以使用范围 <code>for</code> 语句处理 <code>vector</code> 对象中的所有元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v)      <span class="comment">// 对于v中的每个元素（注意：i是一个引用）</span></span><br><span class="line">    i *= i;            <span class="comment">// 求元素值的平方</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : v)       <span class="comment">// 对于v中的每个元素</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;  <span class="comment">// 输出该元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vector</code> 的 <code>size</code> 函数返回 <code>vector</code> 对象中元素的个数，返回值的类型是由 <code>vector</code> 定义的 <code>size_type</code> 类型。要使用 <code>size_type</code>，需首先指定它是由哪种类型定义的。<code>vector</code> 对象的类型总是包含着元素的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type  <span class="comment">// 正确</span></span><br><span class="line"><span class="built_in">vector</span>::size_type       <span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>两个 <code>vector</code> 对象相等当且仅当它们所含的元素个数相同，而且对应位置的元素值也相同。关系运算符依照字典顺序进行比较：如果两个 <code>vector</code> 对象的容量不同，但是在相同位置上的元素值都一样，则元素较少的 <code>vector</code> 对象小于元素较多的 <code>vector</code> 对象；若元素的值有区别，则 <code>vector</code> 对象的大小关系由第一对相异的元素值的大小关系决定。</p>
</li>
<li><p>只要 <code>vector</code> 对象不是一个常量，就能向下标运算符返回的元素赋值。</p>
</li>
<li><p><strong>两个整数相除，结果还是整数，余数部分被自动忽略掉了。</strong>下面的程序以 10 分为一个分数段统计成绩的数量：0~9，10~19…，90~99，100：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">unsigned</span>&gt; <span class="title">scores</span><span class="params">(<span class="number">11</span>, <span class="number">0</span>)</span></span>;  <span class="comment">// 11个分数段，全都初始化为0</span></span><br><span class="line"><span class="keyword">unsigned</span> grade;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; grade)         <span class="comment">// 读取成绩</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (grade &lt;= <span class="number">100</span>)        <span class="comment">// 只处理有效的成绩</span></span><br><span class="line">        ++scores[grade/<span class="number">10</span>];  <span class="comment">// 将对应分数段的计数值加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>下面的代码试图为 <code>vector</code> 对象 ivec 添加 10 个元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;  <span class="comment">// 空vector对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">decltype</span>(ivec.size()) ix = <span class="number">0</span>; ix != <span class="number">10</span>; ++ix)</span><br><span class="line">    ivec[ix] = ix;  <span class="comment">// 严重错误：ivec不包含任何元素</span></span><br></pre></td></tr></table></figure>
<p>然而，这段代码是错误的：ivec 是一个空 <code>vector</code>，根本不包含任何元素，当然也就不能通过下标去访问任何元素！如前所述，正确的方法是使用 <code>push_back</code>。<code>vector</code> 对象（以及 <code>string</code> 对象）的下标运算符可用于访问已存在的元素，而不能用于添加元素。</p>
</li>
<li><p><strong>试图用下标的形式去访问一个不存在的元素将引发错误，不过这种错误不会被编译器发现，而是在运行时产生一个不可预知的值。</strong>不幸的是，这种通过下标访问不存在的元素的行为非常常见，而且会产生很严重的后果。所谓的缓冲区溢出（buffer overflow）指的就是这类错误，这也是导致 PC 及其他设备上应用程序出现安全问题的一个重要原因。<strong>确保下标合法的一种有效手段就是尽可能使用范围 <code>for</code> 语句。</strong></p>
</li>
<li><p>可以使用下标运算符来访问 <code>string</code> 对象的字符或 <code>vector</code> 对象的元素，使用<strong>迭代器</strong>（iterator）也可以做到这一点。所有标准库容器都可以使用迭代器，但是其中只有少数几种才同时支持下标运算符。</p>
</li>
<li><p>迭代器也提供了对对象的间接访问。就迭代器而言，其对象是容器中的元素或者 string 对象中的字符。使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。迭代器有有效和无效之分，这一点和指针差不多。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一位置；其他所有情况都属于无效。</p>
</li>
<li><p>获取迭代器不是使用取地址符，有迭代器的类型同时拥有返回迭代器的成员。比如，这些类型都拥有名为 <strong><code>begin</code></strong> 和 <strong><code>end</code></strong> 的成员，其中 <code>begin</code> 成员负责返回指向第一个元素（或第一个字符）的迭代器。<code>end</code> 成员则负责返回指向容器（或 string 对象）“尾元素的下一位置（one past the end）”的迭代器，也就是说，该迭代器指示的是容器的一个本不存在的“<strong>尾后</strong>（off the end）”元素。<code>end</code> 成员返回的迭代器常被称作<strong>尾后迭代器</strong>（off-the-end iterator）或者简称为尾迭代器（end iterator）。特殊情况下如果容器为空，则 <code>begin</code> 和 <code>end</code> 返回的是同一个迭代器——尾迭代器。</p>
</li>
<li><p>下表列举了迭代器支持的一些运算。使用 <code>==</code> 和 <code>!=</code> 来比较两个合法的迭代器是否相等，如果两个迭代器指向的元素相同或者都是同一个容器的尾后迭代器，则它们相等：否则就说这两个迭代器不相等。</p>
<table>
<tbody>
<tr>
    <td colspan="2"><b><center>标准容器迭代器的运算符</center></b></td>
</tr>
<tr>
    <td>*iter</td>
    <td>返回迭代器iter所指元素的引用</td>
</tr>
<tr>
    <td>iter-&gt;mem</td>
    <td>解引用iter并获取该元素的名为mem的成员，等价于(*iter).mem</td>
</tr>
<tr>
    <td>++iter</td>
    <td>令iter指示容器中的下一个元素</td>
</tr>
<tr>
    <td>--iter</td>
    <td>令iter指示容器中的上一个元素</td>
</tr>
<tr>
    <td>iter1 == iter2</td>
    <td rowspan="2">判断两个迭代器是否相等（不相等），如果两个迭代器指示的是同一个元素或者它们是同一个容器的尾后迭代器，则相等；反之，不相等</td>
</tr>
<tr>
    <td>iter1 != iter2</td>
</tr>
</tbody>
</table>

<p>和指针类似，也能通过解引用迭代器来获取它所指示的元素，执行解引用的迭代器必须合法并确实指示着某个元素。试图解引用一个非法迭代器或者尾后迭代器都是未被定义的行为。</p>
</li>
<li><p>下面的程序将 <code>string</code> 对象的第一个字母改为了大写形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (s.begin() != s.end())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.begin();</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>迭代器使用递增（<code>++</code>）运算符来从一个元素移动到下一个元素。因为 <code>end</code> 返回的迭代器并不实际指示某个元素，所以不能对其进行递增或解引用的操作。</p>
</li>
<li><p>下面的程序将 <code>string</code> 对象的第一个单词改为了大写形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = s.begin(); it != s.end() &amp;&amp; !<span class="built_in">isspace</span>(*it); ++it)</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有 <code>string</code> 和 <code>vector</code> 等一些标准库类型有下标运算符，而并非全都如此。与之类似，所有标准库容器的迭代器都定义了 <code>==</code> 和 <code>!=</code>，但是它们中的太多数都没有定义 <code>&lt;</code> 运算符。因此，只要养成使用迭代器和 <code>!=</code> 的习惯，就不用太在意用的到底是哪种容器类型。</p>
</li>
<li><p>拥有迭代器的标准库类型使用 <code>iterator</code> 和 <code>const_iterator</code> 来表示迭代器的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;         <span class="comment">// it能读写vector&lt;int&gt;的元素</span></span><br><span class="line"><span class="built_in">string</span>::iterator it2;             <span class="comment">// it2能读写string对象中的元素</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it3;  <span class="comment">// it3只能读元素，不能写元素</span></span><br><span class="line"><span class="built_in">string</span>::const_iterator it4;       <span class="comment">// it4只能读字符，不能写字符</span></span><br></pre></td></tr></table></figure>
<p><code>const_iterator</code> 和指向常量的指针差不多，能读取但不能修改它所指的元素值。相反，<code>iterator</code> 的对象可读可写。如果 <code>vector</code> 对象或 <code>string</code> 对象是一个常量，只能使用 <code>const_iterator</code>；如果 <code>vector</code> 对象或 <code>string</code> 对象不是常量，那么既能使用 <code>iterator</code> 也能使用 <code>const_iterator</code>。</p>
</li>
<li><p>每个容器类定义了一个名为 <code>iterator</code> 的类型，该类型支持迭代器概念所规定的一套操作。</p>
</li>
<li><p><code>begin</code> 和 <code>end</code> 返回的具体类型由对象是否是常量决定，如果对象是常量，<code>begin</code> 和 <code>end</code> 返回 <code>const_iterator</code>；如果对象不是常量，返回 <code>iterator</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.begin();   <span class="comment">// it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.begin();  <span class="comment">// it2的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<p>如果对象只需读操作而无须写操作的话最好使用常量类型（比如 <code>const_iterator</code>）。为了便于专门得到 <code>const_iterator</code> 类型的返回值，C++11 新标准引入了两个新函数，分别是 <code>cbegin</code> 和 <code>cend</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.cbegin();  <span class="comment">// it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<p>类似于 <code>begin</code> 和 <code>end</code>，上述两个新函数也分别返回指示容器第一个元素或最后元素下一位置的迭代器。有所不同的是，不论 <code>vector</code> 对象（或 <code>string</code> 对象）本身是否是常量，返回值都是 <code>const_iterator</code>。</p>
</li>
<li><p><strong>箭头运算符</strong>把解引用和成员访问两个操作结合在一起，也就是说，<code>it-&gt;mem</code> 和 <code>(*it).mem</code> 表达的意思相同。</p>
</li>
<li><p>虽然 <code>vector</code> 对象可以动态地增长，但是也会有一些副作用。已知的一个限制是<strong>不能在范围 <code>for</code> 循环中向 <code>vector</code> 对象添加元素</strong>。另外一个限制是<strong>任何一种可能改变 <code>vector</code> 对象容量的操作，比如 <code>push_back</code>，都会使该 <code>vector</code> 对象的迭代器失效</strong>。谨记，<strong>但凡是使用了迭代器的循环体，都不要向选代器所属的容器添加元素</strong>。</p>
</li>
<li><p>假设用一个名为 text 的字符串向量存放文本文件中的数据，其中的元素或者是一句话或者是一个用于表示段落分隔的空字符串。下面的程序将 text 的第一段全都改成大写形式，然后进行输出：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">text</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">text[<span class="number">0</span>] = <span class="string">"The world is fantastic."</span>;</span><br><span class="line">text[<span class="number">1</span>] = <span class="string">"If you have a dream, struggle for it."</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = text.begin();</span><br><span class="line">     iter != text.end() &amp;&amp; !iter-&gt;empty();</span><br><span class="line">     iter++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : *iter)</span><br><span class="line">        c = <span class="built_in">toupper</span>(c);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译代码后，运行可执行程序，将输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">THE WORLD IS FANTASTIC.</span><br><span class="line">IF YOU HAVE A DREAM, STRUGGLE FOR IT.</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>vector</code> 和 <code>string</code> 迭代器支持的运算如下表所示：</p>
<table>
<tbody>
<tr>
    <td colspan="2"><b><center>vector和string迭代器支持的运算</center></b></td>
</tr>
<tr>
    <td>iter + n</td>
    <td>迭代器加上一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向前移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置</td>
</tr>
<tr>
    <td>iter - n</td>
    <td>迭代器减去一个整数值仍得一个迭代器，迭代器指示的新位置与原来相比向后移动了若干个元素。结果迭代器或者指示容器内的一个元素，或者指示容器尾元素的下一位置</td>
</tr>
<tr>
    <td>iter1 += n</td>
    <td>选代器加法的复合赋值语句，将iter1加n的结果赋给iter1</td>
</tr>
<tr>
    <td>iter1 -= n</td>
    <td>迭代器减法的复合赋值语句，将iter1减n的结果赋给iter1</td>
</tr>
<tr>
    <td>iter1 - iter2</td>
    <td>两个迭代器相减的结果是它们之间的距离，也就是说，将运算符右侧的迭代器向前移动差值个元素后将得到左侧的迭代器。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置</td>
</tr>
<tr>
    <td>&gt;、&gt;=、&lt;、&lt;=</td>
    <td>迭代器的关系运算符，如果某迭代器指向的容器位置在另一个迭代器所指位置之前，则说前者小于后者。参与运算的两个迭代器必须指向的是同一个容器中的元素或者尾元素的下一位置</td>
</tr>
</tbody>
</table>
</li>
<li><p>只要两个迭代器指向的是同一个容器中的元素或者尾元素的下一位置，就能将其相减，所得结果是两个迭代器的距离。所谓距离指的是右侧的迭代器向前移动多少位置就能追上左侧的迭代器，其类型是名为 <strong><code>difference_type</code></strong> 的带符号整型数。<code>string</code> 和 <code>vector</code> 都定义了 <code>difference_type</code>，因为这个距离可正可负，所以 <code>difference_type</code> 是带符号类型的。</p>
</li>
<li><p>使用迭代器运算的一个经典算法是二分搜索：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 下面的程序使用迭代器完成了二分搜索</span></span><br><span class="line"><span class="comment">// beg和end表示我们要搜索的范围</span></span><br><span class="line"><span class="keyword">auto</span> beg = text.begin(), end = text.end();</span><br><span class="line"><span class="keyword">auto</span> mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">while</span> (mid != end &amp;&amp; *mid != sought)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*mid &lt; sought)</span><br><span class="line">        end = mid;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        beg = mid + <span class="number">1</span>;</span><br><span class="line">    mid = beg + (end - beg) / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>循环过程终止时，mid 或者等于 end 或者指向要找的元素。如果 mid 等于 end，说明 text 中没有我们要找的元素。</p>
</li>
<li><p>数组与 <code>vector</code> 相似的地方是，数组也是存放类型相同的对象的容器，这些对象本身没有名字，需要通过其所在位置访问。与 <code>vector</code> 不同的地方是，数组的大小确定不变，不能随意向数组中增加元素。因为数组的太小固定，因此对某些特殊的应用来说程序的运行时性能较好，但是相应地也损失了一些灵活性。<strong>如果不清楚元素的确切个数，请使用 <code>vector</code>。</strong></p>
</li>
<li><p>数组中元素的个数也属于数组类型的一部分，编译的时候维度应该是已知的。也就是说，<strong>维度必须是一个常量表达式</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> cnt = <span class="number">42</span>;           <span class="comment">// 不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">unsigned</span> sz = <span class="number">42</span>;  <span class="comment">// 常量表达式</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];                 <span class="comment">// 含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> *parr[sz];               <span class="comment">// 含有42个整型指针的数组</span></span><br><span class="line"><span class="built_in">string</span> bad[cnt];             <span class="comment">// 错误：cnt不是常量表达式</span></span><br><span class="line"><span class="built_in">string</span> strs[get_size()];     <span class="comment">// 当get_size是constexpr时正确；否则错误</span></span><br></pre></td></tr></table></figure>
<p><strong>默认情况下，数组的元素被默认初始化。</strong></p>
</li>
<li><p><strong>定义数组的时候必须指定数组的类型，不允许用 <code>auto</code> 关键字由初始值的列表推断类型。另外和 <code>vector</code> 一样，数组的元素应为对象，因此不存在引用的数组。</strong></p>
</li>
<li><p>可以对数组的元素进行列表初始化，此时允许忽略数组的维度。如果在声明时没有指明维度，编译器会根据初始值的数量计算并推测出来：相反，如果指明了维度，那么初始值的总数量不应该超出指定的大小。<strong>如果维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化成默认值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ia1[sz] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;       <span class="comment">// 含有3个元素的数组，元素值分别是0，1，2</span></span><br><span class="line"><span class="keyword">int</span> a2[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;          <span class="comment">// 维度是3的数组</span></span><br><span class="line"><span class="keyword">int</span> a3[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;         <span class="comment">// 等价于a3[] = &#123;0, 1, 2, 0, 0&#125;;</span></span><br><span class="line"><span class="built_in">string</span> a4[<span class="number">3</span>] = &#123;<span class="string">"hi"</span>, <span class="string">"bye"</span>&#125;;  <span class="comment">// 等价于a4[] = &#123;"hi", "bye", ""&#125;;</span></span><br><span class="line"><span class="keyword">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;         <span class="comment">// 错误：初始值过多</span></span><br></pre></td></tr></table></figure>
<p>应注意，int a[10] = 1;并不会将数组 a 的所有元素初始化为 1。</p>
</li>
<li><p>字符数组有一种额外的初始化形式，可以用字符串字面值对此类数组初始化。当使用这种方式时，一定要注意<strong>字符串字面值的结尾处还有一个空字符，这个空字符也会像字符串的其他字符一样被拷贝到字符数组中去</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'c'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;         <span class="comment">// 列表初始化，没有空字符</span></span><br><span class="line"><span class="keyword">char</span> a1[] = &#123;<span class="string">'c'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>, <span class="string">'\0'</span>&#125;;   <span class="comment">// 列表初始化，含有显式的空字符</span></span><br><span class="line"><span class="keyword">char</span> a3[] = <span class="string">"c++"</span>;                   <span class="comment">// 自动添加表示字符串结束的空字符</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> a4[<span class="number">5</span>] = <span class="string">"Hello"</span>;          <span class="comment">// 错误：没有空间可存放空字符！</span></span><br></pre></td></tr></table></figure>
<p>关于最后一例，编译器会提示：</p>
<p><img data-src="https://image.shipengx.com/%E6%95%B0%E7%BB%84%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%EF%BC%8C%E6%97%A0%E6%B3%95%E5%AD%98%E6%94%BE%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E5%80%BC%E4%B8%AD%E7%9A%84%E7%A9%BA%E5%AD%97%E7%AC%A6.png" alt="数组空间不足，无法存放字符串字面值中的空字符"></p>
</li>
<li><p><strong>不能将数组的内容拷贝给其他数组作为其初始值，也不能用数组为其他数组赋值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;  <span class="comment">// 含有3个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> a2[] = a;         <span class="comment">// 错误：不允许使用一个数组初始化另一个数组</span></span><br><span class="line">a2 = a;               <span class="comment">// 错误：不能把一个数组直接赋值给另一个数组</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>一些编译器支持数组的赋值，这就是所谓的<strong>编译器扩展</strong>（compiler extension）。但一般来说，最好避免使用非标准特性，因为含有非标准特性的程序很可能在其他编译器上无法正常工作。</p>
</blockquote>
</li>
<li><p>数组指针和指针数组总是容易让人混淆：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];             <span class="comment">// ptrs是含有10个整型指针的数组</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>] = <span class="comment">/* ? */</span>;   <span class="comment">// 错误：不存在引用的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;  <span class="comment">// Parry指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;rref)[<span class="number">10</span>] = arr;     <span class="comment">// arrRef引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，类型修饰符从右向左依次绑定。数组的维度是紧跟着被声明的名字的，所以就数组而言，由内向外阅读要比从右向左好多了。由内向外的顺序可帮助我们更好地理解 Parray 的含义。<br>观察下面的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *(&amp;arry)[<span class="number">10</span>] = ptrs;</span><br></pre></td></tr></table></figure>
<p>按照由内向外的顺序阅读上述语句，首先知道 arry 是一个引用，然后观察右边知道，arry 引用的对象是一个大小为 10 的数组，最后观察左边知道，数组的元素类型是指向 <code>int</code> 的指针。这样，arry 就是一个含有 10 个 <code>int</code> 型指针的数组的引用。</p>
<blockquote>
<p>要想理解数组声明的含义，最好的办法是从数组的名字开始按照由内向外的顺序阅读。</p>
</blockquote>
</li>
<li><p>在使用数组下标的时候，通常将其定义为 <code>size_t</code> 类型。<strong><code>size_t</code> 是一种机器相关的无符号类型，它被设计得足够大以便能表示内存中任意对象的大小。</strong>在 <code>cstddef</code> 头文件中定义了 <code>size_t</code> 类型，这个文件是 C 标准库 <code>stddef.h</code> 头文件的 C++语言版本。</p>
</li>
<li><p>与<code>vector</code> 和 <code>string</code> 一样，当需要遍历数组的所有元素时，最好的办法也是使用范围 <code>for</code> 语句。例如，下面的程序输出数组 <code>scores</code> 中的所有元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i : scores)  <span class="comment">// 对于scores中的每个计数值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span>;  <span class="comment">// 输出当前的计数值</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>因为维度是数组类型的一部分，所以系统知道数组 scores 中有多少个元素，使用范围<code>for</code>语句可以减轻人为控制遍历过程的负担。</p>
<blockquote>
<p>WARNING 大多数常见的安全问题都源于缓冲区溢出错误。当数组或其他类似数据结构的下标越界并试图访问非法内存区域时，就会产生此类错误。</p>
</blockquote>
</li>
<li><p>像其他对象一样，对数组的元素使用取地址符就能得到指向该元素的指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> nums[] = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;  <span class="comment">// 数组的元素是string对象</span></span><br><span class="line"><span class="built_in">string</span> *p = &amp;nums[<span class="number">0</span>];                     <span class="comment">// p指向nums的第一个元素</span></span><br></pre></td></tr></table></figure>
<p>数组还有一个特性：<strong>在很多用到数组名字的地方，编译器都会自动地将其替换为一个指向数组首元素的指针</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> *p2 = nums;  <span class="comment">// 等价于p2 = &amp;nums[0];</span></span><br></pre></td></tr></table></figure>
<p>但应注意：<strong><code>&amp;num</code> 和 <code>&amp;num[0]</code> 拥有不同的含义。</strong></p>
<blockquote>
<p>在大多数表达式中，使用数组类型的对象其实是使用一个指向该数组首元素的指针。</p>
</blockquote>
</li>
<li><p><strong>当使用数组作为一个 <code>auto</code> 变量的初始值时，推断得到的类型是指针而非数组</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;  <span class="comment">// ia是一个含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;                               <span class="comment">// ia2是一个整型指针，指向ia的第一个元素</span></span><br><span class="line">ia2 = <span class="number">42</span>;                                   <span class="comment">// 错误：ia2是一个指针，不能用int值给指针赋值</span></span><br></pre></td></tr></table></figure>
<p>尽管 ia 是由 10 个整数构成的数组，但当使用 ia 作为初始值时，编译器实际执行的初始化过程类似于下面的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(&amp;ia[<span class="number">0</span>])</span></span>;  <span class="comment">// 显然 ia2 的类型是 int*</span></span><br></pre></td></tr></table></figure>
<p><strong>当使用 <code>decltype</code> 关键字时上述转换不会发生</strong>，<code>decltype(ia)</code> 返回的类型是由 10 个整数构成的数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ia3是一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line">ia3 = p;     <span class="comment">// 错误：不能用整型指针给数组赋值</span></span><br><span class="line">ia3[<span class="number">4</span>] = i;  <span class="comment">// 正确：把i的值赋给ia3的一个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以设法获取数组尾元素之后的那个并不存在的元素的地址：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *e = &amp;arr[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++ 新标准引入了两个名为 <code>begin</code> 和 <code>end</code> 的函数，这两个函数与容器中的两个同名成员功能类似，不过数组不是类类型，因此两个函数不是成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = begin(ia);  <span class="comment">// 指向ia首元素的指针</span></span><br><span class="line"><span class="keyword">int</span> *last = end(ia);   <span class="comment">// 指向ia尾元素的下一位置的指针</span></span><br></pre></td></tr></table></figure>
<p><code>begin</code> 函数返回指向 ia 首元素的指针，<code>end</code> 函数返回指向 ia 尾元素下一位置的指针，这两个函数定义在 <code>iterator</code> 头文件中。</p>
</li>
<li><p>假设 arr 是一个整型数组，下面的程序负责找到 arr 中的第一个负数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// pbeg指向arr的首元素，pend指向arr尾元素的下一位置</span></span><br><span class="line"><span class="keyword">int</span> *pbeg = begin(arr), *pend = end(arr);</span><br><span class="line"><span class="keyword">while</span> (pbeg != pend &amp;&amp; *pbeg &gt;= <span class="number">0</span>)</span><br><span class="line">    ++pbeg;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一个指针如果指向了某种内置类型数组的尾元素的“下一位置”，则其具备与 <code>vector</code> 的 <code>end</code> 函数返回的与迭代器类似的功能。特别要注意，尾后指针不能执行解引用和递增操作。</p>
</blockquote>
</li>
<li><p>给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向同一数组的尾元素的下一位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[sz] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// 正确：arr转换成指向它首元素的指针；p指向arr尾元素的下一位置</span></span><br><span class="line"><span class="keyword">int</span> *p = arr + sz;   <span class="comment">// 使用警告：不要解引用！</span></span><br><span class="line"><span class="keyword">int</span> *p2 = arr + <span class="number">10</span>;  <span class="comment">// 错误：arr只有5个元素，p2的值未定义</span></span><br></pre></td></tr></table></figure>
<p><strong>如果计算所得的指针超出了数组范围就将产生错误，而且这种错误编译器一般发现不了。</strong></p>
</li>
<li><p><strong>和迭代器一样，两个指针相减的结果是它们之间的距离。参与运算的两个指针必须指向同一个数组当中的元素</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> size = <span class="built_in">std</span>::end(<span class="built_in">array</span>) - <span class="built_in">std</span>::begin(<span class="built_in">array</span>);  <span class="comment">// 以此获取数组中元素的数量</span></span><br></pre></td></tr></table></figure>
<p>两个指针相减的结果的类型是一种名为 <strong><code>ptrdiff_t</code></strong> 的标准库类型，和 <code>size_t</code> 一样，<code>ptrdiff_t</code> 也是一种定义在 <code>cstddef</code> 头文件中的机器相关的类型。因为差值可能为负值，所以 <code>ptrdiff_t</code> 是一种带符号类型。</p>
</li>
<li><p>只要两个指针指向同一个数组的元素，或者指向该数组的尾元素的下一位置，就能利用关系运算符对其进行比较：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *b = arr, *e = arr + sz;</span><br><span class="line"><span class="keyword">while</span> (b &lt; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用*b</span></span><br><span class="line">    ++b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个指针分别指向不相关的对象，则不能比较它们（没有意义）。</p>
</li>
<li><p>只要指针指向的是数组中的元素（或者数组中尾元素的下一位置），都可以执行下标运算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];  <span class="comment">// p指向索引为2的元素</span></span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];     <span class="comment">// p[1]等价于*(p + 1)，即ia[3]表示的那个元素</span></span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>];    <span class="comment">// p[-2]是ia[0]表示的那个元素</span></span><br></pre></td></tr></table></figure>
<p><strong>标准库类型限定使用的下标必须是无符号类型，而内置的下标运算无此要求</strong>，当然，结果地址必须指向原来的指针所指同一数组中的元素（或是同一数组尾元素的下一位置）。</p>
<blockquote>
<p>内置的下标运算符所用的索引值不是无符号类型，这一点与 <code>vector</code> 和 <code>string</code> 不一样。</p>
</blockquote>
</li>
<li><p>假定 p1 和 p2 指向同一个数组中的元素，则下面程序的功能是什么？什么情况下该程序是非法的？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">p1 += p2 -p1;</span><br></pre></td></tr></table></figure>
<p>使 p1 指向 p2 所指元素。当 p1 为常量指针时（即 p1 本身的值不可更改时），该程序非法。</p>
</li>
<li><p>C 语言标准库提供了一组函数，如下表所示。这些函数可用于操作 C 风格字符串，它们定义在 <code>cstring</code> 头文件中。</p>
<table>
<tbody>
<tr>
    <td colspan="2"><b><center>C风格字符串的函数</center></b></td>
</tr>
<tr>
    <td>strlen(p)</td>
    <td>返回p的长度，空字符不计算在内</td>
</tr>
<tr>
    <td>strcmp(p1, p2)</td>
    <td>比较p1和p2的相等性。如果p1 == p2，返回0；如果p1 &gt; p2，返回一个正值；如果p1 &lt; p2，返回一个负值</td>
</tr>
<tr>
    <td>strcat(p1, p2)</td>
    <td>将p2附加到p1之后，返回p1</td>
</tr>
<tr>
    <td>strcpy(p1, p2)</td>
    <td>将p2拷贝给p1，返回p1</td>
</tr>
</tbody>
</table>

<p>传入此类函数的指针必须指向以空字符作为结束的数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ca[] = &#123;<span class="string">'C'</span>, <span class="string">'+'</span>, <span class="string">'+'</span>&#125;;  <span class="comment">// 不以空字符结束</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(ca) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 严重错误：ca没有以空字符结束</span></span><br></pre></td></tr></table></figure>
<p>但实际调试结果是，上述代码可以正常输出结果 3。</p>
</li>
<li><p>观察下述代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = <span class="string">"A string example"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca2[] = <span class="string">"A different string"</span>;</span><br><span class="line"><span class="keyword">if</span> (ca1 &lt; ca2)  <span class="comment">// 未定义的：试图比较两个无关的地址</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当使用数组的时候其实真正用的是指向数组首元素的指针</strong>，上面的 <code>if</code> 条件实际上比较的是两个 <code>const char*</code> 的值。</p>
<blockquote>
<p>对大多数应用来说，使用标准库<code>string</code>要比使用 C 风格字符串更安全，更高效。</p>
</blockquote>
</li>
<li><p>下面程序的输出结果是什么？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ca1[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = ca1;</span><br><span class="line"><span class="keyword">while</span> (*cp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *cp &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++cp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>逐行输出 ca1 中的内容，但*cp 什么时候为假？ca1 尾元素的下一位置是空字符‘\0’，这是编译器对字符数组的默认处理吗？</strong></p>
</li>
<li><p>此前已介绍过允许使用字符串字面值来初始化 <code>string</code>对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"Hello World"</span>)</span></span>; <span class="comment">// s 的内容是 Hello World</span></span><br></pre></td></tr></table></figure>
<p>更一般的情况是，<strong>任何出现字符串字面值的地方都可以用以空字符结束的字符数组来替代</strong>：</p>
<ul>
<li>允许使用以空字符结束的字符数组来初始化 <code>string</code> 对象或为 <code>string</code> 对象赋值；</li>
<li>在 <code>string</code> 对象的加法运算中允许使用以空字符结束的字符数组作为其中一个运算对象（<strong>不能两个运算对象都是</strong>）；在 string 对象的复合赋值运算中允许使用以空字符结束的字符数组作为右侧的运算对象。<br><br></li>
</ul>
</li>
<li><p>如果程序的某处需要一个 C 风格字符串，无法直接用 <code>string</code> 对象来代替它。例如，不能用 <code>string</code> 对象直接初始化指向字符的指针。为了完成该功能，<code>string</code> 专门提供了一个名为 <code>c_str</code> 的成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *str = s;                <span class="comment">// 错误：不能用string对象初始化char*</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str();  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p><code>c_str</code> 函数的返回值是一个 C 风格的字符串。也就是说，<strong><code>c_str</code> 函数的返回结果是一个指针，该指针指向一个以空字符结束的字符数组，而这个数组所存的数据恰好与那个 <code>string</code> 对象的一样。结果指针的类型是 <code>const char*</code>，从而确保我们不会改变字符数组的内容。</strong>无法保证<code>c_str</code> 函数返回的数组一直有效，事实上，如果后续的操作改变了 s 的值就可能让之前返回的数组失去效用。</p>
<blockquote>
<p>如果执行完 <code>c_str()</code> 函数后程序想一直都能使用其返回的数组，最好将该数组重新拷贝一份。</p>
</blockquote>
</li>
<li><p><strong>不允许使用一个数组为另一个内置类型的数组赋初值，也不允许使用 <code>vector</code> 对象初始化数组。相反的，允许使用数组来初始化 <code>vector</code> 对象。要实现这一目的，只需指明要拷贝区域的首元素地址和尾后地址就可以了</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> int_arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">// ivec有6个元素，分别是int_arr中对应元素的副本</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(begin(int_arr), end(int_arr))</span></span>;</span><br></pre></td></tr></table></figure>
<p>用于初始化 <code>vector</code> 对象的值也可能仅是数组的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 拷贝三个元素：int_arr[1]、int_arr[2]、int_arr[3]</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">subVec</span><span class="params">(int_arr + <span class="number">1</span>, int_arr + <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这条初始化语句用 3 个元素创建了对象 subVec，3 个元素的值分别来自 <code>int_arr[1]</code>、<code>int_arr[2]</code>和<code>int_arr[3]</code>。</p>
<blockquote>
<p>现代的 C++ 程序应当尽量使用 <code>vector</code> 和迭代器，避免使用内置数组和指针；应该尽量使用 <code>string</code>，避免使用 C 风格的基于数组的字符串。</p>
</blockquote>
<p><strong>不敢苟同，看需求，如果仅需要存储一些数据，那数组足够。（博主注）</strong></p>
</li>
<li><p>当一个数组的元素仍然是数组时，通常使用两个维度来定义它：一个维度表示数组本身大小，另外一个维度表示其元素（也是数组）大小。</p>
</li>
<li><p>允许使用花括号括起来的一组值初始化多维数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,   <span class="comment">// 第1行的初始值</span></span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;,   <span class="comment">// 第2行的初始值</span></span><br><span class="line">    &#123;<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;  <span class="comment">// 第3行的初始值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中,内层嵌套着的花括号并非必须：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>类似于一维数组，在初始化多维数组时也并非所有元素的值都必须包含在初始化列表之内。如果仅仅想初始化每一行的第一个元素，通过如下的语句即可：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">4</span>&#125;, &#123;<span class="number">8</span>&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>其他未列出的元素执行默认值初始化，这个过程和一维数组一样。在这种情况下如果再省略掉内层的花括号，结果就大不一样了：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>&#125;;  <span class="comment">// 显式地初始化第1行,其它元素执行值初始化</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];  <span class="comment">// 把row定义成一个含有4个整数的数组的引用，然后绑定到ia的第二个4元素数组上</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用范围 <code>for</code> 语句处理二维数组中的每一个元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">size_t</span> rowCnt = <span class="number">3</span>, colCnt = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ia[rowCnt][colCnt];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;row : ia)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;col : row)</span><br><span class="line">    &#123;</span><br><span class="line">        col = cnt;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，因为要改变数组元素的值，所以我们选用引用类型作为循环控制变量，但其实还有一个深层次的原因促使我们这么做。举一个例子，考虑如下的循环：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;row : ia)  <span class="comment">// 对于外层数组的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)    <span class="comment">// 对于内层数组的每一个元素</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; col &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>这个循环中并没有任何写操作，可是我们还是将外层循环的控制变量声明成了引用类型，这是<strong>为了避免数组被自动转成指针</strong>。假设不用引用类型，则循环如下述形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> row : ia)  <span class="comment">// 对于外层数组的每一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> col : row)    <span class="comment">// 对于内层数组的每一个元素</span></span><br></pre></td></tr></table></figure>
<p>程序将无法通过编译。这是因为，像之前一样第一个循环遍历 ia 的所有元素，注意这些元素实际上是大小为 4 的数组。因为 row 不是引用类型，所以编译器初始化 row 时会自动将这些数组形式的元素（和其他类型的数组一样）转换成指向该数组内首元素的指针。这样得到的 row 的类型就是 <code>int*</code>，显然内层的循环就不合法了，编译器将试图在一个 <code>int*</code> 内遍历，这显然和程序的初衷相去甚远。</p>
<blockquote>
<p>要使用范围 <code>for</code> 语句处理多维数组，除了最内层的循环外，其他所有循环的控制变量都应该是引用类型。</p>
</blockquote>
</li>
<li><p>当程序使用多维数组的名字时，也会自动将其转换成指向数组首元素的指针。因为多维数组实际上是数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia;  <span class="comment">// p指向含有4个整数的数组</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];        <span class="comment">// p指向ia的尾元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过使用 <code>auto</code> 和 <code>decltype</code> 关键字，可以尽可能地避免在数组前加上一个指针类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出ia中每个最小元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="comment">// p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = ia; p != ia + <span class="number">3</span>; p++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// q指向4个整数数组的首元素，意即，q指向一个整数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q = *p; q != *p +<span class="number">4</span>; ++q)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用标准库函数 <code>begin</code> 和 <code>end</code> 也能实现同样的功能，而且更加简洁：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// p指向ia的第一个数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> p = begin(ia); p != end(ia); ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// q指向内层数组的首元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> q = begin(*p); q != end(*p); ++q)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;  <span class="comment">// 输出q所指的整数值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数组别名简化工作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> int_array = <span class="keyword">int</span>[<span class="number">4</span>];  <span class="comment">// 使用using声明的方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> int_array[<span class="number">4</span>];  <span class="comment">// 使用typedef声明的方式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出ia中每个最小元素的值，每个内层数组各占一行</span></span><br><span class="line"><span class="keyword">for</span> (int_array *p = ia; p != ia + <span class="number">3</span>; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> *q = *p; q != *p + <span class="number">4</span>; ++q)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>只有当逻辑与运算符 <code>&amp;&amp;</code> 左侧运算对象为真时才会检查其右侧运算对象的真值，只有当逻辑或运算符 <code>||</code> 左侧运算对象为假时才会检查其右侧运算对象的真值。</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 18 章 用于大型程序的工具</title>
    <url>/archives/5029459.html</url>
    <content><![CDATA[<h1 id="18-1-异常处理" class="heading-control"><a href="#18-1-异常处理" class="headerlink" title="18.1 异常处理"></a>18.1 异常处理<a class="heading-anchor" href="#18-1-异常处理" aria-hidden="true"></a></h1><ol>
<li><strong>异常处理</strong>（exception handling）机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并做出相应的处理。</li>
</ol>
<h2 id="18-1-1-抛出异常" class="heading-control"><a href="#18-1-1-抛出异常" class="headerlink" title="18.1.1 抛出异常"></a>18.1.1 抛出异常<a class="heading-anchor" href="#18-1-1-抛出异常" aria-hidden="true"></a></h2><ol>
<li><p>在 C++ 语言中，我们通过<strong>抛出</strong>（throwing）一条表达式来<strong>引发</strong>（raised）一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段<strong>处理代码</strong>（handler）将被用来处理该异常。被选中的处理代码是在调用链中与抛出对象类型匹配的最近的处理代码。其中，根据抛出对象的类型和内容，程序的异常抛出部分将会告知异常处理部分到底发生了什么错误。</p>
</li>
<li><p>当执行一个 <code>throw</code> 时，跟在 <code>throw</code> 后面的语句将不再被执行。相反，程序的控制权从 <code>throw</code> 转移到与之匹配的 <code>catch</code> 模块。该 <code>catch</code> 可能是同一个函数中的局部 <code>catch</code>，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个重要的含义：</p>
<ul>
<li>沿着调用链的函数可能会提早退出。</li>
<li>一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁。</li>
</ul>
<p>因为跟在 <code>throw</code> 后面的语句将不再被执行，所以 <code>throw</code> 语句的用法有点类似于 <code>return</code> 语句：它通常作为条件语句的一部分或者作为某个函数的最后（或者唯一）一条语句。</p>
</li>
<li><p>当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的 <code>catch</code> 子句。当 <code>throw</code> 出现在一个 <strong><code>try</code> 语句块</strong>（try block）内时，检查与该 <code>try</code> 块关联的 <code>catch</code> 子句。如果找到了匹配的 <code>catch</code>，就使用该 <code>catch</code> 处理异常。如果这一步没找到匹配的 <code>catch</code> 且该 <code>try</code> 语句嵌套在其他 <code>try</code> 块中，则继续检查与外层 <code>try</code> 匹配的 <code>catch</code> 子句。如果还是找不到匹配的 <code>catch</code>，则退出当前的函数，在调用当前函数的外层函数中继续寻找。</p>
<p>如果对抛出异常的函数的调用语句位于一个 <code>try</code> 语句块内，则检查与该 <code>try</code> 块关联的 <code>catch</code> 子句。如果找到了匹配的 <code>catch</code>，就使用该 <code>catch</code> 处理异常。否则，如果该 <code>try</code> 语句嵌套在其他 <code>try</code> 块中，则继续检查与外层 <code>try</code> 匹配的 <code>catch</code> 子句。如果仍然没有找到匹配的 <code>catch</code>，则退出当前这个主调函数，继续在调用了刚刚退出的这个函数的其他函数中寻找，以此类推。</p>
<p>上述过程被称为<strong>栈展开</strong>（stack unwinding）过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的 <code>catch</code> 子句为止；或者也可能一直没找到匹配的 <code>catch</code>，则退出主函数后查找过程终止。</p>
<p>假设找到了一个匹配的 <code>catch</code> 子句，则程序进入该子句并执行其中的代码。当执行完这个 <code>catch</code> 子句后，找到与 <code>try</code> 块关联的最后一个 <code>catch</code> 子句之后的点，并从这里继续执行。</p>
<p>如果没找到匹配的 <code>catch</code> 子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件，所以一旦引发了某个异常，就不能对它置之不理。当找不到匹配的 <code>catch</code> 时，程序将调用标准库函数 <strong><code>terminate</code></strong>，顾名思义，<code>terminate</code> 负责终止程序的执行过程。</p>
<blockquote>
<p><strong>Note：一个异常如果没有被捕获，则它将终止当前的程序。</strong></p>
</blockquote>
</li>
<li><p>在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下，程序在这些块中创建了一些局部对象。我们已经知道，块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果在栈展开过程中退出了某个块，编译器将负责确保在这个块中创建的对象能被正确地销毁。如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用。与往常一样，<strong>编译器在销毁内置类型的对象时不需要做任何事情</strong>。</p>
<p><strong>如果异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始化了，而另外一些成员在异常发生前也许还没有初始化。即使某个对象只构造了一部分，我们也要确保已构造的成员能被正确地销毁。</strong></p>
<p>类似的，异常也可能发生在数组或标准库容器的元素初始化过程中。与之前类似，如果在异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确地销毁。</p>
</li>
<li><p><strong>析构函数总是会被执行的，但是函数中负责释放资源的代码却可能被跳过，如果一个块分配了资源，并且在负责释放这些资源的代码前面发生了异常，则释放资源的代码将不会被执行。</strong> 另一方面，类对象分配的资源将由类的析构函数负责释放。因此，如果我们使用类来控制资源的分配，就能确保无论函数正常结束还是遭遇异常，资源都能被正确地释放。</p>
<p>析构函数在栈展开的过程中执行。在栈展开的过程中，已经引发了异常但是我们还没有处理它。如果异常抛出后没有被正确捕获，则系统将调用 <code>terminate</code> 函数。因此，<strong>出于栈展开可能使用析构函数的考虑，析构函数不应该抛出不能被它自身处理的异常。换句话说，如果析构函数需要执行某个可能抛出异常的操作，则该操作应该被放置在一个 <code>try</code> 语句块当中，并且在析构函数内部得到处理。</strong></p>
<p>在实际的编程过程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所有标准库类型都能确保它们的析构函数不会引发异常。</p>
<blockquote>
<p><strong>WARNING：</strong> 在栈展开的过程中，运行类类型的局部对象的析构函数。因为这些析构函数是自动执行的，所以它们不应该抛出异常。一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。</p>
</blockquote>
</li>
<li><p><strong>异常对象</strong>（exception object）是一种特殊的对象，编译器使用异常抛出表达式来对异常对象进行拷贝初始化。因此，<code>throw</code> 语句中的表达式必须拥有完全类型。而且<strong>如果该表达式是类类型的话，则相应的类必须含有一个可访问的析构函数和一个可访问的拷贝或移动构造函数。如果该表达式是数组类型或函数类型，则表达式将被转换成与之对应的指针类型。</strong></p>
<p>异常对象位于由编译器管理的空间中，编译器确保无论最终调用的是哪个 <code>catch</code> 子句都能访问该空间。当异常处理完毕后，异常对象被销毁。</p>
<p>如我们所知，当一个异常被抛出时，沿着调用链的块将依次退出直至找到与异常匹配的处理代码。如果退出了某个块，则同时释放块中局部对象使用的内存。因此，抛出一个指向局部对象的指针几乎肯定是一种错误的行为。出于同样的原因，从函数中返回指向局部对象的指针也是错误的。如果指针所指的对象位于某个块中，而该块在 <code>catch</code> 语句之前就已经退出了，则意味着在执行 <code>catch</code> 语句之前局部对象已经被销毁了。</p>
<p>当我们抛出一条表达式时，该表达式的静态编译时类型决定了异常对象的类型，很多情况下程序抛出的表达式类型来自于某个继承体系。<strong>如果一条 <code>throw</code> 表达式解引用一个基类指针，而该指针实际指向的是派生类对象，则抛出的对象将被切掉一部分，只有基类部分被抛出。</strong></p>
<blockquote>
<p><strong>WARNING：</strong> 抛出指针要求在任何对应的处理代码存在的地方，指针所指的对象都必须存在。</p>
</blockquote>
</li>
</ol>
<h2 id="18-1-2-捕获异常" class="heading-control"><a href="#18-1-2-捕获异常" class="headerlink" title="18.1.2 捕获异常"></a>18.1.2 捕获异常<a class="heading-anchor" href="#18-1-2-捕获异常" aria-hidden="true"></a></h2><ol>
<li><p><code>catch</code> 子句（catch clause）中的<strong>异常声明</strong>（exception declaration）看起来像是只包含一个形参的函数形参列表。像在形参列表中一样，如果 <code>catch</code> 无须访问抛出的表达式的话，则我们可以忽略捕获形参的名字。</p>
</li>
<li><p><strong>声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能是右值引用。</strong></p>
</li>
<li><p>当进入一个 <code>catch</code> 语句后，通过异常对象初始化异常声明中的参数。和函数的参数类似，如果 <code>catch</code> 的参数类型是非引用类型，则该参数是异常对象的一个副本，在 <code>catch</code> 语句内改变该参数实际上改变的是局部副本而非异常对象本身；相反，如果参数是引用类型，则和其他引用参数一样，该参数是异常对象的一个别名，此时改变参数也就是改变异常对象。</p>
<p><code>catch</code> 的参数还有一个特性也与函数的参数非常类似：<strong>如果 <code>catch</code> 的参数是基类类型，则我们可以使用其派生类类型的异常对象对其进行初始化。此时，如果 <code>catch</code> 的参数是非引用类型，则异常对象将被切掉一部分，这与将派生类对象以值传递的方式传给一个普通函数差不多。另一方面，如果 <code>catch</code> 的参数是基类的引用，则该参数将以常规方式绑定到异常对象上。</strong></p>
<p>最后一点需要注意的是，异常声明的静态类型将决定 <code>catch</code> 语句所能执行的操作。如果 <code>catch</code> 的参数是基类类型，则 <code>catch</code> 无法使用派生类特有的任何成员。</p>
<blockquote>
<p>《Effective C++》第三版“条款 20：宁以 pass-by-reference-to-const 替换 pass-by-value”也阐述了派生类对象以传值方式传给一个函数的基类形参时存在的对象切割问题。——博主注</p>
<p><strong>Best Practices：</strong> 通常情况下，如果 <code>catch</code> 接受的异常与某个继承体系有关，则最好将该 <code>catch</code> 的参数定义成引用类型。</p>
</blockquote>
</li>
<li><p>在搜寻 <code>catch</code> 语句的过程中，我们最终找到的 <code>catch</code> 未必是异常的最佳匹配。相反，<strong>挑选出来的应该是第一个与异常匹配的 <code>catch</code> 语句。因此，越是专门的 <code>catch</code> 越应该置于整个 <code>catch</code> 列表的前端。</strong></p>
<p>因为 <code>catch</code> 语句是按照其出现的顺序逐一进行匹配的，所以当程序使用具有继承关系的多个异常时必须对 <code>catch</code> 语句的顺序进行组织和管理，<strong>使得派生类异常的处理代码出现在基类异常的处理代码之前</strong>。</p>
<p>与实参和形参的匹配规则相比，异常和 <code>catch</code> 异常声明的匹配规则受到更多限制。此时，绝大多数类型转换都不被允许，除了一些极细小的差别之外，要求异常的类型和 <code>catch</code> 声明的类型是精确匹配的：</p>
<ul>
<li>允许从非常量向常量的类型转换，也就是说，一条非常量对象的 <code>throw</code> 语句可以匹配一个接受常量引用的 <code>catch</code> 语句。</li>
<li>允许从派生类向基类的类型转换。</li>
<li>数组被转换成指向数组（元素）类型的指针，函数被转换成指向该函数类型的指针。</li>
</ul>
<p>除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能在匹配 <code>catch</code> 的过程中使用。</p>
<blockquote>
<p><strong>Note：如果在多个 <code>catch</code> 语句的类型之间存在着继承关系，则我们应该把继承链最底端的类（most derived type）放在前面，而将继承链最顶端的类（least derived type）放在后面。</strong></p>
</blockquote>
</li>
<li><p>有时，一个单独的 <code>catch</code> 语句不能完整地处理某个异常。在执行了某些校正操作之后，当前的 <code>catch</code> 可能会决定由调用链更上一层的函数接着处理异常。一条 <code>catch</code> 语句通过重新抛出（rethrowing）的操作将异常传递给另外一个 <code>catch</code> 语句。这里的重新抛出仍然是一条 <code>throw</code> 语句，只不过不包含任何表达式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span>;</span><br></pre></td></tr></table></figure>
<p>空的 <code>throw</code> 语句只能出现在 <code>catch</code> 语句或 <code>catch</code> 语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空 <code>throw</code> 语句，编译器将调用 <code>terminate</code>。</p>
<p>一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。</p>
<p>很多时候，<code>catch</code> 语句会改变其参数的内容。如果在改变了参数的内容后 <code>catch</code> 语句重新抛出异常，则只有当 <code>catch</code> 异常声明是引用类型时我们对参数所做的改变才会被保留并继续传播：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (my_error &amp;eObj) <span class="comment">// 引用类型</span></span><br><span class="line">&#123;</span><br><span class="line">    eobj.status = errCodes::severeErr; <span class="comment">// 修改了异常对象</span></span><br><span class="line">    <span class="keyword">throw</span>;                             <span class="comment">// 异常对象的 status 成员是 severeErr</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (other_error eObj) <span class="comment">// 非引用类型</span></span><br><span class="line">&#123;</span><br><span class="line">    eObj.status = errCodes::badErr; <span class="comment">// 只修改了异常对象的局部副本</span></span><br><span class="line">    <span class="keyword">throw</span>;                          <span class="comment">// 异常对象的 status 成员没有改变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有时我们希望不论抛出的异常是什么类型，程序都能统一捕获它们。为了一次性捕获所有异常，我们使用省略号作为异常声明，这样的处理代码称为<strong>捕获所有异常</strong>（catch-all）的处理代码，形如 <code>catch(...)</code>。一条捕获所有异常的语句可以与任意类型的异常匹配。<code>catch(...)</code> 通常与重新抛出语句一起使用，其中 <code>catch</code> 执行当前局部能完成的工作，随后重新抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里的操作将引发并抛出一个异常 catch</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (...)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 处理异常的某些特殊操作</span></span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>catch(...)</code> 既能单独出现，也能与其他几个 <code>catch</code> 语句一起出现。</p>
<blockquote>
<p><strong>Note：</strong> 如果 <code>catch(...)</code> 与其他几个 <code>catch</code> 语句一起出现，则 <code>catch(...)</code> 必须在最后的位置。出现在捕获所有异常语句后面的 <code>catch</code> 语句将永远不会被匹配。</p>
</blockquote>
</li>
</ol>
<h2 id="18-1-3-函数-try-语句块与构造函数" class="heading-control"><a href="#18-1-3-函数-try-语句块与构造函数" class="headerlink" title="18.1.3 函数 try 语句块与构造函数"></a>18.1.3 函数 try 语句块与构造函数<a class="heading-anchor" href="#18-1-3-函数-try-语句块与构造函数" aria-hidden="true"></a></h2><ol>
<li><p><strong>构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的 <code>try</code> 语句块还未生效，所以构造函数体内的 <code>catch</code> 语句无法处理构造函数初始值列表抛出的异常。</strong></p>
<p><strong>要想处理构造函数初始值抛出的异常，我们必须将构造函数写成函数 <code>try</code> 语句块（也称为函数测试块，function try block）的形式。函数 <code>try</code> 语句块使得一组 <code>catch</code> 语句既能处理构造函数体（或析构函数体），也能处理构造函数的初始化过程（或析构函数的析构过程）</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt; il)</span><br><span class="line"><span class="keyword">try</span> : data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(il))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 空函数体 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::bad_alloc &amp;e)</span><br><span class="line">&#123;</span><br><span class="line">    handle_out_of_memory(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：<strong>关键字 <code>try</code> 出现在表示构造函数初始值列表的冒号以及表示构造函数体（此例为空）的花括号之前。与这个 <code>try</code> 关联的 <code>catch</code> 既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。</strong></p>
<blockquote>
<p>构造函数初始化列表先于构造函数体执行，因此构造函数初始化列表抛出的异常无法被构造函数体内的一般的 <code>try...catch...</code> 语句捕获，需要将构造函数写成函数 <code>try</code> 语句块的形式。——博主注</p>
</blockquote>
</li>
<li><p><strong>在初始化构造函数的参数时也可能发生异常，这样的异常不属于函数 <code>try</code> 语句块的一部分。函数 <code>try</code> 语句块只能处理构造函数开始执行后发生的异常。和其他函数调用一样，如果在参数初始化的过程中发生了异常，则该异常属于调用表达式的一部分，并将在调用者所在的上下文中处理。</strong></p>
</li>
<li><blockquote>
<p><strong>Note：处理构造函数初始值异常的唯一方法是将构造函数写成函数 <code>try</code> 语句块。</strong></p>
</blockquote>
</li>
</ol>
<h2 id="18-1-4-noexcept-异常说明" class="heading-control"><a href="#18-1-4-noexcept-异常说明" class="headerlink" title="18.1.4 noexcept 异常说明"></a>18.1.4 noexcept 异常说明<a class="heading-anchor" href="#18-1-4-noexcept-异常说明" aria-hidden="true"></a></h2><ol>
<li><p>首先，知道函数不会抛出异常有助于简化调用该函数的代码：其次，如果编译器确认函数不会抛出异常，它就能执行某些特殊的优化操作，而这些优化操作并不适用于可能出错的代码。</p>
</li>
<li><p>在 C++11 新标准中，我们可以通过提供 <strong><code>noexcept</code> 说明</strong>（noexcept specification）指定某个函数不会抛出异常。其形式是关键字 <code>noexcept</code> 紧跟在函数的参数列表后面，用以标识该函数不会抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span>)</span></span>;           <span class="comment">// 可能抛出异常</span></span><br></pre></td></tr></table></figure>
<p>我们说 <code>recoup</code> 做了<strong>不抛出说明</strong>（nonthrowing specification）。</p>
</li>
<li><p>对于一个函数来说，<code>noexcept</code> 说明要么出现在该函数的所有声明语句和定义语句中，要么一次也不出现。该说明应该在函数的尾置返回类型之前。我们也可以在函数指针的声明和定义中指定 <code>noexcept</code>。在 <code>typedef</code> 或类型别名中则不能出现 <code>noexcept</code>。在成员函数中，<code>noexcept</code> 说明符需要跟在 <code>const</code> 及引用限定符之后，而在 <code>final</code>、<code>override</code> 或虚函数的 <code>=0</code> 之前。</p>
</li>
<li><p>编译器并不会在编译时检查 <code>noexcept</code> 说明。实际上，如果一个函数在说明了 <code>noexcept</code> 的同时又含有 <code>throw</code> 语句或者调用了可能抛出异常的其他函数，编译器将顺利编译通过，并不会因为这种违反异常说明的情况而报错（不排除个别编译器会对这种用法提出警告）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尽管该函数明显违反了异常说明，但它仍然可以顺利编译通过</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="keyword">noexcept</span> <span class="comment">// 承诺不会抛出异常</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> exception(); <span class="comment">// 违反了异常说明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此可能出现这样一种情况：尽管函数声明了它不会抛出异常，但实际上还是抛出了。一旦一个 <code>noexcept</code> 函数抛出了异常，程序就会调用 <code>terminate</code> 以确保遵守不在运行时抛出异常的承诺。上述过程对是否执行栈展开未作约定，因此 <strong><code>noexcept</code> 可以用在两种情况下：一是我们确认函数不会抛出异常，二是我们根本不知道该如何处理异常</strong>。</p>
<p>指明某个函数不会抛出异常可以令该函数的调用者不必再考虑如何处理异常。无论是函数确实不抛出异常，还是程序被终止，调用者都无须为此负责。</p>
<blockquote>
<p><strong>WARNING：</strong> 通常情况下，编译器不能也不必在编译时验证异常说明。</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>向后兼容：异常说明。</strong> 早期的 C++ 版本设计了一套更加详细的异常说明方案，该方案使得我们可以指定某个函数可能抛出的异常类型。函数可以指定一个关键字 <code>throw</code>，在后面跟上括号括起来的异常类型列表。<code>throw</code> 说明符所在的位置与新版本 C++ 中 <code>noexcept</code> 所在的位置相同。<br>上述使用 <code>throw</code> 的异常说明方案在 C++11 新版本中已经被取消了。然而尽管如此，它还有一个重要的用处。如果函数被设计为是 <code>throw()</code> 的，则意味着该函数将不会抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// recoup 不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">throw</span><span class="params">()</span></span>;  <span class="comment">// 等价的声明</span></span><br></pre></td></tr></table></figure>
<p>上面的两条声明语句是等价的，它们都承诺 <code>recoup</code> 不会抛出异常。</p>
</blockquote>
</li>
<li><p><code>noexcept</code> 说明符接受一个可选的实参，该实参必须能转换为 <code>bool</code> 类型：如果实参是 <code>true</code>，则函数不会抛出异常；如果实参是 <code>false</code>，则函数可能抛出异常：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recoup</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">true</span>)</span></span>; <span class="comment">// recoup 不会抛出异常</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">alloc</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>; <span class="comment">// alloc 可能抛出异常</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>noexcept</code> 说明符的实参常常与 <strong><code>noexcept</code> 运算符</strong>（noexcept operator）混合使用。<code>noexcept</code> 运算符是一个一元运算符，它的返回值是一个 <code>bool</code> 类型的右值常量表达式，用于表示给定的表达式是否会抛出异常。和 <code>sizeof</code> 类似，<code>noexcept</code> 也不会求其运算对象的值。</p>
<p>例如，因为我们声明 <code>recoup</code> 时使用了 <code>noexcept</code> 说明符，所以下面的表达式的返回值为 <code>true</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">noexcept</span>(recoup(i)) <span class="comment">// 如果 recoup 不抛出异常则结果为 true；否则结果为 false</span></span><br></pre></td></tr></table></figure>
<p>更普通的形式是：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">noexcept</span>(e)</span><br></pre></td></tr></table></figure>
<p>当 <code>e</code> 调用的所有函数都做了不抛出说明且 <code>e</code> 本身不含有 <code>throw</code> 语句时，上述表达式为 <code>true</code>；否则 <code>noexcept(e)</code> 返回 <code>false</code>。</p>
<p>我们可以使用 <code>noexcept</code> 运算符得到如下的异常说明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="keyword">noexcept</span>(g()))</span></span>; <span class="comment">// f 和 g 的异常说明一致</span></span><br></pre></td></tr></table></figure>
<p>如果函数 <code>g</code> 承诺了不会抛出异常，则 <code>f</code> 也不会抛出异常；如果 <code>g</code> 没有异常说明符，或者 <code>g</code> 虽然有异常说明符但是允许抛出异常，则 <code>f</code> 也可能抛出异常。</p>
<blockquote>
<p><strong>Note： <code>noexcept</code> 有两层含义：当跟在函数参数列表后面时它是异常说明符；而当作为 <code>noexcept</code> 异常说明的 <code>bool</code> 实参出现时，它是一个运算符。</strong></p>
</blockquote>
</li>
<li><p>尽管 <code>noexcept</code> 说明符不属于函数类型的一部分，但是函数的异常说明仍然会影响函数的使用。</p>
<p><strong>函数指针及该指针所指的函数必须具有一致的异常说明。</strong> 也就是说，如果我们为某个指针做了不抛出异常的声明，则该指针将只能指向不抛出异常的函数。相反，如果我们显式或隐式地说明了指针可能抛出异常，则该指针可以指向任何函数，即使是承诺了不抛出异常的函数也可以：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// recoup 和 pf1 都承诺不会抛出异常</span></span><br><span class="line"><span class="keyword">void</span> (*pf1)(<span class="keyword">int</span>) <span class="keyword">noexcept</span> = recoup;</span><br><span class="line"><span class="comment">// 正确：recoup 不会抛出异常，pf2 可能抛出异常，二者之间互不干扰</span></span><br><span class="line"><span class="keyword">void</span> (*pf2)(<span class="keyword">int</span>) = recoup;</span><br><span class="line">pf1 = alloc; <span class="comment">// 错误：alloc 可能抛出异常，但是 pf1 已经说明了它不会抛出异常</span></span><br><span class="line">pf2 = alloc; <span class="comment">// 正确：pf2 和 alloc 都可能抛出异常</span></span><br></pre></td></tr></table></figure>
<p><strong>如果一个虚函数承诺了它不会抛出异常，则后续派生出来的虚函数也必须做出同样的承诺；与之相反，如果基类的虚函数允许抛出异常，则派生类的对应函数既可以允许抛出异常，也可以不允许抛出异常</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span> <span class="keyword">noexcept</span></span>; <span class="comment">// 不会抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>;   <span class="comment">// 可能抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span>;                  <span class="comment">// 可能抛出异常</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">f1</span><span class="params">(<span class="keyword">double</span>)</span></span>;        <span class="comment">// 错误：Base::f1 承诺不会抛出异常</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> <span class="title">noexcept</span><span class="params">(<span class="literal">false</span>)</span></span>; <span class="comment">// 正确：与 Base::f2 的异常说明一致</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;       <span class="comment">// 正确：Derived 的 f3 做了更严格的限定,</span></span><br><span class="line">                              <span class="comment">// 这是允许的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当编译器合成拷贝控制成员时，同时也生成一个异常说明。如果对所有成员和基类的所有操作都承诺了不会抛出异常，则合成的成员是 <code>noexcept</code> 的。如果合成成员调用的任意一个函数可能抛出异常，则合成的成员是 <code>noexcept(false)</code>。而且，如果我们定义了一个析构函数但是没有为它提供异常说明，则编译器将合成一个。合成的异常说明将与假设由编译器为类合成析构函数时所得的异常说明一致。</p>
</li>
</ol>
<h2 id="18-1-5-异常类层次" class="heading-control"><a href="#18-1-5-异常类层次" class="headerlink" title="18.1.5 异常类层次"></a>18.1.5 异常类层次<a class="heading-anchor" href="#18-1-5-异常类层次" aria-hidden="true"></a></h2><ol>
<li><p>标准库异常类构成了如下图所示的继承体系：</p>
<p><img data-src="https://image.shipengx.com/%E6%A0%87%E5%87%86%20exception%20%E7%B1%BB%E5%B1%82%E6%AC%A1.png" alt="标准 exception 类层次"></p>
<p>类型 <code>exception</code> 仅仅定义了拷贝构造函数、拷贝赋值运算符、一个虚析构函数和一个名为 <code>what</code> 的虚成员。其中 <code>what</code> 函数返回一个 <code>const char*</code>，该指针指向一个以 un11 结尾的字符数组，并且确保不会抛出任何异常。</p>
<p>类 <code>exception</code>、<code>bad_cast</code> 和 <code>bad_alloc</code> 定义了默认构造函数。类 <code>runtime_error</code> 和 <code>logic_error</code> 没有默认构造函数，但是有一个可以接受 C 风格字符串或者标准库 <code>string</code> 类型实参的构造函数，这些实参负责提供关于错误的更多信息。在这些类中，<code>what</code> 负责返回用于初始化异常对象的信息。<strong>因为 <code>what</code> 是虚函数，所以当我们捕获基类的引用时，对 <code>what</code> 函数的调用将执行与异常对象动态类型对应的版本。</strong></p>
</li>
<li><p>和其他继承体系一样，异常类也可以看作按照层次关系组织的。层次越低，表示的异常情况就越特殊。例如，在异常类继承体系中位于最顶层的通常是 <code>exception</code>，<code>exception</code> 表示的含义是某处出错了，至于错误的细节则未作描述。</p>
<p>继承体系的第二层将 <code>exception</code> 划分为两个大的类别：运行时错误和逻辑错误。运行时错误表示的是只有在程序运行时才能检测到的错误；而逻辑错误一般指的是我们可以在程序代码中发现的错误。</p>
</li>
</ol>
<h1 id="18-2-命名空间" class="heading-control"><a href="#18-2-命名空间" class="headerlink" title="18.2 命名空间"></a>18.2 命名空间<a class="heading-anchor" href="#18-2-命名空间" aria-hidden="true"></a></h1><ol>
<li><p>大型程序往往会使用多个独立开发的库，这些库又会定义大量的全局名字，如类、函数和模板等。多个库将名字放置在全局命名空间中将引发<strong>命名空间污染</strong>（namespace pollution）。</p>
</li>
<li><p><strong>命名空间</strong>（namespace）为防止名字冲突提供了更加可控的机制。命名空间分割了全局命名空间，其中每个命名空间是一个作用域。</p>
</li>
</ol>
<h2 id="18-2-1-命名空间定义" class="heading-control"><a href="#18-2-1-命名空间定义" class="headerlink" title="18.2.1 命名空间定义"></a>18.2.1 命名空间定义<a class="heading-anchor" href="#18-2-1-命名空间定义" aria-hidden="true"></a></h2><ol>
<li><p>一个命名空间的定义包含两部分：首先是关键字 <code>namespace</code>，随后是命名空间的名字。在命名空间名字后面是一系列由花括号括起来的声明和定义。只要能出现在全局作用域中的声明就能置于命名空间内，主要包括：类、变量（及其初始化操作）、函数（及其定义）、模板和其他命名空间。</p>
</li>
<li><p>和其他名字一样，命名空间的名字也必须在定义它的作用域内保持唯一。命名空间既可以定义在全局作用域内，也可以定义在其他命名空间中，但是不能定义在函数或类的内部。</p>
<blockquote>
<p><strong>Note：</strong> 命名空间作用域后面无须分号。</p>
</blockquote>
</li>
<li><p>因为不同命名空间的作用域不同，所以在不同命名空间内可以有相同名字的成员。</p>
<p>定义在某个命名空间中的名字可以被该命名空间内的其他成员直接访问，也可以被这些成员内嵌作用域中的任何单位访问。位于该命名空间之外的代码则必须明确指出所用的名字属于哪个命名空间。</p>
</li>
<li><p>命名空间可以定义在几个不同的部分，这一点与其他作用域不太一样。编写如下的命名空间定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> nsp &#123;</span><br><span class="line"><span class="comment">// 相关声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能是定义了一个名为 <code>nsp</code> 的新命名空间，也可能是为已经存在的命名空间添加一些新成员。如果之前没有名为 <code>nsp</code> 的命名空间定义，则上述代码创建一个新的命名空间；否则，上述代码打开已经存在的命名空间定义并为其添加一些新成员的声明。</p>
<p>命名空间的定义可以不连续的特性使得我们可以将几个独立的接口和实现文件组成一个命名空间。此时，命名空间的组织方式类似于我们管理自定义类及函数的方式：</p>
<ul>
<li>命名空间的一部分成员的作用是定义类，以及声明作为类接口的函数及对象，则这些成员应该置于头文件中，这些头文件将被包含在使用了这些成员的文件中。</li>
<li>命名空间成员的定义部分则置于另外的源文件中。</li>
</ul>
<p>在程序中某些实体只能定义一次：如非内联函数、静态数据成员、变量等，命名空间中定义的名字也需要满足这一要求，我们可以通过上面的方式组织命名空间并达到目的。这种接口和实现分离的机制确保我们所需的函数和其他名字只定义一次，而只要是用到这些实体的地方都能看到对于实体名字的声明。</p>
<blockquote>
<p><strong>Best Practices：</strong> 定义多个类型不相关的命名空间应该使用单独的文件分别表示每个类型（或关联类型构成的集合）。</p>
</blockquote>
</li>
<li><p><strong>在通常情况下，我们不把 <code>#include</code> 放在命名空间内部。</strong> 如果我们这么做了，隐含的意思是把头文件中所有的名字定义成该命名空间的成员。</p>
</li>
<li><p>假定作用域中存在合适的声明语句，则命名空间中的代码可以使用同一命名空间定义的名字的简写形式。</p>
<p>也可以在命名空间定义的外部定义该命名空间的成员。命名空间对于名字的声明必须在作用域内，同时该名字的定义需要明确指出其所属的命名空间。</p>
<p>和定义在类外部的类成员一样，一旦看到含有完整前缀的名字，我们就可以确定该名字位于命名空间的作用域内。</p>
</li>
<li><p>模板特例化必须定义在原始模板所属的命名空间中。<strong>和其他命名空间名字类似，只要我们在命名空间中声明了特例化，就能在命名空间外部定义它了</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们必须将模板特例化声明成 std 的成员</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;Sales_data&gt;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在 std 中添加了模板特例化的声明后，就可以在命名空间 std 的外部定义它了</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">std</span>:</span>:hash&lt;Sales_data&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(s.bookNo) ^ hash&lt;<span class="keyword">unsigned</span>&gt;()(s.units_sold) ^</span><br><span class="line">               hash&lt;<span class="keyword">double</span>&gt;()(s.revenue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他成员与之前的版本一致</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局作用域中定义的名字（即在所有类、函数及命名空间之外定义的名字）也就是定义在<strong>全局命名空间</strong>（global namespace）中。<strong>全局命名空间以隐式的方式声明，并且在所有程序中都存在。全局作用域中定义的名字被隐式地添加到全局命名空间中。</strong></p>
<p>作用域运算符同样可以用于全局作用域的成员，因为全局作用域是隐式的，所以它并没有名字。下面的形式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">::member_name</span><br></pre></td></tr></table></figure>
<p>表示全局命名空间中的一个成员。</p>
</li>
<li><p><strong>嵌套的命名空间</strong>是指定义在其他命名空间中的命名空间。嵌套的命名空间同时是一个嵌套的作用域，它嵌套在外层命名空间的作用域中。嵌套的命名空间中的名字遵循的规则与往常类似：内层命名空间声明的名字将隐藏外层命名空间声明的同名成员。在嵌套的命名空间中定义的名字只在内层命名空间中有效，外层命名空间中的代码要想访问它必须在名字前添加限定符。例如，在嵌套的命名空间 <code>QueryLib</code> 中声明的类名是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cplusplus_primer::QueryLib::Query</span><br></pre></td></tr></table></figure>
</li>
<li><p>C++11 新标准引入了一种新的嵌套命名空间，称为<strong>内联命名空间</strong>（inline namespace）。和普通的嵌套命名空间不同，<strong>内联命名空间中的名字可以被外层命名空间直接使用</strong>。也就是说，我们无须在内联命名空间的名字前添加表示该命名空间的前缀，通过外层命名空间的名字就可以直接访问它。</p>
<p>定义内联命名空间的方式是在关键字 <code>namespace</code> 前添加关键字 <code>inline</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> FifthEd &#123;</span><br><span class="line"><span class="comment">// 该命名空间表示 C++ Primer 第 5 版的代码</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> FifthEd &#123; <span class="comment">// 隐式内联</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="comment">// 其他与 Query 有关的声明</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace FifthEd</span></span><br></pre></td></tr></table></figure>
<p><strong>关键字 <code>inline</code> 必须出现在命名空间第一次定义的地方，后续再打开命名空间的时候可以写 <code>inline</code>，也可以不写。</strong></p>
<p>当应用程序的代码在一次发布和另一次发布之间发生了改变时，常常会用到内联命名空间。例如，我们可以把本书当前版本的所有代码都放在一个内联命名空间中，而之前版本的代码都放在一个非内联命名空间中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> FourthEd &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// C++ Primer 第 4 版用到的其他代码</span></span><br><span class="line">&#125; <span class="comment">// namespace FourthEd</span></span><br></pre></td></tr></table></figure>
<p>命名空间 <code>cplusplus_primer</code> 将同时使用这两个命名空间。例如，假定每个命名空间都定义在同名的头文件中，则我们可以把命名空间 <code>cplusplus_primer</code> 定义成如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"FifthEd.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"FourthEd.h"</span></span></span><br><span class="line">&#125; <span class="comment">// namespace cplusplus_primer</span></span><br></pre></td></tr></table></figure>
<p>因为 <code>FifthEd</code> 是内联的，所以形如 <code>cplusplus_primer::</code> 的代码可以直接获得 <code>FifthEd</code> 的成员。如果我们想使用早期版本的代码，则必须像其他嵌套的命名空间一样加上完整的外层命名空间名字，比如 <code>cplusplus_primer::FourthEd::Query_base</code>。</p>
</li>
<li><p><strong>未命名的命名空间</strong>（unnamed namespace）是指关键字 <code>namespace</code> 后紧跟花括号括起来的一系列声明语句。<strong>未命名的命名空间中定义的变量拥有静态生命周期：它们在第一次使用前创建，并且直到程序结束才销毁。</strong></p>
<p><strong>一个未命名的命名空间可以在某个给定的文件内不连续，但是不能跨越多个文件。</strong> 每个文件定义自己的未命名的命名空间，如果两个文件都含有未命名的命名空间，则这两个空间互相无关。在这两个未命名的命名空间中可以定义相同的名字，并且这些定义表示的是不同实体。如果一个头文件定义了未命名的命名空间，则该命名空间中定义的名字将在每个包含了该头文件的文件中对应不同实体。</p>
<blockquote>
<p><strong>Note：和其他命名空间不同，未命名的命名空间仅在特定的文件内部有效，其作用范围不会横跨多个不同的文件。</strong></p>
</blockquote>
</li>
<li><p><strong>定义在未命名的命名空间中的名字可以直接使用</strong>，毕竟我们找不到什么命名空间的名字来限定它们；同样的，我们也不能对未命名的命名空间的成员使用作用域运算符。</p>
<p><strong>未命名的命名空间中定义的名字的作用域与该命名空间所在的作用域相同。如果未命名的命名空间定义在文件的最外层作用域中，则该命名空间中的名字一定要与全局作用域中的名字有所区别</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i; <span class="comment">// i 的全局声明</span></span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二义性：i 的定义既出现在全局作用域中，又出现在未嵌套的未命名的命名空间中</span></span><br><span class="line">i = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>其他情况下，未命名的命名空间中的成员都属于正确的程序实体。和所有命名空间类似，一个未命名的命名空间也能嵌套在其他命名空间当中。此时，未命名的命名空间中的成员可以通过外层命名空间的名字来访问：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> local &#123;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace local</span></span><br><span class="line"><span class="comment">// 正确：定义在嵌套的未命名的命名空间中的 i 与全局作用域中的 i 不同</span></span><br><span class="line">local::i = <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p><strong>未命名的命名空间取代文件中的静态声明。</strong> 在标准 C++ 引入命名空间的概念之前，程序需要将名字声明成 <code>static</code> 的以使得其对于整个文件有效。在文件中进行静态声明的做法是从 C 语言继承而来的。在 C 语言中，声明为 <code>static</code> 的全局实体在其所在的文件外不可见。</p>
<p><strong>WARNING：</strong> 在文件中进行静态声明的做法已经被 C++ 标准取消了，现在的做法是使用未命名的命名空间。</p>
</blockquote>
</li>
</ol>
<h2 id="18-2-2-使用命名空间成员" class="heading-control"><a href="#18-2-2-使用命名空间成员" class="headerlink" title="18.2.2 使用命名空间成员"></a>18.2.2 使用命名空间成员<a class="heading-anchor" href="#18-2-2-使用命名空间成员" aria-hidden="true"></a></h2><ol>
<li><p><strong>命名空间的别名</strong>（namespace alias）使得我们可以为命名空间的名字设定一个短得多的同义词。例如，一个很长的命名空间的名字形如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> cplusplus_primer &#123;</span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以为其设定一个短得多的同义词：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> primer = cplusplus_primer;</span><br></pre></td></tr></table></figure>
<p>命名空间的别名声明以关键字 <code>namespace</code> 开始，后面是别名所用的名字、<code>=</code> 符号、命名空间原来的名字以及一个分号。<strong>不能在命名空间还没有定义前就声明别名，否则将产生错误。</strong></p>
<p><strong>命名空间的别名也可以指向一个嵌套的命名空间</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Qlib = cplusplus_primer::QueryLib;</span><br><span class="line">Qlib::Query q;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：</strong> 一个命名空间可以有好几个同义词或别名，所有别名都与命名空间原来的名字等价。</p>
</blockquote>
</li>
<li><p><strong>一条 <code>using</code> 声明</strong>（using declaration）语句一次只引入命名空间的一个成员。它使得我们可以清楚地知道程序中所用的到底是哪个名字。</p>
<p><strong><code>using</code> 声明引入的名字遵守与过去一样的作用域规则：它的有效范围从 <code>using</code> 声明的地方开始，一直到 <code>using</code> 声明所在的作用域结束为止。在此过程中，外层作用域的同名实体将被隐藏。未加限定的名字只能在 <code>using</code> 声明所在的作用域以及其内层作用域中使用。在有效作用域结束后，我们就必须使用完整的经过限定的名字了。</strong></p>
<p><strong>一条 <code>using</code> 声明语句可以出现在全局作用域、局部作用域、命名空间作用域以及类的作用域中。在类的作用域中，这样的声明语句只能指向基类成员。</strong></p>
</li>
<li><p><strong><code>using</code> 指示</strong>（using directive）和 <code>using</code> 声明类似的地方是，我们可以使用命名空间名字的简写形式；和 <code>using</code> 声明不同的地方是，我们无法控制哪些名字是可见的，因为所有名字都是可见的。</p>
<p><code>using</code> 指示以关键字 <code>using</code> 开始，后面是关键字 <code>namespace</code> 以及命名空间的名字。如果这里所用的名字不是一个已经定义好的命名空间的名字，则程序将发生错误。<code>using</code> 指示可以出现在全局作用域、局部作用域和命名空间作用域中，但是不能出现在类的作用域中。</p>
<p><strong><code>using</code> 指示使得某个特定的命名空间中所有的名字都可见，这样我们就无须再为它们添加任何前缀限定符了。简写的名字从 <code>using</code> 指示开始，一直到 <code>using</code> 指示所在的作用域结束都能使用。</strong></p>
<blockquote>
<p><strong>WARNING：如果我们提供了一个对 <code>std</code> 等命名空间的 <code>using</code> 指示而未做任何特殊控制的话，将重新引入由于使用了多个库而造成的名字冲突问题。</strong></p>
</blockquote>
</li>
<li><p><code>using</code> 指示引入的名字的作用域远比 <code>using</code> 声明引入的名字的作用域复杂。如我们所知，<code>using</code> 声明的名字的作用域与 <code>using</code> 声明语句本身的作用域一致，从效果上看就好像 <code>using</code> 声明语句为命名空间的成员在当前作用域内创建了一个别名一样。</p>
<p><strong><code>using</code> 指示所做的绝非声明别名这么简单。相反，它具有将命名空间成员提升到包含命名空间本身和 <code>using</code> 指示的最近作用域的能力。</strong></p>
<p><code>using</code> 声明和 <code>using</code> 指示在作用域上的区别直接决定了它们工作方式的不同。对于 <code>using</code> 声明来说，我们只是简单地令名字在局部作用域内有效。相反，<code>using</code> 指示是令整个命名空间的所有内容变得有效。通常情况下，命名空间中会含有一些不能出现在局部作用域中的定义，因此，<code>using</code> 指示一般被看作是出现在最近的外层作用域中。</p>
<p>在最简单的情况下，假定我们有一个命名空间 <code>A</code> 和一个函数 <code>f</code>，它们都定义在全局作用域中。如果 <code>f</code> 含有一个对 <code>A</code> 的 <code>using</code> 指示，则在 <code>f</code> 看来，<code>A</code> 中的名字仿佛是出现在全局作用域中 <code>f</code> 之前的位置一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 命名空间 A 和函数 f 定义在全局作用域中</span></span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> A;     <span class="comment">// 把 A 中的名字注入到全局作用域中</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i * j &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 使用命名空间 A 中的 i 和 j</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个简单的示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> blip &#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">16</span>, j = <span class="number">15</span>, k = <span class="number">23</span>;</span><br><span class="line"><span class="comment">// 其他声明</span></span><br><span class="line">&#125; <span class="comment">// namespace blip</span></span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>; <span class="comment">// 正确：blip 的 j 隐藏在命名空间中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// using 指示，blip 中的名字被“添加”到全局作用域中</span></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> blip; <span class="comment">// 如果使用了 j，则将在 ::j 和 blip::j 之间产生冲突</span></span><br><span class="line">    ++i;                  <span class="comment">// 将 blip::i 设定为 17</span></span><br><span class="line">    ++j;                  <span class="comment">// 二义性错误：是全局的 j 还是 blip::j？</span></span><br><span class="line">    ++::j;                <span class="comment">// 正确：全局的 j 设定为 1</span></span><br><span class="line">    ++blip::j;            <span class="comment">// 正确：将 blip::j 设定为 16</span></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">97</span>;           <span class="comment">// 当前局部的 k 隐藏了 blip::k</span></span><br><span class="line">    ++k;                  <span class="comment">// 将当前局部的 k 设定为 98</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>manip</code> 的 <code>using</code> 指示使得程序可以直接访问 <code>blip</code> 的所有名字，也就是说，<code>manip</code> 的代码可以使用 <code>blip</code> 中名字的简写形式。</p>
<p><strong><code>blip</code> 的成员看起来好像是定义在 <code>blip</code> 和 <code>manip</code> 所在的作用域一样。假定 <code>manip</code> 定义在全局作用域中，则 <code>blip</code> 的成员也好像是定义在全局作用域中一样。</strong></p>
<p>当命名空间被注入到它的外层作用域之后，很有可能该命名空间中定义的名字会与其外层作用域中的成员冲突。例如在 <code>manip</code> 中，<code>blip</code> 的成员 <code>j</code> 就与全局作用域中的 <code>j</code> 产生了冲突。这种冲突是允许存在的，但是要想使用冲突的名字，我们就必须明确指出名字的版本。<code>manip</code> 中所有未加限定的 <code>j</code> 都会产生二义性错误。</p>
<p>为了使用像这样的名字，我们必须使用作用域运算符来明确指出所需的版本。我们使用 <code>::j</code> 来表示定义在全局作用域中的 <code>j</code>，而使用 <code>blip::j</code> 来表示定义在 <code>blip</code> 中的 <code>j</code>。</p>
<p>因为 <code>manip</code> 的作用域和命名空间的作用域不同，所以 <code>manip</code> 内部的声明可以隐藏命名空间中的某些成员名字。例如，局部变量 <code>k</code> 隐藏了命名空间的成员 <code>blip::k</code>。在 <code>manip</code> 内使用 <code>k</code> 不存在二义性，它指的就是局部变量 <code>k</code>。</p>
</li>
<li><p><strong>头文件如果在其顶层作用域中含有 <code>using</code> 指示或 <code>using</code> 声明，则会将名字注入到所有包含了该头文件的文件中。</strong> 通常情况下，头文件应该只负责定义接口部分的名字，而不定义实现部分的名字。因此，头文件最多只能在它的函数或命名空间内使用 <code>using</code> 指示或 <code>using</code> 声明。</p>
</li>
<li><blockquote>
<p><strong>提示：避免 <code>using</code> 指示。</strong> <code>using</code> 指示一次性注入某个命名空间的所有名字，这种用法看似简单实则充满了风险：只使用一条语句就突然将命名空间中所有成员的名字变得可见了。如果应用程序使用了多个不同的库，而这些库中的名字通过 <code>using</code> 指示变得可见，则全局命名空间污染的问题将重新出现。<br>而且，当引入库的新版本后，正在工作的程序很可能会编译失败。如果新版本引入了一个与应用程序正在使用的名字冲突的名字，就会出现这个问题。<br>另一个风险是<strong>由 <code>using</code> 指示引发的二义性错误只有在使用了冲突名字的地方才能被发现。这种延后的检测意味着可能在特定库引入很久之后才爆发冲突。直到程序开始使用该库的新部分后，之前一直未被检测到的错误才会出现。</strong><br>相比于使用 <code>using</code> 指示，在程序中对命名空间的每个成员分别使用 <code>using</code> 声明效果更好，这么做可以减少注入到命名空间中的名字数量。<code>using</code> 声明引起的二义性问题在声明处就能发现，无须等到使用名字的地方，这显然对检测并修改错误大有益处。</p>
<p><strong>Tip：</strong> <code>using</code> 指示也并非一无是处，例如在命名空间本身的实现文件中就可以使用 <code>using</code> 指示。</p>
</blockquote>
</li>
</ol>
<h2 id="18-2-3-类、命名空间与作用域" class="heading-control"><a href="#18-2-3-类、命名空间与作用域" class="headerlink" title="18.2.3 类、命名空间与作用域"></a>18.2.3 类、命名空间与作用域<a class="heading-anchor" href="#18-2-3-类、命名空间与作用域" aria-hidden="true"></a></h2><ol>
<li><p><strong>对命名空间内部名字的查找遵循常规的查找规则：即由内向外依次查找每个外层作用域。</strong> 外层作用域也可能是一个或多个嵌套的命名空间，直到最外层的全局命名空间查找过程终止。<strong>只有位于开放的块中且在使用点之前声明的名字才被考虑</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">namespace</span> B &#123;</span><br><span class="line"><span class="keyword">int</span> i; <span class="comment">// 在 B 中隐藏了 A::i</span></span><br><span class="line"><span class="keyword">int</span> j;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;    <span class="comment">// j 是 f1 的局部变量，隐藏了 A::B::j</span></span><br><span class="line">    <span class="keyword">return</span> i; <span class="comment">// 返回 B::i</span></span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="comment">// namespace B</span></span><br><span class="line"><span class="comment">// 命名空间 B 结束，此后 B 中定义的名字不再可见</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> j; <span class="comment">// 错误：j 没有被定义</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">// 用 A::i 进行初始化</span></span><br><span class="line">&#125; <span class="comment">// namespace A</span></span><br></pre></td></tr></table></figure>
<p><strong>对于位于命名空间中的类来说，常规的查找规则仍然适用：当成员函数使用某个名字时，首先在该成员中进行查找，然后在类中查找（包括基类），接着在外层作用域中查找，这时一个或几个外层作用域可能就是命名空间</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    C1() : i(<span class="number">0</span>), j(<span class="number">0</span>) &#123;&#125;   <span class="comment">// 正确：初始化 C1::i 和 C1::j</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> k; &#125; <span class="comment">// 返回 A::k</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> h; &#125; <span class="comment">// 错误：h 未定义</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">f3</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// 在 c1 中隐藏了 A::i</span></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> h = i; <span class="comment">// 用 A::i 进行初始化</span></span><br><span class="line">&#125; <span class="comment">// namespace A</span></span><br><span class="line"><span class="comment">// 成员 f3 定义在 C1 和命名空间 A 的外部</span></span><br><span class="line"><span class="keyword">int</span> A::C1::f3() &#123; <span class="keyword">return</span> h; &#125; <span class="comment">// 正确：返回 A::h</span></span><br></pre></td></tr></table></figure>
<p><strong>除了类内部出现的成员函数定义之外，总是向上查找作用域。名字必须先声明后使用</strong>，因此 <code>f2</code> 的 <code>return</code> 语句无法通过编译。该语句试图使用命名空间 <code>A</code> 的名字 <code>h</code>，但此时 <code>h</code> 尚未定义。如果 <code>h</code> 在 <code>A</code> 中定义的位置位于 <code>C1</code> 的定义之前，则上述语句将合法。类似的，因为 <code>f3</code> 的定义位于 <code>A::h</code> 之后，所以 <code>f3</code> 对于 <code>h</code> 的使用是合法的。</p>
<blockquote>
<p><strong>Tip：</strong> 可以从函数的限定名推断出查找名字时检查作用域的次序，限定名以相反次序指出被查找的作用域。</p>
</blockquote>
<p>限定符 <code>A::C1::f3</code> 指出了查找类作用域和命名空间作用域的相反次序。首先查找函数 <code>f3</code> 的作用域，然后查找外层类 <code>C1</code> 的作用域，最后检查命名空间 <code>A</code> 的作用域以及包含着 <code>f3</code> 定义的作用域。</p>
</li>
<li><p>考虑下面的程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; s;</span><br></pre></td></tr></table></figure>
<p>该调用等价于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::<span class="built_in">cin</span>, s);</span><br></pre></td></tr></table></figure>
<p><code>operator&gt;&gt;</code> 函数定义在标准库 <code>string</code> 中，<code>string</code> 又定义在命名空间 <code>std</code> 中。但是我们不用 <code>std::</code> 限定符和 <code>using</code> 声明就可以调用 <code>operator&gt;&gt;</code>。</p>
<p><strong>对于命名空间中名字的隐藏规则来说有一个重要的例外，它使得我们可以直接访问输出运算符。这个例外是，当我们给函数传递一个类类型的对象时，除了在常规的作用域查找外还会查找实参类所属的命名空间。这一例外对于传递类的引用或指针的调用同样有效。</strong></p>
<p>在此例中，当编译器发现对 <code>operator&gt;&gt;</code> 的调用时，首先在当前作用域中寻找合适的函数，接着查找输出语句的外层作用域。随后，因为 <code>&gt;&gt;</code> 表达式的形参是类类型的，所以编译器还会查找 <code>cin</code> 和 <code>s</code> 的类所属的命名空间。也就是说，对于这个调用来说，编译器会查找定义了 <code>istream</code> 和 <code>string</code> 的命名空间 <code>std</code>。当在 <code>std</code> 中查找时，编译器找到了 <code>string</code> 的输出运算符函数。</p>
<p>查找规则的这个例外允许概念上作为类接口一部分的非成员函数无须单独的 <code>using</code> 声明就能被程序使用。假如该例外不存在，则我们将不得不为输出运算符专门提供一个 <code>using</code> 声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="keyword">operator</span>&gt;&gt;; <span class="comment">// 要想使用 cin &gt;&gt; s 就必须有该 using 声明</span></span><br></pre></td></tr></table></figure>
<p>或者使用函数调用的形式以把命名空间的信息包含进来：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="keyword">operator</span>&gt;&gt;(<span class="built_in">std</span>::<span class="built_in">cin</span>, s); <span class="comment">// 正确：显式地使用 std::&gt;&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通常情况下，如果在应用程序中定义了一个标准库中已有的名字，则将出现以下两种情况中的一种：要么根据一般的重载规则确定某次调用应该执行函数的哪个版本；要么应用程序根本就不会执行函数的标准库版本。</p>
<p><strong>标准库 <code>move</code> 和 <code>forward</code> 函数都是模板函数，在标准库的定义中它们都接受一个右值引用的函数形参。</strong> 如我们所知，<strong>在函数模板中，右值引用形参可以匹配任何类型</strong>。如果我们的应用程序也定义了一个接受单一形参的 <code>move</code> 函数，则不管该形参是什么类型，应用程序的 <code>move</code> 函数都将与标准库的版本冲突。<code>forward</code> 函数也是如此。因此，<code>move</code>（以及 <code>forward</code>）的名字冲突要比其他标准库函数的冲突频繁得多，建议最好使用它们的带限定语的完整版本。</p>
</li>
<li><p><strong>当类声明了一个友元时，该友元声明并没有使得友元本身可见。然而，一个另外的未声明的类或函数如果第一次出现在友元声明中，则我们认为它是最近的外层命名空间的成员。这条规则与实参相关的查找规则结合在一起将产生意想不到的效果</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 两个友元，在友元声明之外没有其他的声明</span></span><br><span class="line">    <span class="comment">// 这些函数隐式地成为命名空间 A 的成员</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;         <span class="comment">// 除非另有声明，否则不会被找到</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> C &amp;)</span></span>; <span class="comment">// 根据实参相关的查找规则可以被找到</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125; <span class="comment">// namespace A</span></span><br></pre></td></tr></table></figure>
<p><strong>此时，<code>f</code> 和 <code>f2</code> 都是命名空间 <code>A</code> 的成员。即使 <code>f</code> 不存在其他声明，我们也能通过实参相关的查找规则调用 <code>f</code></strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::C cobj;</span><br><span class="line">    f(cobj); <span class="comment">// 正确：通过在 A::C 中的友元声明找到 A::f</span></span><br><span class="line">    f2();    <span class="comment">// 错误：A::f2 没有被声明</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>因为 <code>f</code> 接受一个类类型的实参，而且 <code>f</code> 在 <code>C</code> 所属的命名空间进行了隐式的声明，所以 <code>f</code> 能被找到。相反，因为 <code>f2</code> 没有形参，所以它无法被找到。</strong></p>
</li>
<li><p><strong>练习 18.18：</strong> 已知有下面的 <code>swap</code> 的典型定义，当 <code>mem1</code> 是一个 <code>string</code> 时程序使用 <code>swap</code> 的哪个版本？如果 <code>mem1</code> 是 <code>int</code> 呢？说明在这两种情况下名字查找的过程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T v1, T v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(v1.mem1, v2.mem1);</span><br><span class="line">    <span class="comment">// 交换类型 T 的其他成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>答：</strong><code>mem1</code> 是 <code>string</code> 时，使用 <a href="http://www.cplusplus.com/reference/string/string/swap/" target="_blank" rel="noopener"><code>std::string::swap</code></a>；<code>mem1</code> 时 <code>int</code> 时，使用 <a href="http://www.cplusplus.com/reference/algorithm/swap/" target="_blank" rel="noopener"><code>std::swap</code></a>。</p>
</li>
</ol>
<h2 id="18-2-4-重载与命名空间" class="heading-control"><a href="#18-2-4-重载与命名空间" class="headerlink" title="18.2.4 重载与命名空间"></a>18.2.4 重载与命名空间<a class="heading-anchor" href="#18-2-4-重载与命名空间" aria-hidden="true"></a></h2><ol>
<li><p>命名空间对函数的匹配过程有两方面的影响。其中一个影响非常明显：<strong><code>using</code> 声明或 <code>using</code> 指示能将某些函数添加到候选函数集。</strong></p>
</li>
<li><p><strong>对于接受类类型实参的函数来说，其名字查找将在实参类所属的命名空间中进行。这条规则对于我们如何确定候选函数集同样也有影响。我们将在每个实参类（以及实参类的基类）所属的命名空间中搜寻候选函数。在这些命名空间中所有与被调用函数同名的函数都将被添加到候选集当中，即使其中某些函数在调用语句处不可见也是如此</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NS &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span> <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">const</span> Quote &amp;)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">&#125; <span class="comment">// namespace NS</span></span><br><span class="line"><span class="comment">// Bulk_item 的基类声明在命名空间 NS 中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_item</span> :</span> <span class="keyword">public</span> NS::Quote &#123; <span class="comment">/* ... */</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Bulk_item book1;</span><br><span class="line">    display(book1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们传递给 <code>display</code> 的实参属于类类型 <code>Bulk_item</code>，因此该调用语句的候选函数不仅应该在调用语句所在的作用域中查找，而且也应该在 <code>Bulk_item</code> 及其基类 <code>Quote</code> 所属的命名空间中查找。命名空间 <code>NS</code> 中声明的函数 <code>display(const Quote&amp;)</code> 也将被添加到候选函数集当中。</p>
</li>
<li><p>要想理解 <code>using</code> 声明与重载之间的交互关系，必须首先明确一条：<strong><code>using</code> 声明语句声明的是一个名字，而非一个特定的函数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">using</span> <span class="title">NS::print</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 错误：不能指定形参列表</span></span><br><span class="line"><span class="keyword">using</span> NS::print;      <span class="comment">// 正确：using 声明只声明一个名字</span></span><br></pre></td></tr></table></figure>
<p><strong>当我们为函数书写 <code>using</code> 声明时，该函数的所有版本都被引入到当前作用域中。</strong></p>
<p><strong>一个 <code>using</code> 声明囊括了重载函数的所有版本以确保不违反命名空间的接口。</strong> 库的作者为某项任务提供了好几个不同的函数，允许用户选择性地忽略重载函数中的一部分但不是全部有可能导致意想不到的程序行为。</p>
<p><strong>一个 <code>using</code> 声明引入的函数将重载该声明语句所属作用域中已有的其他同名函数。如果 <code>using</code> 声明出现在局部作用域中，则引入的名字将隐藏外层作用域的相关声明。如果 <code>using</code> 声明所在的作用域中已经有一个函数与新引入的函数同名且形参列表相同，则该 <code>using</code> 声明将引发错误。除此之外，<code>using</code> 声明将为引入的名字添加额外的重载实例，并最终扩充候选函数集的规模。</strong></p>
</li>
<li><p><strong><code>using</code> 指示将命名空间的成员提升到外层作用域中，如果命名空间的某个函数与该命名空间所属作用域的函数同名，则命名空间的函数将被添加到重载集合中</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> libs_R_us &#123;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125; <span class="comment">// namespace libs_R_us</span></span><br><span class="line"><span class="comment">// 普通的声明</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 这个 using 指示把名字添加到 print 调用的候选函数集</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> libs_R_us;</span><br><span class="line"><span class="comment">// print 调用此时的候选函数包括:</span></span><br><span class="line"><span class="comment">// libs R_us 的 print(int)</span></span><br><span class="line"><span class="comment">// libs_R_us 的 print(double)</span></span><br><span class="line"><span class="comment">// 显式声明的 print(const std::string &amp;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fooBar</span><span class="params">(<span class="keyword">int</span> ival)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="string">"Value:"</span>); <span class="comment">// 调用全局函数 print(const string &amp;)</span></span><br><span class="line">    print(ival);     <span class="comment">// 调用 libs_R_us::print(int)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>与 <code>using</code> 声明不同的是，对于 <code>using</code> 指示来说，引入一个与已有函数形参列表完全相同的函数并不会产生错误。此时，只要我们指明调用的是命名空间中的函数版本还是当前作用域的版本即可。</strong></p>
</li>
<li><p><strong>如果存在多个 <code>using</code> 指示，则来自每个命名空间的名字都会成为候选函数集的一部分</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> AW &#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Primer &#123;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// using 指示从不同的命名空间中创建了一个重载函数集合</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> AW;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Primer;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">double</span> <span class="title">print</span><span class="params">(<span class="keyword">long</span> <span class="keyword">double</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    print(<span class="number">1</span>);   <span class="comment">// 调用 AW::print(int)</span></span><br><span class="line">    print(<span class="number">3.1</span>); <span class="comment">// 调用 Primer::print(double)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在全局作用域中，函数 <code>print</code> 的重载集合包括 <code>print(int)</code>、<code>print(double)</code> 和 <code>print(long double)</code>，尽管它们的声明位于不同作用域中，但它们都属于 <code>main</code> 函数中 <code>print</code> 调用的候选函数集。</p>
</li>
<li><p><strong>练习 18.20：</strong> 在下面的代码中，确定哪个函数与 <code>compute</code> 调用匹配。列出所有候选函数和可行函数，对于每个可行函数的实参与形参的匹配过程来说，发生了哪种类型转换？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> primerLib &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *)</span></span>;</span><br><span class="line">&#125; <span class="comment">// namespace primerLib</span></span><br><span class="line"><span class="keyword">using</span> primerLib::compute;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">double</span>, <span class="keyword">double</span> = <span class="number">3.4</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">compute</span><span class="params">(<span class="keyword">char</span> *, <span class="keyword">char</span> * = <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123; compute(<span class="number">0</span>); &#125;</span><br></pre></td></tr></table></figure>
<p>如果将 <code>using</code> 声明置于 <code>f</code> 函数中 <code>compute</code> 的调用点之前将发生什么情况？重新回答之前的那些问题。</p>
<p><strong>答：</strong> <code>primerLib</code> 和全局作用域中的五个 <code>compute</code> 函数都是候选函数，其中：<code>void primerLib::compute()</code> 不可行；<code>void primerLib::compute(const void *)</code> 可行，<code>0</code> 被转换为 <code>const void *</code>；<code>void compute(int)</code> 可行，为最优匹配；<code>void compute(double, double = 3.4)</code> 可行，<code>int</code> 被转换为 <code>double</code>；<code>void compute(char*, char* = 0)</code> 可行，<code>int</code> 被转换为 <code>char*</code>。</p>
<p>如果将 <code>using</code> 声明置于 <code>f</code> 函数中 <code>compute</code> 的调用点之前，则全局作用域中的三个 <code>compute</code> 函数被屏蔽，不可见，<code>primerLib</code> 中的两个 <code>compute</code> 函数是候选函数，其中：<code>void primerLib::compute()</code> 不可行；<code>void primerLib::compute(const void *)</code> 可行，<code>0</code> 被转换为 <code>const void *</code>。</p>
</li>
</ol>
<h1 id="18-3-多重继承与虚继承" class="heading-control"><a href="#18-3-多重继承与虚继承" class="headerlink" title="18.3 多重继承与虚继承"></a>18.3 多重继承与虚继承<a class="heading-anchor" href="#18-3-多重继承与虚继承" aria-hidden="true"></a></h1><ol>
<li><strong>多重继承</strong>（multiple inheritance）是指从多个直接基类中，产生派生类的能力。多重继承的派生类继承了所有父类的属性。</li>
</ol>
<h2 id="18-3-1-多重继承" class="heading-control"><a href="#18-3-1-多重继承" class="headerlink" title="18.3.1 多重继承"></a>18.3.1 多重继承<a class="heading-anchor" href="#18-3-1-多重继承" aria-hidden="true"></a></h2><ol>
<li><p>在派生类的派生列表中可以包含多个基类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">public</span> ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> :</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Endangered</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>每个基类包含一个可选的访问说明符。一如往常，如果访问说明符被忽略掉了，则关键字 <code>class</code> 对应的默认访问说明符是 <code>private</code>，关键字 <code>struct</code> 对应的是 <code>public</code>。</strong></p>
<p><strong>和只有一个基类的继承一样，多重继承的派生列表也只能包含已经被定义过的类，而且这些类不能是 <code>final</code> 的。对于派生类能够继承的基类个数，C++ 没有进行特殊规定；但是在某个给定的派生列表中，同一个基类只能出现一次。</strong></p>
</li>
<li><p>在多重继承关系中，派生类的对象包含有每个基类的子对象。如下图所示，在 <code>Panda</code> 对象中含有一个 <code>Bear</code> 部分（其中又含有一个 <code>ZooAnimal</code> 部分）、一个 <code>Endangered</code> 部分以及在 <code>Panda</code> 中声明的非静态数据成员。</p>
<p><img data-src="https://image.shipengx.com/Panda%20%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%A6%82%E5%BF%B5%E7%BB%93%E6%9E%84.png" alt="Panda 对象的概念结构"></p>
</li>
<li><p><strong>构造一个派生类的对象将同时构造并初始化它的所有基类子对象。与从一个基类进行的派生一样，多重继承的派生类的构造函数初始值也只能初始化它的直接基类</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 显式地初始化所有基类</span></span><br><span class="line">Panda::Panda(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit)</span><br><span class="line">    : Bear(name, onExhibit, <span class="string">"Panda"</span>),</span><br><span class="line">      Endangered(Endangered::critical)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 隐式地使用 Bear 的默认构造函数初始化 Bear 子对象</span></span><br><span class="line">Panda::Panda() : Endangered(Endangered::critical) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>派生类的构造函数初始值列表将实参分别传递给每个直接基类。其中<strong>基类的构造顺序与派生列表中基类的出现顺序保持一致，而与派生类构造函数初始值列表中基类的顺序无关</strong>。一个 <code>Panda</code> 对象按照如下次序进行初始化：</p>
<ul>
<li><code>ZooAnimal</code> 是整个继承体系的最终基类，<code>Bear</code> 是 <code>Panda</code> 的直接基类，<code>ZooAnimal</code> 是 <code>Bear</code> 的基类，所以首先初始化 <code>ZooAnimal</code>。</li>
<li>接下来初始化 <code>Panda</code> 的第一个直接基类 <code>Bear</code>。</li>
<li>然后初始化 <code>Panda</code> 的第二个直接基类 <code>Endangered</code>。</li>
<li>最后初始化 <code>Panda</code>。</li>
</ul>
</li>
<li><p><strong>在 C++11 新标准中，允许派生类从它的一个或几个基类中继承构造函数。但是如果从多个基类中继承了相同的构造函数（即形参列表完全相同），则程序将产生错误</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base1() = <span class="keyword">default</span>;</span><br><span class="line">    Base1(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base1(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Base2() = <span class="keyword">default</span>;</span><br><span class="line">    Base2(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;);</span><br><span class="line">    Base2(<span class="keyword">int</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 错误：D1 试图从两个基类中都继承 D1::D1(const string&amp;)</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1,</span><br><span class="line">            <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1; <span class="comment">// 从 Base1 继承构造函数</span></span><br><span class="line">    <span class="keyword">using</span> Base2::Base2; <span class="comment">// 从 Base2 继承构造函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>如果一个类从它的多个基类中继承了相同的构造函数，则这个类必须为该构造函数定义它自己的版本</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base1, <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">using</span> Base1::Base1; <span class="comment">// 从 Base1 继承构造函数</span></span><br><span class="line">    <span class="keyword">using</span> Base2::Base2; <span class="comment">// 从 Base2 继承构造函数</span></span><br><span class="line">    <span class="comment">// D2 必须自定义一个接受 string 的构造函数</span></span><br><span class="line">    D2(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s) : Base1(s), Base2(s) &#123;&#125;</span><br><span class="line">    D2() = <span class="keyword">default</span>; <span class="comment">// 一旦 D2 定义了它自己的构造函数，则必须出现</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>和往常一样，派生类的析构函数只负责清除派生类本身分配的资源，派生类的成员及基类都是自动销毁的。合成的析构函数体为空。</strong></p>
<p><strong>析构函数的调用顺序正好与构造函数相反</strong>，在我们的例子中，析构函数的调用顺序是 <code>~Panda</code>、<code>~Endangered</code>、<code>~Bear</code> 和 <code>~ZooAnimal</code>。</p>
</li>
<li><p><strong>与只有一个基类的继承一样，多重继承的派生类如果定义了自己的拷贝/赋值构造函数和赋值运算符，则必须在完整的对象上执行拷贝、移动或赋值操作。只有当派生类使用的是合成版本的拷贝、移动或赋值成员时，才会自动对其基类部分执行这些操作。在合成的拷贝控制成员中，每个基类分别使用自己的对应成员隐式地完成构造、赋值或销毁等工作。</strong></p>
</li>
<li><p><strong>练习 18.22：</strong> 已知存在如下所示的类的继承体系，其中每个类都定义了一个默认构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> :</span> <span class="keyword">public</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> :</span> <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Z</span> :</span> <span class="keyword">public</span> X, <span class="keyword">public</span> Y</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> C, <span class="keyword">public</span> z</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于下面的定义来说，构造函数的执行顺序是怎样的？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MI mi;</span><br></pre></td></tr></table></figure>
<p><strong>答：</strong> A，B，C，X，Y，Z，MI。</p>
</li>
</ol>
<h2 id="18-3-2-类型转换与多个基类" class="heading-control"><a href="#18-3-2-类型转换与多个基类" class="headerlink" title="18.3.2 类型转换与多个基类"></a>18.3.2 类型转换与多个基类<a class="heading-anchor" href="#18-3-2-类型转换与多个基类" aria-hidden="true"></a></h2><ol>
<li><p><strong>在只有一个基类的情况下，派生类的指针或引用能自动转换成一个可访问基类的指针或引用。多个基类的情况与之类似。我们可以令某个可访问基类的指针或引用直接指向一个派生类对象。</strong> 例如，一个 <code>ZooAnimal</code>、<code>Bear</code> 或 <code>Endangered</code> 类型的指针或引用可以绑定到 <code>Panda</code> 对象上：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接受 Panda 的基类引用的一系列操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Bear &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">highlight</span><span class="params">(<span class="keyword">const</span> Endangered &amp;)</span></span>;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;, <span class="keyword">const</span> ZooAnimal &amp;);</span><br><span class="line"><span class="function">Panda <span class="title">ying_yang</span><span class="params">(<span class="string">"ying_yang"</span>)</span></span>;</span><br><span class="line">print(ying_yang);          <span class="comment">// 把一个 Panda 对象传递给一个 Bear 的引用</span></span><br><span class="line">highlight(ying_yang);      <span class="comment">// 把一个 Panda 对象传递给一个 Endangered 的引用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ying_yang &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 把一个 Panda 对象传递给一个 ZooAnimal 的引用</span></span><br></pre></td></tr></table></figure>
<p><strong>编译器不会在派生类向基类的几种转换中进行比较和选择，因为在它看来转换到任意一种基类都一样好。</strong> 例如，如果存在如下所示的 <code>print</code> 重载形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Bear &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> Endangered &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>则通过 <code>Panda</code> 对象对不带前缀限定符的 <code>print</code> 函数进行调用将产生编译错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Panda <span class="title">ying_yang</span><span class="params">(<span class="string">"ying_yang"</span>)</span></span>;</span><br><span class="line">print(ying_yang); <span class="comment">// 二义性错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>与只有一个基类的继承一样，对象、指针和引用的静态类型决定了我们能够使用哪些成员。</strong> 如果我们使用一个 <code>ZooAnimal</code> 指针，则只有定义在 <code>ZooAnimal</code> 中的操作是可以使用的，<code>Panda</code> 接口中的 <code>Bear</code>、<code>Panda</code> 和 <code>Endangered</code> 特有的部分都不可见。类似的，一个 <code>Bear</code> 类型的指针或引用只能访问 <code>Bear</code> 及 <code>ZooAnimal</code> 的成员，一个 <code>Endangered</code> 的指针或引用只能访问 <code>Endangered</code> 的成员。</p>
<p>举个例子，已知我们的类已经定义了下表列出的<strong>虚函数</strong>，考虑下面的这些函数调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bear *pb = <span class="keyword">new</span> Panda(<span class="string">"ying_yang"</span>);</span><br><span class="line">pb-&gt;print();     <span class="comment">// 正确：Panda::print()，多态调用</span></span><br><span class="line">pb-&gt;cuddle();    <span class="comment">// 错误：不属于 Bear 的接口</span></span><br><span class="line">pb-&gt;highlight(); <span class="comment">// 错误：不属于 Bear 的接口</span></span><br><span class="line"><span class="keyword">delete</span> pb;       <span class="comment">// 正确：Panda::~Panda()，多态调用</span></span><br></pre></td></tr></table></figure>
<p>当我们通过 <code>Endangered</code> 的指针或引用访问一个 <code>Panda</code> 对象时，<code>Panda</code> 接口中 <code>Panda</code> 特有的部分以及属于 <code>Bear</code> 的部分都是不可见的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Endangered *pe = <span class="keyword">new</span> Panda(<span class="string">"ying_yang"</span>);</span><br><span class="line">pe-&gt;print();     <span class="comment">// 正确：Panda::print()，多态调用</span></span><br><span class="line">pe-&gt;toes();      <span class="comment">// 错误：不属于 Endangered 的接口</span></span><br><span class="line">pe-&gt;cuddle();    <span class="comment">// 错误：不属于 Endangered 的接口</span></span><br><span class="line">pe-&gt;highlight(); <span class="comment">// 正确：Panda::highlight()，多态调用</span></span><br><span class="line"><span class="keyword">delete</span> pe;       <span class="comment">// 正确：Panda::~Panda()，多态调用</span></span><br></pre></td></tr></table></figure>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;   font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;   font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-1wig{font-weight:bold;text-align:left;vertical-align:top}<br>.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-amwm" colspan="2"><center>在 ZooAnimal/Endangered 中定义的虚函数</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-1wig"><b>函数</b></td>
    <td class="tg-1wig"><b>含有自定义版本的类</b></td>
  </tr>
  <tr>
    <td class="tg-cly1" rowspan="4">print</td>
    <td class="tg-0lax">ZooAnimal::ZooAnimal</td>
  </tr>
  <tr>
    <td class="tg-0lax">Bear::Bear</td>
  </tr>
  <tr>
    <td class="tg-0lax">Endangered::Endangered</td>
  </tr>
  <tr>
    <td class="tg-0lax">Panda::Panda</td>
  </tr>
  <tr>
    <td class="tg-cly1" rowspan="2">highlight</td>
    <td class="tg-0lax">Endangered::Endangered</td>
  </tr>
  <tr>
    <td class="tg-0lax">Panda::Panda</td>
  </tr>
  <tr>
    <td class="tg-cly1" rowspan="2">toes</td>
    <td class="tg-0lax">Bear::Bear</td>
  </tr>
  <tr>
    <td class="tg-0lax">Panda::Panda</td>
  </tr>
  <tr>
    <td class="tg-0lax">cuddle</td>
    <td class="tg-0lax">Panda::Panda</td>
  </tr>
  <tr>
    <td class="tg-cly1" rowspan="2">析构函数</td>
    <td class="tg-0lax">ZooAnimal::ZooAnimal</td>
  </tr>
  <tr>
    <td class="tg-0lax">Endangered::Endangered</td>
  </tr>
</tbody>
</table>
</li>
<li><p><strong>练习 18.25：</strong> 假设我们有两个基类 <code>Base1</code> 和 <code>Base2</code>，它们各自定义了一个名为 <code>print</code> 的虚成员和一个虚析构函数。从这两个基类中我们派生出下面的类，它们都重新定义了 <code>print</code> 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">public</span> Base1</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">public</span> Base2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过下面的指针，指出在每个调用中分别使用了哪个函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base1 *pb1 = <span class="keyword">new</span> MI;</span><br><span class="line">Base2 *pb2 = <span class="keyword">new</span> MI;</span><br><span class="line">D1 *pd1 = <span class="keyword">new</span> MI;</span><br><span class="line">D2 *pd2 = <span class="keyword">new</span> MI;</span><br><span class="line"></span><br><span class="line">(a) pb1-&gt;print(); (b) pd1-&gt;print(); (c) pd2-&gt;print();</span><br><span class="line">(d) <span class="keyword">delete</span> pb2; (e) <span class="keyword">delete</span> pd1; (f) <span class="keyword">delete</span> pd2;</span><br></pre></td></tr></table></figure>
<p><strong>答：</strong>（a）、（b）、（c）：<code>MI::print</code>；（d）、（e）、（f）：<code>~MI</code>，<code>~D2</code>，<code>~Base2</code>，<code>~D1</code>，<code>~Base1</code>。</p>
</li>
</ol>
<h2 id="18-3-3-多重继承下的类作用域" class="heading-control"><a href="#18-3-3-多重继承下的类作用域" class="headerlink" title="18.3.3 多重继承下的类作用域"></a>18.3.3 多重继承下的类作用域<a class="heading-anchor" href="#18-3-3-多重继承下的类作用域" aria-hidden="true"></a></h2><ol>
<li><p>在只有一个基类的情况下，派生类的作用域嵌套在直接基类和间接基类的作用域中。<strong>查找过程沿着继承体系自底向上进行，直到找到所需的名字。派生类的名字将隐藏基类的同名成员。</strong></p>
<p><strong>在多重继承的情况下，相同的查找过程在所有直接基类中同时进行。如果名字在多个基类中都被找到，则对该名字的使用将具有二义性。</strong></p>
<p>在我们的例子中，如果我们通过 <code>Panda</code> 的对象、指针或引用使用了某个名字，则程序会并行地在 <code>Endangered</code> 和 <code>Bear</code>/<code>ZooAnimal</code> 这两棵子树中查找该名字。如果名字在超过一棵子树中被找到，则该名字的使用具有二义性。<strong>对于一个派生类来说，从它的几个基类中分别继承名字相同的成员是完全合法的，只不过在使用这个名字时必须明确指出它的版本。</strong></p>
<blockquote>
<p><strong>WARNING：当一个类拥有多个基类时，有可能出现派生类从两个或更多基类中继承了同名成员的情况。此时，不加前缀限定符直接使用该名字将引发二义性。</strong></p>
</blockquote>
</li>
<li><p>例如，如果 <code>ZooAnimal</code> 和 <code>Endangered</code> 都定义了名为 <code>max_weight</code> 的成员，并且 <code>Panda</code> 没有定义该成员，则下面的调用是错误的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> d = ying_yang.max_weight();</span><br></pre></td></tr></table></figure>
<p><code>Panda</code> 在派生的过程中拥有了两个名为 <code>max_weight</code> 的成员，这是完全合法的。<strong>派生仅仅是产生了潜在的二义性，只要 <code>Panda</code> 对象不调用 <code>max_weight</code> 函数就能避免二义性错误。另外，如果每次调用 <code>max_weight</code> 时都指出所调用的版本（<code>ZooAnimal::max_weight</code> 或者 <code>Endangered::max_weight</code>），也不会发生二义性。只有当要调用哪个函数含糊不清时程序才会出错。</strong></p>
<p>在上面的例子中，派生类继承的两个 <code>max_weight</code> 会产生二义性，这一点显而易见。一种更复杂的情况是，<strong>有时即使派生类继承的两个函数形参列表不同也可能发生错误。此外，即使 <code>max_weight</code> 在一个类中是私有的，而在另一个类中是公有的或受保护的同样也可能发生错误</strong>。最后一种情况，假如 <code>max_weight</code> 定义在 <code>Bear</code> 中而非 <code>ZooAnimal</code> 中，上面的程序仍然是错误的。<strong>和往常一样，先查找名字后进行类型检查。当编译器在两个作用域中同时发现了 <code>max_weight</code> 时，将直接报告一个调用二义性的错误。</strong></p>
<p><strong>要想避免潜在的二义性，最好的办法是在派生类中为该函数定义一个新版本。</strong> 例如，我们可以为 <code>Panda</code> 定义一个 <code>max_weight</code> 函数从而解决二义性问题：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Panda::max_weight</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::max(ZooAnimal::max_weight(), Endangered::max_weight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="18-3-4-虚继承" class="heading-control"><a href="#18-3-4-虚继承" class="headerlink" title="18.3.4 虚继承"></a>18.3.4 虚继承<a class="heading-anchor" href="#18-3-4-虚继承" aria-hidden="true"></a></h2><ol>
<li><p>尽管在派生列表中同一个基类只能出现一次，但实际上派生类可以多次继承同一个类。<strong>派生类可以通过它的两个直接基类分别继承同一个间接基类，也可以直接继承某个基类，然后通过另一个基类再一次间接继承该类。</strong></p>
<p>举个例子，IO 标准库的 <code>istream</code> 和 <code>ostream</code> 分别继承了一个共同的名为 <code>base_ios</code> 的抽象基类。该抽象基类负责保存流的缓冲内容并管理流的条件状态。<code>iostream</code> 是另外一个类，它从 <code>istream</code> 和 <code>ostream</code> 直接继承而来，可以同时读写流的内容。因为 <code>istream</code> 和 <code>ostream</code> 都继承自 <code>base_ios</code>，所以 <code>iostream</code> 继承了 <code>base_ios</code> 两次，一次是通过 <code>istream</code>，另一次是通过 <code>ostream</code>。</p>
<p><strong>在默认情况下，派生类中含有继承链上每个类对应的子部分。如果某个类在派生过程中出现了多次，则派生类中将包含该类的多个子对象。</strong></p>
<p>这种默认的情况对某些形如 <code>iostream</code> 的类显然是行不通的。一个 <code>iostream</code> 对象肯定希望在同一个缓冲区中进行读写操作，也会要求条件状态能同时反映输入和输出操作的情况。假如在 <code>iostream</code> 对象中真的包含了 <code>base_ios</code> 的两份拷贝，则上述的共享行为就无法实现了。</p>
<p>在 C++ 语言中我们通过<strong>虚继承</strong>（virtual inheritance）的机制解决上述问题。<strong>虚继承的目的是令某个类做出声明，承诺愿意共享它的基类。其中，共享的基类子对象称为虚基类（virtual base class）。在这种机制下，不论虚基类在继承体系中出现了多少次，在派生类中都只包含唯一一个共享的虚基类子对象。</strong></p>
</li>
<li><p>我们可以对 <code>Panda</code> 类进行修改，令其同时继承 <code>Bear</code> 和 <code>Raccoon</code>。此时，为了避免赋予 <code>Panda</code> 两份 <code>ZooAnimal</code> 的子对象，我们将 <code>Bear</code> 和 <code>Raccoon</code> 继承 <code>ZooAnimal</code> 的方式定义为虚继承。</p>
<p><img data-src="https://image.shipengx.com/Panda%20%E7%9A%84%E8%99%9A%E7%BB%A7%E6%89%BF%E5%B1%82%E6%AC%A1.png" alt="Panda 的虚继承层次"></p>
<p>观察这个新的继承体系，我们将发现虚继承的一个不太直观的特征：<strong>必须在虚派生的真实需求出现前就已经完成虚派生的操作。例如在我们的类中，当我们定义 <code>Panda</code> 时才出现了对虚派生的需求，但是如果 <code>Bear</code> 和 <code>Raccoon</code> 不是从 <code>ZooAnimal</code> 虚派生得到的，那么 <code>Panda</code> 的设计者就显得不太幸运了。</strong></p>
<p>在实际的编程过程中，位于中间层次的基类将其继承声明为虚继承一般不会带来什么问题。</p>
<blockquote>
<p><strong>Note：虚派生只影响从指定了虚基类的派生类中进一步派生出的类，它不会影响派生类本身。</strong></p>
</blockquote>
</li>
<li><p>我们<strong>指定虚基类的方式是在派生列表中添加关键字 <code>virtual</code></strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关键字 public 和 virtual 的顺序随意</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Raccoon</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bear</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> ZooAnimal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码我们将 <code>ZooAnimal</code> 定义为 <code>Raccoon</code> 和 <code>Bear</code> 的虚基类。</p>
<p><strong><code>virtual</code> 说明符表明了一种愿望，即在后续的派生类当中共享虚基类的同一份实例。至于什么样的类能够作为虚基类并没有特殊规定。</strong></p>
<p><strong>如果某个类指定了虚基类，则该类的派生仍按常规方式进行</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Panda</span> :</span> <span class="keyword">public</span> Bear, <span class="keyword">public</span> Raccoon, <span class="keyword">public</span> Endangered</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Panda</code> 通过 <code>Raccoon</code> 和 <code>Bear</code> 继承了 <code>ZooAnimal</code>，因为 <code>Raccoon</code> 和 <code>Bear</code> 继承 <code>ZooAnimal</code> 的方式都是虚继承，所以在 <code>Panda</code> 中只有一个 <code>ZooAnimal</code> 基类部分。（如果 <code>Raccoon</code> 和 <code>Bear</code> 中，一个是虚继承自 <code>ZooAnimal</code>，而另一个是常规继承自 <code>ZooAnimal</code> 呢？——博主注）</p>
</li>
<li><p><strong>不论基类是不是虚基类，派生类对象都能被可访问基类的指针或引用操作。</strong> 例如，下面这些从 <code>Panda</code> 向基类的类型转换都是合法的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">(<span class="keyword">const</span> Bear &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rummage</span><span class="params">(<span class="keyword">const</span> Raccoon &amp;)</span></span>;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;, <span class="keyword">const</span> ZooAnimal &amp;);</span><br><span class="line">Panda ying_yang;</span><br><span class="line">dance(ying_yang);   <span class="comment">// 正确：把一个 Panda 对象当成 Bear 传递</span></span><br><span class="line">rummage(ying_yang); <span class="comment">// 正确：把一个 Panda 对象当成 Raccoon 传递</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ying_yang;  <span class="comment">// 正确：把一个 Panda 对象当成 ZooAnimal 传递</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>因为在每个共享的虚基类中只有唯一一个共享的子对象，所以该基类的成员可以被直接访问，并且不会产生二义性。此外，如果虚基类的成员只被一条派生路径覆盖，则我们仍然可以直接访问这个被覆盖的成员。但是如果成员被多余一个基类覆盖，则一般情况下派生类必须为该成员自定义一个新的版本。</strong></p>
<p>例如，假定类 <code>B</code> 定义了一个名为 <code>x</code> 的成员，<code>D1</code> 和 <code>D2</code> 都是从 <code>B</code> 虚继承得到的，<code>D</code> 继承了 <code>D1</code> 和 <code>D2</code>，则在 <code>D</code> 的作用域中，<code>x</code> 通过 <code>D</code> 的两个基类都是可见的。如果我们通过 <code>D</code> 的对象使用 <code>x</code>，有三种可能性：</p>
<ul>
<li>如果在 <code>D1</code> 和 <code>D2</code> 中都没有 <code>x</code> 的定义，则 <code>x</code> 将被解析为 <code>B</code> 的成员，此时不存在二义性，一个 <code>D</code> 的对象只含有 <code>x</code> 的一个实例。</li>
<li>如果 <code>x</code> 是 <code>B</code> 的成员，同时是 <code>D1</code> 和 <code>D2</code> 中某一个的成员，则同样没有二义性，<strong>派生类的 <code>x</code> 比共享虚基类 <code>B</code> 的 <code>x</code> 优先级更高</strong>。</li>
<li>如果在 <code>D1</code> 和 <code>D2</code> 中都有 <code>x</code> 的定义，则直接访问 <code>x</code> 将产生二义性问题。</li>
</ul>
<p><strong>与非虚的多重继承体系一样，解决这种二义性问题最好的方法是在派生类中为成员自定义新的实例。</strong></p>
</li>
<li><p><strong>练习 18.28：</strong> 已知存在如下的继承体系，在 <code>VMI</code> 类的内部哪些继承而来的成员无须前缀限定符就能直接访问？哪些必须有限定符才能访问？说明你的原因。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 默认情况下是公有的</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">char</span>)</span></span>; <span class="comment">// 默认情况下是公有的</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">char</span> cval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 默认情况下是公有的</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> ival;</span><br><span class="line">    <span class="keyword">char</span> cval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VMI</span> :</span> <span class="keyword">public</span> Derived1, <span class="keyword">public</span> Derived2</span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>答：</strong> <code>bar</code> 和 <code>ival</code> 可以不加限定地访问：<code>bar</code> 在共享基类 <code>Base</code> 和派生类 <code>Derived1</code> 中都存在，但这只是在一条派生路径上，特定派生类实例的优先级高于共享基类实例，所以在 <code>VMI</code> 类内部不加限定地访问 <code>bar</code>，访问到的是 <code>Derived1</code> 中的 <code>bar</code> 实例。<code>ival</code> 在共享基类 <code>Base</code> 和派生类 <code>Derived2</code> 中都存在，同理，在 <code>VMI</code> 类内部不加限定地访问 <code>ival</code>，访问到的是 <code>Derived2</code> 中的 <code>ival</code> 实例。</p>
<p><code>foo</code> 和 <code>cval</code> 需要限定：二者在 <code>Derived1</code> 和 <code>Derived2</code> 中都存在，<code>Derived1</code> 和 <code>Derived2</code> 均为 <code>Base</code> 的派生类，访问优先级相同，所以，在 <code>VMI</code> 类内不加限定地访问 <code>foo</code> 和 <code>cval</code> 存在二义性。</p>
</li>
</ol>
<h2 id="18-3-5-构造函数与虚继承" class="heading-control"><a href="#18-3-5-构造函数与虚继承" class="headerlink" title="18.3.5 构造函数与虚继承"></a>18.3.5 构造函数与虚继承<a class="heading-anchor" href="#18-3-5-构造函数与虚继承" aria-hidden="true"></a></h2><ol>
<li><p><strong>在虚派生中，虚基类是由最低层的派生类初始化的。</strong> 以我们的程序为例，当创建 <code>Panda</code> 对象时，由 <code>Panda</code> 的构造函数独自控制 <code>ZooAnimal</code> 的初始化过程。</p>
<p>为了理解这一规则，我们不妨假设当以普通规则处理初始化任务时会发生什么情况。在此例中，虚基类将会在多条继承路径上被重复初始化。以 <code>ZooAnimal</code> 为例，如果应用普通规则，则 <code>Raccoon</code> 和 <code>Bear</code> 都会试图初始化 <code>Panda</code> 对象的 <code>ZooAnimal</code> 部分。</p>
<p>当然，继承体系中的每个类都可能在某个时刻成为“最低层的派生类”。只要我们能创建虚基类的派生类对象，该派生类的构造函数就必须初始化它的虚基类。例如在我们的继承体系中，当创建一个 <code>Bear</code>（或 <code>Raccoon</code>）的对象时，它已经位于派生的最低层，因此 <code>Bear</code>（或 <code>Raccoon</code>）的构造函数将直接初始化其 <code>ZooAnimal</code> 基类部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Bear::Bear(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit)</span><br><span class="line">    : ZooAnimal(name, onExhibit, <span class="string">"Bear"</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">Raccoon::Raccoon(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit)</span><br><span class="line">    : ZooAnimal(name, onExhibit, <span class="string">"Raccoon"</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>而当创建一个 <code>Panda</code> 对象时，<code>Panda</code> 位于派生的最低层并由它负责初始化共享的 <code>ZooAnimal</code> 基类部分。即使 <code>ZooAnimal</code> 不是 <code>Panda</code> 的直接基类，<code>Panda</code> 的构造函数也可以初始化 <code>ZooAnimal</code></strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Panda::Panda(<span class="built_in">std</span>::<span class="built_in">string</span> name, <span class="keyword">bool</span> onExhibit)</span><br><span class="line">    : ZooAnimal(name, onExhibit, <span class="string">"Panda"</span>),</span><br><span class="line">      Bear(name, onExhibit),</span><br><span class="line">      Raccoon(name, onExhibit),</span><br><span class="line">      Endangered(Endangered::critical),</span><br><span class="line">      sleeping_flag(<span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>含有虚基类的对象的构造顺序与一般的顺序稍有区别：首先使用提供给最低层派生类构造函数的初始值初始化该对象的虚基类子部分，接下来按照直接基类在派生列表中出现的次序依次对其进行初始化。</strong></p>
<p>例如，当我们创建一个 Panda 对象时：</p>
<ul>
<li>首先使用 <code>Panda</code> 的构造函数初始值列表中提供的初始值构造虚基类 <code>ZooAnimal</code> 部分。</li>
<li>接下来构造 <code>Bear</code> 部分。</li>
<li>然后构造 <code>Raccoon</code> 部分。</li>
<li>然后构造第三个直接基类 <code>Endangered</code>。</li>
<li>最后构造 <code>Panda</code> 部分。</li>
</ul>
<p><strong>如果 <code>Panda</code> 没有显式地初始化 <code>ZooAnimal</code> 基类，则 <code>ZooAnimal</code> 的默认构造函数将被调用。如果 <code>ZooAnimal</code> 没有默认构造函数，则代码将发生错误。</strong></p>
</li>
<li><blockquote>
<p><strong>Note：虚基类总是先于非虚基类构造，与它们在继承体系中的次序和位置无关。</strong></p>
</blockquote>
</li>
<li><p><strong>一个类可以有多个虚基类。此时，这些虚的子对象按照它们在派生列表中出现的顺序从左向右依次构造。</strong> 例如，在下面这个稍显杂乱的 <code>TeddyBear</code> 派生关系中有两个虚基类：<code>ToyAnimal</code> 是直接虚基类，<code>ZooAnimal</code> 是 <code>Bear</code> 的虚基类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Character</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BookCharacter</span> :</span> <span class="keyword">public</span> Character</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToyAnimal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TeddyBear</span> :</span> <span class="keyword">public</span> BookCharacter, <span class="keyword">public</span> Bear, <span class="keyword">public</span> <span class="keyword">virtual</span> ToyAnimal</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>编译器按照直接基类的声明顺序对其依次进行检查，以确定其中是否含有虚基类。如果有，则先构造虚基类，然后按照声明的顺序逐一构造其他非虚基类。</strong> 因此，要想创建一个 <code>TeddyBear</code> 对象，需要按照如下次序调用这些构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ZooAnimal();     <span class="comment">// Bear 的虚基类</span></span><br><span class="line">ToyAnimal();     <span class="comment">// 直接虚基类</span></span><br><span class="line">Character();     <span class="comment">// 第一个非虚基类的间接基类</span></span><br><span class="line">BookCharacter(); <span class="comment">// 第一个直接非虚基类</span></span><br><span class="line">Bear();          <span class="comment">// 第二个直接非虚基类</span></span><br><span class="line">TeddyBear();     <span class="comment">// 最低层的派生类</span></span><br></pre></td></tr></table></figure>
<p><strong>合成的拷贝和移动构造函数按照完全相同的顺序执行，合成的赋值运算符中的成员也按照该顺序赋值。和往常一样，对象的销毁顺序与构造顺序正好相反</strong>，首先销毁 <code>TeddyBear</code> 部分，最后销毁 <code>ZooAnimal</code> 部分。</p>
</li>
<li><p><strong>练习 18.29：</strong> 已知有如下所示的类继承关系：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Class</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> :</span> <span class="keyword">public</span> Class</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D1</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D2</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> :</span> <span class="keyword">public</span> D1, <span class="keyword">public</span> D2</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Final</span> :</span> <span class="keyword">public</span> MI, <span class="keyword">public</span> Class</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（a）当作用于一个 <code>Final</code> 对象时，构造函数和析构函数的执行次序分别是什么？</p>
<p><strong>答：</strong> 优先构造虚基类部分，所以构造函数执行次序为 <code>Class</code>，<code>Base</code>，<code>D1</code>，<code>D2</code>，<code>MI</code>，<code>Class</code>，<code>Final</code>；析构函数执行顺序相反。</p>
<p>（b）在一个 <code>Final</code> 对象中有几个 <code>Base</code> 部分？几个 <code>Class</code> 部分？</p>
<p><strong>答：</strong> 一个 <code>Base</code> 部分，两个 <code>Class</code> 部分。</p>
<p>（c）下面的哪些赋值运算将造成编译错误？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Base *pb; Class *pc; MI *pmi; D2 *pd2;</span><br><span class="line">(a) pb = <span class="keyword">new</span> Class; (b) pc = <span class="keyword">new</span> Final; (c) pmi = pb; (d) pd2 = pmi;</span><br></pre></td></tr></table></figure>
<p><strong>答：</strong> （a）错误，<code>Class</code> 是 <code>Base</code> 的基类，不能将基类指针转换为派生类指针；（b）错误，<code>Final</code> 中有两个 <code>Class</code> 部分，即 <code>Class</code> 是 <code>Final</code> 的二义基类；（c）错误，<code>Base</code> 是 <code>MI</code> 的基类，不能将基类指针转换为派生类指针；（d）正确。</p>
</li>
</ol>
<h1 id="小结" class="heading-control"><a href="#小结" class="headerlink" title="小结"></a>小结<a class="heading-anchor" href="#小结" aria-hidden="true"></a></h1><ol>
<li><p>异常处理使得我们可以将程序的错误检测部分与错误处理部分分隔开来。当程序抛出一个异常时，当前正在执行的函数暂时中止，开始查找最邻近的与异常匹配的 <code>catch</code> 语句。作为异常处理的一部分，如果查找 <code>catch</code> 语句的过程中退出了某些函数，则函数中定义的局部变量也随之销毁。</p>
</li>
<li><p>从概念上来说，多重继承非常简单：<strong>一个派生类可以从多个直接基类继承而来。在派生类对象中既包含派生类部分，也包含与每个基类对应的基类部分。</strong> 虽然看起来很简单，但实际上多重继承的细节非常复杂。特别是<strong>对多个基类的继承可能会引入新的名字冲突，并造成来自于基类部分的名字的二义性问题</strong>。</p>
<p><strong>如果一个类是从多个基类直接继承而来的，那么有可能这些基类本身又其享了另一个基类。在这种情况下，中间类可以选择使用虚继承，从而声明愿意与层次中虚继承同一基类的其他类共享虚基类。用这种方法，后代派生类中将只有一个共享虚基类的副本。</strong></p>
</li>
</ol>
<h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%AC%AC%2018%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%881%EF%BC%89.png" alt="第 18 章术语表（1）"></p>
<p><img data-src="https://image.shipengx.com/%E7%AC%AC%2018%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%882%EF%BC%89.png" alt="第 18 章术语表（2）"></p>
<p><img data-src="https://image.shipengx.com/%E7%AC%AC%2018%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%883%EF%BC%89.png" alt="第 18 章术语表（3）"></p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>Apollo 6.0 Perception 模块 Fusion 组件（二）：主体算法流程分析</title>
    <url>/archives/46155f38.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%9B%AE%E5%BD%95-Apollo%206.0%20Perception%20%E6%A8%A1%E5%9D%97%20Fusion%20%E7%BB%84%E4%BB%B6%E4%B8%BB%E4%BD%93%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90.png" alt="目录-Apollo 6.0 Perception 模块 Fusion 组件主体算法流程分析"></p>
<h1 id="0-前言" class="heading-control"><a href="#0-前言" class="headerlink" title="0 前言"></a>0 前言<a class="heading-anchor" href="#0-前言" aria-hidden="true"></a></h1><p>Apollo 框架中，每个功能组件都对应一个继承自 <code>Component</code> 类的具体组件类，具体组件类中都包含 <code>public</code> 的 <code>Init</code> 方法和 <code>Proc</code> 方法，<code>Init</code> 方法实现了组件的初始化，<code>Proc</code> 方法实现了组件的具体算法流程。</p>
<p>Perception 模块 Fusion 组件的具体组件类为 <code>FusionComponent</code>，从上一篇文章<a href="https://blog.shipengx.com/archives/e8e6ccc3.html">《Apollo 6.0 Perception 模块 Fusion 组件（一）：构建与启动流程分析》</a>中我们已经知道，Fusion 组件的 <code>FusionComponent</code> 类的 <code>Init</code> 方法最终会在 <code>Component</code> 类的 <code>Initialize</code> 方法中被多态调用一次，而 <code>FusionComponent</code> 类的 <code>Proc</code> 方法将成为 Fusion 组件对应 channel 上的消息回调函数（意即，收到一帧消息触发一次）。</p>
<p>本文将以 Apollo 6.0 源码 <code>master</code> 分支上的 <code>74f7d1a429</code> 提交为基础详细分析 Perception 模块 Fusion 组件的初始化、消息回调处理以及障碍物融合的主体算法框架，至于前景航迹融合的算法细节将在后续的文章中单独讲述。</p>
<h1 id="1-Fusion-组件成员组成" class="heading-control"><a href="#1-Fusion-组件成员组成" class="headerlink" title="1 Fusion 组件成员组成"></a>1 Fusion 组件成员组成<a class="heading-anchor" href="#1-Fusion-组件成员组成" aria-hidden="true"></a></h1><p>首先，打开 <code>apollo/modules/perception/onboard/component/fusion_component.h</code> 看看 <code>FusionComponent</code> 类中由哪些数据成员和方法成员构成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FusionComponent</span> :</span> <span class="keyword">public</span> cyber::Component&lt;SensorFrameMessage&gt; &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  ~FusionComponent() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Init</span><span class="params">()</span> <span class="keyword">override</span></span>;  <span class="comment">// 由 Cyber RT 在启动组件过程中进行间接调用，只会执行一次</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Proc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt;&amp; message)</span> <span class="keyword">override</span></span>;  <span class="comment">// 由 Cyber RT 在启动组件过程中注册为消息回调函数</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InitAlgorithmPlugin</span><span class="params">()</span></span>;  <span class="comment">// 组件内部的初始化方法，由 Init 方法进行调用</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">InternalProc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage <span class="keyword">const</span>&gt;&amp; in_message,  <span class="comment">// 组件内部的消息处理方法，具体算法流程入口，由 Proc 方法进行调用</span></span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PerceptionObstacles&gt; out_message,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; viz_message)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::mutex s_mutex_;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">uint32_t</span> s_seq_num_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_name_;  <span class="comment">// 融合名称</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> fusion_method_;  <span class="comment">// 融合方法</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; fusion_main_sensors_;  <span class="comment">// 融合主传感器</span></span><br><span class="line">  <span class="keyword">bool</span> object_in_roi_check_ = <span class="literal">false</span>;  <span class="comment">// 是否开启 HD Map ROI 融合障碍物校验</span></span><br><span class="line">  <span class="keyword">double</span> radius_for_roi_object_check_ = <span class="number">0</span>;  <span class="comment">// HD Map ROI 融合障碍物校验半径</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;fusion::BaseMultiSensorFusion&gt; fusion_;  <span class="comment">// 独占智能指针，用于管理多传感器融合抽象基类对象，最为关键的数据成员</span></span><br><span class="line">  <span class="built_in">map</span>::HDMapInput* hdmap_input_ = <span class="literal">nullptr</span>;  <span class="comment">// HD Map 输入</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;PerceptionObstacles&gt;&gt; writer_;  <span class="comment">// Cyber Writer 对象，用于输出 protobuf 格式的经 HD Map ROI 校验过的有效融合障碍物信息</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;apollo::cyber::Writer&lt;SensorFrameMessage&gt;&gt; inner_writer_;  <span class="comment">// Cyber Writer 对象，用于输出可视化信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里需要先着重提下 <code>std::unique_ptr&lt;fusion::BaseMultiSensorFusion&gt; fusion_</code> 这个数据成员，<code>fusion_</code> 是个独占智能指针，用于管理 <code>BaseMultiSensorFusion</code> 类型的对象，<code>BaseMultiSensorFusion</code> 是多传感器融合的抽象基类，会被表示障碍物多传感器融合的 <code>ObstacleMultiSensorFusion</code> 类所继承并实现对应纯虚接口方法。<code>fusion_</code> 中的指针值会在 <code>FusionComponent::InitAlgorithmPlugin</code> 方法中被更新为工厂方法（Factory Method）模式返回的 <code>ObstacleMultiSensorFusion</code> 指针，后文中将对此进行详述。</p>
<p>再来看下 Perception 模块整个 Fusion 组件的 UML 类图：</p>
<p><img data-src="https://image.shipengx.com/Perception%20%E6%A8%A1%E5%9D%97%20Fusion%20%E7%BB%84%E4%BB%B6%20UML%20%E7%B1%BB%E5%9B%BE.png" alt="Perception 模块 Fusion 组件 UML 类图"></p>
<p><code>I</code> 表示由抽象基类实现的接口（Interface）类 ，通常情况下不会对接口类进行实例化；<code>C</code> 表示对接口类的具体实现。</p>
<h1 id="2-初始化" class="heading-control"><a href="#2-初始化" class="headerlink" title="2 初始化"></a>2 初始化<a class="heading-anchor" href="#2-初始化" aria-hidden="true"></a></h1><h2 id="2-1-对外的初始化接口：FusionComponent-Init-方法" class="heading-control"><a href="#2-1-对外的初始化接口：FusionComponent-Init-方法" class="headerlink" title="2.1 对外的初始化接口：FusionComponent::Init 方法"></a>2.1 对外的初始化接口：FusionComponent::Init 方法<a class="heading-anchor" href="#2-1-对外的初始化接口：FusionComponent-Init-方法" aria-hidden="true"></a></h2><p>打开 <code>apollo/modules/perception/onboard/component/fusion_component.cc</code>，我们看下 <code>FusionComponent</code> 类 <code>Init</code> 方法的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FusionComponent::Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FusionComponentConfig comp_config;  <span class="comment">// 实例化配置参数 protobuf 类：fusion_component_config.proto</span></span><br><span class="line">  <span class="keyword">if</span> (!GetProtoConfig(&amp;comp_config)) &#123;  <span class="comment">// 将 txt 配置文件中的配置参数读入 protobuf 类：fusion_component_conf.pb.txt</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Fusion Component Configs: "</span> &lt;&lt; comp_config.DebugString();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// to load component configs</span></span><br><span class="line">  fusion_name_ = comp_config.fusion_name();  <span class="comment">// 融合名称：ObstacleMultiSensorFusion</span></span><br><span class="line">  fusion_method_ = comp_config.fusion_method();  <span class="comment">// 融合方法：ProbabilisticFusion</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; comp_config.fusion_main_sensors_size(); ++i) &#123;  <span class="comment">// 融合主传感器：velodyne128，front_6mm，front_12mm</span></span><br><span class="line">    fusion_main_sensors_.push_back(comp_config.fusion_main_sensors(i));</span><br><span class="line">  &#125;</span><br><span class="line">  object_in_roi_check_ = comp_config.object_in_roi_check();  <span class="comment">// 是否开启 HD Map ROI 融合障碍物校验：true</span></span><br><span class="line">  radius_for_roi_object_check_ = comp_config.radius_for_roi_object_check();  <span class="comment">// HD Map ROI 融合障碍物校验半径：120m</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// init algorithm plugin</span></span><br><span class="line">  ACHECK(InitAlgorithmPlugin()) &lt;&lt; <span class="string">"Failed to init algorithm plugin."</span>;  <span class="comment">// 调用私有初始化方法 InitAlgorithmPlugin，执行更详细的初始化动作</span></span><br><span class="line">  writer_ = node_-&gt;CreateWriter&lt;PerceptionObstacles&gt;(</span><br><span class="line">      comp_config.output_obstacles_channel_name());  <span class="comment">// 用于输出 protobuf 格式的经 HD Map ROI 校验过的有效融合障碍物信息：perception_obstacle.proto</span></span><br><span class="line">  inner_writer_ = node_-&gt;CreateWriter&lt;SensorFrameMessage&gt;(</span><br><span class="line">      comp_config.output_viz_fused_content_channel_name());  <span class="comment">// 用于输出供可视化的高精地图和融合障碍物信息</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Fusion 组件的 <code>txt</code> 配置文件为 <code>apollo/modules/perception/production/conf/perception/fusion/fusion_component_conf.pb.txt</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fusion_name: &quot;ObstacleMultiSensorFusion&quot;</span><br><span class="line">fusion_method: &quot;ProbabilisticFusion&quot;</span><br><span class="line">fusion_main_sensors: &quot;velodyne128&quot;</span><br><span class="line">fusion_main_sensors: &quot;front_6mm&quot;</span><br><span class="line">fusion_main_sensors: &quot;front_12mm&quot;</span><br><span class="line">object_in_roi_check: true</span><br><span class="line">radius_for_roi_object_check: 120</span><br><span class="line">output_obstacles_channel_name: &quot;&#x2F;perception&#x2F;vehicle&#x2F;obstacles&quot;</span><br><span class="line">output_viz_fused_content_channel_name: &quot;&#x2F;perception&#x2F;inner&#x2F;visualization&#x2F;FusedObjects&quot;</span><br></pre></td></tr></table></figure>
<p>从配置参数中可以看出，Fusion 组件会融合来自 128 线 velodyne 激光雷达、6mm 焦距前视相机和 12mm 焦距前视相机三个传感器的障碍物消息。两个输出消息通道分别为：</p>
<ul>
<li><code>/perception/vehicle/obstacles</code>：输出融合障碍物信息</li>
<li><code>/perception/inner/visualization/FusedObjects</code>：输出可视化信息</li>
</ul>
<p><code>FusionComponentConfig</code> 是一个 protobuf 类，用于存放从 Fusion 组件 <code>txt</code> 配置文件中读入的配置参数，它对应的 proto 文件为 <code>apollo/modules/perception/onboard/proto/fusion_component_config.proto</code>。</p>
<h2 id="2-2-内部的初始化接口：FusionComponent-InitAlgorithmPlugin-方法" class="heading-control"><a href="#2-2-内部的初始化接口：FusionComponent-InitAlgorithmPlugin-方法" class="headerlink" title="2.2 内部的初始化接口：FusionComponent::InitAlgorithmPlugin 方法"></a>2.2 内部的初始化接口：FusionComponent::InitAlgorithmPlugin 方法<a class="heading-anchor" href="#2-2-内部的初始化接口：FusionComponent-InitAlgorithmPlugin-方法" aria-hidden="true"></a></h2><p><code>Init</code> 方法中会调用 <code>InitAlgorithmPlugin</code> 方法，我们看下它的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FusionComponent::InitAlgorithmPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  fusion::BaseMultiSensorFusion* fusion =</span><br><span class="line">    fusion::BaseMultiSensorFusionRegisterer::GetInstanceByName(fusion_name_);  <span class="comment">// 通过工厂方法模式获取 ObstacleMultiSensorFusion 类的实例指针</span></span><br><span class="line">  CHECK_NOTNULL(fusion);</span><br><span class="line">  fusion_.reset(fusion);  <span class="comment">// 更新 fusion_ 的指针值为 ObstacleMultiSensorFusion 类实例指针</span></span><br><span class="line">  fusion::ObstacleMultiSensorFusionParam param;  <span class="comment">// 障碍物多传感器融合参数</span></span><br><span class="line">  param.main_sensors = fusion_main_sensors_;  <span class="comment">// 障碍物多传感器融合参数——主传感器：velodyne128，front_6mm，front_12mm</span></span><br><span class="line">  param.fusion_method = fusion_method_;  <span class="comment">// 障碍物多传感器融合参数——融合方法：ProbabilisticFusion</span></span><br><span class="line">  ACHECK(fusion_-&gt;Init(param)) &lt;&lt; <span class="string">"Failed to init ObstacleMultiSensorFusion"</span>;  <span class="comment">// 多态调用 ObstacleMultiSensorFusion::Init 方法，执行主要的初始化动作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAGS_obs_enable_hdmap_input &amp;&amp; object_in_roi_check_) &#123;</span><br><span class="line">    hdmap_input_ = <span class="built_in">map</span>::HDMapInput::Instance();  <span class="comment">// 获取 map::HDMapInput 的唯一实例，这是一个单例类</span></span><br><span class="line">    ACHECK(hdmap_input_-&gt;Init()) &lt;&lt; <span class="string">"Failed to init hdmap input."</span>;  <span class="comment">// 初始化 HD Map</span></span><br><span class="line">  &#125;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Init algorithm successfully, onboard fusion: "</span> &lt;&lt; fusion_method_;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InitAlgorithmPlugin</code> 方法主要做了三件事：</p>
<ul>
<li>通过工厂方法模式获取 <code>ObstacleMultiSensorFusion</code> 类的实例指针</li>
<li>多态调用 <code>ObstacleMultiSensorFusion::Init</code> 方法，执行主要的初始化动作</li>
<li>获取 HD Map 的唯一实例，并执行初始化</li>
</ul>
<p>针对前两点我们会进行详细讨论，HD Map 部分不是本文重点。</p>
<h3 id="2-2-1-通过工厂方法模式获取-ObstacleMultiSensorFusion-类的实例指针" class="heading-control"><a href="#2-2-1-通过工厂方法模式获取-ObstacleMultiSensorFusion-类的实例指针" class="headerlink" title="2.2.1 通过工厂方法模式获取 ObstacleMultiSensorFusion 类的实例指针"></a>2.2.1 通过工厂方法模式获取 ObstacleMultiSensorFusion 类的实例指针<a class="heading-anchor" href="#2-2-1-通过工厂方法模式获取-ObstacleMultiSensorFusion-类的实例指针" aria-hidden="true"></a></h3><p><strong>工厂方法</strong>是一种创建型设计模式，与简单工厂（Simple Factory）、抽象工厂（Abstract Factory）一并称为工厂模式，关于三者的区别可以概括为：</p>
<ul>
<li>简单工厂：只有一个工厂，将不同产品的生产语句罗列到工厂的一个生产方法中，根据配置参数选择性生产具体的产品；</li>
<li>工厂方法：每种产品对应一个具体工厂，每个具体工厂负责生产对应的具体产品；</li>
<li>抽象工厂：将不同的产品根据相关性划分为多个产品族，每个产品族对应一个具体工厂，每个具体工厂中包含多个产品生产方法，用于生产对应产品族中的不同产品。</li>
</ul>
<p>关于工厂模式具体不作展开，可以查阅相关文章。Apollo 中使用了一种更加泛化和灵活的工厂方法，其泛化性和灵活性通过 <code>Any</code> 类和宏定义实现。</p>
<p>打开 <code>apollo/modules/perception/fusion/lib/interface/base_multisensor_fusion.h</code>，看下 <code>BaseMultiSensorFusion</code> 类的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseMultiSensorFusion</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BaseMultiSensorFusion() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="keyword">virtual</span> ~BaseMultiSensorFusion() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Init</span><span class="params">(<span class="keyword">const</span> ObstacleMultiSensorFusionParam&amp; param)</span> </span>= <span class="number">0</span>;  <span class="comment">// 初始化接口</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">Process</span><span class="params">(<span class="keyword">const</span> base::FrameConstPtr&amp; frame,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;* objects)</span> </span>= <span class="number">0</span>;  <span class="comment">// 处理接口</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">Name</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  DISALLOW_COPY_AND_ASSIGN(BaseMultiSensorFusion);  <span class="comment">// 禁止拷贝构造与拷贝赋值</span></span><br><span class="line">&#125;;  <span class="comment">// Class BaseMultiSensorFusion</span></span><br><span class="line"></span><br><span class="line">PERCEPTION_REGISTER_REGISTERER(BaseMultiSensorFusion);  <span class="comment">// 生成 BaseMultiSensorFusion 的客户端代码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERCEPTION_REGISTER_MULTISENSORFUSION(name) \</span></span><br><span class="line">  PERCEPTION_REGISTER_CLASS(BaseMultiSensorFusion, name)  <span class="comment">// 生成 name 具体产品的具体工厂类</span></span><br></pre></td></tr></table></figure>
<p>不难发现，<code>BaseMultiSensorFusion</code> 是一个抽象基类，其内部含有三个 <code>public</code> 的对外接口：<code>Init</code>、<code>Process</code> 和 <code>Name</code>，通过使用宏定义 <code>DISALLOW_COPY_AND_ASSIGN</code> 来禁止拷贝构造与拷贝赋值，<code>DISALLOW_COPY_AND_ASSIGN</code> 定义在 <code>apollo/cyber/common/macros.h</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISALLOW_COPY_AND_ASSIGN(classname) \</span></span><br><span class="line">  classname(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;    \</span><br><span class="line">  classname &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> classname &amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
<p>同时可以发现，<code>BaseMultiSensorFusion</code> 类定义的外面调用了一个宏定义 <code>PERCEPTION_REGISTER_REGISTERER</code>，并定义了一个新的宏定义 <code>PERCEPTION_REGISTER_MULTISENSORFUSION</code> 来间接调用另一个宏定义 <code>PERCEPTION_REGISTER_CLASS</code>。</p>
<p><code>PERCEPTION_REGISTER_REGISTERER</code> 用于生成工厂方法的客户端代码，<code>PERCEPTION_REGISTER_CLASS</code> 用于生成工厂方法的具体工厂类，它们都定义在 <code>apollo/modules/perception/lib/registerer/registerer.h</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> apollo &#123;</span><br><span class="line"><span class="keyword">namespace</span> perception &#123;</span><br><span class="line"><span class="keyword">namespace</span> lib &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idea from boost any but make it more simple and don't use type_info.</span></span><br><span class="line"><span class="comment">// 从 boost 库借鉴而来的 Any 类实现，可表示任意的抽象产品</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Any</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Any() : content_(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Any</span><span class="params">(<span class="keyword">const</span> ValueType &amp;value)</span></span></span><br><span class="line"><span class="function">      : <span class="title">content_</span><span class="params">(<span class="keyword">new</span> Holder&lt;ValueType&gt;(value))</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  Any(<span class="keyword">const</span> Any &amp;other)</span><br><span class="line">      : content_(other.content_ ? other.content_-&gt;Clone() : <span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~Any() &#123; <span class="keyword">delete</span> content_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line">  <span class="function">ValueType *<span class="title">AnyCast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> content_ ? &amp;(<span class="keyword">static_cast</span>&lt;Holder&lt;ValueType&gt; *&gt;(content_)-&gt;held_)</span><br><span class="line">                    : <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">PlaceHolder</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~PlaceHolder() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PlaceHolder *<span class="title">Clone</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ValueType&gt;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> :</span> <span class="keyword">public</span> PlaceHolder &#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Holder</span><span class="params">(<span class="keyword">const</span> ValueType &amp;value)</span> : <span class="title">held_</span><span class="params">(value)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Holder() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> PlaceHolder *<span class="title">Clone</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Holder(held_); &#125;</span><br><span class="line"></span><br><span class="line">    ValueType held_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  PlaceHolder *content_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用于生产任意抽象产品的抽象工厂类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectFactory</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  ObjectFactory() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~ObjectFactory() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Any <span class="title">NewInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Any(); &#125;  <span class="comment">// 产品生产接口</span></span><br><span class="line">  ObjectFactory(<span class="keyword">const</span> ObjectFactory &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  ObjectFactory &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> ObjectFactory &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, ObjectFactory *&gt; FactoryMap;  <span class="comment">// 派生类（具体产品）工厂指针映射</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, FactoryMap&gt; BaseClassMap;  <span class="comment">// 抽象基类（抽象产品）映射</span></span><br><span class="line"><span class="function">BaseClassMap &amp;<span class="title">GlobalFactoryMap</span><span class="params">()</span></span>;  <span class="comment">// 获取 static 的抽象基类映射</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 结合 BaseClassMap 和 FactoryMap 获取指定基类对应的所有派生类</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">GetRegisteredClasses</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;base_class_name,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; *registered_derived_classes_names)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;  <span class="comment">// namespace lib</span></span><br><span class="line">&#125;  <span class="comment">// namespace perception</span></span><br><span class="line">&#125;  <span class="comment">// namespace apollo</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端代码</span></span><br><span class="line"><span class="comment">// 为指定的抽象产品类生成一个注册器类，包含用于生产产品实例的静态方法</span></span><br><span class="line"><span class="comment">// 宏定义中，## 用于连接两个记号，# 用于将宏参数转换为字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERCEPTION_REGISTER_REGISTERER(base_class)                    \</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">base_class</span>##<span class="title">Registerer</span> &#123;</span>                                      \</span><br><span class="line">    <span class="keyword">typedef</span> ::apollo::perception::lib::Any Any;                       \</span><br><span class="line">    <span class="keyword">typedef</span> ::apollo::perception::lib::FactoryMap FactoryMap;         \</span><br><span class="line">                                                                      \</span><br><span class="line">   <span class="keyword">public</span>:                                                            \</span><br><span class="line">    <span class="function"><span class="keyword">static</span> base_class *<span class="title">GetInstanceByName</span><span class="params">(<span class="keyword">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span> </span>&#123; \</span><br><span class="line">      FactoryMap &amp;<span class="built_in">map</span> =                                               \</span><br><span class="line">          ::apollo::perception::lib::GlobalFactoryMap()[#base_class]; \</span><br><span class="line">      FactoryMap::iterator iter = <span class="built_in">map</span>.find(name);                     \</span><br><span class="line">      <span class="keyword">if</span> (iter == <span class="built_in">map</span>.end()) &#123;                                        \</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : <span class="built_in">map</span>) &#123;                                          \</span><br><span class="line">          AERROR &lt;&lt; <span class="string">"Instance:"</span> &lt;&lt; c.first;                           \</span><br><span class="line">        &#125;                                                             \</span><br><span class="line">        AERROR &lt;&lt; <span class="string">"Get instance "</span> &lt;&lt; name &lt;&lt; <span class="string">" failed."</span>;              \</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;                                               \</span><br><span class="line">      &#125;                                                               \</span><br><span class="line">      Any object = iter-&gt;second-&gt;NewInstance();                       \</span><br><span class="line">      <span class="keyword">return</span> *(object.AnyCast&lt;base_class *&gt;());                       \</span><br><span class="line">    &#125;                                                                 \</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base_class *&gt; <span class="title">GetAllInstances</span><span class="params">()</span> </span>&#123;              \</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base_class *&gt; instances;                            \</span><br><span class="line">      FactoryMap &amp;<span class="built_in">map</span> =                                               \</span><br><span class="line">          ::apollo::perception::lib::GlobalFactoryMap()[#base_class]; \</span><br><span class="line">      instances.reserve(<span class="built_in">map</span>.size());                                  \</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">auto</span> item : <span class="built_in">map</span>) &#123;                                         \</span><br><span class="line">        Any object = item.second-&gt;NewInstance();                      \</span><br><span class="line">        instances.push_back(*(object.AnyCast&lt;base_class *&gt;()));       \</span><br><span class="line">      &#125;                                                               \</span><br><span class="line">      <span class="keyword">return</span> instances;                                               \</span><br><span class="line">    &#125;                                                                 \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> ::<span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">GetUniqInstanceName</span><span class="params">()</span> </span>&#123;                \</span><br><span class="line">      FactoryMap &amp;<span class="built_in">map</span> =                                               \</span><br><span class="line">          ::apollo::perception::lib::GlobalFactoryMap()[#base_class]; \</span><br><span class="line">      CHECK_EQ(<span class="built_in">map</span>.size(), <span class="number">1U</span>) &lt;&lt; <span class="built_in">map</span>.size();                         \</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">map</span>.begin()-&gt;first;                                      \</span><br><span class="line">    &#125;                                                                 \</span><br><span class="line">    <span class="function"><span class="keyword">static</span> base_class *<span class="title">GetUniqInstance</span><span class="params">()</span> </span>&#123;                            \</span><br><span class="line">      FactoryMap &amp;<span class="built_in">map</span> =                                               \</span><br><span class="line">          ::apollo::perception::lib::GlobalFactoryMap()[#base_class]; \</span><br><span class="line">      CHECK_EQ(<span class="built_in">map</span>.size(), <span class="number">1U</span>) &lt;&lt; <span class="built_in">map</span>.size();                         \</span><br><span class="line">      Any object = <span class="built_in">map</span>.begin()-&gt;second-&gt;NewInstance();                \</span><br><span class="line">      <span class="keyword">return</span> *(object.AnyCast&lt;base_class *&gt;());                       \</span><br><span class="line">    &#125;                                                                 \</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsValid</span><span class="params">(<span class="keyword">const</span> ::<span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span> </span>&#123;                  \</span><br><span class="line">      FactoryMap &amp;<span class="built_in">map</span> =                                               \</span><br><span class="line">          ::apollo::perception::lib::GlobalFactoryMap()[#base_class]; \</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">map</span>.find(name) != <span class="built_in">map</span>.end();                             \</span><br><span class="line">    &#125;                                                                 \</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂类</span></span><br><span class="line"><span class="comment">// 在 Perception 功能模块 .so 动态库文件加载期间，被 __attribute__((constructor))</span></span><br><span class="line"><span class="comment">// 修饰的函数会优先执行，创建具体产品类对应的具体工厂指针，并将其映射到相应的 FactoryMap 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERCEPTION_REGISTER_CLASS(clazz, name)                                \</span></span><br><span class="line">  <span class="keyword">namespace</span> &#123;                                                                 \</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ObjectFactory</span>##<span class="title">name</span> :</span> <span class="keyword">public</span> apollo::perception::lib::ObjectFactory &#123; \</span><br><span class="line">   <span class="keyword">public</span>:                                                                    \</span><br><span class="line">    <span class="keyword">virtual</span> ~ObjectFactory#<span class="meta">#name() &#123;&#125;                                         \</span></span><br><span class="line">    <span class="keyword">virtual</span> ::apollo::perception::<span class="function">lib::Any <span class="title">NewInstance</span><span class="params">()</span> </span>&#123;                    \</span><br><span class="line">      <span class="keyword">return</span> ::apollo::perception::lib::Any(<span class="keyword">new</span> name());                      \</span><br><span class="line">    &#125;                                                                         \</span><br><span class="line">  &#125;;                                                                          \</span><br><span class="line">  __attribute__((constructor)) <span class="keyword">void</span> RegisterFactory#<span class="meta">#name() &#123;                 \</span></span><br><span class="line">    ::apollo::perception::lib::FactoryMap &amp;<span class="built_in">map</span> =                              \</span><br><span class="line">        ::apollo::perception::lib::GlobalFactoryMap()[#clazz];                \</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">map</span>.find(#name) == <span class="built_in">map</span>.end()) <span class="built_in">map</span>[<span class="meta">#name] = new ObjectFactory##name(); \</span></span><br><span class="line">  &#125;                                                                           \</span><br><span class="line">  &#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
<p>在感知子功能模块 <code>.so</code> 动态库文件加载期间，下面这条语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PERCEPTION_REGISTER_REGISTERER(BaseMultiSensorFusion);</span><br></pre></td></tr></table></figure>
<p>将为 <code>BaseMultiSensorFusion</code> 类创建客户端类 <code>BaseMultiSensorFusionRegisterer</code>，通过调用 <code>BaseMultiSensorFusionRegisterer::GetInstanceByName</code> 可以获得指定具体产品类 <code>ObstacleMultiSensorFusion</code> 的实例指针，问题在于，<code>ObstacleMultiSensorFusion</code> 的具体工厂是什么时候创建的？</p>
<p>打开 <code>apollo/modules/perception/fusion/app/obstacle_multi_sensor_fusion.cc</code>，最后有这样一条语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PERCEPTION_REGISTER_MULTISENSORFUSION(ObstacleMultiSensorFusion);</span><br></pre></td></tr></table></figure>
<p>结合上面的分析，该语句会被替换为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PERCEPTION_REGISTER_CLASS(BaseMultiSensorFusion, ObstacleMultiSensorFusion)</span><br></pre></td></tr></table></figure>
<p>将上面这个宏定义进行展开：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectFactoryObstacleMultiSensorFusion</span> :</span> <span class="keyword">public</span> apollo::perception::lib::ObjectFactory &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">virtual</span> ~ObjectFactoryObstacleMultiSensorFusion() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ::apollo::perception::<span class="function">lib::Any <span class="title">NewInstance</span><span class="params">()</span> </span>&#123;  <span class="comment">// 产品生产方法</span></span><br><span class="line">    <span class="keyword">return</span> ::apollo::perception::lib::Any(<span class="keyword">new</span> ObstacleMultiSensorFusion());  <span class="comment">// 生产 ObstacleMultiSensorFusion 具体产品</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">__attribute__((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">RegisterFactoryObstacleMultiSensorFusion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ::apollo::perception::lib::FactoryMap &amp;<span class="built_in">map</span> =</span><br><span class="line">      ::apollo::perception::lib::GlobalFactoryMap()[<span class="string">"BaseMultiSensorFusion"</span>];</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">map</span>.find(<span class="string">"ObstacleMultiSensorFusion"</span>) == <span class="built_in">map</span>.end()) <span class="built_in">map</span>[<span class="string">"ObstacleMultiSensorFusion"</span>] = <span class="keyword">new</span> ObjectFactoryObstacleMultiSensorFusion();  <span class="comment">// 创建具体工厂指针，并将其多态地映射到相应的 FactoryMap 中</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;  <span class="comment">// namespace</span></span><br></pre></td></tr></table></figure>
<p><code>ObjectFactoryObstacleMultiSensorFusion</code> 即为 <code>ObstacleMultiSensorFusion</code> 对应的具体工厂类，<code>RegisterFactoryObstacleMultiSensorFusion</code> 函数由于被 <code>__attribute__((constructor))</code> 属性修饰，因而会在 Perception 功能模块 <code>.so</code> 动态库文件加载期间被执行，完成 <code>ObstacleMultiSensorFusion</code> 类具体工厂指针的创建（相应的 <code>new</code> 语句），并将其多态地映射到相应的 FactoryMap 中。最后，通过调用客户端方法 <code>BaseMultiSensorFusionRegisterer::GetInstanceByName</code> 即可获得 <code>ObstacleMultiSensorFusion</code> 类的实例指针。</p>
<h3 id="2-2-2-主要的初始化动作：ObstacleMultiSensorFusion-Init-方法" class="heading-control"><a href="#2-2-2-主要的初始化动作：ObstacleMultiSensorFusion-Init-方法" class="headerlink" title="2.2.2 主要的初始化动作：ObstacleMultiSensorFusion::Init 方法"></a>2.2.2 主要的初始化动作：ObstacleMultiSensorFusion::Init 方法<a class="heading-anchor" href="#2-2-2-主要的初始化动作：ObstacleMultiSensorFusion-Init-方法" aria-hidden="true"></a></h3><p><code>FusionComponent::fusion_</code> 所管理对象的静态类型虽然是 <code>BaseMultiSensorFusion</code>，但由于其指针被绑定到工厂方法返回的 <code>ObstacleMultiSensorFusion</code> 类型指针上，故 <code>InitAlgorithmPlugin</code> 方法中的语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ACHECK(fusion_-&gt;Init(param)) &lt;&lt; <span class="string">"Failed to init ObstacleMultiSensorFusion"</span>;</span><br></pre></td></tr></table></figure>
<p>会多态调用 <code>ObstacleMultiSensorFusion::Init</code>，打开 <code>apollo/modules/perception/fusion/app/obstacle_multi_sensor_fusion.cc</code> 看下其定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObstacleMultiSensorFusion::Init</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> ObstacleMultiSensorFusionParam&amp; param)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fusion_ != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Already inited"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  BaseFusionSystem* fusion =</span><br><span class="line">          BaseFusionSystemRegisterer::GetInstanceByName(param.fusion_method);  <span class="comment">// 通过工厂方法模式获取 ProbabilisticFusion 类的实例指针</span></span><br><span class="line">  fusion_.reset(fusion);</span><br><span class="line"></span><br><span class="line">  FusionInitOptions init_options;  <span class="comment">// 融合初始化可选项</span></span><br><span class="line">  init_options.main_sensors = param.main_sensors;  <span class="comment">// 融合初始化可选项——主传感器：velodyne128，front_6mm，front_12mm</span></span><br><span class="line">  <span class="keyword">if</span> (fusion_ == <span class="literal">nullptr</span> || !fusion_-&gt;Init(init_options)) &#123;  <span class="comment">// 多态调用 ProbabilisticFusion::Init 方法</span></span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Failed to Get Instance or Initialize "</span> &lt;&lt; param.fusion_method;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ObstacleMultiSensorFusion::fusion_</code> 也是个独占智能指针，用于管理 <code>BaseFusionSystem</code> 类型的对象，<code>BaseFusionSystem</code> 是融合方法的抽象基类，会被表示概率融合的 <code>ProbabilisticFusion</code> 类所继承并实现对应纯虚接口方法。类似上文的分析，这里 <code>fusion_</code> 中的指针值会被更新为工厂方法模式返回的 <code>ProbabilisticFusion</code> 指针，具体不再赘述。同时，下面的语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (fusion_ == <span class="literal">nullptr</span> || !fusion_-&gt;Init(init_options)) &#123;</span><br></pre></td></tr></table></figure>
<p>会多态调用 <code>ProbabilisticFusion::Init</code>，打开 <code>apollo/modules/perception/fusion/lib/fusion_system/probabilistic_fusion/probabilistic_fusion.cc</code> 看下其定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ProbabilisticFusion::Init</span><span class="params">(<span class="keyword">const</span> FusionInitOptions&amp; init_options)</span> </span>&#123;</span><br><span class="line">  main_sensors_ = init_options.main_sensors;  <span class="comment">// 主传感器：velodyne128，front_6mm，front_12mm</span></span><br><span class="line"></span><br><span class="line">  BaseInitOptions options;</span><br><span class="line">  <span class="keyword">if</span> (!GetFusionInitOptions(<span class="string">"ProbabilisticFusion"</span>, &amp;options)) &#123;  <span class="comment">// 读取 probabilistic_fusion.config 中 pt 配置文件的相对路径（root_dir）与名称（conf_file）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> work_root_config = GetAbsolutePath(  <span class="comment">// 获取 pt 配置文件父路径的绝对路径</span></span><br><span class="line">      lib::ConfigManager::Instance()-&gt;work_root(), options.root_dir);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> config = GetAbsolutePath(work_root_config, options.conf_file);  <span class="comment">// 获取 pt 配置文件的绝对路径</span></span><br><span class="line">  ProbabilisticFusionConfig params;  <span class="comment">// 实例化概率融合配置参数 protobuf 类：probabilistic_fusion_config.proto</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!cyber::common::GetProtoFromFile(config, &amp;params)) &#123;  <span class="comment">// 将 pt 配置文件中的配置参数读入 protobuf 类：probabilistic_fusion.pt</span></span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Read config failed: "</span> &lt;&lt; config;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  params_.use_lidar = params.use_lidar();  <span class="comment">// 是否使用 lidar：true</span></span><br><span class="line">  params_.use_radar = params.use_radar();  <span class="comment">// 是否使用 radar：true</span></span><br><span class="line">  params_.use_camera = params.use_camera();  <span class="comment">// 是否使用 camera：true</span></span><br><span class="line">  params_.tracker_method = params.tracker_method();  <span class="comment">// 跟踪方法：PbfTracker</span></span><br><span class="line">  params_.data_association_method = params.data_association_method();  <span class="comment">// 数据关联方法：HMAssociation</span></span><br><span class="line">  params_.gate_keeper_method = params.gate_keeper_method();  <span class="comment">// 门限保持方法：PbfGatekeeper</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.prohibition_sensors_size(); ++i) &#123;  <span class="comment">// 被禁止用于创建新航迹的传感器：radar_front</span></span><br><span class="line">    params_.prohibition_sensors.push_back(params.prohibition_sensors(i));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// static member initialization from PB config</span></span><br><span class="line">  Track::SetMaxLidarInvisiblePeriod(params.max_lidar_invisible_period());  <span class="comment">// Lidar 历史量测最大不可见时长：0.25s</span></span><br><span class="line">  Track::SetMaxRadarInvisiblePeriod(params.max_radar_invisible_period());  <span class="comment">// Radar 历史量测最大不可见时长：0.50s</span></span><br><span class="line">  Track::SetMaxCameraInvisiblePeriod(params.max_camera_invisible_period());  <span class="comment">// Camera 历史量测最大不可见时长：0.75s</span></span><br><span class="line">  Sensor::SetMaxCachedFrameNumber(params.max_cached_frame_num());  <span class="comment">// 缓存的最大帧数：50</span></span><br><span class="line"></span><br><span class="line">  scenes_.reset(<span class="keyword">new</span> Scene());  <span class="comment">// 初始化用于管理场景的共享智能指针，场景中包含所有的前景航迹与背景航迹</span></span><br><span class="line">  <span class="keyword">if</span> (params_.data_association_method == <span class="string">"HMAssociation"</span>) &#123;  <span class="comment">// 如果使用 HMAssociation 数据关联方法</span></span><br><span class="line">    matcher_.reset(<span class="keyword">new</span> HMTrackersObjectsAssociation());  <span class="comment">// 多态地初始化用于管理数据关联的独占智能指针</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Unknown association method: "</span> &lt;&lt; params_.data_association_method;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!matcher_-&gt;Init()) &#123;  <span class="comment">// 多态调用 HMTrackersObjectsAssociation::Init</span></span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to init matcher."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (params_.gate_keeper_method == <span class="string">"PbfGatekeeper"</span>) &#123;  <span class="comment">// 如果使用 PbfGatekeeper 门限保持方法</span></span><br><span class="line">    gate_keeper_.reset(<span class="keyword">new</span> PbfGatekeeper());  <span class="comment">// 多态地初始化用于管理门限保持的独占智能指针</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Unknown gate keeper method: "</span> &lt;&lt; params_.gate_keeper_method;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!gate_keeper_-&gt;Init()) &#123;  <span class="comment">// 多态调用 PbfGatekeeper::Init</span></span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to init gatekeeper."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> state = DstTypeFusion::Init() &amp;&amp; DstExistenceFusion::Init() &amp;&amp;</span><br><span class="line">               PbfTracker::InitParams();  <span class="comment">// DST 类型融合初始化、DST 存在性融合初始化、概率跟踪器参数初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ProbabilisticFusion::Init</code> 主要做了三方面的初始化工作：</p>
<ul>
<li><code>ProbabilisticFusion</code> 参数初始化</li>
<li><code>ProbabilisticFusion</code> 成员初始化</li>
<li>其它初始化：DST 类型融合初始化、DST 存在性融合初始化、概率跟踪器参数初始化</li>
</ul>
<p>具体细节不作展开。</p>
<h1 id="3-消息回调处理" class="heading-control"><a href="#3-消息回调处理" class="headerlink" title="3 消息回调处理"></a>3 消息回调处理<a class="heading-anchor" href="#3-消息回调处理" aria-hidden="true"></a></h1><h2 id="3-1-对外的消息处理接口：FusionComponent-Proc-方法" class="heading-control"><a href="#3-1-对外的消息处理接口：FusionComponent-Proc-方法" class="headerlink" title="3.1 对外的消息处理接口：FusionComponent::Proc 方法"></a>3.1 对外的消息处理接口：FusionComponent::Proc 方法<a class="heading-anchor" href="#3-1-对外的消息处理接口：FusionComponent-Proc-方法" aria-hidden="true"></a></h2><p>如前文所述，<code>FusionComponent</code> 类的 <code>Proc</code> 方法由 Fusion 组件对应 channel 上的消息进行回调触发，我们打开 <code>apollo/modules/perception/onboard/component/fusion_component.cc</code> 看下 <code>Proc</code> 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FusionComponent::Proc</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt;&amp; message)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (message-&gt;process_stage_ == ProcessStage::SENSOR_FUSION) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PerceptionObstacles&gt; <span class="title">out_message</span><span class="params">(<span class="keyword">new</span> (<span class="built_in">std</span>::nothrow)  <span class="comment">// 管理融合障碍物消息的共享智能指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                                       PerceptionObstacles)</span></span>;</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; <span class="title">viz_message</span><span class="params">(<span class="keyword">new</span> (<span class="built_in">std</span>::nothrow)  <span class="comment">// 管理可视化消息的共享智能指针</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                                      SensorFrameMessage)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO(convert sensor id)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; itr = <span class="built_in">std</span>::find(fusion_main_sensors_.begin(),</span><br><span class="line">                              fusion_main_sensors_.end(), message-&gt;sensor_id_);</span><br><span class="line">  <span class="keyword">if</span> (itr == fusion_main_sensors_.end()) &#123;  <span class="comment">// 对于来自融合主传感器以外的消息，不执行后续步骤</span></span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Fusion receives message from "</span> &lt;&lt; message-&gt;sensor_id_</span><br><span class="line">          &lt;&lt; <span class="string">" which is not in main sensors. Skip sending."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> status = InternalProc(message, out_message, viz_message);  <span class="comment">// 调用私有消息处理方法 InternalProc</span></span><br><span class="line">  <span class="keyword">if</span> (status) &#123;</span><br><span class="line">    writer_-&gt;Write(out_message);  <span class="comment">// 发送融合障碍物消息</span></span><br><span class="line">    AINFO &lt;&lt; <span class="string">"Send fusion processing output message."</span>;</span><br><span class="line">    <span class="comment">// send msg for visualization</span></span><br><span class="line">    <span class="keyword">if</span> (FLAGS_obs_enable_visualization) &#123;</span><br><span class="line">      inner_writer_-&gt;Write(viz_message);  <span class="comment">// 发送可视化消息</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Proc</code> 内部对接收到的传感器消息进行判断，若消息来自融合主传感器以外的其它传感器，则不作处理，否则调用私有消息处理方法 <code>FusionComponent::InternalProc</code> 对消息进行融合处理，并视处理结果发送融合障碍物消息和可视化消息（若使能可视化 flag 得话）。</p>
<h2 id="3-2-内部的消息处理接口：FusionComponent-InternalProc-方法" class="heading-control"><a href="#3-2-内部的消息处理接口：FusionComponent-InternalProc-方法" class="headerlink" title="3.2 内部的消息处理接口：FusionComponent::InternalProc 方法"></a>3.2 内部的消息处理接口：FusionComponent::InternalProc 方法<a class="heading-anchor" href="#3-2-内部的消息处理接口：FusionComponent-InternalProc-方法" aria-hidden="true"></a></h2><p>我们看下 <code>FusionComponent::InternalProc</code> 的定义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">FusionComponent::InternalProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage <span class="keyword">const</span>&gt;&amp; in_message,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PerceptionObstacles&gt; out_message,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;SensorFrameMessage&gt; viz_message)</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(s_mutex_)</span></span>;</span><br><span class="line">    s_seq_num_++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  PERF_BLOCK_START();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> timestamp = in_message-&gt;timestamp_;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">uint64_t</span> lidar_timestamp = in_message-&gt;lidar_timestamp_;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt; valid_objects;  <span class="comment">// 有效融合障碍物</span></span><br><span class="line">  <span class="keyword">if</span> (in_message-&gt;error_code_ != apollo::common::ErrorCode::OK) &#123;  <span class="comment">// 接收的传感器消息存在异常</span></span><br><span class="line">    <span class="keyword">if</span> (!MsgSerializer::SerializeMsg(</span><br><span class="line">            timestamp, lidar_timestamp, in_message-&gt;seq_num_, valid_objects,</span><br><span class="line">            in_message-&gt;error_code_, out_message.get())) &#123;</span><br><span class="line">      AERROR &lt;&lt; <span class="string">"Failed to gen PerceptionObstacles object."</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (FLAGS_obs_enable_visualization) &#123;</span><br><span class="line">      viz_message-&gt;process_stage_ = ProcessStage::SENSOR_FUSION;</span><br><span class="line">      viz_message-&gt;error_code_ = in_message-&gt;error_code_;</span><br><span class="line">    &#125;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Fusion receive message with error code, skip it."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  base::FramePtr frame = in_message-&gt;frame_;  <span class="comment">// 传感器原始障碍物信息</span></span><br><span class="line">  frame-&gt;timestamp = in_message-&gt;timestamp_;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt; fused_objects;  <span class="comment">// 融合障碍物信息</span></span><br><span class="line">  <span class="keyword">if</span> (!fusion_-&gt;Process(frame, &amp;fused_objects)) &#123;  <span class="comment">// 多态调用 ObstacleMultiSensorFusion::Process，处理传感器原始障碍物信息，生成融合障碍物信息</span></span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to call fusion plugin."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  PERF_BLOCK_END_WITH_INDICATOR(<span class="string">"fusion_process"</span>, in_message-&gt;sensor_id_);</span><br><span class="line"></span><br><span class="line">  Eigen::Matrix4d sensor2world_pose =</span><br><span class="line">      in_message-&gt;frame_-&gt;sensor2world_pose.matrix();</span><br><span class="line">  <span class="keyword">if</span> (object_in_roi_check_ &amp;&amp; FLAGS_obs_enable_hdmap_input) &#123;  <span class="comment">// 若开启了 HD Map ROI 融合障碍物校验且使能了 HD Map 输入</span></span><br><span class="line">    <span class="comment">// get hdmap</span></span><br><span class="line">    <span class="function">base::HdmapStructPtr <span class="title">hdmap</span><span class="params">(<span class="keyword">new</span> base::HdmapStruct())</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (hdmap_input_) &#123;  <span class="comment">// HD Map 加载成功</span></span><br><span class="line">      base::PointD position;  <span class="comment">// 传感器在世界坐标系中的位置</span></span><br><span class="line">      position.x = sensor2world_pose(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">      position.y = sensor2world_pose(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">      position.z = sensor2world_pose(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">      hdmap_input_-&gt;GetRoiHDMapStruct(position, radius_for_roi_object_check_,</span><br><span class="line">                                      hdmap);  <span class="comment">// 获取传感器指定半径范围（120m）内的 HD Map</span></span><br><span class="line">      <span class="comment">// TODO(use check)</span></span><br><span class="line">      <span class="comment">// ObjectInRoiSlackCheck(hdmap, fused_objects, &amp;valid_objects);  // HD Map ROI 融合障碍物校验</span></span><br><span class="line">      valid_objects.assign(fused_objects.begin(), fused_objects.end());  <span class="comment">// 拷贝经 HD Map ROI 校验过的有效融合障碍物到 valid_objects</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// HD Map 加载失败，直接拷贝融合障碍物到 valid_objects</span></span><br><span class="line">      valid_objects.assign(fused_objects.begin(), fused_objects.end());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 若未开启 HD Map ROI 融合障碍物校验或未使能 HD Map 输入，直接拷贝融合障碍物到 valid_objects</span></span><br><span class="line">    valid_objects.assign(fused_objects.begin(), fused_objects.end());</span><br><span class="line">  &#125;</span><br><span class="line">  PERF_BLOCK_END_WITH_INDICATOR(<span class="string">"fusion_roi_check"</span>, in_message-&gt;sensor_id_);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// produce visualization msg  // 生成可视化消息</span></span><br><span class="line">  <span class="keyword">if</span> (FLAGS_obs_enable_visualization) &#123;</span><br><span class="line">    viz_message-&gt;timestamp_ = in_message-&gt;timestamp_;</span><br><span class="line">    viz_message-&gt;seq_num_ = in_message-&gt;seq_num_;</span><br><span class="line">    viz_message-&gt;frame_ = base::FramePool::Instance().Get();</span><br><span class="line">    viz_message-&gt;frame_-&gt;sensor2world_pose =</span><br><span class="line">        in_message-&gt;frame_-&gt;sensor2world_pose;</span><br><span class="line">    viz_message-&gt;sensor_id_ = in_message-&gt;sensor_id_;</span><br><span class="line">    viz_message-&gt;hdmap_ = in_message-&gt;hdmap_;  <span class="comment">// 可视化 HD Map 信息</span></span><br><span class="line">    viz_message-&gt;process_stage_ = ProcessStage::SENSOR_FUSION;</span><br><span class="line">    viz_message-&gt;error_code_ = in_message-&gt;error_code_;</span><br><span class="line">    viz_message-&gt;frame_-&gt;objects = fused_objects;  <span class="comment">// 可视化融合障碍物信息</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// produce pb output msg  // 生成 protobuf 格式的输出消息</span></span><br><span class="line">  apollo::common::ErrorCode error_code = apollo::common::ErrorCode::OK;</span><br><span class="line">  <span class="keyword">if</span> (!MsgSerializer::SerializeMsg(timestamp, lidar_timestamp,  <span class="comment">// 序列化有效融合障碍物信息 valid_objects 到输出消息</span></span><br><span class="line">                                   in_message-&gt;seq_num_, valid_objects,</span><br><span class="line">                                   error_code, out_message.get())) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"Failed to gen PerceptionObstacles object."</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  PERF_BLOCK_END_WITH_INDICATOR(<span class="string">"fusion_serialize_message"</span>,</span><br><span class="line">                                in_message-&gt;sensor_id_);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> cur_time = ::apollo::cyber::Clock::NowInSeconds();</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">double</span> latency = (cur_time - timestamp) * <span class="number">1e3</span>;  <span class="comment">// 算法时延</span></span><br><span class="line">  AINFO &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">16</span>) &lt;&lt; <span class="string">"FRAME_STATISTICS:Obstacle:End:msg_time["</span></span><br><span class="line">        &lt;&lt; timestamp &lt;&lt; <span class="string">"]:cur_time["</span> &lt;&lt; cur_time &lt;&lt; <span class="string">"]:cur_latency["</span> &lt;&lt; latency</span><br><span class="line">        &lt;&lt; <span class="string">"]:obj_cnt["</span> &lt;&lt; valid_objects.size() &lt;&lt; <span class="string">"]"</span>;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"publish_number: "</span> &lt;&lt; valid_objects.size() &lt;&lt; <span class="string">" obj"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中我们不难看出，<code>FusionComponent::InternalProc</code> 方法主要做了四件事：</p>
<ul>
<li>调用 <code>ObstacleMultiSensorFusion::Process</code> 方法，处理输入信息，生成融合障碍物信息 <code>fused_objects</code></li>
<li>使用 HD Map ROI 校验融合障碍物有效性，生成有效融合障碍物信息 <code>valid_objects</code></li>
<li>生成可视化消息 <code>viz_message</code></li>
<li>序列化有效融合障碍物信息 <code>valid_objects</code>，生成 protobuf 格式的输出消息 <code>out_message</code></li>
</ul>
<p>需要指出的是，HD Map ROI 融合障碍物校验方法 <code>ObjectInRoiSlackCheck</code> 在 Apollo 中尚未实现，相应的校验步骤在 <code>FusionComponent::InternalProc</code> 中也被注释掉了，所以最终的有效融合障碍物信息 <code>valid_objects</code> 与融合障碍物信息 <code>fused_objects</code> 是相同的。</p>
<h1 id="4-融合" class="heading-control"><a href="#4-融合" class="headerlink" title="4 融合"></a>4 融合<a class="heading-anchor" href="#4-融合" aria-hidden="true"></a></h1><h2 id="4-1-ObstacleMultiSensorFusion-Process-方法" class="heading-control"><a href="#4-1-ObstacleMultiSensorFusion-Process-方法" class="headerlink" title="4.1 ObstacleMultiSensorFusion::Process 方法"></a>4.1 ObstacleMultiSensorFusion::Process 方法<a class="heading-anchor" href="#4-1-ObstacleMultiSensorFusion-Process-方法" aria-hidden="true"></a></h2><p><code>FusionComponent::InternalProc</code> 方法调用的 <code>ObstacleMultiSensorFusion::Process</code> 方法定义在 <code>apollo/modules/perception/fusion/app/obstacle_multi_sensor_fusion.cc</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ObstacleMultiSensorFusion::Process</span><span class="params">(<span class="keyword">const</span> base::FrameConstPtr&amp; frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;* objects)</span> </span>&#123;</span><br><span class="line">  FusionOptions options;</span><br><span class="line">  <span class="keyword">return</span> fusion_-&gt;Fuse(options, frame, objects);  <span class="comment">// 多态调用 ProbabilisticFusion::Fuse</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参照前文分析，<code>ObstacleMultiSensorFusion::fusion_</code> 所管理对象的静态类型虽然是 <code>BaseFusionSystem</code>，但由于其指针被绑定到工厂方法返回的 <code>ProbabilisticFusion</code> 类型指针上，故 <code>ObstacleMultiSensorFusion::Process</code> 方法中的语句</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> fusion_-&gt;Fuse(options, frame, objects);</span><br></pre></td></tr></table></figure>
<p>会多态调用 <code>ProbabilisticFusion::Fuse</code> 方法。</p>
<h2 id="4-2-ProbabilisticFusion-Fuse-方法" class="heading-control"><a href="#4-2-ProbabilisticFusion-Fuse-方法" class="headerlink" title="4.2 ProbabilisticFusion::Fuse 方法"></a>4.2 ProbabilisticFusion::Fuse 方法<a class="heading-anchor" href="#4-2-ProbabilisticFusion-Fuse-方法" aria-hidden="true"></a></h2><p><code>ProbabilisticFusion::Fuse</code> 方法定义在 <code>apollo/modules/perception/fusion/lib/fusion_system/probabilistic_fusion/probabilistic_fusion.cc</code> 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ProbabilisticFusion::Fuse</span><span class="params">(<span class="keyword">const</span> FusionOptions&amp; options,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> base::FrameConstPtr&amp; sensor_frame,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;base::ObjectPtr&gt;* fused_objects)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fused_objects == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    AERROR &lt;&lt; <span class="string">"fusion error: fused_objects is nullptr"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 传感器数据管理单例类的唯一实例指针，管理各个传感器的历史 10 帧数据</span></span><br><span class="line">  <span class="keyword">auto</span>* sensor_data_manager = SensorDataManager::Instance();</span><br><span class="line">  <span class="comment">// 1. save frame data  // 保存当前数据帧</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">data_lock</span><span class="params">(data_mutex_)</span></span>;  <span class="comment">// 数据锁</span></span><br><span class="line">    <span class="keyword">if</span> (!params_.use_lidar &amp;&amp; sensor_data_manager-&gt;IsLidar(sensor_frame)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 若不融合 Lidar 数据且当前帧来自 Lidar，则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!params_.use_radar &amp;&amp; sensor_data_manager-&gt;IsRadar(sensor_frame)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 若不融合 Radar 数据且当前帧来自 Radar，则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!params_.use_camera &amp;&amp; sensor_data_manager-&gt;IsCamera(sensor_frame)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 若不融合 Camera 数据且当前帧来自 Camera，则直接返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前帧是否来自可发布传感器（与主传感器相同：velodyne128，front_6mm，front_12mm）</span></span><br><span class="line">    <span class="keyword">bool</span> is_publish_sensor = <span class="keyword">this</span>-&gt;IsPublishSensor(sensor_frame);</span><br><span class="line">    <span class="keyword">if</span> (is_publish_sensor) &#123;  <span class="comment">// 若当前帧来自可发布传感器</span></span><br><span class="line">      started_ = <span class="literal">true</span>;  <span class="comment">// 使能数据缓存启动变量（默认为 false）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (started_) &#123;  <span class="comment">// 若启动数据缓存</span></span><br><span class="line">      AINFO &lt;&lt; <span class="string">"add sensor measurement: "</span> &lt;&lt; sensor_frame-&gt;sensor_info.name</span><br><span class="line">            &lt;&lt; <span class="string">", obj_cnt : "</span> &lt;&lt; sensor_frame-&gt;objects.size() &lt;&lt; <span class="string">", "</span></span><br><span class="line">            &lt;&lt; FORMAT_TIMESTAMP(sensor_frame-&gt;timestamp);</span><br><span class="line">      sensor_data_manager-&gt;AddSensorMeasurements(sensor_frame);  <span class="comment">// 缓存当前数据帧到对应传感器的历史数据序列中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对于来自可发布传感器以外的消息，不执行后续步骤，意味着只有来自可发布传感器的消息才可以触发融合动作</span></span><br><span class="line">    <span class="keyword">if</span> (!is_publish_sensor) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. query related sensor_frames for fusion  // 查询每个传感器历史数据中的相关数据帧</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">fuse_lock</span><span class="params">(fuse_mutex_)</span></span>;  <span class="comment">// 融合锁</span></span><br><span class="line">  <span class="keyword">double</span> fusion_time = sensor_frame-&gt;timestamp;  <span class="comment">// 当前融合时间</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SensorFramePtr&gt; frames;  <span class="comment">// 当前融合时间下每个传感器历史数据中的相关数据帧组成的序列</span></span><br><span class="line">  sensor_data_manager-&gt;GetLatestFrames(fusion_time, &amp;frames);  <span class="comment">// 获取每个传感器历史数据中与当前融合时间最接近（≤）的数据帧组成的序列</span></span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Get "</span> &lt;&lt; frames.size() &lt;&lt; <span class="string">" related frames for fusion"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. perform fusion on related frames  // 融合所有的相关数据帧</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; frame : frames) &#123;  <span class="comment">// 对每一帧数据</span></span><br><span class="line">    FuseFrame(frame);  <span class="comment">// 融合单帧数据，最终的融合算法入口</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. collect fused objects  // 从前景航迹和背景航迹中收集可被发布的融合目标</span></span><br><span class="line">  CollectFusedObjects(fusion_time, fused_objects);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们需要先简单介绍下四个至关重要的类：</p>
<ul>
<li><strong><code>SensorDataManager</code></strong>：传感器数据管理单例类，通过一个无序映射 <code>std::unordered_map</code> 管理所有传感器的数据，每个传感器的数据类型是 <code>Sensor</code>，<code>SensorDataManager</code> 内部含有一个关键方法 <code>AddSensorMeasurements</code> 用于缓存传感器数据；</li>
<li><strong><code>Sensor</code></strong>：传感器数据类，通过一个双端队列 <code>std::deque</code> 维护传感器 10 帧的历史数据，每一帧的类型是 <code>SensorFrame</code>，<code>Sensor</code> 内部含有一个关键方法 <code>AddFrame</code>，<code>AddFrame</code> 将 <code>Frame</code> 类型的新的数据帧转换为 <code>SensorFrame</code> 类型的数据，并添加到历史数据队列中。<code>Frame</code> 数据到 <code>SensorFrame</code> 数据转换的过程中完成了数据中目标的前景与背景分类；</li>
<li><strong><code>SensorFrame</code></strong>：传感器数据帧类，通过 <code>std::vector</code> 维护每一帧的前景目标列表 <code>foreground_objects_</code> 和背景目标列表 <code>background_objects_</code>，每个目标的类型是 <code>SensorObject</code>；</li>
<li><strong><code>SensorObject</code></strong>：传感器目标类。</li>
</ul>
<p>下图展示了四个关键类之间的关系：</p>
<p><img data-src="https://image.shipengx.com/%E4%BC%A0%E6%84%9F%E5%99%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86.png" alt="传感器的数据管理"></p>
<p>下面我们依次展开 <code>ProbabilisticFusion::Fuse</code> 方法中的四个主要流程。</p>
<h3 id="4-2-1-保存当前数据帧" class="heading-control"><a href="#4-2-1-保存当前数据帧" class="headerlink" title="4.2.1 保存当前数据帧"></a>4.2.1 保存当前数据帧<a class="heading-anchor" href="#4-2-1-保存当前数据帧" aria-hidden="true"></a></h3><p>作以下几点说明：</p>
<ul>
<li>判断当前帧数据是否需要参与融合，若不需要，则直接返回；</li>
<li><code>ProbabilisticFusion</code> 中有<strong>可发布传感器</strong>（Publish Sensor）的概念，即 <code>std::vector&lt;std::string&gt; main_sensors_</code> 成员，被初始化为与 <code>FusionComponent::fusion_main_sensors_</code> 相同的内容：velodyne128、front_6mm 和 front_12mm；</li>
<li><code>ProbabilisticFusion</code> 类内部含有一个布尔类型的数据缓存启动变量 <code>started_</code>，默认为 <code>false</code>，只有接收到过来自可发布传感器的数据才会将 <code>started_</code> 置 <code>true</code> 以启动数据缓存，若启动了数据缓存，则调用 <code>SensorDataManager::AddSensorMeasurements</code> 方法将当前数据帧缓存到对应传感器的历史数据队列 <code>std::deque&lt;SensorFramePtr&gt; frames_</code> 中；</li>
<li>对于来自可发布传感器以外的消息，只作缓存，不执行后续步骤，意味着只有来自可发布传感器的消息才可以触发融合动作。</li>
</ul>
<h3 id="4-2-2-查询各个传感器历史数据中可参与融合的相关数据帧" class="heading-control"><a href="#4-2-2-查询各个传感器历史数据中可参与融合的相关数据帧" class="headerlink" title="4.2.2 查询各个传感器历史数据中可参与融合的相关数据帧"></a>4.2.2 查询各个传感器历史数据中可参与融合的相关数据帧<a class="heading-anchor" href="#4-2-2-查询各个传感器历史数据中可参与融合的相关数据帧" aria-hidden="true"></a></h3><p>通过 <code>SensorDataManager::GetLatestFrames</code> 方法分别获取（<code>Sensor::QueryLatestFrame</code>）每个传感器的历史数据中与当前数据帧时间戳最接近的那一帧数据，这样可以得到与传感器类别数量相同的若干帧最新历史数据，再通过 <code>std::sort</code> 对这若干帧最新历史数据进行升序排序，最终得到可参与融合的相关数据帧序列。</p>
<h3 id="4-2-3-融合所有的相关数据帧" class="heading-control"><a href="#4-2-3-融合所有的相关数据帧" class="headerlink" title="4.2.3 融合所有的相关数据帧"></a>4.2.3 融合所有的相关数据帧<a class="heading-anchor" href="#4-2-3-融合所有的相关数据帧" aria-hidden="true"></a></h3><p>对所有的相关数据帧，循环调用 <code>ProbabilisticFusion::FuseFrame</code> 方法进行融合，这是最终的融合算法入口，后文将会详细阐述。</p>
<h3 id="4-2-4-从前景航迹和背景航迹中收集可被发布的融合目标" class="heading-control"><a href="#4-2-4-从前景航迹和背景航迹中收集可被发布的融合目标" class="headerlink" title="4.2.4 从前景航迹和背景航迹中收集可被发布的融合目标"></a>4.2.4 从前景航迹和背景航迹中收集可被发布的融合目标<a class="heading-anchor" href="#4-2-4-从前景航迹和背景航迹中收集可被发布的融合目标" aria-hidden="true"></a></h3><p>执行完所有相关数据帧的融合动作后，通过在 <code>ProbabilisticFusion::CollectFusedObjects</code> 方法中调用 <code>PbfGatekeeper::AbleToPublish</code> 方法判断相应融合航迹是否满足可发布逻辑，可发布逻辑具体细节不作展开，其主要与以下几点有关：</p>
<ul>
<li><code>PbfGatekeeper</code> 配置参数</li>
<li>各传感器与航迹关联过的最新历史量测的可见性</li>
<li>航迹融合目标类别</li>
<li>航迹融合目标时间戳对应的本地时间</li>
<li>与航迹关联过的某种传感器的最新历史量测的距离、速度、置信度、所属的子传感器类别</li>
<li>航迹被跟踪上的次数</li>
</ul>
<p>对于可被发布的航迹，通过 <code>ProbabilisticFusion::CollectObjectsByTrack</code> 方法提取出融合目标信息。</p>
<h2 id="4-3-最终的融合算法入口：ProbabilisticFusion-FuseFrame-方法" class="heading-control"><a href="#4-3-最终的融合算法入口：ProbabilisticFusion-FuseFrame-方法" class="headerlink" title="4.3 最终的融合算法入口：ProbabilisticFusion::FuseFrame 方法"></a>4.3 最终的融合算法入口：ProbabilisticFusion::FuseFrame 方法<a class="heading-anchor" href="#4-3-最终的融合算法入口：ProbabilisticFusion-FuseFrame-方法" aria-hidden="true"></a></h2><p>上文中提到 <code>ProbabilisticFusion::FuseFrame</code> 方法是最终的融合算法入口：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProbabilisticFusion::FuseFrame</span><span class="params">(<span class="keyword">const</span> SensorFramePtr&amp; frame)</span> </span>&#123;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Fusing frame: "</span> &lt;&lt; frame-&gt;GetSensorId()</span><br><span class="line">        &lt;&lt; <span class="string">", foreground_object_number: "</span></span><br><span class="line">        &lt;&lt; frame-&gt;GetForegroundObjects().size()</span><br><span class="line">        &lt;&lt; <span class="string">", background_object_number: "</span></span><br><span class="line">        &lt;&lt; frame-&gt;GetBackgroundObjects().size()</span><br><span class="line">        &lt;&lt; <span class="string">", timestamp: "</span> &lt;&lt; FORMAT_TIMESTAMP(frame-&gt;GetTimestamp());</span><br><span class="line">  <span class="keyword">this</span>-&gt;FuseForegroundTrack(frame);  <span class="comment">// 前景航迹融合</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;FusebackgroundTrack(frame);  <span class="comment">// 背景航迹融合</span></span><br><span class="line">  <span class="keyword">this</span>-&gt;RemoveLostTrack();  <span class="comment">// 移除丢失航迹</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，对于某一帧相关数据帧，执行了三个动作：</p>
<ul>
<li>前景航迹融合</li>
<li>背景航迹融合</li>
<li>移除丢失航迹</li>
</ul>
<p>在谈航迹融合前，需要先看下定义在 <code>apollo/modules/perception/fusion/base/track.h</code> 中的航迹类 <code>Track</code> 都包含哪些数据成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Track</span> &#123;</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"> <span class="comment">// ······</span></span><br><span class="line"> <span class="comment">// 此处省略了方法成员</span></span><br><span class="line"> <span class="comment">// ······</span></span><br><span class="line"> <span class="comment">//</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  SensorId2ObjectMap lidar_objects_;  <span class="comment">// 所有的 Lidar 各自与当前航迹关联过的最新历史量测</span></span><br><span class="line">  SensorId2ObjectMap radar_objects_;  <span class="comment">// 所有的 Radar 各自与当前航迹关联过的最新历史量测</span></span><br><span class="line">  SensorId2ObjectMap camera_objects_;  <span class="comment">// 所有的 Camera 各自与当前航迹关联过的最新历史量测</span></span><br><span class="line"></span><br><span class="line">  FusedObjectPtr fused_object_ = <span class="literal">nullptr</span>;  <span class="comment">// 管理当前航迹融合目标的共享智能指针</span></span><br><span class="line">  <span class="keyword">double</span> tracking_period_ = <span class="number">0.0</span>;  <span class="comment">// 当前航迹的跟踪时长</span></span><br><span class="line">  <span class="keyword">double</span> existence_prob_ = <span class="number">0.0</span>;  <span class="comment">// 当前航迹的存在概率</span></span><br><span class="line">  <span class="keyword">double</span> toic_prob_ = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> is_background_ = <span class="literal">false</span>;  <span class="comment">// 当前航迹是否是背景航迹</span></span><br><span class="line">  <span class="keyword">bool</span> is_alive_ = <span class="literal">true</span>;  <span class="comment">// 当前航迹是否存活</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> tracked_times_ = <span class="number">0</span>;  <span class="comment">// 当前航迹的跟踪次数</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  FRIEND_TEST(TrackTest, test);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">size_t</span> s_track_idx_;  <span class="comment">// track id</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> s_max_lidar_invisible_period_;  <span class="comment">// Lidar 历史量测最大不可见时长：0.25s</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> s_max_radar_invisible_period_;  <span class="comment">// Radar 历史量测最大不可见时长：0.50s</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">double</span> s_max_camera_invisible_period_;  <span class="comment">// Camera 历史量测最大不可见时长：0.75s</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>lidar_objects_</code>、<code>radar_objects_</code> 和 <code>camera_objects_</code> 分别存放了某种类型传感器中每种子类型传感器与当前航迹关联过的最新历史量测，以 <code>camera_objects_</code> 为例，它存放了每种 Camera 与当前航迹关联过的最新历史量测。</p>
<h3 id="4-3-1-前景航迹融合" class="heading-control"><a href="#4-3-1-前景航迹融合" class="headerlink" title="4.3.1 前景航迹融合"></a>4.3.1 前景航迹融合<a class="heading-anchor" href="#4-3-1-前景航迹融合" aria-hidden="true"></a></h3><p><code>ProbabilisticFusion::FuseForegroundTrack</code> 是前景航迹融合方法，其大体流程与背景航迹融合类似，但具体细节内容篇幅巨大，后续会单开一篇文章详细讲解。</p>
<h3 id="4-3-2-背景航迹融合" class="heading-control"><a href="#4-3-2-背景航迹融合" class="headerlink" title="4.3.2 背景航迹融合"></a>4.3.2 背景航迹融合<a class="heading-anchor" href="#4-3-2-背景航迹融合" aria-hidden="true"></a></h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProbabilisticFusion::FusebackgroundTrack</span><span class="params">(<span class="keyword">const</span> SensorFramePtr&amp; frame)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. association  // 数据关联</span></span><br><span class="line">  <span class="keyword">size_t</span> track_size = scenes_-&gt;GetBackgroundTracks().size();  <span class="comment">// 背景航迹数量</span></span><br><span class="line">  <span class="keyword">size_t</span> obj_size = frame-&gt;GetBackgroundObjects().size();  <span class="comment">// 当前帧的背景目标数量</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">size_t</span>&gt; local_id_2_track_ind_map;  <span class="comment">// 背景航迹融合目标 track id 与航迹索引间的映射关系</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">track_tag</span><span class="params">(track_size, <span class="literal">false</span>)</span></span>;  <span class="comment">// 航迹匹配结果标签列表：0 - 不存在与航迹匹配的量测，1 - 存在与航迹匹配的量测</span></span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; <span class="title">object_tag</span><span class="params">(obj_size, <span class="literal">false</span>)</span></span>;  <span class="comment">// 量测匹配结果标签列表：0 - 不存在与量测匹配的航迹，1 - 存在与量测匹配的航迹</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackMeasurmentPair&gt; assignments;  <span class="comment">// 航迹与量测的配对关系列表</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackPtr&gt;&amp; background_tracks = scenes_-&gt;GetBackgroundTracks();  <span class="comment">// 所有的背景航迹</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; track_size; ++i) &#123;  <span class="comment">// 对每个背景航迹</span></span><br><span class="line">    <span class="keyword">const</span> FusedObjectPtr&amp; obj = background_tracks[i]-&gt;GetFusedObject();  <span class="comment">// 背景航迹中的融合目标</span></span><br><span class="line">    <span class="keyword">int</span> local_id = obj-&gt;GetBaseObject()-&gt;track_id;  <span class="comment">// 背景航迹中融合目标的 track id</span></span><br><span class="line">    local_id_2_track_ind_map[local_id] = i;  <span class="comment">// 建立背景航迹融合目标 track id 与航迹索引间的映射关系</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SensorObjectPtr&gt;&amp; frame_objs = frame-&gt;GetBackgroundObjects();  <span class="comment">// 当前帧的所有背景目标</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; obj_size; ++i) &#123;  <span class="comment">// 对每个背景目标</span></span><br><span class="line">    <span class="keyword">int</span> local_id = frame_objs[i]-&gt;GetBaseObject()-&gt;track_id;  <span class="comment">// 背景目标的 track id</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>&amp; it = local_id_2_track_ind_map.find(local_id);  <span class="comment">// 查找是否存在与当前背景目标 track id 相同的背景航迹融合目标</span></span><br><span class="line">    <span class="keyword">if</span> (it != local_id_2_track_ind_map.end()) &#123; <span class="comment">// 存在与当前背景目标 track id 相同的背景航迹融合目标</span></span><br><span class="line">      <span class="keyword">size_t</span> track_ind = it-&gt;second;  <span class="comment">// 与当前背景目标对应的背景航迹索引</span></span><br><span class="line">      assignments.push_back(<span class="built_in">std</span>::make_pair(track_ind, i));  <span class="comment">// 构造航迹与量测的配对关系</span></span><br><span class="line">      track_tag[track_ind] = <span class="literal">true</span>;  <span class="comment">// 将航迹匹配结果标签列表中的对应元素置 true</span></span><br><span class="line">      object_tag[i] = <span class="literal">true</span>;  <span class="comment">// 将量测匹配结果标签列表中的对应元素置 true</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. update assigned track  // 更新匹配上的航迹</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; assignments.size(); ++i) &#123;  <span class="comment">// 对航迹与量测配对关系列表中的每一组配对关系</span></span><br><span class="line">    <span class="keyword">int</span> track_ind = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(assignments[i].first);  <span class="comment">// 背景航迹索引</span></span><br><span class="line">    <span class="keyword">int</span> obj_ind = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(assignments[i].second);  <span class="comment">// 与背景航迹关联上的当前帧背景目标索引</span></span><br><span class="line">    background_tracks[track_ind]-&gt;UpdateWithSensorObject(frame_objs[obj_ind]);  <span class="comment">// 使用背景目标更新与其关联上的背景航迹</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. update unassigned track  // 更新未被匹配上的航迹</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> sensor_id = frame-&gt;GetSensorId();  <span class="comment">// 当前量测帧所属的传感器 id</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; track_tag.size(); ++i) &#123;  <span class="comment">// 对航迹匹配结果标签列表中的每个元素</span></span><br><span class="line">    <span class="keyword">if</span> (!track_tag[i]) &#123;  <span class="comment">// 如果背景航迹不存在与之匹配的量测</span></span><br><span class="line">      background_tracks[i]-&gt;UpdateWithoutSensorObject(sensor_id,  <span class="comment">// 更新该未被匹配上的背景航迹</span></span><br><span class="line">                                                      frame-&gt;GetTimestamp());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. create new track  // 创建新航迹</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; object_tag.size(); ++i) &#123;  <span class="comment">// 对量测匹配结果标签列表中的每个元素</span></span><br><span class="line">    <span class="keyword">if</span> (!object_tag[i]) &#123;  <span class="comment">// 如果量测不存在与之匹配的背景航迹</span></span><br><span class="line">      TrackPtr track = TrackPool::Instance().Get();  <span class="comment">// 从航迹池中获取一个未经初始化的航迹</span></span><br><span class="line">      track-&gt;Initialize(frame-&gt;GetBackgroundObjects()[i], <span class="literal">true</span>);  <span class="comment">// 使用未被匹配上的量测目标初始化背景航迹</span></span><br><span class="line">      scenes_-&gt;AddBackgroundTrack(track);  <span class="comment">// 将新的背景航迹添加到场景的背景航迹列表中</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>背景航迹融合的流程与前景航迹融合类似，都是由下面四个主要步骤组成：</p>
<h4 id="4-3-2-1-数据关联" class="heading-control"><a href="#4-3-2-1-数据关联" class="headerlink" title="4.3.2.1 数据关联"></a>4.3.2.1 数据关联<a class="heading-anchor" href="#4-3-2-1-数据关联" aria-hidden="true"></a></h4><p>航迹与量测的关联是首要步骤，要做的是找出航迹与量测的对应关系。从代码注释中可以看出，背景航迹融合的数据关联策略很简单，只做了背景航迹融合目标与当前帧背景目标的 track id 关联。</p>
<h4 id="4-3-2-2-更新匹配上的航迹" class="heading-control"><a href="#4-3-2-2-更新匹配上的航迹" class="headerlink" title="4.3.2.2 更新匹配上的航迹"></a>4.3.2.2 更新匹配上的航迹<a class="heading-anchor" href="#4-3-2-2-更新匹配上的航迹" aria-hidden="true"></a></h4><p>完成航迹与量测的关联后，通过 <code>Track::UpdateWithSensorObject</code> 方法更新与量测匹配上的背景航迹：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Track::UpdateWithSensorObject</span><span class="params">(<span class="keyword">const</span> SensorObjectPtr&amp; obj)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> sensor_id = obj-&gt;GetSensorId();  <span class="comment">// 量测目标所属的传感器 id</span></span><br><span class="line">  SensorId2ObjectMap* objects = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (IsLidar(obj)) &#123;  <span class="comment">// 量测目标来自 Lidar</span></span><br><span class="line">    objects = &amp;lidar_objects_;  <span class="comment">// 获取所有的 Lidar 各自与当前航迹关联过的最新历史量测</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsRadar(obj)) &#123;  <span class="comment">// 目标来自 Radar</span></span><br><span class="line">    objects = &amp;radar_objects_;  <span class="comment">// 获取所有的 Radar 各自与当前航迹关联过的最新历史量测</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsCamera(obj)) &#123;  <span class="comment">// 目标来自 Camera</span></span><br><span class="line">    objects = &amp;camera_objects_;  <span class="comment">// 获取所有的 Camera 各自与当前航迹关联过的最新历史量测</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 量测目标来自其它传感器</span></span><br><span class="line">    <span class="keyword">return</span>;  <span class="comment">// 不作任何处理</span></span><br><span class="line">  &#125;</span><br><span class="line">  UpdateSensorObject(objects, obj);  <span class="comment">// 更新与当前航迹关联过的指定传感器的量测目标</span></span><br><span class="line">  <span class="keyword">double</span> time_diff = obj-&gt;GetTimestamp() - fused_object_-&gt;GetTimestamp();  <span class="comment">// 量测目标与当前航迹融合目标间的时间间隔</span></span><br><span class="line">  tracking_period_ += time_diff;  <span class="comment">// 更新当前航迹的跟踪时长</span></span><br><span class="line"></span><br><span class="line">  UpdateSensorObjectWithMeasurement(&amp;lidar_objects_, sensor_id,</span><br><span class="line">                                    obj-&gt;GetTimestamp(),</span><br><span class="line">                                    s_max_lidar_invisible_period_);  <span class="comment">// 删除不可见时长超过阈值的 Lidar 历史量测</span></span><br><span class="line">  UpdateSensorObjectWithMeasurement(&amp;radar_objects_, sensor_id,</span><br><span class="line">                                    obj-&gt;GetTimestamp(),</span><br><span class="line">                                    s_max_radar_invisible_period_);  <span class="comment">// 删除不可见时长超过阈值的 Radar 历史量测</span></span><br><span class="line">  UpdateSensorObjectWithMeasurement(&amp;camera_objects_, sensor_id,</span><br><span class="line">                                    obj-&gt;GetTimestamp(),</span><br><span class="line">                                    s_max_camera_invisible_period_);  <span class="comment">// 删除不可见时长超过阈值的 Camera 历史量测</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_background_) &#123;  <span class="comment">// 如果当前航迹是背景航迹</span></span><br><span class="line">    <span class="keyword">return</span> UpdateWithSensorObjectForBackground(obj);  <span class="comment">// 更新背景航迹融合目标并返回</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 下面的代码只适用于前景航迹融合，暂不做分析</span></span><br><span class="line">  fused_object_-&gt;GetBaseObject()-&gt;latest_tracked_time = obj-&gt;GetTimestamp();</span><br><span class="line">  UpdateSupplementState(obj);</span><br><span class="line">  UpdateUnfusedState(obj);</span><br><span class="line">  is_alive_ = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，通过 <code>IsLidar</code> 方法、<code>IsRadar</code> 方法和 <code>IsCamera</code> 方法判断量测目标所属的大的传感器类别：Lidar、Radar 或 Camera。</p>
<p>然后，通过 <code>Track::UpdateSensorObject</code> 方法新建或更新量测目标所属传感器与当前航迹关联过的最新历史量测：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Track::UpdateSensorObject</span><span class="params">(SensorId2ObjectMap* objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> SensorObjectPtr&amp; obj)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> sensor_id = obj-&gt;GetSensorId();  <span class="comment">// 量测目标所属的传感器 id</span></span><br><span class="line">  <span class="keyword">auto</span> it = objects-&gt;find(sensor_id);  <span class="comment">// 查找来自量测目标所属传感器的数据是否与当前航迹关联过</span></span><br><span class="line">  <span class="keyword">if</span> (it == objects-&gt;end()) &#123;  <span class="comment">// 来自量测目标所属传感器的数据未与当前航迹关联过</span></span><br><span class="line">    (*objects)[sensor_id] = obj;  <span class="comment">// 新增与当前航迹关联过的 [传感器-最新历史量测] 映射关系</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 来自量测目标所属传感器的数据与当前航迹关联过</span></span><br><span class="line">    it-&gt;second = obj;  <span class="comment">// 更新对应传感器与当前航迹关联过的最新历史量测</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其次，通过 <code>Track::UpdateSensorObjectWithMeasurement</code> 方法删除 Lidar、Radar 和 Camera 中不可见时长超过阈值的历史量测：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Track::UpdateSensorObjectWithMeasurement</span><span class="params">(SensorId2ObjectMap* objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; sensor_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">double</span> measurement_timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">double</span> max_invisible_period)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = objects-&gt;begin(); it != objects-&gt;end();) &#123;  <span class="comment">// 对于某种类型传感器（Lidar，Radar，Camera）下的各种子类型传感器</span></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;first != sensor_id) &#123;  <span class="comment">// 如果量测目标不是来自当前子类型传感器</span></span><br><span class="line">      <span class="keyword">double</span> period = measurement_timestamp - it-&gt;second-&gt;GetTimestamp();  <span class="comment">// 量测目标和当前子类型传感器与航迹关联过的最新历史量测间的时间间隔</span></span><br><span class="line">      <span class="keyword">if</span> (period &gt; max_invisible_period) &#123;  <span class="comment">// 如果时间间隔超过对应的最大不可见时长</span></span><br><span class="line">        it-&gt;second = <span class="literal">nullptr</span>;  <span class="comment">// 清空当前子类型传感器与航迹关联过的最新历史量测</span></span><br><span class="line">        it = objects-&gt;erase(it);  <span class="comment">// 擦除当前子类型传感器的历史量测记录</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 时间间隔小于对应的最大不可见时长</span></span><br><span class="line">        ++it;  <span class="comment">// 处理下一个子类型传感器</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 量测目标来自当前子类型传感器</span></span><br><span class="line">      ++it;  <span class="comment">// 处理下一个子类型传感器</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，通过 <code>Track::UpdateWithSensorObjectForBackground</code> 方法更新背景航迹的融合目标：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Track::UpdateWithSensorObjectForBackground</span><span class="params">(<span class="keyword">const</span> SensorObjectPtr&amp; obj)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::Object&gt; fused_base_object =</span><br><span class="line">      fused_object_-&gt;GetBaseObject();  <span class="comment">// 背景航迹融合目标</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> base::Object&gt; measurement_base_object =</span><br><span class="line">      obj-&gt;GetBaseObject();  <span class="comment">// 量测目标</span></span><br><span class="line">  <span class="keyword">int</span> track_id = fused_base_object-&gt;track_id;  <span class="comment">// 暂存背景航迹融合目标的 track id</span></span><br><span class="line">  *fused_base_object = *measurement_base_object;  <span class="comment">// 使用量测目标直接替换背景航迹融合目标</span></span><br><span class="line">  fused_base_object-&gt;track_id = track_id;  <span class="comment">// 维持背景航迹融合目标 track id 不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，背景航迹融合目标的更新过程比较简单，只是单纯地使用量测目标替换了融合目标，并维持融合目标 track id 不变。</p>
<h4 id="4-3-2-3-更新未被匹配上的航迹" class="heading-control"><a href="#4-3-2-3-更新未被匹配上的航迹" class="headerlink" title="4.3.2.3 更新未被匹配上的航迹"></a>4.3.2.3 更新未被匹配上的航迹<a class="heading-anchor" href="#4-3-2-3-更新未被匹配上的航迹" aria-hidden="true"></a></h4><p>通过 <code>Track::UpdateWithoutSensorObject</code> 方法更新未与量测匹配上的背景航迹：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Track::UpdateWithoutSensorObject</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; sensor_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">double</span> measurement_timestamp)</span> </span>&#123;</span><br><span class="line">  UpdateSensorObjectWithoutMeasurement(&amp;lidar_objects_, sensor_id,</span><br><span class="line">                                       measurement_timestamp,</span><br><span class="line">                                       s_max_lidar_invisible_period_);  <span class="comment">// 设置与航迹关联过的 Lidar 最新历史量测的不可见时长，并删除不可见时长超过阈值的 Lidar 历史量测</span></span><br><span class="line">  UpdateSensorObjectWithoutMeasurement(&amp;radar_objects_, sensor_id,</span><br><span class="line">                                       measurement_timestamp,</span><br><span class="line">                                       s_max_radar_invisible_period_);  <span class="comment">// 设置与航迹关联过的 Radar 最新历史量测的不可见时长，并删除不可见时长超过阈值的 Radar 历史量测</span></span><br><span class="line">  UpdateSensorObjectWithoutMeasurement(&amp;camera_objects_, sensor_id,</span><br><span class="line">                                       measurement_timestamp,</span><br><span class="line">                                       s_max_camera_invisible_period_);  <span class="comment">// 设置与航迹关联过的 Camera 最新历史量测的不可见时长，并删除不可见时长超过阈值的 Camera 历史量测</span></span><br><span class="line"></span><br><span class="line">  UpdateSupplementState();  <span class="comment">// 更新航迹融合目标的补充属性状态（形参缺省为 nullptr）</span></span><br><span class="line">  is_alive_ = (!lidar_objects_.empty()) || (!radar_objects_.empty()) ||</span><br><span class="line">              (!camera_objects_.empty());  <span class="comment">// 当前航迹至少拥有一个与之关联过且不可见时长未超过阈值的历史量测才允许存活</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，通过 <code>Track::UpdateSensorObjectWithoutMeasurement</code> 方法设置与航迹关联过的某种传感器的最新历史量测的不可见时长，并删除不可见时长超过阈值的历史量测：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Track::UpdateSensorObjectWithoutMeasurement</span><span class="params">(SensorId2ObjectMap* objects,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; sensor_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">double</span> measurement_timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 <span class="keyword">double</span> max_invisible_period)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = objects-&gt;begin(); it != objects-&gt;end();) &#123;  <span class="comment">// 对于某种类型传感器（Lidar，Radar，Camera）下的各种子类型传感器</span></span><br><span class="line">    <span class="keyword">double</span> period = measurement_timestamp - it-&gt;second-&gt;GetTimestamp();  <span class="comment">// 量测帧和当前子类型传感器与航迹关联过的最新历史量测间的时间间隔</span></span><br><span class="line">    <span class="keyword">if</span> (it-&gt;first == sensor_id) &#123;  <span class="comment">// 如果量测帧来自当前子类型传感器</span></span><br><span class="line">      it-&gt;second-&gt;SetInvisiblePeriod(period);  <span class="comment">// 设置当前子类型传感器与航迹关联过的最新历史量测的不可见时长</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second-&gt;GetInvisiblePeriod() &gt; <span class="number">0.0</span>) &#123;  <span class="comment">// 如果量测帧不是来自当前子类型传感器，且当前子类型传感器与航迹关联过的最新历史量测的不可见时长大于 0</span></span><br><span class="line">      it-&gt;second-&gt;SetInvisiblePeriod(period);  <span class="comment">// 设置当前子类型传感器与航迹关联过的最新历史量测的不可见时长</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (period &gt; max_invisible_period) &#123;  <span class="comment">// 如果时间间隔超过对应的最大不可见时长</span></span><br><span class="line">      it-&gt;second = <span class="literal">nullptr</span>;  <span class="comment">// 清空当前子类型传感器与航迹关联过的最新历史量测</span></span><br><span class="line">      it = objects-&gt;erase(it);  <span class="comment">// 擦除当前子类型传感器的历史量测记录</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 时间间隔小于对应的最大不可见时长</span></span><br><span class="line">      ++it;  <span class="comment">// 处理下一个子类型传感器</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，通过 <code>Track::UpdateSupplementState</code> 方法更新航迹融合目标的补充属性状态（形参缺省为 <code>nullptr</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Track::UpdateSupplementState</span><span class="params">(<span class="keyword">const</span> SensorObjectPtr&amp; src_object)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::Object&gt; dst_obj = fused_object_-&gt;GetBaseObject();  <span class="comment">// 航迹融合目标</span></span><br><span class="line">  <span class="keyword">if</span> (src_object != <span class="literal">nullptr</span>) &#123;  <span class="comment">// 如果输入的量测目标形参不为空</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> base::Object&gt; src_obj = src_object-&gt;GetBaseObject();  <span class="comment">// 量测目标</span></span><br><span class="line">    <span class="keyword">if</span> (IsLidar(src_object)) &#123;  <span class="comment">// 量测目标来自 Lidar</span></span><br><span class="line">      dst_obj-&gt;lidar_supplement = src_obj-&gt;lidar_supplement;  <span class="comment">// 使用量测目标的 Lidar 补充属性更新航迹融合目标的 Lidar 补充属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsRadar(src_object)) &#123;  <span class="comment">// 量测目标来自 Radar</span></span><br><span class="line">      dst_obj-&gt;radar_supplement = src_obj-&gt;radar_supplement;  <span class="comment">// 使用量测目标的 Radar 补充属性更新航迹融合目标的 Radar 补充属性</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsCamera(src_object)) &#123;  <span class="comment">// 量测目标来自 Camera</span></span><br><span class="line">      dst_obj-&gt;camera_supplement = src_obj-&gt;camera_supplement;  <span class="comment">// 使用量测目标的 Camera 补充属性更新航迹融合目标的 Camera 补充属性</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (lidar_objects_.empty()) &#123;  <span class="comment">// 不存在有效的与当前航迹关联过的 Lidar 历史量测</span></span><br><span class="line">    dst_obj-&gt;lidar_supplement.Reset();  <span class="comment">// 重置航迹融合目标的 Lidar 补充属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (radar_objects_.empty()) &#123;  <span class="comment">// 不存在有效的与当前航迹关联过的 Radar 历史量测</span></span><br><span class="line">    dst_obj-&gt;radar_supplement.Reset();  <span class="comment">// 重置航迹融合目标的 Radar 补充属性</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (camera_objects_.empty()) &#123;  <span class="comment">// 不存在有效的与当前航迹关联过的 Camera 历史量测</span></span><br><span class="line">    dst_obj-&gt;camera_supplement.Reset();  <span class="comment">// 重置航迹融合目标的 Camera 补充属性</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，若当前航迹至少拥有一个与之关联过且不可见时长未超过阈值的历史量测，则允许该航迹存活。</p>
<h4 id="4-3-2-4-创建新航迹" class="heading-control"><a href="#4-3-2-4-创建新航迹" class="headerlink" title="4.3.2.4 创建新航迹"></a>4.3.2.4 创建新航迹<a class="heading-anchor" href="#4-3-2-4-创建新航迹" aria-hidden="true"></a></h4><p>对于未与背景航迹匹配上的量测，需要为其创建新的背景航迹。首先，从航迹池中获取一个未经初始化的航迹。</p>
<p>然后，通过 <code>Track::Initialize</code> 方法使用未被匹配上的量测目标初始化背景航迹：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Track::Initialize</span><span class="params">(SensorObjectPtr obj, <span class="keyword">bool</span> is_background)</span> </span>&#123;</span><br><span class="line">  Reset();  <span class="comment">// 重置航迹的各个属性</span></span><br><span class="line">  <span class="keyword">int</span> track_id = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(GenerateNewTrackId());  <span class="comment">// 生成新的 track id</span></span><br><span class="line">  is_background_ = is_background;  <span class="comment">// 是否是背景航迹</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;base::Object&gt; fused_base_obj = fused_object_-&gt;GetBaseObject();  <span class="comment">// 航迹融合目标</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">const</span> base::Object&gt; sensor_base_obj = obj-&gt;GetBaseObject();  <span class="comment">// 量测目标</span></span><br><span class="line">  *fused_base_obj = *sensor_base_obj;  <span class="comment">// 将量测目标拷贝到航迹融合目标</span></span><br><span class="line">  fused_base_obj-&gt;track_id = track_id;  <span class="comment">// 更新航迹融合目标 track id</span></span><br><span class="line">  UpdateWithSensorObject(obj);  <span class="comment">// 使用量测目标更新该航迹</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Track::Initialize</code> 方法内部也会调用 <code>Track::UpdateWithSensorObject</code> 方法，参考前文，此处不再赘述。</p>
<p>最后，通过 <code>Scene::AddBackgroundTrack</code> 方法将新的背景航迹添加到场景的背景航迹列表中。</p>
<h3 id="4-3-3-移除丢失航迹" class="heading-control"><a href="#4-3-3-移除丢失航迹" class="headerlink" title="4.3.3 移除丢失航迹"></a>4.3.3 移除丢失航迹<a class="heading-anchor" href="#4-3-3-移除丢失航迹" aria-hidden="true"></a></h3><p>如前文所述，<code>Track::is_alive_</code> 成员表征了航迹是否存活，若航迹至少拥有一个与之关联过且不可见时长未超过阈值的历史量测，则允许该航迹存活。对于已经失活的前景航迹和背景航迹，通过 <code>ProbabilisticFusion::RemoveLostTrack</code> 方法进行移除：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProbabilisticFusion::RemoveLostTrack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// need to remove tracker at the same time</span></span><br><span class="line">  <span class="keyword">size_t</span> foreground_track_count = <span class="number">0</span>;  <span class="comment">// 存活的前景航迹计数，也代表了下一个存活的前景航迹的新的索引</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackPtr&gt;&amp; foreground_tracks = scenes_-&gt;GetForegroundTracks();  <span class="comment">// 前景航迹</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; foreground_tracks.size(); ++i) &#123;  <span class="comment">// 对于每一个前景航迹</span></span><br><span class="line">    <span class="keyword">if</span> (foreground_tracks[i]-&gt;IsAlive()) &#123;  <span class="comment">// 当前前景航迹存活</span></span><br><span class="line">      <span class="keyword">if</span> (i != foreground_track_count) &#123;  <span class="comment">// 当前存活的前景航迹之前存在失活航迹</span></span><br><span class="line">        foreground_tracks[foreground_track_count] = foreground_tracks[i];  <span class="comment">// 将当前存活的前景航迹移动到前景航迹列表新的位置</span></span><br><span class="line">        trackers_[foreground_track_count] = trackers_[i];  <span class="comment">// 将当前存活的前景航迹对应的 tracker 移动到 tracker 列表新的位置</span></span><br><span class="line">      &#125;</span><br><span class="line">      foreground_track_count++;  <span class="comment">// 存活的前景航迹计数加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Remove "</span> &lt;&lt; foreground_tracks.size() - foreground_track_count</span><br><span class="line">        &lt;&lt; <span class="string">" foreground tracks. "</span> &lt;&lt; foreground_track_count &lt;&lt; <span class="string">" tracks left."</span>;</span><br><span class="line">  foreground_tracks.resize(foreground_track_count);  <span class="comment">// 析构前景航迹列表尾部多余的元素</span></span><br><span class="line">  trackers_.resize(foreground_track_count);  <span class="comment">// 析构 tracker 列表尾部多余的元素</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// only need to remove frame track</span></span><br><span class="line">  <span class="keyword">size_t</span> background_track_count = <span class="number">0</span>;  <span class="comment">// 存活的背景航迹计数，也代表了下一个存活的背景航迹的新的索引</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;TrackPtr&gt;&amp; background_tracks = scenes_-&gt;GetBackgroundTracks();  <span class="comment">// 背景航迹</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; background_tracks.size(); ++i) &#123;  <span class="comment">// 对于每一个背景航迹</span></span><br><span class="line">    <span class="keyword">if</span> (background_tracks[i]-&gt;IsAlive()) &#123;  <span class="comment">// 当前背景航迹存活</span></span><br><span class="line">      <span class="keyword">if</span> (i != background_track_count) &#123;  <span class="comment">// 当前存活的背景航迹之前存在失活航迹</span></span><br><span class="line">        background_tracks[background_track_count] = background_tracks[i];  <span class="comment">// 将当前存活的背景航迹移动到背景航迹列表新的位置</span></span><br><span class="line">      &#125;</span><br><span class="line">      background_track_count++;  <span class="comment">// 存活的背景航迹计数加 1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  AINFO &lt;&lt; <span class="string">"Remove "</span> &lt;&lt; background_tracks.size() - background_track_count</span><br><span class="line">        &lt;&lt; <span class="string">" background tracks"</span>;</span><br><span class="line">  background_tracks.resize(background_track_count);  <span class="comment">// 析构背景航迹列表尾部多余的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要指出的是，每个前景航迹都有一个与之对应的 tracker，在移除失活前景航迹的同时，需要同时移除相应的 tracker。</p>
<h1 id="5-总结" class="heading-control"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结<a class="heading-anchor" href="#5-总结" aria-hidden="true"></a></h1><p>本文详细分析了 Apollo 6.0 Perception 模块 Fusion 组件的初始化、消息回调处理以及障碍物融合的主体算法框架。</p>
<p><code>ProbabilisticFusion::FuseFrame</code> 方法是最终的融合算法入口，对于某一帧相关数据帧，该方法都执行了三个动作：</p>
<ul>
<li>前景航迹融合</li>
<li>背景航迹融合</li>
<li>移除丢失航迹</li>
</ul>
<p>文章剖析了“背景航迹融合”和“移除丢失航迹”部分的具体实现，前景航迹融合部分由于篇幅巨大，我们将在后续的文章中单独讲述。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JyaWJsdWUvYXJ0aWNsZS9kZXRhaWxzLzExODEwMTU5Nj9zcG09MTAwMS4yMDE0LjMwMDEuNTUwMQ==" title="https://blog.csdn.net/briblue/article/details/118101596?spm=1001.2014.3001.5501">自动驾驶 Apollo 源码分析系列，感知篇(八)：感知融合代码的基本流程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzE1MjE1Mi9hcnRpY2xlL2RldGFpbHMvMTE0ODM2ODgyP3NwbT0xMDAxLjIwMTQuMzAwMS41NTAx" title="https://blog.csdn.net/weixin_43152152/article/details/114836882?spm=1001.2014.3001.5501">Apollo perception 源码阅读 | fusion<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRlZS5jb20vQXBvbGxvQXV0by9hcG9sbG8vYmxvYi9tYXN0ZXIvZG9jcy9ob3d0by9ob3dfdG9fYWRkX2FfbmV3X2Z1c2lvbl9zeXN0ZW1fY24ubWQ=" title="https://gitee.com/ApolloAuto/apollo/blob/master/docs/howto/how_to_add_a_new_fusion_system_cn.md">如何添加新的 fusion 融合系统<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjA1MzAyOS9ob3ctZXhhY3RseS1kb2VzLWF0dHJpYnV0ZS1jb25zdHJ1Y3Rvci13b3Jr" title="https://stackoverflow.com/questions/2053029/how-exactly-does-attribute-constructor-work">How exactly does __attribute__((constructor)) work?<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0N4aWF6YWl5dS9hcnRpY2xlL2RldGFpbHMvMTA2MjU2MzMw" title="https://blog.csdn.net/Cxiazaiyu/article/details/106256330">Apollo 源码分析：视觉感知 （v5.5）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9yZWZhY3RvcmluZy5ndXJ1L2Rlc2lnbi1wYXR0ZXJucy9hYnN0cmFjdC1mYWN0b3J5L2NwcC9leGFtcGxl" title="https://refactoring.guru/design-patterns/abstract-factory/cpp/example">Abstract Factory in C++<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9yZWZhY3RvcmluZy5ndXJ1L2Rlc2lnbi1wYXR0ZXJucy9mYWN0b3J5LW1ldGhvZC9jcHAvZXhhbXBsZQ==" title="https://refactoring.guru/design-patterns/factory-method/cpp/example">Factory Method in C++<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIwMzY3NzM0" title="https://www.zhihu.com/question/20367734">抽象工厂模式和工厂模式的区别？<i class="fa fa-external-link"></i></span></li>
</ol>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>Apollo</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>Apollo</tag>
        <tag>多传感器信息融合</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 16 章 模板与泛型编程</title>
    <url>/archives/8c16df73.html</url>
    <content><![CDATA[<h1 id="16-1-定义模板" class="heading-control"><a href="#16-1-定义模板" class="headerlink" title="16.1 定义模板"></a>16.1 定义模板<a class="heading-anchor" href="#16-1-定义模板" aria-hidden="true"></a></h1><h2 id="16-1-1-函数模板" class="heading-control"><a href="#16-1-1-函数模板" class="headerlink" title="16.1.1 函数模板"></a>16.1.1 函数模板<a class="heading-anchor" href="#16-1-1-函数模板" aria-hidden="true"></a></h2><ol>
<li><p>我们可以定义一个通用的<strong>函数模板</strong>（function template），而不是为每个类型都定义一个新函数。一个函数模板就是一个公式，可用来生成针对特定类型的函数版本。</p>
</li>
<li><p>模板定义以关键字 <code>template</code> 开始，后跟一个<strong>模板参数列表</strong>（template parameter list），这是一个逗号分隔的一个或多个<strong>模板参数</strong>（template parameter）的列表，用小于号（<code>&lt;</code>）和大于号（<code>&gt;</code>）包围起来。</p>
<blockquote>
<p><strong>Note：</strong> 在模板定义中，模板参数列表不能为空。</p>
</blockquote>
</li>
<li><p>模板参数表示在类或函数定义中用到的类型或值。当使用模板时，我们（隐式地或显式地）指定<strong>模板实参</strong>（template argument），将其绑定到模板参数上。</p>
</li>
<li><p>当我们调用一个函数模板时，编译器（通常）用函数实参来为我们推断模板实参。即，编译器使用实参的类型来确定绑定到模板参数 <code>T</code> 的类型。</p>
<p>编译器用推断出的模板参数来为我们<strong>实例化</strong>（instantiate）一个特定版本的函数。当编译器实例化一个模板时，它使用实际的模板实参代替对应的模板参数来创建出模板的一个新<strong>实例</strong>（instantiation）。</p>
</li>
<li><p>模板<strong>类型参数</strong>（type parameter）。一般来说，我们可以将类型参数看作类型说明符，就像内置类型或类类型说明符一样使用。特别是，类型参数可以用来指定返回类型或函数的参数类型，以及在函数体内用于变量声明或类型转换。</p>
</li>
<li><p>类型参数前必须使用关键字 <code>class</code> 或 <code>typename</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误：U 之前必须加上 class 或 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, U&gt;</span><br><span class="line"><span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> U &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在模板参数列表中，这两个关键字的含义相同，可以互换使用。一个模板参数列表中可以同时使用这两个关键字：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：在模板参数列表中，typename 和 class 没有什么不同</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">calc</span>(<span class="title">const</span> <span class="title">T</span> &amp;, <span class="title">const</span> <span class="title">U</span> &amp;);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>除了定义类型参数，还可以在模板中定义<strong>非类型参数</strong>（nontype parameter）。<strong>一个非类型参数表示一个值而非一个类型。</strong> 我们通过一个特定的类型名而非关键字 <code>class</code> 或 <code>typename</code> 来指定非类型参数。</p>
<p>当一个模板被实例化时，非类型参数被一个用户提供的或编译器推断出的值所代替。<br>这些值必须是常量表达式，从而允许编译器在编译时实例化模板。</p>
<p>例如，我们可以编写一个 <code>compare</code> 版本处理字符串字面常量。这种字面常量是 <code>const char</code> 的数组。由于不能拷贝一个数组，所以我们将自己的参数定义为数组的引用，由于我们希望能比较不同长度的字符串字面常量，因此为模板定义了两个非类型的参数。第一个模板参数表示第一个数组的长度，第二个参数表示第二个数组的长度：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们调用这个版本的 <code>compare</code> 时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">compare(<span class="string">"hi"</span>, <span class="string">"mom"</span>)</span><br></pre></td></tr></table></figure>
<p>编译器会使用字面常量的大小来代替 <code>N</code> 和 <code>M</code>，从而实例化模板。记住，<strong>编译器会在一个字符串字面常量的末尾插入一个空字符作为终结符</strong>，因此编译器会实例化出如下版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;p1)[<span class="number">3</span>], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;p2)[<span class="number">4</span>])</span></span></span><br></pre></td></tr></table></figure>
<p>（需要注意对于字符串字面常量来说，<code>sizeof</code> 和 <code>strlen</code> 的区别——博主注。）</p>
</li>
<li><p><strong>一个非类型参数可以是一个整型，或者是一个指向对象或函数类型的指针或（左值）引用。绑定到非类型整型参数的实参必须是一个常量表达式。绑定到指针或引用非类型参数的实参必须具有静态的生存期，我们不能用一个普通（非 <code>static</code>）局部变量或动态对象作为指针或引用非类型模板参数的实参。指针参数也可以用 <code>nullptr</code> 或一个值为 0 的常量表达式来实例化。</strong></p>
</li>
<li><p>在模板定义内，模板非类型参数是一个常量值。在需要常量表达式的地方，可以使用非类型参数，例如，指定数组大小。</p>
<blockquote>
<p><strong>Note：</strong> 非类型模板参数的模板实参必须是常量表达式。</p>
</blockquote>
</li>
<li><p>函数模板可以声明为 <code>inline</code> 或 <code>constexpr</code> 的，如同非模板函数一样。<code>inline</code> 或 <code>constexpr</code> 说明符放在模板参数列表之后，返回类型之前：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：inline 说明符跟在模板参数列表之后</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 错误：inline 说明符的位置不正确</span></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写泛型代码的两个重要原则：</p>
<ul>
<li>模板中的函数参数是 <code>const</code> 的引用。</li>
<li>函数体中的条件判断仅使用 <code>&lt;</code> 比较运算。</li>
</ul>
</li>
<li><blockquote>
<p><strong>Best Practices：</strong> 模板程序应该尽量减少对实参类型的要求。</p>
</blockquote>
</li>
<li><p><strong>当编译器遇到一个模板定义时，它并不生成代码。只有当我们实例化出模板的一个特定版本时，编译器才会生成代码。</strong></p>
</li>
<li><p>通常，当我们调用一个函数时，编译器只需要掌握函数的声明。类似的，当我们使用一个类类型的对象时，类定义必须是可用的，但成员函数的定义不必已经出现。因此，我们将类定义和函数声明放在头文件中，而普通函数和类的成员函数的定义放在源文件中。</p>
<p>模板则不同：<strong>为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义。因此，与非模板代码不同，模板的头文件通常既包括声明也包括定义。</strong></p>
<blockquote>
<p><strong>Note：函数模板和类模板成员函数的定义通常放在头文件中。</strong></p>
</blockquote>
</li>
<li><p>模板包含两种名字：</p>
<ul>
<li>那些不依赖于模板参数的名字</li>
<li>那些依赖于模板参数的名字</li>
</ul>
<p><br></p>
<p>当使用模板时，所有不依赖于模板参数的名字都必须是可见的，这是由模板的提供者来保证的。而且，模板的提供者必须保证，当模板被实例化时，模板的定义，包括类模板的成员的定义，也必须是可见的。</p>
<p>用来实例化模板的所有函数、类型以及与类型关联的运算符的声明都必须是可见的，这是由模板的用户来保证的。</p>
</li>
<li><p>模板的设计者应该提供一个头文件，包含模板定义以及在类模板或成员定义中用到的所有名字的声明。模板的用户必须包含模板的头文件，以及用来实例化模板的任何类型的头文件。</p>
</li>
<li><p>模板直到实例化时才会生成代码，这一特性影响了我们何时才会获知模板内代码的编译错误。通常，编译器会在三个阶段报告错误。</p>
<ul>
<li>第一个阶段是<strong>编译模板本身时</strong>。在这个阶段，编译器通常不会发现很多错误。编译器可以检查语法错误，例如忘记分号或者变量名拼错等，但也就这么多了。</li>
<li>第二个阶段是<strong>编译器遇到模板使用时</strong>。在此阶段，编译器仍然没有很多可检查的。对于函数模板调用，编译器通常会检查实参数目是否正确。它还能检查参数类型是否匹配。对于类模板，编译器可以检查用户是否提供了正确数目的模板实参，但也仅限于此了。</li>
<li>第三个阶段是<strong>模板实例化时</strong>，只有这个阶段才能发现类型相关的错误。依赖于编译器如何管理实例化，这类错误可能在链接时才报告。</li>
</ul>
</li>
<li><blockquote>
<p><strong>WARNING：</strong> 保证传递给模板的实参支持模板所要求的操作，以及这些操作在模板中能正确工作，是调用者的责任。</p>
</blockquote>
</li>
</ol>
<h2 id="16-1-2-类模板" class="heading-control"><a href="#16-1-2-类模板" class="headerlink" title="16.1.2 类模板"></a>16.1.2 类模板<a class="heading-anchor" href="#16-1-2-类模板" aria-hidden="true"></a></h2><ol>
<li><p><strong>类模板</strong>（class template）。与函数模板的不同之处是，<strong>编译器不能为类模板推断模板参数类型</strong>。如我们已经多次看到的，为了使用类模板，我们必须在模板名后的尖括号中提供额外信息——用来代替模板参数的模板实参列表。</p>
</li>
<li><p>类似函数模板，类模板以关键字 <code>template</code> 开始，后跟模板参数列表。</p>
</li>
<li><p>当使用一个类模板时，我们必须提供额外信息。这些额外信息是<strong>显式模板实参</strong>（explicit template argument）列表，它们被绑定到模板参数。编译器使用这些模板实参来实例化出特定的类。</p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 一个类模板的每个实例都形成一个独立的类。</p>
</blockquote>
</li>
<li><p>类模板的名字不是一个类型名。类模板用来实例化类型，而一个实例化的类型总是包含模板参数的。</p>
</li>
<li><p>一个类模板中的代码如果使用了另外一个模板，通常不将一个实际类型（或值）的名字用作其模板实参。相反的，我们通常将模板自己的参数当作被使用模板的实参。</p>
</li>
<li><p>与其他任何类相同，我们<strong>既可以在类模板内部，也可以在类模板外部为其定义成员函数，且定义在类模板内的成员函数被隐式声明为内联函数</strong>。</p>
</li>
<li><p>类模板的成员函数具有和模板相同的模板参数。因而，<strong>定义在类模板之外的成员函数就必须以关键字 <code>template</code> 开始，后接类模板参数列表</strong>。当我们在类外定义一个成员时，必须说明成员属于哪个类。而且，从一个模板生成的类的名字中必须包含其模板实参。当我们定义一个成员函数时，模板实参与模板形参相同。例如像下面这样定义 <code>Blob</code> 模板类的一些成员函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::check(size_type i, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= data-&gt;size())</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T &amp;Blob&lt;T&gt;::back()</span><br><span class="line">&#123;</span><br><span class="line">    check(o, <span class="string">"back on empty Blob"</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;back();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T &amp;Blob&lt;T&gt;::<span class="keyword">operator</span>[](size_type i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果 i 太大，check 会抛出异常，阻止访问一个不存在的元素</span></span><br><span class="line">    check(i, <span class="string">"subscript out of range"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::pop_back()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"pop back on empty Blob"</span>);</span><br><span class="line">    data-&gt;pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与其他任何定义在类模板外的成员一样，构造函数的定义要以模板参数开始：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob() : data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;()) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果一个成员函数没有被使用，则它不会被实例化。成员函数只有在被用到时才进行实例化，这一特性使得即使某种类型不能完全符合模板操作的要求，我们仍然能用该类型实例化类。</p>
<blockquote>
<p><strong>Note：默认情况下，对于一个实例化了的类模板，其成员只有在使用时才被实例化。</strong></p>
</blockquote>
</li>
<li><p>当我们使用一个类模板类型时必须提供模板实参，但这一规则有一个例外。<strong>在类模板自己的作用域中，我们可以直接使用模板名而不提供实参</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 若试图访问一个不存在的元素，BlobPtr 抛出一个异常</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BlobPtr() : curr(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    BlobPtr(Blob&lt;T&gt; &amp;a, <span class="keyword">size_t</span> sz = <span class="number">0</span>) : wptr(a.data), curr(sz) &#123;&#125;</span><br><span class="line">    T &amp;<span class="keyword">operator</span>*() <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">        <span class="keyword">return</span> (*p)[curr]; <span class="comment">// (*p) 为本对象指向的 vector</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递增和递减</span></span><br><span class="line">    BlobPtr &amp;<span class="keyword">operator</span>++(); <span class="comment">// 前置运算符</span></span><br><span class="line">    BlobPtr &amp;<span class="keyword">operator</span>--();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 若检查成功，check 返回一个指向 vector 的 shared_ptr</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; <span class="title">check</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 保存一个 weak_ptr，表示底层 vector 可能被销毁</span></span><br><span class="line">    <span class="built_in">std</span>::weak_ptr&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; wptr;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">size_t</span> curr; <span class="comment">// 数组中的当前位置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>BlobPtr</code> 的前置递增和递减成员返回 <code>BlobPtr&amp;</code>，而不是 <code>BlobPtr&lt;T&gt;&amp;</code>。<strong>当我们处于一个类模板的作用域中时，编译器处理模板自身引用时就好像我们已经提供了与模板参数匹配的实参一样。</strong> 即，就好像我们这样编写代码一样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BlobPtr&lt;T&gt; &amp;<span class="keyword">operator</span>++();</span><br><span class="line">BlobPtr&lt;T&gt; &amp;<span class="keyword">operator</span>--();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>当我们在类模板外定义其成员时，必须记住，我们并不在类的作用域中，直到遇到类名才表示进入类的作用域</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 后置：递增/递减对象但返回原值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">BlobPtr&lt;T&gt; BlobPtr&lt;T&gt;::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处无须检查；调用前置递增时会进行检查</span></span><br><span class="line">    BlobPtr ret = *<span class="keyword">this</span>; <span class="comment">// 保存当前值</span></span><br><span class="line">    ++*<span class="keyword">this</span>;             <span class="comment">// 推进一个元素；前置 ++ 检查递增是否合法</span></span><br><span class="line">    <span class="keyword">return</span> ret;          <span class="comment">// 返回保存的状态</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于返回类型位于类的作用域之外，我们必须指出返回类型是一个实例化的 <code>BlobPtr</code>，它所用类型与类实例化所用类型一致。在函数体内，我们已经进入类的作用域，因此在定义 <code>ret</code> 时无须重复模板实参。如果不提供模板实参，则编译器将假定我们使用的类型与成员实例化所用类型一致。因此，<code>ret</code> 的定义与如下代码等价：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BlobPtr&lt;T&gt; ret = *<span class="keyword">this</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：</strong> 在一个类模板的作用域内，我们可以直接使用模板名而不必指定模板实参。</p>
</blockquote>
</li>
<li><p>当一个类包含一个友元声明时，类与友元各自是否是模板是相互无关的。<strong>如果一个类模板包含一个非模板友元，则友元被授权可以访问所有模板实例。如果友元自身是模板，类可以授权给所有友元模板实例，也可以只授权给特定实例。</strong></p>
</li>
<li><p>类模板与另一个（类或函数）模板间友好关系的最常见的形式是建立对应实例及其友元间的友好关系。</p>
</li>
<li><p>为了引用（类或函数）模板的一个特定实例，我们必须首先声明模板自身。一个模板声明包括模板参数列表：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在 Blob 中声明友元所需要的</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span> <span class="comment">// 运算符 == 中的参数所需要的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Blob&lt;T&gt; &amp;, <span class="keyword">const</span> Blob&lt;T&gt; &amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 每个 Blob 实例将访问权限授予用相同类型实例化的 BlobPtr 和相等运算符</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;T&gt;;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;(<span class="keyword">const</span> Blob&lt;T&gt; &amp;, <span class="keyword">const</span> Blob&lt;T&gt; &amp;);</span><br><span class="line">    <span class="comment">// 其他成员定义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们首先将 <code>Blob</code>、<code>BlobPtr</code> 和 <code>operator==</code> 声明为模板。这些声明是 <code>operator==</code> 函数的参数声明以及 <code>Blob</code> 中的友元声明所需要的。</p>
<p>友元的声明用 <code>Blob</code> 的模板形参作为它们自己的模板实参。因此，友好关系被限定在用相同类型实例化的 <code>Blob</code> 与 <code>BlobPtr</code> 相等运算符之间：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Blob&lt;<span class="keyword">char</span>&gt; ca; <span class="comment">// BlobPtr&lt;char&gt; 和 operator==&lt;char&gt; 都是本对象的友元</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; ia;  <span class="comment">// BlobPtr&lt;int&gt; 和 operator==&lt;int&gt; 都是本对象的友元</span></span><br></pre></td></tr></table></figure>
<p><code>BlobPtr&lt;char&gt;</code> 的成员可以访问 <code>ca</code>（或任何其他 <code>Blob&lt;char&gt;</code> 对象）的非 <code>public</code> 部分，但 <code>ca</code> 对 <code>ia</code>（或任何其他 <code>Blob&lt;int&gt;</code> 对象）或 <code>Blob</code> 的任何其他实例都没有特殊访问权限。</p>
</li>
<li><p><strong>一个类也可以将另一个模板的每个实例都声明为自己的友元，或者限定特定的实例为友元</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置声明，在将模板的一个特定实例声明为友元时要用到</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> // <span class="title">C</span> 是一个普通的非模板类</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;C&gt;;</span> <span class="comment">// 用类 C 实例化的 Pal 是 C 的一个友元</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pal2 的所有实例都是 C 的友元；这种情况无须前置声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> // <span class="title">C2</span> 本身是一个类模板</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// C2 的每个实例将相同实例化的 Pal 声明为友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>&lt;T&gt;;</span> <span class="comment">// Pal 的模板声明必须在作用域之内</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pal2 的所有实例都是 C2 的每个实例的友元，不需要前置声明</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> X&gt;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pal3 是一个非模板类，它是 C2 所有实例的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span> <span class="comment">// 不需要 Pal3 的前置声明</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>为了让所有实例成为友元，友元声明中必须使用与类模板本身不同的模板参数。</strong></p>
</li>
<li><p><strong>在新标准中，我们可以将模板类型参数声明为友元</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> Type; <span class="comment">// 将访问权限授予用来实例化 Bar 的类型</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>此处我们将用来实例化 <code>Bar</code> 的类型声明为友元。因此，对于某个类型名 <code>Foo</code>，<code>Foo</code> 将成为 <code>Bar&lt;Foo&gt;</code> 的友元，<code>Sales_data</code> 将成为 <code>Bar&lt;Sales_data&gt;</code> 的友元，依此类推。</p>
<p>值得注意的是，<strong>虽然友元通常来说应该是一个类或是一个函数，但我们完全可以用一个内置类型来实例化 <code>Bar</code>。这种与内置类型的友好关系是允许的</strong>，以便我们能用内置类型来实例化 <code>Bar</code> 这样的类。</p>
</li>
<li><p>类模板的一个实例定义了一个类类型，与任何其他类类型一样，我们可以定义一个 <code>typedef</code> 来引用实例化的类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Blob&lt;<span class="built_in">string</span>&gt; StrBlob;</span><br></pre></td></tr></table></figure>
<p><strong>由于模板不是一个类型，我们不能定义一个 <code>typedef</code> 引用一个模板。</strong> 即，无法定义一个 <code>typedef</code> 引用 <code>Blob&lt;T&gt;</code>。</p>
<p>但是，<strong>新标准允许我们为类模板定义一个类型别名</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors; <span class="comment">// authors 是一个 pair&lt;string, string&gt;</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们将 <code>twin</code> 定义为成员类型相同的 <code>pair</code> 的别名。这样，<code>twin</code> 的用户只需指定一次类型。一个模板类型别名是一族类的别名：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">twin&lt;<span class="keyword">int</span>&gt; win_loss; <span class="comment">// win_loss 是一个 pair&lt;int, int&gt;</span></span><br><span class="line">twin&lt;<span class="keyword">double</span>&gt; area;  <span class="comment">// area 是一个 pair&lt;double, double&gt;</span></span><br></pre></td></tr></table></figure>
<p>就像使用类模板一样，当我们使用 <code>twin</code> 时，需要指出希望使用哪种特定类型的 <code>twin</code>。<strong>当我们定义一个模板类型别名时，可以固定一个或多个模板参数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br><span class="line"></span><br><span class="line">partNo&lt;<span class="built_in">string</span>&gt; books; <span class="comment">// books 是一个 pair&lt;string, unsigned&gt;</span></span><br><span class="line">partNo&lt;Vehicle&gt; cars; <span class="comment">// cars 是一个 pair&lt;Vehicle, unsigned&gt;</span></span><br><span class="line">partNo&lt;Student&gt; kids; <span class="comment">// kids 是一个 pair&lt;Student, unsigned&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码中我们将 <code>partNo</code> 定义为一族类型的别名，这族类型是 <code>second</code> 成员为 <code>unsigned</code> 的 <code>pair</code>。<code>partNo</code> 的用户需要指出 <code>pair</code> 的 <code>first</code> 成员的类型，但不能指定 <code>second</code> 成员的类型。</p>
</li>
<li><p>与任何其他类相同，<strong>类模板可以声明 <code>static</code> 成员</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line">    <span class="comment">// 其他接口成员</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::<span class="keyword">size_t</span> ctr;</span><br><span class="line">    <span class="comment">// 其他实现成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，<code>Foo</code> 是一个类模板，它有一个名为 <code>count</code> 的 <code>public static</code> 成员函数和一个名为 <code>ctr</code> 的 <code>private static</code> 数据成员。每个 <code>Foo</code> 的实例都有其自己的 <code>static</code> 成员实例。即，对任意给定类型 <code>X</code>，都有一个 <code>Foo&lt;X&gt;::ctr</code> 和一个 <code>Foo&lt;X&gt;::count</code> 成员。所有 <code>Foo&lt;X&gt;</code> 类型的对象共享相同的 <code>ctr</code> 对象和 <code>count</code> 函数。例如，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化 static 成员 Foo&lt;string&gt;::ctr 和 Foo&lt;string&gt;::count</span></span><br><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs;</span><br><span class="line"><span class="comment">// 所有三个对象共享相同的 Foo&lt;int&gt;::ctr 和 Foo&lt;int&gt;::count 成员</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi, fi2, fi3;</span><br></pre></td></tr></table></figure>
<p>与任何其他 <code>static</code> 数据成员相同，模板类的每个 <code>static</code> 数据成员必须有且仅有一个定义。但是，类模板的每个实例都有一个独有的 <code>static</code> 对象。因此，与定义模板的成员函数类似，我们将 <code>static</code> 数据成员也定义为模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">size_t</span> Foo&lt;T&gt;::ctr = <span class="number">0</span>; <span class="comment">// 定义并初始化 ctr</span></span><br></pre></td></tr></table></figure>
<p>与类模板的其他任何成员类似，定义的开始部分是模板参数列表，随后是我们定义的成员的类型和名字。与往常一样，成员名包括成员的类名，对于从模板生成的类来说，类名包括模板实参。因此，当使用一个特定的模板实参类型实例化 <code>Foo</code> 时，将会为该类类型实例化一个独立的 <code>ctr</code>，并将其初始化为 0。</p>
<p><strong>与非模板类的静态成员相同，我们可以通过类类型对象来访问一个类模板的 <code>static</code> 成员，也可以使用作用域运算符直接访问成员。当然，为了通过类来直接访问 <code>static</code> 成员，我们必须引用一个特定的实例</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;                 <span class="comment">// 实例化 Foo&lt;int&gt; 类和 static 数据成员 ctr</span></span><br><span class="line"><span class="keyword">auto</span> ct = Foo&lt;<span class="keyword">int</span>&gt;::count(); <span class="comment">// 实例化 Foo&lt;int&gt;::count</span></span><br><span class="line">ct = fi.count();             <span class="comment">// 使用 Foo&lt;int&gt;::count</span></span><br><span class="line">ct = Foo::count();           <span class="comment">// 错误：使用哪个模板实例的 count？</span></span><br></pre></td></tr></table></figure>
<p><strong>类似任何其他成员函数，一个 <code>static</code> 成员函数只有在使用时才会实例化。</strong></p>
</li>
</ol>
<h2 id="16-1-3-模板参数" class="heading-control"><a href="#16-1-3-模板参数" class="headerlink" title="16.1.3 模板参数"></a>16.1.3 模板参数<a class="heading-anchor" href="#16-1-3-模板参数" aria-hidden="true"></a></h2><ol>
<li><p>模板参数遵循普通的作用域规则。<strong>一个模板参数名的可用范围是在其声明之后，至模板声明或定义结束之前。与任何其他名字一样，模板参数会隐藏外层作用域中声明的相同名字。但是，与大多数其他上下文不同，在模板内不能重用模板参数名</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> A;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(A a, B b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A tmp = a; <span class="comment">// tmp 的类型为模板参数 A 的类型，而非 double</span></span><br><span class="line">    <span class="keyword">double</span> B;  <span class="comment">// 错误：重声明模板参数 B</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常的名字隐藏规则决定了 <code>A</code> 的 <code>typedef</code> 被类型参数 <code>A</code> 隐藏。因此，<code>tmp</code> 不是一个 <code>double</code>，其类型是使用 <code>f</code> 时绑定到类型参数 <code>A</code> 的类型。由于我们不能重用模板参数名，声明名字为 <code>B</code> 的变量是错误的。</p>
<p><strong>由于参数名不能重用，所以一个模板参数名在一个特定模板参数列表中只能出现一次</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误：非法重用模板参数名 V</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> V, <span class="keyword">typename</span> V&gt; <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>模板声明必须包含模板参数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明但不定义 compare 和 Blob</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br></pre></td></tr></table></figure>
<p><strong>与函数参数相同，声明中的模板参数的名字不必与定义中相同</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3 个 calc 都指向相同的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">calc</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">U <span class="title">calc</span><span class="params">(<span class="keyword">const</span> U &amp;, <span class="keyword">const</span> U &amp;)</span></span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 模板的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function">Type <span class="title">calc</span><span class="params">(<span class="keyword">const</span> Type &amp;a, <span class="keyword">const</span> Type &amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，<strong>一个给定模板的每个声明和定义必须有相同数量和种类（即，类型或非类型）的参数</strong>。</p>
</li>
<li><blockquote>
<p><strong>Best Practices：一个特定文件所需要的所有模板的声明通常一起放置在文件开始位置，出现于任何使用这些模板的代码之前。</strong></p>
</blockquote>
</li>
<li><p><strong>我们用作用域运算符（<code>::</code>）来访 <code>static</code> 成员和类型成员。</strong> 在普通（非模板）代码中，编译器掌握类的定义。因此，它知道通过作用域运算符访问的名字是类型还是 <code>static</code> 成员。</p>
<p>但对于模板代码就存在困难。例如，假定 <code>T</code> 是一个模板类型参数，当编译器遇到类似 <code>T::mem</code> 这样的代码时，它不会知道 <code>mem</code> 是一个类型成员还是一个 <code>static</code> 数据成员，直至实例化时才会知道。但是，为了处理模板，编译器必须知道名字是否表示一个类型。例如，假定 <code>T</code> 是一个类型参数的名字，当编译器遇到如下形式的语句时：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">T::size_type *p;</span><br></pre></td></tr></table></figure>
<p>它需要知道我们是正在定义一个名为 <code>p</code> 的变量还是将一个名为 <code>size_type</code> 的 <code>static</code> 数据成员与名为 <code>p</code> 的变量相乘。</p>
<p><strong>默认情况下，C++ 语言假定通过作用域运算符访问的名字不是类型。因此，如果我们希望使用一个模板类型参数的类型成员，就必须显式告诉编译器该名字是一个类型。我们通过使用关键字 <code>typename</code> 来实现这一点</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T &amp;c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!c.empty())</span><br><span class="line">        <span class="keyword">return</span> c.back();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">typename</span> T::value_type();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：当我们希望通知编译器一个名字表示类型时，必须使用关键字 <code>typename</code>，而不能使用 <code>class</code>。</strong></p>
</blockquote>
</li>
<li><p>就像我们能为函数参数提供默认实参一样，我们也可以提供<strong>默认模板实参</strong>（default template argument）。<strong>在新标准中，我们可以为函数和类模板提供默认实参。</strong> 而更早的 C++ 标准只允许为类模板提供默认实参。</p>
<p>例如，我们重写 <code>compare</code>，默认使用标准库的 <code>less</code> 函数对象模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compare 有一个默认模板实参 less&lt;T&gt; 和一个默认函数实参 F()</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T &amp;v1, <span class="keyword">const</span> T &amp;v2, F f = F())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (f(v1, v2))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (f(v2, v1))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们为模板添加了第二个类型参数，名为 <code>F</code>，表示可调用对象的类型；并定义了一个新的函数参数 <code>f</code>，绑定到一个可调用对象上。</p>
<p>我们为此模板参数提供了默认实参，并为其对应的函数参数也提供了默认实参。默认模板实参指出 <code>compare</code> 将使用标准库的 <code>less</code> 函数对象类，它是使用与 <code>compare</code> 一样的类型参数实例化的。默认函数实参指出 <code>f</code> 将是类型 <code>F</code> 的一个默认初始化的对象。</p>
<p>当用户调用这个版本的 <code>compare</code> 时，可以提供自己的比较操作，但这并不是必需的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> i = compare(<span class="number">0</span>, <span class="number">42</span>); <span class="comment">// 使用 less；i 为 -1</span></span><br><span class="line"><span class="comment">// 结果依赖于 item1 和 item2 中的 isbn</span></span><br><span class="line">Sales_data item1(cin), item2(cin);</span><br><span class="line"><span class="keyword">bool</span> j = compare(item1, item2, compareIsbn);</span><br></pre></td></tr></table></figure>
<p>第一个调用使用默认函数实参，即，类型 <code>less&lt;T&gt;</code> 的一个默认初始化对象。在此调用中，<code>T</code> 为 <code>int</code>，因此可调用对象的类型为 <code>less&lt;int&gt;</code>，<code>compare</code> 的这个实例化版本将使用 <code>less&lt;int&gt;</code> 进行比较操作。</p>
<p>在第二个调用中，我们传递给 <code>compare</code> 三个实参：<code>compareIsbn</code> 和两个 <code>Sales_data</code> 类型的对象。当传递给 <code>compare</code> 三个实参时，第三个实参的类型必须是一个可调用对象，该可调用对象的返回类型必须能转换为 <code>bool</code> 值，且接受的实参类型必须与 <code>compare</code> 的前两个实参的类型兼容。与往常一样，模板参数的类型从它们对应的函数实参推断而来。在此调用中，<code>T</code> 的类型被推断为 <code>Sales_data</code>，<code>F</code> 被推断为 <code>compareIsbn</code> 的类型。</p>
<p><strong>与函数默认实参一样，对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参。</strong></p>
</li>
<li><p><strong>无论何时使用一个类模板，我们都必须在模板名之后接上尖括号。尖括号指出类必须从一个模板实例化而来。特别是，如果一个类模板为其所有模板参数都提供了默认实参，且我们希望使用这些默认实参，就必须在模板名之后跟一个空尖括号对</strong>（类似于函数调用时必须要要有 <code>()</code>——博主注）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt; // <span class="title">T</span> 默认为 <span class="title">int</span></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Numbers</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Numbers(T v = <span class="number">0</span>) : val(v) &#123;&#125;</span><br><span class="line">    <span class="comment">// 对数值的各种操作</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;<span class="keyword">long</span> <span class="keyword">double</span>&gt; lots_of_precision;</span><br><span class="line">Numbers&lt;&gt; average_precision; <span class="comment">// 空 &lt;&gt; 表示我们希望使用默认类型</span></span><br></pre></td></tr></table></figure>
<p>此例中我们实例化了两个 <code>Numbers</code> 版本：<code>average_precision</code> 是用 <code>int</code> 代替 <code>T</code> 实例化得到的：<code>lots_of_precision</code> 是用 <code>long double</code> 代替 <code>T</code> 实例化而得到的。</p>
</li>
</ol>
<h2 id="16-1-4-成员模板" class="heading-control"><a href="#16-1-4-成员模板" class="headerlink" title="16.1.4 成员模板"></a>16.1.4 成员模板<a class="heading-anchor" href="#16-1-4-成员模板" aria-hidden="true"></a></h2><ol>
<li><p>一个类（无论是普通类还是类模板）可以包含本身是模板的成员函数。这种成员被称为<strong>成员模板</strong>（member template）。<strong>成员模板不能是虚函数。</strong></p>
</li>
<li><p>作为普通类包含成员模板的例子，我们定义一个类，类似 <code>unique_ptr</code> 所使用的默认删除器类型。类似默认删除器，我们的类将包含一个重载的函数调用运算符，它接受一个指针并对此指针执行 <code>delete</code>。与默认删除器不同，我们的类还将在删除器被执行时打印一条信息。由于希望删除器适用于任何类型，所以我们将调用运算符定义为一个模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数对象类，对给定指针执行 delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DebugDelete(<span class="built_in">std</span>::ostream &amp;s = <span class="built_in">std</span>::<span class="built_in">cerr</span>) : os(s) &#123;&#125;</span><br><span class="line">    <span class="comment">// 与任何函数模板相同，T 的类型由编译器推断</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(T *p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">"deleting unique_ptr"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::ostream &amp;os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以像下面这样使用 <code>DebugDelete</code> 类：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> *p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d; <span class="comment">// 可像 delete 表达式一样使用的对象</span></span><br><span class="line">d(p);          <span class="comment">// 调用 DebugDelete::operator()(double*)，释放 p</span></span><br><span class="line"><span class="keyword">int</span> *ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="comment">// 在一个临时 DebugDelete 对象上调用 operator()(int*)</span></span><br><span class="line">DebugDelete()(ip);</span><br></pre></td></tr></table></figure>
<p>由于调用一个 <code>DebugDelete</code> 对象会 <code>delete</code> 其给定的指针，我们也可以将 <code>DebugDelete</code> 用作 <code>unique_ptr</code> 的删除器。为了重载 <code>unique_ptr</code> 的删除器，我们在尖括号内给出删除器类型，并提供一个这种类型的对象给 <code>unique_ptr</code> 的构造函数：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 销毁 p 指向的对象</span></span><br><span class="line"><span class="comment">// 实例化 DebugDelete::operator()&lt;int&gt;(int*)</span></span><br><span class="line">unique_ptr&lt;int, DebugDelete&gt; p(new int, DebugDelete());</span><br><span class="line"><span class="comment">// 销毁 sp 指向的对象</span></span><br><span class="line"><span class="comment">// 实例化 DebugDelete::operator()&lt;string&gt;(string*)</span></span><br><span class="line">unique_ptr&lt;string, DebugDelete&gt; sp(new string, DebugDelete());</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于类模板，我们也可以为其定义成员模板。在此情况下，类和成员各自有自己的、独立的模板参数。例如，我们将为 <code>Blob</code> 类定义一个构造函数，它接受两个选代器，表示要拷贝的元素范围。由于我们希望支持不同类型序列的选代器，因此将构造函数定义为模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blob</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">    Blob(It b, It e);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表。类模板的参数列表在前，后跟成员自己的模板参数列表</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;  <span class="comment">// 类的类型参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt; <span class="comment">// 构造函数的类型参数</span></span><br><span class="line">Blob&lt;T&gt;::Blob(It b, It e) : data(<span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt;(b, e))</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>为了实例化一个类模板的成员模板，我们必须同时提供类和函数模板的实参。</strong> 与往常一样，我们在哪个对象上调用成员模板，编译器就根据该对象的类型来推断类模板参数的实参。与普通函数模板相同，编译器通常根据传递给成员模板的函数实参来推断它的模板实参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">long</span>&gt; vi = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; w = &#123;<span class="string">"now"</span>, <span class="string">"is"</span>, <span class="string">"the"</span>, <span class="string">"time"</span>&#125;;</span><br><span class="line"><span class="comment">// 实例化 Blob&lt;int&gt; 类及其接受两个 int* 参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a1</span><span class="params">(begin(ia), end(ia))</span></span>;</span><br><span class="line"><span class="comment">// 实例化 Blob&lt;int&gt; 类的接受两个 vector&lt;long&gt;::iterator 的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(vi.begin(), vi.end())</span></span>;</span><br><span class="line"><span class="comment">// 实例化 Blob&lt;string&gt; 及其接受两个 list&lt;const char*&gt;::iterator 参数的构造函数</span></span><br><span class="line"><span class="function">Blob&lt;<span class="built_in">string</span>&gt; <span class="title">a3</span><span class="params">(w.begin(), w.end())</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="16-1-5-控制实例化" class="heading-control"><a href="#16-1-5-控制实例化" class="headerlink" title="16.1.5 控制实例化"></a>16.1.5 控制实例化<a class="heading-anchor" href="#16-1-5-控制实例化" aria-hidden="true"></a></h2><ol>
<li><p>当模板被使用时才会进行实例化这一特性意味着，相同的实例可能出现在多个对象文件中。<strong>当两个或多个独立编译的源文件使用了相同的模板，并提供了相同的模板参数时，每个文件中就都会有该模板的一个实例。</strong></p>
</li>
<li><p>在大系统中，在多个文件中实例化相同模板的额外开销可能非常严重。在新标准中，我们可以通过<strong>显式实例化</strong>（explicit instantiation）来避免这种开销（与自动实例化相对——博主注）。一个显式实例化有如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration; <span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;        <span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<p>declaration 是一个类或函数声明，其中所有模板参数已被替换为模板实参。例如，</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化声明与定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span>             <span class="comment">// 声明</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>; <span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<p><strong>当编译器遇到 <code>extern</code> 模板声明时，它不会在本文件中生成实例化代码。将一个实例化声明为 <code>extern</code> 就表示承诺在程序其他位置有该实例化的一个非 <code>extern</code> 声明（定义）。对于一个给定的实例化版本，可能有多个 <code>extern</code> 声明，但必须只有一个定义。</strong></p>
<p><strong>由于编译器在使用一个模板时自动对其实例化，因此 <code>extern</code> 声明必须出现在任何使用此实例化版本的代码之前</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Application.cc</span></span><br><span class="line"><span class="comment">// 这些模板类型必须在程序其他位置进行实例化</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line">Blob&lt;<span class="built_in">string</span>&gt; sa1, sa2; <span class="comment">// 实例化会出现在其他位置</span></span><br><span class="line"><span class="comment">// Blob&lt;int&gt; 及其接受 initializer_list 的构造函数在本文件中实例化</span></span><br><span class="line">Blob&lt;<span class="keyword">int</span>&gt; a1 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">Blob&lt;<span class="keyword">int</span>&gt; <span class="title">a2</span><span class="params">(a1)</span></span>;              <span class="comment">// 拷贝构造函数在本文件中实例化</span></span><br><span class="line"><span class="keyword">int</span> i = compare(a1[<span class="number">0</span>], a2[<span class="number">0</span>]); <span class="comment">// 实例化出现在其他位置</span></span><br></pre></td></tr></table></figure>
<p>文件 <code>Application.o</code> 将包含 <code>Blob&lt;int&gt;</code> 的实例及其接受 <code>initializer_list</code> 参数的构造函数和拷贝构造函数的实例。而 <code>compare&lt;int&gt;</code> 函数和 <code>Blob&lt;string&gt;</code> 类将不在本文件中进行实例化。这些模板的定义必须出现在程序的其他文件中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// templateBuild.cc</span></span><br><span class="line"><span class="comment">// 实例化文件必须为每个在其他文件中声明为 extern 的类型和函数提供一个（非 extern）</span></span><br><span class="line"><span class="comment">// 的定义</span></span><br><span class="line"><span class="function"><span class="keyword">template</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>&lt;string&gt;;</span> <span class="comment">// 实例化类模板的所有成员</span></span><br></pre></td></tr></table></figure>
<p>当编译器遇到一个实例化定义（与声明相对）时，它为其生成代码。因此，文件 <code>templateBuild.o</code> 将会包含 <code>compare</code> 的 <code>int</code> 实例化版本的定义和 <code>Blob&lt;string&gt;</code> 类的定义。当我们编译此应用程序时，必须将 <code>templateBuild.o</code> 和 <code>Application.o</code> 链接到一起。</p>
</li>
<li><blockquote>
<p><strong>WARNING：对每个实例化声明，在程序中某个位置必须有其显式的实例化定义。</strong></p>
</blockquote>
</li>
<li><p><strong>一个类模板的实例化定义会实例化该模板的所有成员，包括内联的成员函数。当编译器遇到一个实例化定义时，它不了解程序使用哪些成员函数。因此，与处理类模板的普通实例化（自动实例化——博主注）不同，编译器会实例化该类的所有成员。即使我们不使用某个成员，它也会被实例化。因此，我们用来显式实例化一个类模板的类型，必须能用于模板的所有成员。</strong></p>
<blockquote>
<p><strong>Note：</strong> 在一个类模板的实例化定义中，所用类型必须能用于模板的所有成员函数。</p>
</blockquote>
</li>
<li><p><strong>练习 16.26：</strong> 假设 <code>NoDefault</code> 是一个没有默认构造函数的类，我们可以显式实例化 <code>vector&lt;NoDefault&gt;</code> 吗？如果不可以，解释为什么。</p>
<p>答：不可以，因为显示实例化会 <code>vector&lt;NoDefault&gt;</code> 时会实例化 <code>vector</code> 的所有成员函数，包括其接受容器大小的构造函数，该构造函数需要使用元素类型的默认构造函数对容器元素进行值初始化。</p>
</li>
<li><p><strong>练习 16.27：</strong> 对下面每条带标签的语句，解释发生了什么样的实例化（如果有的话）。如果一个模板被实例化，解释为什么；如果未实例化，解释为什么没有。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Stack&lt;<span class="keyword">char</span>&gt;)</span></span>; <span class="comment">// (a)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Exercise</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Stack&lt;<span class="keyword">double</span>&gt; &amp;rsd; <span class="comment">// (b)</span></span><br><span class="line">    Stack&lt;<span class="keyword">int</span>&gt; si;      <span class="comment">// (c)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">char</span>&gt; *sc;                  <span class="comment">// (d)</span></span><br><span class="line">    f1(*sc);                          <span class="comment">// (e)</span></span><br><span class="line">    <span class="keyword">int</span> iObj = <span class="keyword">sizeof</span>(Stack&lt;<span class="built_in">string</span>&gt;); <span class="comment">// (f)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>答：(a)、(b)、(c)、(f) 分别会发生 <code>Stack</code> 针对 <code>char</code> <code>double</code> <code>int</code> <code>string</code> 类型的模板自动实例化；(d)、(e) 不会发生实例化，因为所涉及到的模板类类型 <code>Stack&lt;char&gt;</code> 在此前已被实例化出来。</p>
</li>
</ol>
<h2 id="16-1-6-效率与灵活性" class="heading-control"><a href="#16-1-6-效率与灵活性" class="headerlink" title="16.1.6 效率与灵活性"></a>16.1.6 效率与灵活性<a class="heading-anchor" href="#16-1-6-效率与灵活性" aria-hidden="true"></a></h2><ol>
<li><ul>
<li><code>shared_ptr</code> 和 <code>unique_ptr</code> 之间的明显不同是它们管理所保存的指针的策略前者给予我们共享指针所有权的能力；后者则独占指针。</li>
<li>这两个类的另一个差异是它们允许用户重载默认删除器的方式。<strong>我们可以很容易地重载一个 <code>shared_ptr</code> 的删除器，只要在创建或 <code>reset</code> 指针时传递给它一个可调用对象即可。与之相反，删除器的类型是一个 <code>unique_ptr</code> 对象的类型的一部分。用户必须在定义 <code>unique_ptr</code> 时以显式模板实参的形式提供删除器的类型。</strong></li>
</ul>
</li>
<li><p><code>shared_ptr</code> 不是将删除器直接保存为一个成员，因为删除器的类型直到运行时才会知道。实际上，在一个 <code>shared_ptr</code> 的生存期中，我们可以随时改变其删除器的类型。我们可以使用一种类型的删除器构造一个 <code>shared_ptr</code>，随后使用 <code>reset</code> 赋予此 <code>shared_ptr</code> 另一种类型的删除器。通常，类成员的类型在运行时是不能改变的。因此，不能直接保存删除器。</p>
</li>
<li><p>在 <code>unique_ptr</code> 类中，删除器的类型是类类型的一部分。即，<strong><code>unique_ptr</code> 有两个模板参数，一个表示它所管理的指针，另一个表示删除器的类型</strong>。由于删除器的类型是 <code>unique_ptr</code> 类型的一部分，因此删除器成员的类型在编译时是知道的，从而删除器可以直接保存在 <code>unique_ptr</code> 对象中。</p>
</li>
<li><p>通过在编译时绑定删除器，<code>unique_ptr</code> 避免了间接调用删除器的运行时开销（一个 <code>if</code> 判断——博主注）。通过在运行时绑定删除器，<code>shared_ptr</code> 使用户重载删除器更为方便。</p>
</li>
</ol>
<h1 id="16-2-模板实参推断" class="heading-control"><a href="#16-2-模板实参推断" class="headerlink" title="16.2 模板实参推断"></a>16.2 模板实参推断<a class="heading-anchor" href="#16-2-模板实参推断" aria-hidden="true"></a></h1><ol>
<li>从函数实参来确定模板实参的过程被称为<strong>模板实参推断</strong>（template argument deduction）。</li>
</ol>
<h2 id="16-2-1-类型转换与模板类型参数" class="heading-control"><a href="#16-2-1-类型转换与模板类型参数" class="headerlink" title="16.2.1 类型转换与模板类型参数"></a>16.2.1 类型转换与模板类型参数<a class="heading-anchor" href="#16-2-1-类型转换与模板类型参数" aria-hidden="true"></a></h2><ol>
<li><p>与往常一样，顶层 <code>const</code> 无论是在形参中还是在实参中，都会被忽略。在其他类型转换中，能在调用中应用于函数模板的包括如下两项。</p>
<ul>
<li><strong><code>const</code> 转换：可以将一个非 <code>const</code> 对象的引用（或指针）传递给一个 <code>const</code> 的引用（或指针）形参。</strong></li>
<li><strong>数组或函数指针转换：如果函数形参不是引用类型，则可以对数组或函数类型的实参应用正常的指针转换。一个数组实参可以转换为一个指向其首元素的指针。类似的，一个函数实参可以转换为一个该函数类型的指针。</strong></li>
</ul>
<p><br></p>
<p>其他类型转换，如算术转换、派生类向基类的转换以及用户定义的转换，都不能应用于函数模板。</p>
</li>
<li><p><strong>如果形参是一个引用，则数组不会转换为指针。</strong></p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 将实参传递给带模板类型的函数形参时，能够自动应用的类型转换只有 <code>const</code> 转换及数组或函数到指针的转换。</p>
</blockquote>
</li>
<li><p>一个模板类型参数可以用作多个函数形参的类型。由于只允许有限的几种类型转换，因此传递给这些形参的实参必须具有相同的类型。如果推断出的类型不匹配，则调用就是错误的。</p>
</li>
<li><p>如果希望允许对函数实参进行正常的类型转换，我们可以将函数模板定义为两个类型参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实参类型可以不同，但必须兼容</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> A, <span class="keyword">typename</span> B&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flexibleCompare</span><span class="params">(<span class="keyword">const</span> A &amp;v1, <span class="keyword">const</span> B &amp;v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (v1 &lt; v2)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (v2 &lt; v1)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数模板可以有用普通类型定义的参数，即，不涉及模板类型参数的类型。这种函数实参不进行特殊处理；它们正常转换为对应形参的类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个函数参数是一个已知类型 <code>ostream&amp;</code>。第二个参数 <code>obj</code> 则是模板参数类型。由于 <code>os</code> 的类型是固定的，因此当调用 <code>print</code> 时，传递给它的实参会进行正常的类型转换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">cout</span>, <span class="number">42</span>); <span class="comment">// 实例化 print(ostream&amp;, int)</span></span><br><span class="line"><span class="function">ofstream <span class="title">f</span><span class="params">(<span class="string">"output"</span>)</span></span>;</span><br><span class="line">print(f, <span class="number">10</span>); <span class="comment">// 使用 print(ostream&amp;, int)；将 f 转换为 ostream&amp;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：</strong> 如果函数参数类型不是模板参数，则对实参进行正常的类型转换。</p>
</blockquote>
</li>
</ol>
<h2 id="16-2-2-函数模板显式实参" class="heading-control"><a href="#16-2-2-函数模板显式实参" class="headerlink" title="16.2.2 函数模板显式实参"></a>16.2.2 函数模板显式实参<a class="heading-anchor" href="#16-2-2-函数模板显式实参" aria-hidden="true"></a></h2><ol>
<li><p>在某些情况下，编译器无法推断出模板实参的类型。其他一些情况下，我们希望允许用户控制模板实例化。<strong>当函数返回类型与参数列表中任何类型都不相同时</strong>，这两种情况最常出现。</p>
<p>我们可以定义表示返回类型的第三个模板参数，从而允许用户控制返回类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 编译器无法推断 T1，它未出现在函数参数列表中</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在本例中，没有任何函数实参的类型可用来推断 <code>T1</code> 的类型。每次调用 <code>sum</code> 时调用者都必须为 <code>T1</code> 提供一个<strong>显式模板实参</strong>（explicit template argument）。</p>
<p>我们提供显式模板实参的方式与定义类模板实例的方式相同。显式模板实参在尖括号中给出，位于函数名之后，实参列表之前：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// T1 是显式指定的，T2 和 T3 是从函数实参类型推断而来的</span></span><br><span class="line"><span class="keyword">auto</span> val3 = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng); <span class="comment">// long long sum(int, long)</span></span><br></pre></td></tr></table></figure>
<p>此调用显式指定 <code>T1</code> 的类型。而 <code>T2</code> 和 <code>T3</code> 的类型则由编译器从 <code>i</code> 和 <code>lng</code> 的类型推断出来。</p>
</li>
<li><p><strong>显式模板实参按由左至右的顺序与对应的模板参数匹配</strong>；第一个模板实参与第一个模板参数匹配，第二个实参与第二个参数匹配，依此类推。只有尾部（最右）参数的显式模板实参才可以忽略，而且前提是它们可以从函数参数推断出来。如果我们的 <code>sum</code> 函数按照如下形式编写：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 糟糕的设计：用户必须指定所有三个模板参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T3 <span class="title">alternative_sum</span><span class="params">(T2, T1)</span></span>;</span><br></pre></td></tr></table></figure>
<p>则我们总是必须为所有三个形参指定实参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 错误：不能推断前几个模板参数</span></span><br><span class="line"><span class="keyword">auto</span> val3 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(i, lng);</span><br><span class="line"><span class="comment">// 正确：显式指定了所有三个参数</span></span><br><span class="line"><span class="keyword">auto</span> val2 = alternative_sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>, <span class="keyword">int</span>, <span class="keyword">long</span>&gt;(i, lng);</span><br></pre></td></tr></table></figure>
</li>
<li><p>对于用普通类型定义的函数参数，允许进行正常的类型转换，出于同样的原因，<strong>对于模板类型参数已经显式指定了的函数实参，也进行正常的类型转换</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare(lng, <span class="number">1024</span>);       <span class="comment">// 错误：模板参数不匹配</span></span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>); <span class="comment">// 正确：实例化 compare(long, long)</span></span><br><span class="line">compare&lt;<span class="keyword">int</span>&gt;(lng, <span class="number">1024</span>);  <span class="comment">// 正确：实例化 compare(int, int)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 16.38：</strong> 当我们调用 <code>make_shared</code> 时，必须提供一个显式模板实参。解释为什么需要显式模板实参以及它是如何使用的。</p>
<p>答：<code>make_shared</code> 的返回类型是 <code>shared_ptr</code>，而 <code>shared_ptr</code> 是个类模板，返回类型里的模板参数只能显式指定。</p>
</li>
</ol>
<h2 id="16-2-3-尾置返回类型与类型转换" class="heading-control"><a href="#16-2-3-尾置返回类型与类型转换" class="headerlink" title="16.2.3 尾置返回类型与类型转换"></a>16.2.3 尾置返回类型与类型转换<a class="heading-anchor" href="#16-2-3-尾置返回类型与类型转换" aria-hidden="true"></a></h2><ol>
<li><p>我们可能希望编写一个函数，接受表示序列的一对迭代器和返回序列中一个元素的引用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">??? &amp;fcn(It beg, It end)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们并不知道返回结果的准确类型，但知道所需类型是所处理的序列的元素类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">Blob&lt;<span class="built_in">string</span>&gt; ca = &#123;<span class="string">"hi"</span>, <span class="string">"bye"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> &amp;i = fcn(vi.begin(), vi.end()); <span class="comment">// fcn 应该返回 int&amp;</span></span><br><span class="line"><span class="keyword">auto</span> &amp;s = fcn(ca.begin(), ca.end()); <span class="comment">// fcn 应该返回 string&amp;</span></span><br></pre></td></tr></table></figure>
<p>此例中，我们知道函数应该返回 <code>*beg</code>，而且知道我们可以用 <code>decltype(*beg)</code> 来获取此表达式的类型。但是，在编译器遇到函数的参数列表之前，<code>beg</code> 都是不存在的。为了定义此函数，我们必须使用尾置返回类型。由于<strong>尾置返回出现在参数列表之后，它可以使用函数的参数</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 尾置返回允许我们在参数列表之后声明返回类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此例中我们通知编译器 <code>fcn</code> 的返回类型与解引用 <code>beg</code> 参数的结果类型相同。<strong>解引用运算符返回一个左值，因此通过 <code>decltype</code> 推断的类型为 <code>beg</code> 表示的元素的类型的引用。</strong> 因此，如果对一个 <code>string</code> 序列调用 <code>fcn</code>，返回类型将是 <code>string&amp;</code>。如果是 <code>int</code> 序列，则返回类型是 <code>int&amp;</code>。</p>
</li>
<li><p>有时我们无法直接获得所需要的类型。例如，我们可能希望编写一个类似 <code>fcn</code> 的函数，但返回一个元素的值而非引用。</p>
<p>在编写这个函数的过程中，我们面临一个问题：对于传递的参数的类型，我们几乎一无所知。在此函数中，我们知道唯一可以使用的操作是迭代器操作，而<strong>所有迭代器操作都不会生成元素，只能生成元素的引用</strong>。</p>
<p>为了获得元素类型，我们可以使用标准库的<strong>类型转换</strong>（type transformation）模板。这些模板定义在头文件 <code>type_traits</code> 中。</p>
<p>在本例中，我们可以使用 <code>remove_reference</code> 来获得元素类型。<code>remove_reference</code> 模板有一个模板类型参数和一个名为 <code>type</code> 的（<code>public</code>）类型成员。如果我们用一个引用类型实例化 <code>remove_reference</code>，则 <code>type</code> 将表示被引用的类型。例如，如果我们实例化 <code>remove_reference&lt;int&amp;&gt;</code>，则 <code>type</code> 成员将是 <code>int</code>。类似的，如果我们实例化 <code>remove_reference&lt;string&amp;&gt;</code>，则 <code>type</code> 成员将是 <code>string</code>，依此类推。更一般的，给定一个迭代器 <code>beg</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br></pre></td></tr></table></figure>
<p>将获得 <code>beg</code> 引用的元素的类型：<code>decltype(*beg)</code> 返回元素类型的引用类型。<code>remove_reference::type</code> 脱去引用，剩下元素类型本身。</p>
<p><strong>组合使用 <code>remove_reference</code>、尾置返回及 <code>decltype</code>，我们就可以在函数中返回元素值的拷贝</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 为了使用模板参数的成员，必须用 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt;</span><br><span class="line">    <span class="keyword">typename</span> remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg; <span class="comment">// 返回序列中一个元素的拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意，<code>type</code> 是一个类的成员，而该类依赖于一个模板参数。因此，我们必须在返回类型的声明中使用 <code>typename</code> 来告知编译器，<code>type</code> 表示一个类型。</strong></p>
</li>
<li><p>下表列出了标准类型转换模板：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-uzvj{border-color:inherit;font-weight:bold;text-align:center;   vertical-align:middle}<br>.tg .tg-g7sd{border-color:inherit;font-weight:bold;text-align:left;   vertical-align:middle}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-uzvj" colspan="3"><center>标准类型转换模板</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-g7sd"><b>对 Mod&lt;T&gt;，其中 Mod 为</b></td>
    <td class="tg-g7sd"><b>若 T 为</b></td>
    <td class="tg-g7sd"><b>则 Mod&lt;T&gt;::type 为</b></td>
  </tr>
  <tr>
    <td class="tg-lboi">remove_reference</td>
    <td class="tg-lboi">X&amp; 或 X&amp;&amp;<br>否则</td>
    <td class="tg-lboi">X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">add_const</td>
    <td class="tg-lboi">X&amp;、const X 或函数<br>否则</td>
    <td class="tg-0pky">T<br>const T</td>
  </tr>
  <tr>
    <td class="tg-lboi">add_lvalue_reference</td>
    <td class="tg-lboi">X&amp;<br>X&amp;&amp;<br>否则</td>
    <td class="tg-lboi">T<br>X&amp;<br>T&amp;</td>
  </tr>
  <tr>
    <td class="tg-lboi">add_rvalue_reference</td>
    <td class="tg-lboi">X&amp; 或 X&amp;&amp;<br>否则</td>
    <td class="tg-lboi">T<br>T&amp;&amp;</td>
  </tr>
  <tr>
    <td class="tg-lboi">remove_pointer</td>
    <td class="tg-lboi">X*<br>否则</td>
    <td class="tg-lboi">X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">add_pointer</td>
    <td class="tg-lboi">X&amp; 或 X&amp;&amp;<br>否则</td>
    <td class="tg-lboi">X*<br>T*</td>
  </tr>
  <tr>
    <td class="tg-lboi">make_signed</td>
    <td class="tg-lboi">unsigned X<br>否则</td>
    <td class="tg-0pky">X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">make_unsigned</td>
    <td class="tg-lboi">带符号类型<br>否则</td>
    <td class="tg-lboi">unsigned X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">remove_extent</td>
    <td class="tg-lboi">X[n]<br>否则</td>
    <td class="tg-0pky">X<br>T</td>
  </tr>
  <tr>
    <td class="tg-lboi">remove_all_extents</td>
    <td class="tg-lboi">X[n1][n2]...<br>否则</td>
    <td class="tg-0pky">X<br>T</td>
  </tr>
</tbody>
</table>

<p>上表中描述的每个类型转换模板的工作方式都与 <code>remove_reference</code> 类似。每个模板都有一个名为 <code>type</code> 的 <code>public</code> 成员，表示一个类型。此类型与模板自身的模板类型参数相关，其关系如模板名所示。如果不可能（或者不必要）转换模板参数，则 <code>type</code> 成员就是模板参数类型本身。例如，如果 <code>T</code> 是一个指针类型，则 <code>remove_pointer&lt;T&gt;::type</code> 是 <code>T</code> 指向的类型。如果 <code>T</code> 不是一个指针，则无须进行任何转换，从而 <code>type</code> 具有与 <code>T</code> 相同的类型。</p>
</li>
</ol>
<h2 id="16-2-4-函数指针和实参推断" class="heading-control"><a href="#16-2-4-函数指针和实参推断" class="headerlink" title="16.2.4 函数指针和实参推断"></a>16.2.4 函数指针和实参推断<a class="heading-anchor" href="#16-2-4-函数指针和实参推断" aria-hidden="true"></a></h2><ol>
<li><p><strong>当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参。</strong><br>例如，假定我们有一个函数指针，它指向的函数返回 <code>int</code>，接受两个参数，每个参数都是指向 <code>const int</code> 的引用。我们可以使用该指针指向 <code>compare</code> 的一个实例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="comment">// pf1 指向实例 int compare(const int&amp;, const int&amp;)</span></span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;) = compare;</span><br></pre></td></tr></table></figure>
<p><code>pf1</code> 中参数的类型决定了 <code>T</code> 的模板实参的类型。在本例中，<code>T</code> 的模板实参类型为 <code>int</code>。指针 <code>pf1</code> 指向 <code>compare</code> 的 <code>int</code> 版本实例。如果不能从函数指针类型确定模板实参，则产生错误：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// func 的重载版本；每个版本接受一个不同的函数指针类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> (*)(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;))</span></span>;</span><br><span class="line">func(compare); <span class="comment">// 错误：使用 compare 的哪个实例?</span></span><br></pre></td></tr></table></figure>
<p>这段代码的问题在于，通过 <code>func</code> 的参数类型无法确定模板实参的唯一类型。对 <code>func</code> 的调用既可以实例化接受 <code>int</code> 的 <code>compare</code> 版本，也可以实例化接受 <code>string</code> 的版本。由于不能确定 <code>func</code> 的实参的唯一实例化版本，此调用将编译失败。</p>
<p>我们可以通过使用显式模板实参来消除 <code>func</code> 调用的歧义：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正确：显式指出实例化哪个 compare 版本</span></span><br><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;); <span class="comment">// 传递 compare(const int&amp;, const int&amp;)</span></span><br></pre></td></tr></table></figure>
<p>此表达式调用的 <code>func</code> 版本接受一个函数指针，该指针指向的函数接受两个 <code>const int&amp;</code> 参数。</p>
<blockquote>
<p><strong>Note：</strong> 当参数是一个函数模板实例的地址时，程序上下文必须满足：对每个模板参数，能唯一确定其类型或值。</p>
</blockquote>
</li>
</ol>
<h2 id="16-2-5-模板实参推断和引用" class="heading-control"><a href="#16-2-5-模板实参推断和引用" class="headerlink" title="16.2.5 模板实参推断和引用"></a>16.2.5 模板实参推断和引用<a class="heading-anchor" href="#16-2-5-模板实参推断和引用" aria-hidden="true"></a></h2><ol>
<li><p>当一个函数参数是模板类型参数的一个普通（左值）引用时（即，形如 <code>T&amp;</code>），绑定规则告诉我们，只能传递给它一个左值（如，一个变量或一个返回引用类型的表达式）。实参可以是 <code>const</code> 类型，也可以不是。如果实参是 <code>const</code> 的，则 <code>T</code> 将被推断为 <code>const</code> 类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(T &amp;)</span></span>; <span class="comment">// 实参必须是一个左值</span></span><br><span class="line"><span class="comment">// 对 f1 的调用使用实参所引用的类型作为模板参数类型</span></span><br><span class="line">f1(i);  <span class="comment">// i 是一个 int；模板参数类型 T 是 int</span></span><br><span class="line">f1(ci); <span class="comment">// ci 是一个 const int；模板参数 T 是 const int</span></span><br><span class="line">f1(<span class="number">5</span>);  <span class="comment">// 错误：传递给一个 &amp; 参数的实参必须是一个左值</span></span><br></pre></td></tr></table></figure>
<p>如果一个函数参数的类型是 <code>const T&amp;</code>，正常的绑定规则告诉我们可以传递给它任何类型的实参——一个对象（<code>const</code> 或非 <code>const</code>）、一个临时对象或是一个字面常量值。当函数参数本身是 <code>const</code> 时，<code>T</code> 的类型推断的结果不会是一个 <code>const</code> 类型。<code>const</code> 已经是函数参数类型的一部分；因此，它不会也是模板参数类型的一部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T &amp;)</span></span>; <span class="comment">// 可以接受一个右值</span></span><br><span class="line"><span class="comment">// f2 中的参数是 const &amp;；实参中的 const 是无关的</span></span><br><span class="line"><span class="comment">// 在每个调用中，f2 的函数参数都被推断为 const int&amp;</span></span><br><span class="line">f2(i);  <span class="comment">// i 是一个 int；模板参数 T 是 int</span></span><br><span class="line">f2(ci); <span class="comment">// ci 是一个 const int，但模板参数 T 是 int</span></span><br><span class="line">f2(<span class="number">5</span>);  <span class="comment">// 一个 const &amp; 参数可以绑定到一个右值；T 是 int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个函数参数是一个右值引用（即，形如 <code>T&amp;&amp;</code>）时，正常绑定规则告诉我们可以传递给它一个右值。当我们这样做时，类型推断过程类似普通左值引用函数参数的推断过程。推断出的 <code>T</code> 的类型是该右值实参的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T &amp;&amp;)</span></span>;</span><br><span class="line">f3(<span class="number">42</span>); <span class="comment">// 实参是一个 int 类型的右值；模板参数 T 是 int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通常我们不能将一个右值引用绑定到一个左值上。但是，C++ 语言在正常绑定规则之外定义了两个例外规则，允许这种绑定。这两个例外规则是 <code>move</code> 这种标准库设施正确工作的基础。</p>
<ul>
<li><p>第一个例外规则影响右值引用参数的推断如何进行。<strong>当我们将一个左值（如 <code>i</code>）传递给函数的右值引用参数，且此右值引用指向模板类型参数（如 <code>T&amp;&amp;</code>）时，编译器推断模板类型参数为实参的左值引用类型。</strong> 因此，当我们调用 <code>f3(i)</code> 时，编译器推断 <code>T</code> 的类型为 <code>int&amp;</code>，而非 <code>int</code>。<code>T</code> 被推断为 <code>int&amp;</code> 看起来好像意味着 <code>f3</code> 的函数参数应该是一个类型 <code>int&amp;</code> 的右值引用。<strong>通常，我们不能（直接）定义一个引用的引用。但是，通过类型别名或通过模板类型参数间接定义是可以的。</strong></p>
</li>
<li><p>在这种情况下，我们可以使用第二个例外绑定规则：<strong>如果我们间接创建一个引用的引用，则这些引用形成了“折叠”。在所有情况下（除了一个例外），引用会折叠成一个普通的左值引用类型。在新标准中，折叠规则扩展到右值引用。只在一种特殊情况下引用会折叠成右值引用：右值引用的右值引用。</strong> 即，对于一个给定类型 <code>X</code>：</p>
<ul>
<li><code>X&amp; &amp;</code>、<code>X&amp; &amp;&amp;</code> 和 <code>X&amp;&amp; &amp;</code> 都折叠成类型 <code>X&amp;</code></li>
<li>类型 <code>X&amp;&amp; &amp;&amp;</code> 折叠成 <code>X&amp;&amp;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Note：</strong> 引用折叠只能应用于间接创建的引用的引用，如类型别名或模板参数。</p>
</blockquote>
</li>
<li><p>如果将引用折叠规则和右值引用的特殊类型推断规则组合在一起，则意味着我们可以对一个左值调用 <code>f3</code>。当我们将一个左值传递给 <code>f3</code> 的（右值引用）函数参数时，编译器推断 <code>T</code> 为一个左值引用类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">f3(i);  <span class="comment">// 实参是一个左值；模板参数 T 是 int&amp;</span></span><br><span class="line">f3(ci); <span class="comment">// 实参是一个左值；模板参数 T 是一个 const int&amp;</span></span><br></pre></td></tr></table></figure>
<p>当一个模板参数 <code>T</code> 被推断为引用类型时，折叠规则告诉我们函数参数 <code>T&amp;&amp;</code> 折叠为一个左值引用类型。例如，<code>f3(i)</code> 的实例化结果可能像下面这样：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 无效代码，只是用于演示目的</span></span><br><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span> &amp;&gt;(<span class="keyword">int</span> &amp; &amp;&amp;); <span class="comment">// 当 T 是 int&amp; 时，函数参数为 int&amp; &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p><code>f3</code> 的函数参数是 <code>T&amp;&amp;</code> 且 <code>T</code> 是 <code>int&amp;</code>，因此 <code>T&amp;&amp;</code> 是 <code>int&amp; &amp;&amp;</code>，会折叠成 <code>int&amp;</code>。因此，即使 <code>f3</code> 的函数参数形式是一个右值引用（即，<code>T&amp;&amp;</code>），此调用也会用一个左值引用类型（即，<code>int&amp;</code>）实例化 <code>f3</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> f3&lt;<span class="keyword">int</span> &amp;&gt;(<span class="keyword">int</span> &amp;); <span class="comment">// 当 T 是 int&amp; 时，函数参数折叠为 int&amp;</span></span><br></pre></td></tr></table></figure>
<p>这两个规则导致了两个重要结果：</p>
<ul>
<li><strong>如果一个函数参数是一个指向模板类型参数的右值引用（如，<code>T&amp;&amp;</code>），则它可以被绑定到一个左值；且</strong></li>
<li><strong>如果实参是一个左值，则推断出的模板实参类型将是一个左值引用，且函数参数将被实例化为一个（普通）左值引用参数（<code>T&amp;</code>）</strong></li>
</ul>
<p>另外值得注意的是，这两个规则暗示，我们<strong>可以将任意类型的实参传递给 <code>T&amp;&amp;</code> 类型的函数参数</strong>。对于这种类型的参数，（显然）可以传递给它右值，而如我们刚刚看到的，也可以传递给它左值。</p>
<blockquote>
<p><strong>Note：如果一个函数参数是指向模板参数类型的右值引用（如，<code>T&amp;&amp;</code>），则可以传递给它任意类型的实参。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的左值引用（<code>T&amp;</code>）。</strong></p>
</blockquote>
</li>
<li><p>模板参数可以推断为一个引用类型，这一特性对模板内的代码可能有令人惊讶的影响：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T &amp;&amp;val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T t = val;  <span class="comment">// 拷贝还是绑定一个引用？</span></span><br><span class="line">    t = fcn(t); <span class="comment">// 赋值只改变 t 还是既改变 t 又改变 val？</span></span><br><span class="line">    <span class="keyword">if</span> (val == t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*...*/</span></span><br><span class="line">    &#125; <span class="comment">// 若 T 是引用类型，则一直为 true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当我们对一个右值调用 <code>f3</code> 时，例如字面常量 <code>42</code>，<code>T</code> 为 <code>int</code>。在此情况下，局部变量 <code>t</code> 的类型为 <code>int</code>，且通过拷贝参数 <code>val</code> 的值被初始化。当我们对 <code>t</code> 赋值时，参数 <code>val</code> 保持不变。</p>
<p>另一方面，当我们对一个左值 <code>i</code> 调用 <code>f3</code> 时，则 <code>T</code> 为 <code>int&amp;</code>。当我们定义并初始化局部变量 <code>t</code> 时，赋予它类型 <code>int&amp;</code>。因此，对 <code>t</code> 的初始化将其绑定到 <code>val</code>。当我们对 <code>t</code> 赋值时，也同时改变了 <code>val</code> 的值。在 <code>f3</code> 的这个实例化版本中，<code>if</code> 判断永远得到 <code>true</code>。</p>
</li>
<li><p><strong>练习 16.42：</strong> 对下面每个调用，确定 <code>T</code> 和 <code>val</code> 的类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T &amp;&amp;val)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i;</span><br></pre></td></tr></table></figure>
<p>（a）g(i)；（b）g(ci)；（c）g(i * ci)；</p>
<p>答：（a）<code>int&amp;</code>；（b）<code>int&amp;</code>；（c）<code>const int&amp;&amp;</code>；</p>
</li>
</ol>
<h2 id="16-2-6-理解-std-move" class="heading-control"><a href="#16-2-6-理解-std-move" class="headerlink" title="16.2.6 理解 std::move"></a>16.2.6 理解 std::move<a class="heading-anchor" href="#16-2-6-理解-std-move" aria-hidden="true"></a></h2><ol>
<li><p>虽然不能直接将一个右值引用绑定到一个左值上，但可以用 <code>move</code> 获得一个绑定到左值上的右值引用。</p>
<p>标准库是这样定义 <code>move</code> 的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在返回类型和类型转换中也要用到 typename</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type &amp;&amp;<span class="title">move</span><span class="params">(T &amp;&amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type &amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们<strong>既可以传递给 <code>move</code> 一个左值，也可以传递给它一个右值</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string s1("hi!"), s2;</span><br><span class="line">s2 = <span class="built_in">std</span>::move(<span class="built_in">string</span>(<span class="string">"bye!"</span>)); <span class="comment">// 正确：从一个右值移动数据</span></span><br><span class="line">s2 = <span class="built_in">std</span>::move(s1);             <span class="comment">// 正确：但在赋值之后，s1 的值是不确定的</span></span><br></pre></td></tr></table></figure>
<p>在第一个赋值中，传递给 <code>move</code> 的实参是 <code>string</code> 的构造函数的右值结果 <code>string(&quot;bye!&quot;)</code>。如我们已经见到过的，<strong>当向一个右值引用函数参数传递一个右值时，由实参推断出的类型为被引用的类型</strong>。因此，在 <code>std::move(string(&quot;bye!&quot;))</code> 中：</p>
<ul>
<li>推断出的 <code>T</code> 的类型为 <code>string</code>。</li>
<li>因此，<code>remove_reference</code> 用 <code>string</code> 进行实例化。</li>
<li><code>remove_reference&lt;string&gt;</code> 的 <code>type</code> 成员是 <code>string</code>。</li>
<li><code>move</code> 的返回类型是 <code>string&amp;&amp;</code>。</li>
<li><code>move</code> 的函数参数 <code>t</code> 的类型为 <code>string&amp;&amp;</code>。</li>
</ul>
<p>因此，这个调用实例化 <code>move&lt;string&gt;</code>，即函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;&amp;<span class="title">move</span><span class="params">(<span class="built_in">string</span> &amp;&amp;t)</span></span></span><br></pre></td></tr></table></figure>
<p>函数体返回 <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。<code>t</code> 的类型已经是 <code>string&amp;&amp;</code>，于是类型转换什么都不做。因此，此调用的结果就是它所接受的右值引用。</p>
<p>第二个赋值中调用了 <code>std::move()</code>。在此调用中，传递给 <code>move</code> 的实参是一个左值。这样：</p>
<ul>
<li>推断出的 <code>T</code> 的类型为 <code>string&amp;</code>（<code>string</code> 的引用，而非普通 <code>string</code>）。</li>
<li>因此，<code>remove_reference</code> 用 <code>string&amp;</code> 进行实例化。</li>
<li><code>remove_reference&lt;string&amp;&gt;</code> 的 <code>type</code> 成员是 <code>string</code>。</li>
<li><code>move</code> 的返回类型仍是 <code>string&amp;&amp;</code>。</li>
<li><code>move</code> 的函数参数 <code>t</code> 实例化为 <code>string&amp; &amp;&amp;</code>，会折叠为 <code>string&amp;</code>。</li>
</ul>
<p>因此，这个调用实例化 <code>move&lt;string&amp;&gt;</code>，即</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> &amp;&amp;<span class="title">move</span><span class="params">(<span class="built_in">string</span> &amp;t)</span></span></span><br></pre></td></tr></table></figure>
<p>这正是我们所寻求的——我们希望将一个右值引用绑定到一个左值。这个实例的函数体返回 <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>。在此情况下，<code>t</code> 的类型为 <code>string&amp;</code>，<code>cast</code> 将其转换为 <code>string&amp;&amp;</code>。</p>
</li>
<li><p>虽然不能隐式地将一个左值转换为右值引用，但我们可以用 <code>static_cast</code> 显示地将一个左值转换为一个右值引用。</p>
</li>
</ol>
<h2 id="16-2-7-转发" class="heading-control"><a href="#16-2-7-转发" class="headerlink" title="16.2.7 转发"></a>16.2.7 转发<a class="heading-anchor" href="#16-2-7-转发" aria-hidden="true"></a></h2><ol>
<li><p>某些函数需要将其一个或多个实参连同类型不变地转发给其他函数。在此情况下，我们需要保持被转发实参的所有性质，包括实参类型是否是 <code>const</code> 的以及实参是左值还是右值。</p>
</li>
<li><p>通过将一个函数参数定义为一个指向模板类型参数的右值引用，我们可以保持其对应实参的所有类型信息。而使用引用参数（无论是左值还是右值）使得我们可以保持 <code>const</code> 属性，因为在引用类型中的 <code>const</code> 是底层的。如果我们将函数参数定义为 <code>T1&amp;&amp;</code> 和 <code>T2&amp;&amp;</code>，通过引用折叠就可以保持翻转实参的左值/右值属性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(t2, t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与较早的版本一样，如果我们调用 <code>flip2(f, j, 42)</code>，将传递给参数 <code>t1</code> 一个左值 <code>j</code>。但是，在 <code>flip2</code> 中，推断出的 <code>T1</code> 的类型为 <code>int&amp;</code>，这意味着 <code>t1</code> 的类型会折叠为 <code>int&amp;</code>。由于是引用类型，<code>t1</code> 被绑定到 <code>j</code> 上。</p>
<blockquote>
<p><strong>Note：如果一个函数参数是指向模板类型参数的右值引用（如 <code>T&amp;&amp;</code>），它对应的实参的 <code>const</code> 属性和左值/右值属性将得到保持。</strong></p>
</blockquote>
<p>这个版本的 <code>flip2</code> 解决了一半问题。它对于接受一个左值引用的函数工作得很好，但不能用于接受右值引用参数的函数。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> &amp;&amp;i, <span class="keyword">int</span> &amp;j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">" "</span> &lt;&lt; j &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们试图通过 <code>flip2</code> 调用 <code>g</code>，则参数 <code>t2</code> 将被传递给 <code>g</code> 的右值引用参数。即使我们传递一个右值给 <code>flip2</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">flip2(g, i, <span class="number">42</span>); <span class="comment">// 错误：不能从一个左值实例化 int&amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>传递给 <code>g</code> 的将是 <code>flip2</code> 中名为 <code>t2</code> 的参数。函数参数与其他任何变量一样，都是左值表达式。因此，<code>flip2</code> 中对 <code>g</code> 的调用将传递给 <code>g</code> 的右值引用参数一个左值。</p>
</li>
<li><p>我们可以使用一个名为 <code>forward</code> 的新标准库设施来传递 <code>flip2</code> 的参数，它能保持原始实参的类型。<strong>类似 <code>move</code>，<code>forward</code> 定义在头文件 <code>utility</code> 中。与 <code>move</code> 不同，<code>forward</code> 必须通过显式模板实参来调用。<code>forward</code> 返回该显式实参类型的右值引用。</strong> 即，<code>forward&lt;T&gt;</code> 的返回类型是 <code>T&amp;&amp;</code>。</p>
<p><strong>通常情况下，我们使用 <code>forward</code> 传递那些定义为模板类型参数的右值引用的函数参数。通过其返回类型上的引用折叠，<code>forward</code> 可以保持给定实参的左值/右值属性</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line">intermediary(Type &amp;&amp;arg)</span><br><span class="line">&#123;</span><br><span class="line">    finalFcn(<span class="built_in">std</span>::forward&lt;Type&gt;(arg));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中我们使用 <code>Type</code> 作为 <code>forward</code> 的显式模板实参类型，它是从 <code>arg</code> 推断出来的。由于 <code>arg</code> 是一个模板类型参数的右值引用，<code>Type</code> 将表示传递给 <code>arg</code> 的实参的所有类型信息。如果实参是一个右值，则 <code>Type</code> 是一个普通（非引用）类型，<code>forward&lt;Type&gt;</code> 将返回 <code>Type&amp;&amp;</code>。如果实参是一个左值，则通过引用折叠，<code>Type</code> 本身是一个左值引用类型。在此情况下，返回类型是一个指向左值引用类型的右值引用。再次对 <code>forward&lt;Type&gt;</code> 的返回类型进行引用折叠，将返回一个左值引用类型。</p>
<blockquote>
<p><strong>Note：当用于一个指向模板参数类型的右值引用函数参数（<code>T&amp;&amp;</code>）时，<code>forward</code> 会保持实参类型的所有细节。</strong></p>
</blockquote>
<p>使用 <code>forward</code>，我们可以再次重写翻转函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip</span><span class="params">(F f, T1 &amp;&amp;t1, T2 &amp;&amp;t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    f(<span class="built_in">std</span>::forward&lt;T2&gt;(t2), <span class="built_in">std</span>::forward&lt;T1&gt;(t1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Note：</strong> 与 <code>std::move</code> 相同，对 <code>std::forward</code> 不使用 <code>using</code> 声明是一个好主意。</p>
</blockquote>
</li>
</ol>
<h1 id="16-3-重载与模板" class="heading-control"><a href="#16-3-重载与模板" class="headerlink" title="16.3 重载与模板"></a>16.3 重载与模板<a class="heading-anchor" href="#16-3-重载与模板" aria-hidden="true"></a></h1><ol>
<li><p>函数模板可以被另一个模板或一个普通非模板函数重载。与往常一样，名字相同的函数必须具有不同数量或类型的参数。</p>
</li>
<li><p>如果涉及函数模板，则函数匹配规则会在以下几方面受到影响：</p>
<ul>
<li>对于一个调用，其候选函数包括所有模板实参推断成功的函数模板实例。</li>
<li>候选的函数模板总是可行的，因为模板实参推断会排除任何不可行的模板。</li>
<li>与往常一样，可行函数（模板与非模板）按类型转换（如果对此调用需要的话）来排序。当然，可以用于函数模板调用的类型转换是非常有限的。</li>
<li>与往常一样，如果恰有一个函数提供比任何其他函数都更好的匹配，则选择此函数。但是，如果有多个函数提供同样好的匹配，则：<ul>
<li>如果同样好的函数中只有一个是非模板函数，则选择此函数。</li>
<li>如果同样好的函数中没有非模板函数，而有多个函数模板，且其中一个模板比其他模板更特例化，则选择此模板。</li>
<li>否则，此调用有歧义。</li>
</ul>
</li>
</ul>
</li>
<li><p>我们有下面两个函数模板：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打印任何我们不能处理的类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; t;         <span class="comment">// 使用 T 的输出运算符打印 t 的一个表示形式</span></span><br><span class="line">    <span class="keyword">return</span> ret.str(); <span class="comment">// 返回 ret 绑定的 string 的一个副本</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印指针的值，后跟指针指向的对象</span></span><br><span class="line"><span class="comment">// 注意：此函数不能用于 char*</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">"pointer:"</span> &lt;&lt; p; <span class="comment">// 打印指针本身的值</span></span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        ret &lt;&lt; <span class="string">""</span> &lt;&lt; debug_rep(*p); <span class="comment">// 打印 p 指向的值</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ret &lt;&lt; <span class="string">"null pointer"</span>; <span class="comment">// 或指出 p 为空</span></span><br><span class="line">    <span class="keyword">return</span> ret.str();          <span class="comment">// 返回 ret 绑定的 string 的一个副本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二个模板不能用于打印字符指针，因为 IO 库为 <code>char*</code> 值定义了一个 <code>&lt;&lt;</code> 版本。此 <code>&lt;&lt;</code> 版本假定指针表示一个空字符结尾的字符数组，并打印数组的内容而非地址值。</p>
<p>我们可以这样使用这些函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hi"</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>对于这个调用，只有第一个版本的 <code>debug_rep</code> 是可行的。第二个 <code>debug_rep</code> 版本要求一个指针参数，但在此调用中我们传递的是一个非指针对象。因此编译器无法从一个非指针实参实例化一个期望指针类型参数的函数模板，因此实参推断失败。由于只有一个可行函数，所以此函数被调用。</p>
<p>如果我们用一个指针调用 <code>debug_rep</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(&amp;s) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>两个函数都生成可行的实例：</p>
<ul>
<li><code>debug_rep(const string *&amp;)</code>，由第一个版本的 <code>debug_rep</code> 实例化而来，<code>T</code> 被绑定到 <code>string *</code>。</li>
<li><code>debug_rep(string *)</code>，由第二个版本的 <code>debug_rep</code> 实例化而来，<code>T</code> 被绑定到 <code>string</code>。</li>
</ul>
<p>第二个版本的 <code>debug_rep</code> 的实例是此调用的精确匹配。第一个版本的实例需要进行普通指针到 <code>const</code> 指针的转换。正常函数匹配规则告诉我们应该选择第二个模板，实际上编译器确实选择了这个版本。</p>
<p>作为另外一个例子，考虑下面的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *sp = &amp;s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(sp) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>此例中的两个模板都是可行的，而且两个都是精确匹配：</p>
<ul>
<li><code>debug_rep(const string *&amp;)</code>，由第一个版本的 <code>debug_rep</code> 实例化而来，<code>T</code> 被绑定到 <code>string *</code>。</li>
<li><code>debug_rep(const string *)</code>，由第二个版本的 <code>debug_rep</code> 实例化而来，<code>T</code> 被绑定到 <code>const string</code>。</li>
</ul>
<p>在此情况下，正常函数匹配规则无法区分这两个函数。我们可能觉得这个调用将是有歧义的。但是，根据重载函数模板的特殊规则，此调用被解析为 <code>debug_rep(T *)</code>，即，更特例化的版本。</p>
<p>设计这条规则的原因是，没有它，将无法对一个 <code>const</code> 的指针调用指针版本的 <code>debug_rep</code>。问题在于模板 <code>debug_rep(const T &amp;)</code> 本质上可以用于任何类型，包括指针类型。此模板比 <code>debug_rep(T *)</code> 更通用，后者只能用于指针类型。没有这条规则，传递 <code>const</code> 的指针的调用永远是有歧义的。</p>
</li>
<li><blockquote>
<p><strong>Note：当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本。</strong>（我们都更倾向于确定性——博主注）</p>
</blockquote>
</li>
<li><blockquote>
<p><strong>Note：对于一个调用，如果一个非函数模板与一个函数模板提供同样好的匹配，则选择非模板版本。</strong></p>
</blockquote>
</li>
<li><p>考虑这个调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; debug_rep(<span class="string">"hi world!"</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 调用 debug_rep(T *)</span></span><br></pre></td></tr></table></figure>
<p>所有三个 <code>debug_rep</code> 版本都是可行的：</p>
<ul>
<li><code>debug_rep(const T &amp;)</code>，<code>T</code> 被绑定到 <code>char[10]</code>。</li>
<li><code>debug_rep(T *)</code>，<code>T</code> 被绑定到 <code>const char</code>。</li>
<li><code>debug_rep(const string &amp;)</code>，要求从 <code>const char *</code> 到 <code>string</code> 的类型。</li>
</ul>
<p>对给定实参来说，两个模板都提供精确匹配——第二个模板需要进行一次（许可的）数组到指针的转换，而对于函数匹配来说，这种转换被认为是精确匹配。非模板版本是可行的，但需要进行一次用户定义的类型转换，因此它没有精确匹配那么好，所以两个模板成为可能调用的函数。与之前一样，<code>T*</code> 版本更加特例化，编译器会选择它。</p>
</li>
<li><p>通常，如果使用了一个忘记声明的函数，代码将编译失败。但对于重载函数模板的函数而言，则不是这样。如果编译器可以从模板实例化出与调用匹配的版本，则缺少的声明就不重要了。</p>
<blockquote>
<p><strong>Tip：</strong> 在定义任何函数之前，记得声明所有重载的函数版本。这样就不必担心编译器由于未遇到你希望调用的函数而实例化一个并非你所需的版本。</p>
</blockquote>
</li>
<li><p><strong>练习 16.49：</strong> 解释下面每个调用会发生什么：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T *)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T *)</span></span>;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, *p2 = &amp;ci;</span><br><span class="line">g(<span class="number">42</span>); g(p); g(ci); g(p2);</span><br><span class="line">f(<span class="number">42</span>); f(p); f(ci); f(p2);</span><br></pre></td></tr></table></figure>
<p>答：<code>g(42)</code>：匹配 <code>g(T)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>g(p)</code>：匹配 <code>g(T *)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>g(ci)</code>：匹配 <code>g(T)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>g(p2)</code>：匹配 <code>g(T *)</code>，<code>T</code> 被推断为 <code>const int</code>；<br><code>f(42)</code>：匹配 <code>f(T)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>f(p)</code>：匹配 <code>f(T)</code>，<code>T</code> 被推断为 <code>int *</code>；<br><code>f(ci)</code>：匹配 <code>f(T)</code>，<code>T</code> 被推断为 <code>int</code>；<br><code>f(p2)</code>：匹配 <code>f(const T *)</code>，<code>T</code> 被推断为 <code>int</code>。</p>
<p>验证代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    Called function: f(T)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T: "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T is const: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;T&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    Called function: f(const T*)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T: "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T is const: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;T&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    Called function: g(T)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T: "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T is const: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;T&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(T *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    Called function: g(T *)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T: "</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"    T is const: "</span> &lt;&lt; <span class="built_in">std</span>::is_const&lt;T&gt;::value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, *p2 = &amp;ci;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g(42)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">g(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g(p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">g(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g(ci)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">g(ci);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"g(p2)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">g(p2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(42)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">f(<span class="number">42</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(p)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">f(p);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(ci)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">f(ci);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f(p2)"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">f(p2);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="16-4-可变参数模板" class="heading-control"><a href="#16-4-可变参数模板" class="headerlink" title="16.4 可变参数模板"></a>16.4 可变参数模板<a class="heading-anchor" href="#16-4-可变参数模板" aria-hidden="true"></a></h1><ol>
<li><p>一个<strong>可变参数模板</strong>（variadic template）就是一个接受可变数目参数的模板函数或模板类。可变数目的参数被称为<strong>参数包</strong>（parameter packet）。存在两种参数包：<strong>模板参数包</strong>（template parameter packet），表示零个或多个模板参数；<strong>函数参数包</strong>（function parameter packet），表示零个或多个函数参数。</p>
</li>
<li><p>我们用一个省略号来指出一个模板参数或函数参数表示一个包。在一个模板参数列表中，<code>class...</code> 或 <code>typename...</code> 指出接下来的参数表示零个或多个类型的列表；一个类型名后面跟一个省略号表示零个或多个给定类型的非类型参数的列表。在函数参数列表中，如果一个参数的类型是一个模板参数包，则此参数也是一个函数参数包。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Args 是一个模板参数包；rest 是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args 表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest 表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args &amp;...rest)</span></span>;</span><br></pre></td></tr></table></figure>
<p>声明了 <code>foo</code> 是一个可变参数函数模板，它有一个名为 <code>T</code> 的类型参数，和一个名为 <code>Args</code> 的模板参数包。这个包表示零个或多个额外的类型参数。<code>foo</code> 的函数参数列表包含一个 <code>const &amp;</code> 类型的参数，指向 <code>T</code> 的类型，还包含一个名为 <code>rest</code> 的函数参数包，此包表示零个或多个函数参数。</p>
<p>与往常一样，编译器从函数的实参推断模板参数类型。对于一个可变参数模板，编译器还会推断包中参数的数目。例如，给定下面的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">string</span> s = <span class="string">"how now brown cow"</span>;</span><br><span class="line">foo(i, s, <span class="number">42</span>, d); <span class="comment">// 包中有三个参数</span></span><br><span class="line">foo(s, <span class="number">42</span>, <span class="string">"hi"</span>); <span class="comment">// 包中有两个参数</span></span><br><span class="line">foo(d, s);        <span class="comment">// 包中有一个参数</span></span><br><span class="line">foo(<span class="string">"hi"</span>);        <span class="comment">// 空包</span></span><br></pre></td></tr></table></figure>
<p>编译器会为 <code>foo</code> 实例化出四个不同的版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">double</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>] &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>[<span class="number">3</span>] &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在每个实例中，<code>T</code> 的类型都是从第一个实参的类型推断出来的。剩下的实参（如果有的话）提供函数额外实参的数目和类型。</p>
</li>
<li><p>当我们需要知道包中有多少元素时，可以使用 <code>sizeof...</code> 运算符，<code>sizeof...</code> 也返回一个常量表达式，而且不会对其实参求值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 类型参数的数目</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="16-4-1-编写可变参数函数模板" class="heading-control"><a href="#16-4-1-编写可变参数函数模板" class="headerlink" title="16.4.1 编写可变参数函数模板"></a>16.4.1 编写可变参数函数模板<a class="heading-anchor" href="#16-4-1-编写可变参数函数模板" aria-hidden="true"></a></h2><ol>
<li><p>可以使用一个 <code>initializer_list</code> 来定义一个可接受可变数目实参的函数。但是，所有实参必须具有相同的类型（或它们的类型可以转换为同一个公共类型）。</p>
</li>
<li><p><strong>可变参数函数通常是递归的。</strong> 第一步调用处理包中的第一个实参，然后用剩余实参调用自身。我们的 <code>print</code> 函数也是这样的模式，每次递归调用将第二个实参打印到第一个实参表示的流中。为了终止递归，我们还需要定义一个非可变参数的 <code>print</code> 函数，它接受一个流和一个对象：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="comment">// 此函数必须在可变参数版本的 print 定义之前声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; t; <span class="comment">// 包中最后一个元素之后不打印分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本的 print</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args &amp;...rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">","</span>;            <span class="comment">// 打印第一个实参</span></span><br><span class="line">    <span class="keyword">return</span> print(os, rest...); <span class="comment">// 递归调用，打印其他实参</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个版本的 <code>print</code> 负责终止递归并打印初始调用中的最后一个实参。第二个版本的 <code>print</code> 是可变参数版本，它打印绑定到 <code>t</code> 的实参，并调用自身来打印函数参数包中的剩余值。</p>
<p>这段程序的关键部分是可变参数函数中对 <code>print</code> 的调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> print(os, rest...); <span class="comment">// 递归调用，打印其他实参</span></span><br></pre></td></tr></table></figure>
<p><strong>我们的可变参数版本的 <code>print</code> 函数接受三个参数：一个 <code>ostream &amp;</code>，一个 <code>const T &amp;</code> 和一个参数包。而此调用只传递了两个实参。其结果是 <code>rest</code> 中的第一个实参被绑定到 <code>t</code>，剩余实参形成下一个 <code>print</code> 调用的参数包。因此，在每个调用中，包中的第一个实参被移除，成为绑定到 <code>t</code> 的实参。</strong> 即，给定：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">cout</span>, i, s, <span class="number">42</span>); <span class="comment">// 包中有两个参数</span></span><br></pre></td></tr></table></figure>
<p>递归会执行如下：</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;   font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;   font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;   vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-fymr">调用</th>
    <th class="tg-fymr">t</th>
    <th class="tg-fymr">rest...</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">print(cout, i, s, 42)</td>
    <td class="tg-0pky">i</td>
    <td class="tg-0pky">s, 42</td>
  </tr>
  <tr>
    <td class="tg-0pky">print(cout, s, 42)</td>
    <td class="tg-0pky">s</td>
    <td class="tg-0pky">42</td>
  </tr>
  <tr>
    <td class="tg-0pky" colspan="3">print(cout, 42) 调用非可变参数版本的 print</td>
  </tr>
</tbody>
</table>

<p>前两个调用只能与可变参数版本的 <code>print</code> 匹配，非可变参数版本是不可行的，因为这两个调用分别传递四个和三个实参，而非可变参数 <code>print</code> 只接受两个实参。</p>
<p>对于最后一次递归调用 <code>print(cout, 42)</code>，两个 <code>print</code> 版本都是可行的。这个调用传递两个实参，第一个实参的类型为 <code>ostream &amp;</code>。因此，可变参数版本的 <code>print</code> 可以实例化为只接受两个参数：一个是 <code>ostream &amp;</code> 参数，另一个是 <code>const T &amp;</code> 参数。</p>
<p>对于最后一个调用，两个函数提供同样好的匹配。但是，<strong>非可变参数模板比可变参数模板更特例化</strong>，因此编译器选择非可变参数版本。</p>
<blockquote>
<p><strong>WARNING：</strong> 当定义可变参数版本的 <code>print</code> 时，非可变参数版本的声明必须在作用域中。否则，可变参数版本会无限递归。</p>
</blockquote>
</li>
</ol>
<h2 id="16-4-2-包扩展" class="heading-control"><a href="#16-4-2-包扩展" class="headerlink" title="16.4.2 包扩展"></a>16.4.2 包扩展<a class="heading-anchor" href="#16-4-2-包扩展" aria-hidden="true"></a></h2><ol>
<li><p>对于一个参数包，除了获取其大小外，我们能对它做的唯一的事情就是<strong>扩展</strong>（expand）它。当扩展一个包时，我们还要提供用于每个扩展元素的<strong>模式</strong>（pattern）。扩展一个包就是将它分解为构成的元素，对每个元素应用模式，获得扩展后的列表。我们通过在模式右边放一个省略号（<code>...</code>）来触发扩展操作。</p>
<p>例如，我们的 <code>print</code> 函数包含两个扩展：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> T &amp;t, <span class="keyword">const</span> Args &amp;...rest)</span> <span class="comment">// 扩展 Args</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    <span class="keyword">return</span> print(os, rest...); <span class="comment">// 扩展 rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个扩展操作扩展模板参数包，为 <code>print</code> 生成函数参数列表。第二个扩展操作出现在对 <code>print</code> 的调用中。此模式为 <code>print</code> 调用生成实参列表。</p>
<p>对 <code>Args</code> 的扩展中，编译器将模式 <code>const Arg &amp;</code> 应用到模板参数包 <code>Args</code> 中的每个元素。因此，此模式的扩展结果是一个逗号分隔的零个或多个类型的列表，每个类型都形如 <code>const type &amp;</code>。例如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">cout</span>, i, s, <span class="number">42</span>); <span class="comment">// 包中有两个参数</span></span><br></pre></td></tr></table></figure>
<p>最后两个实参的类型和模式一起确定了尾置参数的类型。此调用被实例化为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream &amp;<span class="title">print</span><span class="params">(ostream &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="keyword">int</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>第二个扩展发生在对 <code>print</code> 的（递归）调用中。在此情况下，模式是函数参数包的名字（即 <code>rest</code>）。此模式扩展出一个由包中元素组成的、逗号分隔的列表。因此，这个调用等价于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">print(os, s, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>print</code> 中的函数参数包扩展仅仅将包扩展为其构成元素，C++ 语言还允许更复杂的扩展模式。例如，我们可以编写第二个可变参数函数，对其每个实参调用 <code>debug_rep</code>，然后调用 <code>print</code> 打印结果 <code>string</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 print 调用中对每个实参调用 debug_rep</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream &amp;<span class="title">errorMsg</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> Args &amp;...rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// print(os, debug_rep(a1), debug_rep(a2), ..., debug_rep(an)</span></span><br><span class="line">    <span class="keyword">return</span> print(os, debug_rep(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个 <code>print</code> 调用使用了模式 <code>debug_rep(rest)</code>。此模式表示我们希望对函数参数包 <code>rest</code> 中的每个元素调用 <code>debug_rep</code>。扩展结果将是一个逗号分隔的 <code>debug_rep</code> 调用列表。即，下面调用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">errorMsg(<span class="built_in">cerr</span>, fcnName, code.num(), otherData, <span class="string">"other"</span>, item);</span><br></pre></td></tr></table></figure>
<p>就好像我们这样编写代码一样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">cerr</span>, debug_rep(fcnName), debug_rep(code.num()), debug_rep(otherData),</span><br><span class="line">      debug_rep(<span class="string">"otherData"</span>), debug_rep(item));</span><br></pre></td></tr></table></figure>
<p>与之相对，下面的模式会编译失败</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将包传递给 debug_rep； print(os, debug_rep(al, a2, ..., an))</span></span><br><span class="line">print(os, debug_rep(rest...)); <span class="comment">// 错误：此调用无匹配函数</span></span><br></pre></td></tr></table></figure>
<p>这段代码的问题是我们在 <code>debug_rep</code> 调用中扩展了 <code>rest</code>，它等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">print(<span class="built_in">cerr</span>, debug_rep(fcnName, code.num(), otherData, <span class="string">"otherData"</span>, item));</span><br></pre></td></tr></table></figure>
<p>在这个扩展中，我们试图用一个五个实参的列表来调用 <code>debug_rep</code>，但并不存在与此调用匹配的 <code>debug_rep</code> 版本。<code>debug_rep</code> 函数不是可变参数的，而且没有哪个 <code>debug_rep</code> 版本接受五个参数。</p>
</li>
<li><blockquote>
<p><strong>Note：</strong> 扩展中的模式会独立地应用于包中的每个元素。</p>
</blockquote>
</li>
</ol>
<h2 id="16-4-3-转发参数包" class="heading-control"><a href="#16-4-3-转发参数包" class="headerlink" title="16.4.3 转发参数包"></a>16.4.3 转发参数包<a class="heading-anchor" href="#16-4-3-转发参数包" aria-hidden="true"></a></h2><ol>
<li><p>在新标准下，我们可以组合使用可变参数模板与 <code>forward</code> 机制来编写函数，实现将其实参不变地传递给其他函数。</p>
</li>
<li><p><strong>标准库容器的 <code>emplace_back</code> 成员是一个可变参数成员模板，它用其实参在容器管理的内存空间中直接构造一个元素。</strong></p>
</li>
<li><p><strong>保持类型信息是一个两阶段的过程。首先，为了保持实参中的类型信息，必须将 <code>emplace_back</code> 的函数参数定义为模板类型参数的右值引用</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">void</span> <span class="title">emplace_back</span>(<span class="title">Args</span> &amp;&amp;...);</span></span><br><span class="line">    <span class="comment">// 其他成员的定义</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>模板参数包扩展中的模式是 <code>&amp;&amp;</code>，意味着每个函数参数将是一个指向其对应实参的右值引用。</p>
<p><strong>其次，当 <code>emplace_back</code> 将这些实参传递给 <code>construct</code> 时，我们必须使用 <code>forward</code> 来保持实参的原始类型</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">StrVec</span>:</span>:emplace_back(Args &amp;&amp;...args)</span><br><span class="line">&#123;</span><br><span class="line">    chk_n_alloc(); <span class="comment">// 如果需要的话重新分配 StrVec 内存空间</span></span><br><span class="line">    alloc.construct(first_free++, <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>emplace_back</code> 的函数体调用了 <code>chk_n_alloc</code> 来确保有足够的空间容纳一个新元素，然后调用了 <code>construct</code> 在 <code>first_free</code> 指向的位置中创建了一个元素。<code>construct</code> 调用中的扩展为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward&lt;Args&gt;(args)...</span><br></pre></td></tr></table></figure>
<p>它既扩展了模板参数包 <code>Args</code>，也扩展了函数参数包 <code>args</code>。此模式生成如下形式的元素</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward&lt;Ti&gt;(ti)</span><br></pre></td></tr></table></figure>
<p>其中 <code>Ti</code> 表示模板参数包中第 <code>i</code> 个元素的类型，<code>ti</code> 表示函数参数包中第 <code>i</code> 个元素。例如，假定 <code>svec</code> 是一个 <code>StrVec</code>，如果我们调用</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">svec.emplace_back(<span class="number">10</span>, <span class="string">'c'</span>); <span class="comment">// 将 cccccccccc 添加为新的尾元素</span></span><br></pre></td></tr></table></figure>
<p><code>construct</code> 调用中的模式会扩展出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>), <span class="built_in">std</span>::forward&lt;<span class="keyword">char</span>&gt;(c)</span><br></pre></td></tr></table></figure>
<p>通过在此调用中使用 <code>forward</code>，我们保证如果用一个右值调用 <code>emplace_back</code>，则 <code>construct</code> 也会得到一个右值。例如，在下面的调用中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">svec.emplace_back(s1 + s2); <span class="comment">// 使用移动构造函数</span></span><br></pre></td></tr></table></figure>
<p>传递给 <code>emplace_back</code> 的实参是一个右值，它将以如下形式传递给 <code>construct</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::forward&lt;<span class="built_in">string</span>&gt;(<span class="built_in">string</span>(<span class="string">"the end"</span>))</span><br></pre></td></tr></table></figure>
<p><code>forward&lt;string&gt;</code> 的结果类型是 <code>string &amp;&amp;</code>，因此 <code>construct</code> 将得到一个右值引用实参。<code>construct</code> 会继续将此实参传递给 <code>string</code> 的移动构造函数来创建新元素。</p>
</li>
<li><p>可变参数函数通常将它们的参数转发给其他函数。这种函数通常具有与我们的 <code>emplace_back</code> 函数一样的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fun 有零个或多个参数，每个参数都是一个模板参数类型的右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(Args &amp;&amp;...args)</span> <span class="comment">// 将 Args 扩展为一个右值引用的列表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// work 的实参既扩展 Args 又扩展 args</span></span><br><span class="line">    work(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们希望将 <code>fun</code> 的所有实参转发给另一个名为 <code>work</code> 的函数，假定由它完成函数的实际工作。类似 <code>emplace_back</code> 中对 <code>construct</code> 的调用，<code>work</code> 调用中的扩展既扩展了模板参数包也扩展了函数参数包。</p>
<p>由于 <code>fun</code> 的参数是右值引用，因此我们可以传递给它任意类型的实参；由于我们使用 <code>std::forward</code> 传递这些实参，因此它们的所有类型信息在调用 <code>work</code> 时都会得到保持。</p>
</li>
<li><p><strong>右值引用引用的是右值，但右值引用本身是左值。能被赋值的一定是左值，但左值不一定能被赋值，例如右值引用。</strong>——博主注</p>
</li>
<li><p><strong>使用变参模板的关键——完美转发：右值引用 + <code>forward</code>。</strong>——博主注</p>
</li>
</ol>
<h1 id="16-5-模板特例化" class="heading-control"><a href="#16-5-模板特例化" class="headerlink" title="16.5 模板特例化"></a>16.5 模板特例化<a class="heading-anchor" href="#16-5-模板特例化" aria-hidden="true"></a></h1><ol>
<li><p>在某些情况下，通用模板的定义对特定类型是不适合的：通用定义可能编译失败或做得不正确。当我们不能（或不希望）使用模板版本时，可以定义类或函数模板的一个特例化版本。</p>
</li>
<li><p>我们希望 <code>compare</code> 通过调用 <code>strcmp</code> 比较两个字符指针而非比较指针值。实际上，我们已经重载了 <code>compare</code> 函数来处理字符串字面常量：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 第一个版本；可以比较任意两个类型</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br><span class="line"><span class="comment">// 第二个版本处理字符串字面常量</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">size_t</span> N, <span class="keyword">size_t</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[N], <span class="keyword">const</span> <span class="keyword">char</span> (&amp;)[M])</span></span>;</span><br></pre></td></tr></table></figure>
<p>但是，只有当我们传递给 <code>compare</code> 一个字符串字面常量或者一个数组时，编译器才会调用接受两个非类型模板参数的版本。如果我们传递给它字符指针，就会调用第一个版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *p1 = <span class="string">"hi"</span>, *p2 = <span class="string">"mom"</span>;</span><br><span class="line">compare(p1, p2);      <span class="comment">// 调用第一个模板</span></span><br><span class="line">compare(<span class="string">"hi"</span>, <span class="string">"mom"</span>); <span class="comment">// 调用有两个非类型参数的版本</span></span><br></pre></td></tr></table></figure>
<p>我们<strong>无法将一个指针转换为一个数组的引用</strong>，因此当参数是 p1 和 p2 时，第二个版本的 <code>compare</code> 是不可行的。</p>
<p>为了处理字符指针（而不是数组），可以为第一个版本的 <code>compare</code> 定义一个<strong>模板特例化</strong>（template specialization）版本。一个特例化版本就是模板的一个独立的定义，在其中个或多个模板参数被指定为特定的类型。</p>
</li>
<li><p><strong>当我们特例化一个函数模板时，必须为原模板中的每个模板参数都提供实参。</strong> 为了指出我们正在实例化一个模板，应使用关键字 <code>template</code> 后跟一个空尖括号对（<code>&lt;&gt;</code>）。空尖括号指出我们将为原模板的所有模板参数提供实参：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// compare 的特殊版本，处理字符数组的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> &amp;p1, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解此特例化版本的困难之处是函数参数类型。当我们定义一个特例化版本时，函数参数类型必须与一个先前声明的模板中对应的类型匹配。本例中我们特例化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T &amp;, <span class="keyword">const</span> T &amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中函数参数为一个 <code>const</code> 类型的引用。我们希望定义此函数的一个特例化版本，其中 <code>T</code> 为 <code>const char*</code>。我们的函数要求一个指向此类型 <code>const</code> 版本的引用。一个指针类型的 <code>const</code> 版本是一个常量指针而不是指向 <code>const</code> 类型的指针。我们需要在特例化版本中使用的类型是 <code>const char* const&amp;</code>，即一个指向 <code>const char</code> 的 <code>const</code> 指针的引用。</p>
<blockquote>
<p>函数模板只允许全特化，不允许偏特化。——博主注</p>
</blockquote>
</li>
<li><p>当定义函数模板的特例化版本时，我们本质上接管了编译器的工作。即，我们为原模板的一个特殊实例提供了定义。重要的是要弄清：一个特例化版本本质上是一个实例，而非函数名的一个重载版本。</p>
<blockquote>
<p><strong>Note：</strong> 特例化的本质是实例化一个模板，而非重载它。因此，特例化不影响函数匹配。</p>
</blockquote>
</li>
<li><p>我们将一个特殊的函数定义为一个特例化版本还是一个独立的非模板函数，会影响到函数匹配。例如，我们已经定义了两个版本的 <code>compare</code> 函数模板，一个接受数组引用参数，另一个接受 <code>const T&amp;</code>。我们还定义了一个特例化版本来处理字符指针，这对函数匹配没有影响。当我们对字符串字面常量调用 <code>compare</code> 时</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">compare(<span class="string">"hi"</span>, <span class="string">"mom"</span>)</span><br></pre></td></tr></table></figure>
<p>对此调用，两个函数模板都是可行的，且提供同样好的（即精确的）匹配。但是，接受字符数组参数的版本更特例化，因此编译器会选择它。</p>
<p>如果我们将接受字符指针的 <code>compare</code> 版本定义为一个普通的非模板函数（而不是模板的一个特例化版本），此调用的解析就会不同。在此情况下，将会有三个可行的函数：两个模板和非模板的字符指针版本。所有三个函数都提供同样好的匹配。如前所述，当一个非模板函数提供与函数模板同样好的匹配时，编译器会选择非模板版本。</p>
<blockquote>
<p>当提供同样好的匹配时，非模板函数优先于模板函数，特例化模板函数优先于非特例化模板函数。——博主注</p>
</blockquote>
</li>
<li><p>为了特例化一个模板，原模板的声明必须在作用域中。而且，在任何使用模板实例的代码之前，特例化版本的声明也必须在作用域中。</p>
<p>对于普通类和函数，丢失声明的情况（通常）很容易发现——编译器将不能继续处理我们的代码。但是，如果丢失了一个特例化版本的声明，编译器通常可以用原模板生成代码。由于在丢失特例化版本时编译器通常会实例化原模板，很容易产生模板及其特例化版本声明顺序导致的错误，而这种错误又很难查找。</p>
<p>如果一个程序使用一个特例化版本，而同时原模板的一个实例具有相同的模板实参集合，就会产生错误。但是，这种错误编译器又无法发现。</p>
<blockquote>
<p><strong>Best Practices：模板及其特例化版本应该声明在同一个头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本。</strong></p>
</blockquote>
</li>
<li><p>除了特例化函数模板，我们还可以特例化类模板。默认情况下，无序容器使用 <code>hash&lt;key_type&gt;</code> 来组织其元素。为了让我们自己的数据类型也能使用这种默认组织方式，必须定义 <code>hash</code> 模板的一个特例化版本。一个特例化 <code>hash</code> 类必须定义：</p>
<ul>
<li>一个重载的调用运算符，它接受一个容器关键字类型的对象，返回一个 <code>size_t</code>。</li>
<li>两个类型成员，<code>result_type</code> 和 <code>argument_type</code>，分别是调用运算符的返回类型和参数类型。</li>
<li>默认构造函数和拷贝赋值运算符（可以隐式定义）。</li>
</ul>
<p>在定义此特例化版本的 <code>hash</code> 时，唯一复杂的地方是：必须在原模板定义所在的命名空间中特例化它。我们可以向命名空间添加成员。</p>
<p>下面的代码定义了一个能处理 <code>Sales_data</code> 的特例化 <code>hash</code> 版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开 std 命名空间，以便特例化 std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; <span class="comment">// 我们正在定义一个特例化版本，模板参数为 Sales_data</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;Sales_data&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 用来散列一个无序容器的类型必须要定义下列类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">    <span class="keyword">typedef</span> Sales_data argument_type; <span class="comment">// 默认情况下，此类型需要 ==</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;s)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">// 我们的类使用合成的拷贝控制成员和默认构造函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span> hash&lt;Sales_data&gt;::<span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data &amp;s) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(s.bookNo) ^ hash&lt;<span class="keyword">unsigned</span>&gt;()(s.units_sold) ^</span><br><span class="line">           hash&lt;<span class="keyword">double</span>&gt;()(s.revenue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace std</span></span><br></pre></td></tr></table></figure>
<p>我们的 <code>hash&lt;Sales_data&gt;</code> 定义以 <code>template &lt;&gt;</code> 开始，指出我们正在定义一个全特例化的模板。重载的调用运算符必须为给定类型的值定义一个哈希函数。对于一个给定值，任何时候调用此函数都应该返回相同的结果。一个好的哈希函数对不相等的对象（几乎总是）应该产生不同的结果。标准库为内置类型和很多标准库类型定义了 <code>hash</code> 类的特例化版本。</p>
<p>默认情况下，为了处理特定关键字类型，无序容器会组合使用 <code>key_type</code> 对应的特例化 <code>hash</code> 版本和 <code>key_type</code> 上的相等运算符。假定我们的特例化版本在作用域中，当将 <code>Sales_data</code> 作为容器的关键字类型时，编译器就会自动使用此特例化版本：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 hash&lt;Sales_data&gt; 和 Sales_data 的 operator==</span></span><br><span class="line"><span class="built_in">unordered_multiset</span>&lt;Sales_data&gt; SDset;</span><br></pre></td></tr></table></figure>
<p>由于 <code>hash&lt;Sales_data&gt;</code> 使用 <code>Sales_data</code> 的私有成员，我们必须将它声明为 <code>Sales_data</code> 的友元：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">std</span>:</span>:hash; <span class="comment">// 友元声明所需要的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:hash&lt;Sales_data&gt;;</span><br><span class="line">    <span class="comment">// 其他成员定义，如前</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这段代码指出特殊实例 <code>hash&lt;Sales_data&gt;</code> 是 <code>Sales_data</code> 的友元。由于此实例定义在 <code>std</code> 命名空间中，我们必须记得在 <code>friend</code> 声明中应使用 <code>std::hash</code>。</p>
<blockquote>
<p><strong>Note：</strong> 为了让 <code>Sales_data</code> 的用户能使用 <code>hash</code> 的特例化版本，我们应该在 <code>Sales_data</code> 的头文件中定义该特例化版本。</p>
</blockquote>
</li>
<li><p>与函数模板不同，类模板的特例化不必为所有模板参数提供实参。我们可以只指定一部分而非所有模板参数，或是参数的一部分而非全部特性。一个类模板的<strong>部分特例化</strong>（partial specialization）本身是一个模板，使用它时用户还必须为那些在特例化版本中未指定的模板参数提供实参。</p>
<blockquote>
<p><strong>Note：我们只能部分特例化类模板，而不能部分特例化函数模板。</strong></p>
</blockquote>
</li>
<li><p>标准库 <code>remove_reference</code> 类型是通过一系列的特例化版本来完成其功能的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始的、最通用的版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">remove_reference</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 部分特例化版本，将用于左值引用和右值引用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">remove_reference</span>&lt;T &amp;&gt; // 左值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">remove_reference</span>&lt;T &amp;&amp;&gt; // 右值引用</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> T type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第一个模板定义了最通用的模板。它可以用任意类型实例化；它将模板实参作为 <code>type</code> 成员的类型。接下来的两个类是原始模板的部分特例化版本。</p>
<p>由于一个部分特例化版本本质是一个模板，与往常一样，我们首先定义模板参数。类似任何其他特例化版本，部分特例化版本的名字与原模板的名字相同。对每个未完全确定类型的模板参数，在特例化版本的模板参数列表中都有一项与之对应。在类名之后，我们为要特例化的模板参数指定实参，这些实参列于模板名之后的尖括号中。这些实参与原始模板中的参数按位置对应。</p>
<p>部分特例化版本的模板参数列表是原始模板的参数列表的一个子集或者是一个特例化版本。在本例中，特例化版本的模板参数的数目与原始模板相同，但是类型不同。两个特例化版本分别用于左值引用和右值引用类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="comment">// decltype(42) 为 int，使用原始模板</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;</span><br><span class="line"><span class="comment">// decltype(i) 为 int&amp;，使用第一个（T&amp;）部分特例化版本</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(i)&gt;::type b;</span><br><span class="line"><span class="comment">// decitype(std::move(i)) 为int&amp;&amp;，使用第二个（即 T&amp;&amp;）部分特例化版本</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="built_in">std</span>::move(i))&gt;::type c;</span><br></pre></td></tr></table></figure>
<p>三个变量 a、b 和 c 均为 <code>int</code> 类型。</p>
</li>
<li><p>我们可以只特例化特定成员函数而不是特例化整个模板。例如，如果 <code>Foo</code> 是一个模板类，包含一个成员 <code>Bar</code>，我们可以只特例化该成员：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Foo(<span class="keyword">const</span> T &amp;t = T()) : mem(t) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Bar</span><span class="params">()</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line">    T mem;</span><br><span class="line">    <span class="comment">// Foo 的其他成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;          <span class="comment">// 我们正在特例化一个模板</span></span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar() <span class="comment">// 我们正在特例化 Foo&lt;int&gt; 的成员 Bar</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 进行应用于 int 的特例化处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本例中我们只特例化 <code>Foo&lt;int&gt;</code> 类的一个成员，其他成员将由 <code>Foo</code> 模板提供：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Foo&lt;<span class="built_in">string</span>&gt; fs; <span class="comment">// 实例化 Foo&lt;string&gt;::Foo()</span></span><br><span class="line">fs.Bar();       <span class="comment">// 实例化 Foo&lt;string&gt;::Bar()</span></span><br><span class="line">Foo&lt;<span class="keyword">int</span>&gt; fi;    <span class="comment">// 实例化 Foo&lt;int&gt;::Foo()</span></span><br><span class="line">fi.Bar();       <span class="comment">// 使用我们特例化版本的 Foo&lt;int&gt;::Bar()</span></span><br></pre></td></tr></table></figure>
<p>当我们用 <code>int</code> 之外的任何类型使用 <code>Foo</code> 时，其成员像往常一样进行实例化。当我们用 <code>int</code> 使用 <code>Foo</code> 时，<code>Bar</code> 之外的成员像往常一样进行实例化。如果我们使用 <code>Foo&lt;int&gt;</code> 的成员 <code>Bar</code>，则会使用我们定义的特例化版本。</p>
</li>
</ol>
<h1 id="小结" class="heading-control"><a href="#小结" class="headerlink" title="小结"></a>小结<a class="heading-anchor" href="#小结" aria-hidden="true"></a></h1><ol>
<li><p>一个模板就是一个编译器用米生成特定类类型或函数的蓝图。生成特定类或函数的过程称为实例化。标准库算法都是函数模板，标准库容器都是类模板。</p>
</li>
<li><p>显式模板实参允许我们固定一个或多个模板参数的类型或值。对于指定了显式模板实参的模板参数，可以应用正常的类型转换。</p>
</li>
</ol>
<h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%AC%AC%2016%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%881%EF%BC%89.png" alt="第 16 章术语表（1）"></p>
<p><img data-src="https://image.shipengx.com/%E7%AC%AC%2016%20%E7%AB%A0%E6%9C%AF%E8%AF%AD%E8%A1%A8%EF%BC%882%EF%BC%89.png" alt="第 16 章术语表（2）"></p>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>从贝叶斯滤波到粒子滤波</title>
    <url>/archives/f3c9e219.html</url>
    <content><![CDATA[<h1 id="目录" class="heading-control"><a href="#目录" class="headerlink" title="目录"></a>目录<a class="heading-anchor" href="#目录" aria-hidden="true"></a></h1><p><img data-src="https://image.shipengx.com/%E7%9B%AE%E5%BD%95-%E4%BB%8E%E8%B4%9D%E5%8F%B6%E6%96%AF%E6%BB%A4%E6%B3%A2%E5%88%B0%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2.png" alt="目录-从贝叶斯滤波到粒子滤波"></p>
<h1 id="0-回顾与引言" class="heading-control"><a href="#0-回顾与引言" class="headerlink" title="0 回顾与引言"></a>0 回顾与引言<a class="heading-anchor" href="#0-回顾与引言" aria-hidden="true"></a></h1><p>在此前的文章<a href="https://blog.shipengx.com/archives/9fb25cec.html">《从概率到贝叶斯滤波》</a>中，我们曾经提到，贝叶斯滤波框架下求解预测步中的先验概率密度函数 $f_{X_k}^-(x)$、更新步中的归一化常数 $\eta_k$、状态量最优估计 $\hat{x}_k$ 时均涉及到<strong>无穷积分</strong>，大多数情况无法得到解析解，使得贝叶斯滤波算法的直接应用十分困难。为了解决贝叶斯滤波积分难的问题，通常从两个角度出发：</p>
<p><strong>(1) 作理想假设</strong></p>
<ul>
<li><p><strong>线性高斯</strong><br>假设状态转移函数 $g(x)$ 和观测函数 $h(x)$ 均为线性函数，过程噪声随机变量 $Q_k$ 和观测噪声随机变量 $R_k$ 均服从均值为 0 的正态分布。线性高斯问题可通过卡尔曼滤波（Kalman Filter）进行解决，详细内容请参考此前文章<a href="https://blog.shipengx.com/archives/3bb74af.html">《从贝叶斯滤波到卡尔曼滤波》</a>。</p>
</li>
<li><p><strong>非线性高斯</strong><br>假设状态转移函数 $g(x)$ 和（或）观测函数 $h(x)$ 为非线性函数，过程噪声随机变量 $Q_k$ 和观测噪声随机变量 $R_k$ 均服从均值为 0 的正态分布。非线性高斯问题可通过扩展卡尔曼滤波（Extended Kalman Filter）和无迹卡尔曼滤波（Unscented Kalman Filter）进行解决。扩展卡尔曼滤波通过一阶泰勒级数展开将非线性高斯系统的状态转移函数 $g(x)$ 和（或）观测函数 $h(x)$ 线性化，然后采用标准卡尔曼滤波框架实现状态量的滤波过程，详细内容请参考此前文章<a href="https://blog.shipengx.com/archives/ea375326.html">《从贝叶斯滤波到扩展卡尔曼滤波》</a>；无迹卡尔曼滤波基于无迹变换，无迹变换研究的是如何通过确定的采样点捕获经非线性变换的高斯随机变量的后验分布的问题，通过无迹变换得到相应的统计特性后，再结合标准卡尔曼滤波框架，便得到无迹卡尔曼滤波，详细内容请参考此前文章<a href="https://blog.shipengx.com/archives/cfd8b171.html">《从贝叶斯滤波到无迹卡尔曼滤波》</a>。</p>
</li>
</ul>
<p><strong>(2) 化连续为离散</strong></p>
<p>对于强<strong>非线性非高斯</strong>问题，需要将无穷积分转化为离散的数值积分——即化整为零，由此可以引申出本文的主题——粒子滤波（Particle Filter，PF）。</p>
<p>粒子滤波是贝叶斯滤波的一种非参数实现，所谓非参数，即不对滤波状态量的后验概率密度作任何假设。粒子滤波的主要思想是用一系列从后验得到的带权重的随机采样表示后验。从采样的角度考虑，粒子滤波与无迹卡尔曼滤波相似，区别在于，无迹卡尔曼滤波使用 sigma 确定性采样，通过无迹变换计算 sigma 样本点的位置与权重；而粒子滤波使用蒙特卡罗随机采样从建议分布中得到样本（粒子），并通过观测值更新粒子权重，针对粒子的权值退化问题，还涉及粒子的重采样步骤。粒子滤波算法广泛用于解决无人车的定位问题。</p>
<p><strong>关键词：</strong> 贝叶斯，大数定律，蒙特卡罗，重要性采样，序贯重要性采样，粒子退化，重采样，采样重要性重采样，无人车定位</p>
<h1 id="1-蒙特卡罗方法" class="heading-control"><a href="#1-蒙特卡罗方法" class="headerlink" title="1 蒙特卡罗方法"></a>1 蒙特卡罗方法<a class="heading-anchor" href="#1-蒙特卡罗方法" aria-hidden="true"></a></h1><p>假设存在某一连续型随机变量 $X$，其概率密度函数为 $p(x)$，则 $X$ 的数学期望为：</p>
<script type="math/tex; mode=display">
\mathrm{E}(X)=\int x·p(x)\mathrm{d}x \tag{1.1}</script><p>若存在另一连续型随机变量 $Y$，满足 $Y = g(X)$，则 $Y$ 的数学期望为：</p>
<script type="math/tex; mode=display">
\mathrm{E}(Y)=\int g(x)·p(x)\mathrm{d}x \tag{1.2}</script><p>正如我们所知道的，上式中的 $\mathrm{E}(X)$ 和 $\mathrm{E}(Y)$ 可能很难得到解析解。<strong>蒙特卡罗</strong>（Monte Carlo）方法告诉我们，可以通过对随机变量的概率密度进行随机采样，并对样本进行加权求和来近似随机变量的期望，如此一来，积分问题便转化为有限样本点的求和问题。</p>
<p>假设 $\mathcal{X}$ 是从 $p(x)$ 中进行随机采样得到的样本集合，样本数量为 $N$，每一个样本（粒子）$\mathcal{X}^{(i)}$ 代表 $X$ 的一种可能状态，即</p>
<script type="math/tex; mode=display">
\mathcal{X}^{(i)}\sim p(x) \tag{1.3}</script><p>根据<strong>辛钦大数定律</strong>，$\mathcal{X}$ 的样本均值依概率 1 收敛于数学期望，即对 $\forall\epsilon &gt; 0$，有</p>
<script type="math/tex; mode=display">
\lim_{N\rightarrow\infty}P\left\{\bigg|\frac{1}{N}\sum_{i=0}^{N-1}\mathcal{X}^{(i)}-\mathrm{E}(X)\bigg|<\epsilon\right\}=1 \tag{1.4}</script><script type="math/tex; mode=display">
\lim_{N\rightarrow\infty}P\left\{\bigg|\frac{1}{N}\sum_{i=0}^{N-1}g(\mathcal{X}^{(i)})-\mathrm{E}(Y)\bigg|<\epsilon\right\}=1 \tag{1.5}</script><p>式 (1.4) 和 (1.5) 意味着，当样本数量 $N$ 足够大时，有</p>
<script type="math/tex; mode=display">
\mathrm{E}(X)\approx \frac{1}{N}\sum_{i=0}^{N-1}\mathcal{X}^{(i)} \tag{1.6}</script><script type="math/tex; mode=display">
\mathrm{E}(Y)\approx \frac{1}{N}\sum_{i=0}^{N-1}g(\mathcal{X}^{(i)}) \tag{1.7}</script><h1 id="2-重要性采样" class="heading-control"><a href="#2-重要性采样" class="headerlink" title="2 重要性采样"></a>2 重要性采样<a class="heading-anchor" href="#2-重要性采样" aria-hidden="true"></a></h1><h2 id="2-1-什么是重要性采样" class="heading-control"><a href="#2-1-什么是重要性采样" class="headerlink" title="2.1 什么是重要性采样"></a>2.1 什么是重要性采样<a class="heading-anchor" href="#2-1-什么是重要性采样" aria-hidden="true"></a></h2><p>如上述，如果我们能够对概率密度函数 $p(x)$ 进行随机采样，便可通过对样本进行加权求和来近似随机变量 $X$ 和 $Y=g(X)$ 的数学期望，然而现实情况是，$p(x)$ 可能很难直接采样，甚至根本无法采样。此时，可以选择从一个更加容易采样的概率密度函数 $q(x)$ 中进行随机采样得到样本集合 $\mathcal{X}$，并通过 $\mathcal{X}$ 近似估计 $\mathrm{E}(Y)$</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \mathrm{E}(Y)
        & =\int g(x)·p(x)\mathrm{d}x \\
        & = \int g(x)\frac{p(x)}{q(x)}·q(x)\mathrm{d}x \\
        & \approx \frac{1}{N}\sum_{i=0}^{N-1}g(\mathcal{X}^{(i)})\frac{p(\mathcal{X}^{(i)})}{q(\mathcal{X}^{(i)})}
\end{aligned} \tag{2.1}</script><p>其中</p>
<script type="math/tex; mode=display">
\mathcal{X}^{(i)}\sim q(x) \tag{2.2}</script><p>上述的采样方式称为<strong>重要性采样</strong>（Importance Sampling），其中的更易采样的概率密度函数 $q(x)$ 称为<strong>建议分布</strong>（Proposal Distribution），也称重要性密度（Importance Density）或重要性函数（Importance Function）。</p>
<p>令</p>
<script type="math/tex; mode=display">
w(x)=\frac{p(x)}{q(x)} \tag{2.3}</script><p>显然</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \int p(x)\mathrm{d}x
        & = \int w(x)·q(x)\mathrm{d}x \\
        & \approx \frac{1}{N}\sum_{i=0}^{N-1}w(\mathcal{X}^{(i)}) \\
        & = 1
\end{aligned} \tag{2.4}</script><p>故，式 (2.1) 可改写为</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \mathrm{E}(Y)
        & \approx \frac{1}{N}\sum_{i=0}^{N-1}g(\mathcal{X}^{(i)})\frac{p(\mathcal{X}^{(i)})}{q(\mathcal{X}^{(i)})} \\
        & \approx \frac{ \frac{1}{N}\sum\limits_{i=0}^{N-1}g(\mathcal{X}^{(i)})w(\mathcal{X}^{(i)}) }{ \frac{1}{N}\sum\limits_{i=0}^{N-1}w(\mathcal{X}^{(i)}) } \\
        & \approx \sum_{i=0}^{N-1}g(\mathcal{X}^{(i)})\frac{ w(\mathcal{X}^{(i)}) }{ \sum\limits_{i=0}^{N-1}w(\mathcal{X}^{(i)}) }
\end{aligned} \tag{2.5}</script><p>我们记 $w^{(i)}=w(\mathcal{X}^{(i)})$，并记</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \widetilde{w}^{(i)}
        & = \frac{ w(\mathcal{X}^{(i)}) }{ \sum\limits_{i=0}^{N-1}w(\mathcal{X}^{(i)}) } \\
        & = \frac{w^{(i)}}{\sum\limits_{i=0}^{N-1}w^{(i)}}
\end{aligned} \tag{2.6}</script><p>$w^{(i)}$ 我们称之为粒子 $\mathcal{X}^{(i)}$ 的<strong>非归一化的重要性权重</strong>（Unnormalized Importance Weight），$\widetilde{w}^{(i)}$ 我们称之为<strong>归一化的重要性权重</strong>（Normalized Importance Weight），则式 (2.5) 等价于</p>
<script type="math/tex; mode=display">
\mathrm{E}(Y)\approx \sum_{i=0}^{N-1}g(\mathcal{X}^{(i)})\widetilde{w}^{(i)} \tag{2.7}</script><p>从式 (2.7) 中我们不难发现，归一化的重要性权重 $\widetilde{w}^{(i)}$ 即对应粒子 $\mathcal{X}^{(i)}$ 的离散概率值（概率质量），只要得到了粒子 $\mathcal{X}^{(i)}$ 及其对应的归一化的重要性权重 $\widetilde{w}^{(i)}$，便可通过式 (2.7) 近似估计期望 $\mathrm{E}(Y)$。<strong>简言之，重要性采样要解决的是原分布难以采样甚至无法采样的问题。</strong></p>
<h2 id="2-2-序贯重要性采样" class="heading-control"><a href="#2-2-序贯重要性采样" class="headerlink" title="2.2 序贯重要性采样"></a>2.2 序贯重要性采样<a class="heading-anchor" href="#2-2-序贯重要性采样" aria-hidden="true"></a></h2><p>上述的重要性采样过程针对的是单一随机变量的估计，而对于贝叶斯估计而言，我们需要处理的是从 $0$ 时刻到 $k$ 时刻的随机过程</p>
<script type="math/tex; mode=display">
X_{0:k}=\{X_0, X_1, X_2, \dotsb, X_k\} \tag{2.8}</script><p>意即，我们需要估计的是条件期望</p>
<script type="math/tex; mode=display">
\mathrm{E}[g(X_k)|Z_{1:k}]=\int g(x_k)·p(x_k|z_{1:k})\mathrm{d}{x_k} \tag{2.9}</script><p>类似 2.1 节中的推导过程，我们从一个更加容易采样的概率密度函数 $q(x_{0:k}|z_{1:k})$ 中进行随机采样得到样本集合 $\mathcal{X}_{0:k}$，并通过 $\mathcal{X}_{0:k}$ 近似估计条件期望 $\mathrm{E}[g(X_k)|Z_{1:k}]$</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \mathrm{E}[g(X_k)|Z_{1:k}]
        & = \int g(x_k)·p(x_k|z_{1:k})\mathrm{d}{x_k} \\
        & = \int g(x_k)·p(x_{0:k}|z_{1:k})\mathrm{d}{x_{0:k}} \\
        & = \int g(x_k)\frac{p(x_{0:k}|z_{1:k})}{q(x_{0:k}|z_{1:k})}·q(x_{0:k}|z_{1:k})\mathrm{d}x_{0:k} \\
        & \approx \frac{1}{N}\sum_{i=0}^{N-1}g(\mathcal{X}_k^{(i)})\frac{p(\mathcal{X}_{0:k}^{(i)}|z_{1:k})}{q(\mathcal{X}_{0:k}^{(i)}|z_{1:k})}
\end{aligned} \tag{2.10}</script><p>其中</p>
<script type="math/tex; mode=display">
\mathcal{X}_{0:k}^{(i)}\sim q(x_{0:k}|z_{1:k}) \tag{2.11}</script><p>$\mathcal{X}_{0:k}^{(i)}$ 是由每一时刻的第 $i$ 个样本粒子依次增广构成的粒子簇</p>
<script type="math/tex; mode=display">
\mathcal{X}_{0:k}^{(i)}=\{\mathcal{X}_0^{(i)}, \mathcal{X}_1^{(i)}, \dotsb, \mathcal{X}_k^{(i)}\} \quad i=0, 1, 2, \dotsb, N-1 \tag{2.12}</script><p>令</p>
<script type="math/tex; mode=display">
w(x_{0:k})=\frac{p(x_{0:k}|z_{1:k})}{q(x_{0:k}|z_{1:k})} \tag{2.13}</script><p>显然</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \int p(x_{0:k}|z_{1:k})\mathrm{d}x_{0:k}
        & = \int w(x_{0:k})·q(x_{0:k}|z_{1:k})\mathrm{d}x_{0:k} \\
        & \approx \frac{1}{N}\sum_{i=0}^{N-1}w(\mathcal{X}_{0:k}^{(i)}) \\
        & = 1
\end{aligned} \tag{2.14}</script><p>故，式 (2.10) 可改写为</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \mathrm{E}[g(X_k)|Z_{1:k}]
        & \approx \frac{1}{N}\sum_{i=0}^{N-1}g(\mathcal{X}_k^{(i)})\frac{p(\mathcal{X}_{0:k}^{(i)}|z_{1:k})}{q(\mathcal{X}_{0:k}^{(i)}|z_{1:k})} \\
        & \approx \frac{ \frac{1}{N}\sum\limits_{i=0}^{N-1}g(\mathcal{X}_k^{(i)})w(\mathcal{X}_{0:k}^{(i)}) }{ \frac{1}{N}\sum\limits_{i=0}^{N-1}w(\mathcal{X}_{0:k}^{(i)}) } \\
        & \approx \sum_{i=0}^{N-1}g(\mathcal{X}_k^{(i)})\frac{ w(\mathcal{X}_{0:k}^{(i)}) }{ \sum\limits_{i=0}^{N-1}w(\mathcal{X}_{0:k}^{(i)}) }
\end{aligned} \tag{2.15}</script><p>我们记 $w_k^{(i)}=w(\mathcal{X}_{0:k}^{(i)})$，并记</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \widetilde{w}_k^{(i)}
        & = \frac{ w(\mathcal{X}_{0:k}^{(i)}) }{ \sum\limits_{i=0}^{N-1}w(\mathcal{X}_{0:k}^{(i)}) } \\
        & = \frac{w_k^{(i)}}{\sum\limits_{i=0}^{N-1}w_k^{(i)}}
\end{aligned} \tag{2.16}</script><p>$w_k^{(i)}$ 我们称之为粒子簇 $\mathcal{X}_{0:k}^{(i)}$ 的非归一化的重要性权重，$\widetilde{w}^{(i)}$ 我们称之为归一化的重要性权重，则式 (2.15) 等价于</p>
<script type="math/tex; mode=display">
\mathrm{E}[g(X_k)|Z_{1:k}]\approx \sum_{i=0}^{N-1}g(\mathcal{X}_k^{(i)})\widetilde{w}_k^{(i)} \tag{2.17}</script><p>从式 (2.17) 中我们不难发现，归一化的重要性权重 $\widetilde{w}_k^{(i)}$ 即对应粒子簇 $\mathcal{X}_{0:k}^{(i)}$ 的离散概率值（概率质量），只要得到了粒子簇 $\mathcal{X}_{0:k}^{(i)}$ 及其对应的归一化的重要性权重 $\widetilde{w}_k^{(i)}$，便可通过式 (2.17) 近似估计条件期望 $\mathrm{E}[g(X_k)|Z_{1:k}]$。</p>
<p>式 (2.16) 中的重要性权重是批量形式，存在这样一个问题，每个新的时刻的观测数据到来时都需要重新批量计算整个状态序列的重要性权重，随着时间的推移，这无疑将带来巨大的资源消耗。为了递推地更新相邻时刻间粒子的重要性权重，我们引入<strong>序贯重要性采样</strong>（Sequential Importance Sampling，SIS）算法。</p>
<p>根据贝叶斯公式、马尔可夫状态独立性假设和马尔可夫观测独立性假设，我们很容易得到原分布的的递推形式</p>
<script type="math/tex; mode=display">
\begin{aligned}
    p(x_{0:k}|z_{1:k})
        & = \frac{p(x_{0:k},z_{1:k})}{p(z_k,z_{1:{k-1} })} \\
        & = \frac{p(z_k,x_{0:k},z_{1:{k-1} })}{p(z_k|z_{1:{k-1} })p(z_{1:{k-1} })} \\
        & = \frac{p(z_k|x_{0:k},z_{1:{k-1} })p(x_{0:k},z_{1:{k-1} })}{p(z_k|z_{1:{k-1} })p(z_{1:{k-1} })} \\
        & = \frac{p(z_k|x_{0:k},z_{1:{k-1} })p(x_k,x_{0:{k-1} },z_{1:{k-1} })}{p(z_k|z_{1:{k-1} })p(z_{1:{k-1} })} \\
        & = \frac{p(z_k|x_{0:k},z_{1:{k-1} })p(x_k|x_{0:{k-1} },z_{1:{k-1} })p(x_{0:{k-1} },z_{1:{k-1} })}{p(z_k|z_{1:{k-1} })p(z_{1:{k-1} })} \\
        & = \frac{p(z_k|x_{0:k},z_{1:{k-1} })p(x_k|x_{0:{k-1} },z_{1:{k-1} })p(x_{0:{k-1} }|z_{1:{k-1} })p(z_{1:{k-1} })}{p(z_k|z_{1:{k-1} })p(z_{1:{k-1} })} \\
        & = \frac{p(z_k|x_{0:k},z_{1:{k-1} })p(x_k|x_{0:{k-1} },z_{1:{k-1} })p(x_{0:{k-1} }|z_{1:{k-1} })}{p(z_k|z_{1:{k-1} })} \\
        & = \frac{p(z_k|x_k)p(x_k|x_{k-1})p(x_{0:{k-1} }|z_{1:{k-1} })}{p(z_k|z_{1:{k-1} })} \\
        & \propto p(z_k|x_k)p(x_k|x_{k-1})p(x_{0:{k-1} }|z_{1:{k-1} })
\end{aligned} \tag{2.18}</script><p>假定建议分布有如下的递推形式</p>
<script type="math/tex; mode=display">
q(x_{0:k}|z_{1:k})=q(x_k|x_{0:k-1},z_{1:k})q(x_{0:k-1}|z_{1:k-1}) \tag{2.19}</script><p>将式 (2.18) 和式 (2.19) 代入式 (2.13)</p>
<script type="math/tex; mode=display">
\begin{aligned}
    w(x_{0:k})
        & = \frac{p(x_{0:k}|z_{1:k})}{q(x_{0:k}|z_{1:k})} \\
        & \propto \frac{ p(z_k|x_k)p(x_k|x_{k-1})p(x_{0:{k-1} }|z_{1:{k-1} })}{ q(x_k|x_{0:k-1},z_{1:k})q(x_{0:k-1}|z_{1:k-1}) } \\
        & = \frac{ p(z_k|x_k)p(x_k|x_{k-1})}{ q(x_k|x_{0:k-1},z_{1:k})}w(x_{0:{k-1}})
\end{aligned} \tag{2.20}</script><p>根据式 (2.19) 对建议分布递推形式的假设，式 (2.11) 粒子簇的批量采样可以很自然地转化为单个粒子的序贯采样形式：</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \mathcal{X}_0^{(i)} & \sim q(x_0) \\
    \mathcal{X}_1^{(i)} & \sim q(x_1|\mathcal{X}_0^{(i)},z_1) \\
    \mathcal{X}_2^{(i)} & \sim q(x_2|\mathcal{X}_{0:1}^{(i)},z_{1:2}) \\
    & \qquad \vdots \\
    \mathcal{X}_k^{(i)} & \sim q(x_k|\mathcal{X}_{0:{k-1}}^{(i)},z_{1:k})
\end{aligned} \tag{2.21}</script><p>将式 (2.21) 代入式 (2.20) 便得到重要性权重的递推更新形式：</p>
<script type="math/tex; mode=display">
w_k^{(i)}\propto\frac{ p(z_k|\mathcal{X}_k^{(i)})p(\mathcal{X}_k^{(i)}|\mathcal{X}_{k-1}^{(i)})}{ q(\mathcal{X}_k^{(i)}|\mathcal{X}_{0:k-1}^{(i)},z_{1:k})} w_{k-1}^{(i)} \tag{2.22}</script><p>若我们只关心当前 $k$ 时刻状态的估计结果，则根据系统的马尔可夫特性，有</p>
<script type="math/tex; mode=display">
q(x_k|x_{0:k-1},z_{1:k})=q(x_k|x_{k-1},z_k) \tag{2.23}</script><p>此时的建议分布只与 $k-1$ 时刻的状态 $x_{k-1}$ 和 $k$ 时刻的观测结果 $z_k$ 有关，这意味着，在实际应用时，我们无需存储更早时刻的历史状态序列和观测序列。根据式 (2.23)，式 (2.21) 演变为</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \mathcal{X}_0^{(i)} & \sim q(x_0) \\
    \mathcal{X}_1^{(i)} & \sim q(x_1|\mathcal{X}_0^{(i)},z_1) \\
    \mathcal{X}_2^{(i)} & \sim q(x_2|\mathcal{X}_1^{(i)},z_2) \\
    & \qquad \vdots \\
    \mathcal{X}_k^{(i)} & \sim q(x_k|\mathcal{X}_{k-1}^{(i)},z_k)
\end{aligned} \tag{2.24}</script><p>将式 (2.23) 和式 (2.24) 代入式 (2.22)，可以得到重要性权重最终的递推更新形式</p>
<script type="math/tex; mode=display">
w_k^{(i)}\propto\frac{ p(z_k|\mathcal{X}_k^{(i)})p(\mathcal{X}_k^{(i)}|\mathcal{X}_{k-1}^{(i)})}{ q(\mathcal{X}_k^{(i)}|\mathcal{X}_{k-1}^{(i)},z_k)} w_{k-1}^{(i)} \tag{2.25}</script><p>注意，式 (2.25) 中的 $w_k^{(i)}=w(\mathcal{X}_k^{(i)})$。按照式 (2.25) 递推地得到 $k$ 时刻每个粒子的重要性权重后，再对权重作归一化处理，最终便可根据式 (2.17) 近似估计条件期望。式 (2.24)、(2.25)、(2.16) 和 (2.17) 构成了 SIS 算法的核心流程，下面我们总结下 SIS 的整体框架伪代码。</p>
<script type="math/tex; mode=display">
\boxed{
    \begin{aligned}
    & \color{red}{\big[\{ \mathcal{X}_k^{(i)}, w_k^{(i)} \}_{i=0}^{N-1}, \mathrm{E}(·)\big]=\texttt{SIS}\big[\{ \mathcal{X}_{k-1}^{(i)}, w_{k-1}^{(i)} \}_{i=0}^{N-1}, z_k\big]} \\
    & \\
    & \texttt{FOR} \quad i=0:N-1 \\
    & \qquad \text{(1) 0 时刻粒子及其重要性权重初始化：}\mathcal{X}_0^{(i)}\sim q(x_0), \quad w_0^{(i)}=\frac{1}{N}\\
    & \texttt{END FOR} \\
    & \\
    & \texttt{FOR} \quad i=0:N-1 \\
    & \qquad \text{(2) 粒子序贯采样：}\mathcal{X}_k^{(i)} \sim q(x_k|\mathcal{X}_{k-1}^{(i)},z_k) \\
    & \qquad \text{(3) 粒子重要性权重序贯更新：}w_k^{(i)}\propto\frac{ p(z_k|\mathcal{X}_k^{(i)})p(\mathcal{X}_k^{(i)}|\mathcal{X}_{k-1}^{(i)})}{ q(\mathcal{X}_k^{(i)}|\mathcal{X}_{k-1}^{(i)},z_k)} w_{k-1}^{(i)} \\
    & \texttt{END FOR} \\
    & \\
    & \text{(4) 粒子重要性权重归一化：}\widetilde{w}_k^{(i)}= \frac{w_k^{(i)}}{\sum\limits_{i=0}^{N-1}w_k^{(i)}} \\
    & \\
    & \text{(5) 期望估计：}\mathrm{E}[g(X_k)|Z_{1:k}]\approx \sum_{i=0}^{N-1}g(\mathcal{X}_k^{(i)})\widetilde{w}_k^{(i)}
\end{aligned}
}</script><p><strong>简言之，序贯重要性采样是为了序贯地进行粒子采样，并递推地更新粒子的重要性权重。</strong></p>
<h1 id="3-粒子退化问题" class="heading-control"><a href="#3-粒子退化问题" class="headerlink" title="3 粒子退化问题"></a>3 粒子退化问题<a class="heading-anchor" href="#3-粒子退化问题" aria-hidden="true"></a></h1><h2 id="3-1-概述" class="heading-control"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述<a class="heading-anchor" href="#3-1-概述" aria-hidden="true"></a></h2><h3 id="3-1-1-什么是粒子退化" class="heading-control"><a href="#3-1-1-什么是粒子退化" class="headerlink" title="3.1.1 什么是粒子退化"></a>3.1.1 什么是粒子退化<a class="heading-anchor" href="#3-1-1-什么是粒子退化" aria-hidden="true"></a></h3><p>SIS 算法在经历次多次迭代后，粒子重要性权重的方差可能将变得很大，从而引发<strong>粒子退化问题</strong>（Particle Degeneracy Problem）。所谓粒子退化，指的是大量粒子中只有少数粒子具有较高权重，而绝大多数粒子的权重都很小甚至接近于 $0$，导致计算加权均值时大量的运算资源被浪费在了小权重粒子上。粒子退化问题发生的根本原因是建议分布与真实分布的不匹配。</p>
<h3 id="3-1-2-粒子退化程度的度量" class="heading-control"><a href="#3-1-2-粒子退化程度的度量" class="headerlink" title="3.1.2 粒子退化程度的度量"></a>3.1.2 粒子退化程度的度量<a class="heading-anchor" href="#3-1-2-粒子退化程度的度量" aria-hidden="true"></a></h3><p>为了度量粒子退化问题的严重程度，我们引入<strong>有效样本数 $N_{eff}$</strong>，并将其定义如下</p>
<script type="math/tex; mode=display">
N_{eff}=\frac{1}{1+\mathrm{Var}[w_k^{(i)}]} \tag{3.1}</script><p>$N_{eff}$ 的直接计算并不容易，我们通常代为使用其估计量 $\widehat{N_{eff}}$</p>
<script type="math/tex; mode=display">
\widehat{N_{eff}}=\frac{1}{\sum\limits_{i=0}^N(\widetilde{w}_k^{(i)})^2} \tag{3.2}</script><p>$\widehat{N_{eff}}$ 越小，则意味着粒子退化越严重。抑制粒子退化问题最直观的方法是增加采样粒子数量 $N$，但这无疑会增加计算负担，降低算法实时性，以下两个手段则更具实操性：</p>
<ul>
<li>选择合适的建议分布</li>
<li>在 SIS 算法流程结束后，实施粒子重采样（Resampling）步骤</li>
</ul>
<h2 id="3-2-建议分布的选择" class="heading-control"><a href="#3-2-建议分布的选择" class="headerlink" title="3.2 建议分布的选择"></a>3.2 建议分布的选择<a class="heading-anchor" href="#3-2-建议分布的选择" aria-hidden="true"></a></h2><p>最优的建议分布无疑就是真实的后验分布本身</p>
<script type="math/tex; mode=display">
q(x_{0:k}|z_{1:k})=p(x_{0:k}|z_{1:k}) \tag{3.3}</script><p>但这个结论对于问题的求解并没有实际意义，因为正是由于后验分布未知或难于积分我们才引入了建议分布的概念。建议分布的设计已经发展出很多形式，并由此衍生出种类繁多的粒子滤波变种：</p>
<ul>
<li>以 UKF 生成建议分布的无迹粒子滤波（Unscented Particle Filter，UPF）</li>
<li>以 EKF 生成建议分布的扩展卡尔曼粒子滤波（Extended Kalman Particle Filter，EKPF）</li>
<li>通过构建辅助变量，提升和观测更为匹配的粒子被采样的概率的辅助粒子滤波（Auxiliary Particle Filter，APF）</li>
</ul>
<p>UPF、EKPF、APF 等并不是本文的主题，这里我们介绍一种精度尚可，但实现更加简单的建议分布形式——先验状态转移概率分布。</p>
<p>根据式 (2.19) 和式 (2.23) 我们不难发现，只要条件建议分布 $q(x_k|x_{k-1},z_k)$ 一经确定，建议分布 $q(x_{0:k}|z_{1:k})$ 便自然确定，假设我们选取系统的先验状态转移概率分布 $p(x_k|x_{k-1})$ 作为条件建议分布</p>
<script type="math/tex; mode=display">
q(x_k|x_{k-1},z_k)=p(x_k|x_{k-1}) \tag{3.4}</script><p>根据式 (3.4)，式 (2.24) 演变为</p>
<script type="math/tex; mode=display">
\begin{aligned}
    \mathcal{X}_0^{(i)} & \sim p(x_0) \\
    \mathcal{X}_1^{(i)} & \sim p(x_1|\mathcal{X}_0^{(i)}) \\
    \mathcal{X}_2^{(i)} & \sim p(x_2|\mathcal{X}_1^{(i)}) \\
    & \quad \vdots \\
    \mathcal{X}_k^{(i)} & \sim p(x_k|\mathcal{X}_{k-1}^{(i)})
\end{aligned} \tag{3.5}</script><p>从式 (3.5) 我们可以知道，只要确定了系统先验的状态转移概率分布，便可以根据系统的状态转移方程进行粒子序贯采样。根据式 (3.4) 和式 (3.5)，式 (2.25) 演变为</p>
<script type="math/tex; mode=display">
w_k^{(i)}\propto\underbrace{p(z_k|\mathcal{X}_k^{(i)})}_{似然概率分布} w_{k-1}^{(i)} \tag{3.6}</script><p>从式 (3.6) 我们可以知道，只要完成了粒子的序贯采样，并确定了系统的似然概率分布，便可以根据系统的观测方程以及上一时刻粒子的重要性权重递推地更新当前时刻粒子的重要性权重（非归一化的）。</p>
<h2 id="3-3-重采样" class="heading-control"><a href="#3-3-重采样" class="headerlink" title="3.3 重采样"></a>3.3 重采样<a class="heading-anchor" href="#3-3-重采样" aria-hidden="true"></a></h2><p>重采样也可有效抑制粒子退化问题。所谓重采样，指的是在得到当前时刻的粒子集及每个粒子归一化的重要性权重 $\{ \mathcal{X}_k^{(i)}, \widetilde{w}_k^{(i)} \}_{i=0}^{N-1}$ 后，根据每个粒子的权重需要进行重新采样，粒子权重越高，被重新采样到的概率也越高，这意味着，某些粒子在重采样后可能会被复制多份，而某些粒子在重采样后可能直接不存在了，如下图所示（参考 23，P263）。</p>
<p><img data-src="https://image.shipengx.com/%E9%87%8D%E9%87%87%E6%A0%B7%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="重采样示意图"></p>
<p>重采样过程等价于对下面这个离散分布进行采样</p>
<script type="math/tex; mode=display">
\mathrm{P}(x_k=\mathcal{X}_k^{(i)})=\widetilde{w}_k^{(i)} \tag{3.7}</script><p>我们记重采样得到的粒子集及每个粒子各自的权重为 $\{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1}$，因为是直接对离散分布进行采样，故</p>
<script type="math/tex; mode=display">
w_k^{\ast (j)}=\frac{1}{N}, \quad j=0, 1, 2, \dotsb, N-1 \tag{3.8}</script><p>针对重采样过程，目前已发展出多种方法，如多项式重采样（Multinomial Resampling）、分层重采样（Stratified Resampling）、系统重采样（Systematic Resampling）、残差重采样（Residual Resampling）等，后面我们会对这几种方法作简单介绍并给出详尽的伪代码实现框架。</p>
<h3 id="3-3-1-几种经典的重采样算法" class="heading-control"><a href="#3-3-1-几种经典的重采样算法" class="headerlink" title="3.3.1 几种经典的重采样算法"></a>3.3.1 几种经典的重采样算法<a class="heading-anchor" href="#3-3-1-几种经典的重采样算法" aria-hidden="true"></a></h3><h4 id="3-3-1-1-多项式重采样" class="heading-control"><a href="#3-3-1-1-多项式重采样" class="headerlink" title="3.3.1.1 多项式重采样"></a>3.3.1.1 多项式重采样<a class="heading-anchor" href="#3-3-1-1-多项式重采样" aria-hidden="true"></a></h4><p>又称简单随机重采样（Simple Random Resampling）。其核心思想很简单，首先，计算粒子归一化权重的累积分布</p>
<script type="math/tex; mode=display">
c_i=
\begin{cases}
    \widetilde{w}_k^{(0)} & \quad i=0 \\
    c_i=c_{i-1}+\widetilde{w}_k^{(i)} & \quad i=1,2, \cdots , N-1
\end{cases} \tag{3.9}</script><p>然后，生成服从均匀分布 [0, 1] 内的随机数</p>
<script type="math/tex; mode=display">
u\sim\mathcal{U}(0,1) \tag{3.10}</script><p>使用二分搜索查找该随机数在累积分布中所处的位置，得到重采样粒子对应的原粒子的索引 $i$，$i$ 满足</p>
<script type="math/tex; mode=display">
\begin{cases}
    u \le c_i \quad & i=0 \\
    c_{i-1}\lt u \le c_i \quad & i=1,2, \cdots , N-1
\end{cases} \tag{3.11}</script><p>多项式重采样算法的时间复杂度为 $\mathcal{O}(n\log(n))$，其中的对数项源于二分搜索的使用。下面我们给出多项式重采样的伪代码。</p>
<script type="math/tex; mode=display">
\boxed{
    \begin{aligned}
    & \color{red}{\{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1}=\texttt{MultinomialResampling}\big[\{ \mathcal{X}_k^{(i)}, \widetilde{w}_k^{(i)} \}_{i=0}^{N-1}, N_r\big]} \\
    & \\
    & c_0 = \widetilde{w}_k^{(0)} \\
    & \texttt{FOR} \quad i=1:N-1 \\
    & \qquad c_i=c_{i-1}+\widetilde{w}_k^{(i)}\\
    & \texttt{END FOR} \\
    & c_{N-1}=1 \\
    & \\
    & \texttt{FOR} \quad j=N-N_r:N-1 \\
    & \qquad u\sim\mathcal{U}(0,1) \\
    & \qquad left=0, \quad right=N-1 \\
    & \qquad \texttt{WHILE} \quad left \lt right \\
    & \qquad \qquad middle=\lfloor\frac{left+right}{2}\rfloor \\
    & \qquad \qquad \texttt{IF} \quad u \gt c_{middle} \\
    & \qquad \qquad \qquad left=middle+1 \\
    & \qquad \qquad \texttt{ELSE} \\
    & \qquad \qquad \qquad right=middle \\
    & \qquad \qquad \texttt{END IF} \\
    & \qquad \texttt{END WHILE} \\
    & \qquad \mathcal{X}_k^{\ast (j)}=\mathcal{X}_k^{(right)} \\
    & \qquad w_k^{\ast (j)}=\frac{1}{N} \\
    & \texttt{END FOR}
\end{aligned}
}</script><p>其中，$N$ 表示粒子总数，$N_r$ 表示重采样的粒子数（$N_r \leq N$。在单独使用多项式重采样时，$N_r=N$；在用于残差重采样的步骤二时，$N_r \lt N$），$\lfloor \cdot\rfloor$ 表示向下取整。在计算粒子权重的累积分布时，为避免圆整误差，需要令 $c_{N-1}=1$。此外，使用二分搜索时需要注意搜索区间的设置。</p>
<h4 id="3-3-1-2-分层重采样" class="heading-control"><a href="#3-3-1-2-分层重采样" class="headerlink" title="3.3.1.2 分层重采样"></a>3.3.1.2 分层重采样<a class="heading-anchor" href="#3-3-1-2-分层重采样" aria-hidden="true"></a></h4><p>分层重采样将粒子归一化重要性权重的累积分布等分为 $N_r$ 层子区间，对每层子区间，使用一个介于子区间左右边界值的随机数来查找该层子区间重采样粒子所对应的原粒子索引，分层重采样算法的时间复杂度为 $\mathcal{O}(n)$。下面我们给出分层重采样的伪代码。</p>
<script type="math/tex; mode=display">
\boxed{
    \begin{aligned}
    & \color{red}{\{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1}=\texttt{StratifiedResampling}\big[\{ \mathcal{X}_k^{(i)}, \widetilde{w}_k^{(i)} \}_{i=0}^{N-1}, N_r\big]} \\
    & \\
    & c_0 = \widetilde{w}_k^{(0)} \\
    & \texttt{FOR} \quad i=1:N-1 \\
    & \qquad c_i=c_{i-1}+\widetilde{w}_k^{(i)}\\
    & \texttt{END FOR} \\
    & c_{N-1}=1 \\
    & \\
    & i=0 \\
    & \texttt{FOR} \quad j=N-N_r:N-1 \\
    & \qquad u_0\sim\mathcal{U}(0,\frac{1}{N_r}) \\
    & \qquad u=u_0+\frac{j-(N-N_r)}{N_r} \\
    & \qquad \texttt{WHILE} \quad c_i \lt u \\
    & \qquad \qquad i=i+1 \\
    & \qquad \texttt{END WHILE} \\
    & \qquad \mathcal{X}_k^{\ast (j)}=\mathcal{X}_k^{(i)} \\
    & \qquad w_k^{\ast (j)}=\frac{1}{N} \\
    & \texttt{END FOR}
\end{aligned}
}</script><p>其中，$N$ 表示粒子总数，$N_r$ 表示重采样的粒子数（$N_r \leq N$。在单独使用分层重采样时，$N_r=N$；在用于残差重采样的步骤二时，$N_r \lt N$）。</p>
<h4 id="3-3-1-3-系统重采样" class="heading-control"><a href="#3-3-1-3-系统重采样" class="headerlink" title="3.3.1.3 系统重采样"></a>3.3.1.3 系统重采样<a class="heading-anchor" href="#3-3-1-3-系统重采样" aria-hidden="true"></a></h4><p>系统重采样与分层重采样类似，唯一的区别在于，系统重采样中的每层子区间在查找各自重采样粒子对应的原粒子索引时使用的是同一个随机数，意即，系统重采样只涉及一次随机数生成操作，系统重采样算法的时间复杂度同样为 $\mathcal{O}(n)$。下面我们给出系统重采样的伪代码。</p>
<script type="math/tex; mode=display">
\boxed{
    \begin{aligned}
    & \color{red}{\{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1}=\texttt{SystematicResampling}\big[\{ \mathcal{X}_k^{(i)}, \widetilde{w}_k^{(i)} \}_{i=0}^{N-1}, N_r\big]} \\
    & \\
    & c_0 = \widetilde{w}_k^{(0)} \\
    & \texttt{FOR} \quad i=1:N-1 \\
    & \qquad c_i=c_{i-1}+\widetilde{w}_k^{(i)}\\
    & \texttt{END FOR} \\
    & c_{N-1}=1 \\
    & \\
    & i=0 \\
    & u_0\sim\mathcal{U}(0,\frac{1}{N_r}) \\
    & \texttt{FOR} \quad j=N-N_r:N-1 \\
    & \qquad u=u_0+\frac{j-(N-N_r)}{N_r} \\
    & \qquad \texttt{WHILE} \quad c_i \lt u \\
    & \qquad \qquad i=i+1 \\
    & \qquad \texttt{END WHILE} \\
    & \qquad \mathcal{X}_k^{\ast (j)}=\mathcal{X}_k^{(i)} \\
    & \qquad w_k^{\ast (j)}=\frac{1}{N} \\
    & \texttt{END FOR}
\end{aligned}
}</script><p>其中，$N$ 表示粒子总数，$N_r$ 表示重采样的粒子数（$N_r \leq N$。在单独使用系统重采样时，$N_r=N$；在用于残差重采样的步骤二时，$N_r \lt N$）。</p>
<h4 id="3-3-1-4-残差重采样" class="heading-control"><a href="#3-3-1-4-残差重采样" class="headerlink" title="3.3.1.4 残差重采样"></a>3.3.1.4 残差重采样<a class="heading-anchor" href="#3-3-1-4-残差重采样" aria-hidden="true"></a></h4><p>残差重采样分两步进行：</p>
<p><strong>步骤一：确定性拷贝采样</strong></p>
<p>对原粒子集的每个粒子 $\mathcal{X}^{(i)}$ 根据 $N_{k_1}^{(i)}$ 作为复制次数进行拷贝采样，其中</p>
<script type="math/tex; mode=display">
N_{k_1}^{(i)}=\lfloor N \widetilde{w}_k^{(i)} \rfloor \qquad i=0,1,2, \cdots , N-1 \tag{3.12}</script><p>例如，原粒子集共有 $N=1000$ 个粒子，第 $i=10$ 个粒子 $\mathcal{X}_k^{(10)}$ 的归一化的重要性权重为 $\widetilde{w}_k^{(10)}=0.0036$，则在残差重采样的步骤一中，$\mathcal{X}_k^{(10)}$ 将被拷贝 $N_{k_1}^{(10)}=\lfloor 1000*0.0036 \rfloor=3$ 次。在步骤一中，总的重采样粒子数为</p>
<script type="math/tex; mode=display">
N_{k_1}^\ast=\sum_{i=0}^{N-1}N_{k_1}^{(i)} \tag{3.13}</script><p>每个拷贝后的重采样粒子的权重置为 $\frac{1}{N}$。</p>
<p><strong>步骤二：残差随机采样</strong></p>
<p>显然，由于忽略了 $N \widetilde{w}_k^{(i)}$ 的小数部分，经过步骤一后重采样粒子集中还缺少 $N_{k_2}=N-N_{k_1}^\ast$ 个粒子，对于剩余的待重采样的粒子，我们结合上面的重采样方法进行随机采样。首先，计算原粒子集中每个粒子经过确定性拷贝采样后新的归一化权重 $\widetilde{w}_k^{r(i)}$（这里我们称之为归一化的残差权重，上角标 $r$ 代表 residual）</p>
<script type="math/tex; mode=display">
\widetilde{w}_k^{r(i)}=\frac{N \widetilde{w}_k^{(i)}-N_{k_1}^{(i)}}{N_{k_2}} \qquad i=0,1,2, \cdots , N-1 \tag{3.14}</script><p>然后，将 $\widetilde{w}_k^{r(i)}$ 和 $N_{k_2}$ 代入多项式重采样、分层重采样或系统重采样中的任意一种，完成剩余重采样粒子的采样。</p>
<p>下面我们给出残差重采样的伪代码，其中步骤二使用的是多项式重采样。</p>
<script type="math/tex; mode=display">
\boxed{
    \begin{aligned}
    & \color{red}{\{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1}=\texttt{ResidualResampling}\big[\{ \mathcal{X}_k^{(i)}, \widetilde{w}_k^{(i)} \}_{i=0}^{N-1}\big]} \\
    & \\
    & j=0 \\
    & \texttt{FOR} \quad i=0:N-1 \\
    & \qquad N_{k_1}^{(i)}=\lfloor N \widetilde{w}_k^{(i)} \rfloor \\
    & \qquad \texttt{FOR} \quad m=0:N_{k_1}^{(i)}-1 \\
    & \qquad \qquad \mathcal{X}_k^{\ast (j)}=\mathcal{X}_k^{(i)} \\
    & \qquad \qquad w_k^{\ast (j)}=\frac{1}{N} \\
    & \qquad \qquad j=j+1\\
    & \qquad \texttt{END FOR} \\
    & \texttt{END FOR} \\
    & \\
    & N_{k_2}=N-j \\
    & \texttt{FOR} \quad i=0:N-1 \\
    & \qquad \widetilde{w}_k^{r(i)}=\frac{N \widetilde{w}_k^{(i)}-N_{k_1}^{(i)}}{N_{k_2}} \\
    & \texttt{END FOR} \\
    & \\
    & \{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1}=\texttt{MultinomialResampling}\big[\{ \mathcal{X}_k^{(i)}, \widetilde{w}_k^{r(i)} \}_{i=0}^{N-1}, N_{k_2}\big]
\end{aligned}
}</script><h3 id="3-3-2-重采样的副作用" class="heading-control"><a href="#3-3-2-重采样的副作用" class="headerlink" title="3.3.2 重采样的副作用"></a>3.3.2 重采样的副作用<a class="heading-anchor" href="#3-3-2-重采样的副作用" aria-hidden="true"></a></h3><p>如果粒子的权值退化问题非常严重，那么重采样后的粒子将会是极少数个别粒子的大量副本，这意味粒子的多样性严重丧失，此时的粒子集已经无法很好地刻画原本的概率密度函数，我们称这种现象为粒子的<strong>样本贫化</strong>（Sample Impoverishment）。样本贫化极有可能导致滤波器发散，为了处理样本贫化问题，已经发展出很多方法，例如正则粒子滤波（Regularized Particle Filter，RPF），本文不对此作展开，有兴趣可以查阅相关文献。</p>
<h3 id="3-3-3-基本的粒子滤波器" class="heading-control"><a href="#3-3-3-基本的粒子滤波器" class="headerlink" title="3.3.3 基本的粒子滤波器"></a>3.3.3 基本的粒子滤波器<a class="heading-anchor" href="#3-3-3-基本的粒子滤波器" aria-hidden="true"></a></h3><p>将 SIS 与重采样进行结合便构成了<strong>基本的粒子滤波器</strong>，下面我们总结下整体框架的伪代码（以 SIS + SystematicResampling 为例）。</p>
<script type="math/tex; mode=display">
\boxed{
    \begin{aligned}
    & \color{red}{\big[\{ \mathcal{X}_k^{(i)}, w_k^{(i)} \}_{i=0}^{N-1}, \mathrm{E}(·)\big]=\texttt{GenericParticleFilter}\big[\{ \mathcal{X}_{k-1}^{(i)}, w_{k-1}^{(i)} \}_{i=0}^{N-1}, z_k\big]} \\
    & \\
    & \texttt{FOR} \quad i=0:N-1 \\
    & \qquad \text{(1) 0 时刻粒子及其重要性权重初始化：}\mathcal{X}_0^{(i)}\sim q(x_0), \quad w_0^{(i)}=\frac{1}{N}\\
    & \texttt{END FOR} \\
    & \\
    & \texttt{FOR} \quad i=0:N-1 \\
    & \qquad \text{(2) 粒子序贯采样：}\mathcal{X}_k^{(i)} \sim q(x_k|\mathcal{X}_{k-1}^{(i)},z_k) \\
    & \qquad \text{(3) 粒子重要性权重序贯更新：}w_k^{(i)}\propto\frac{ p(z_k|\mathcal{X}_k^{(i)})p(\mathcal{X}_k^{(i)}|\mathcal{X}_{k-1}^{(i)})}{ q(\mathcal{X}_k^{(i)}|\mathcal{X}_{k-1}^{(i)},z_k)} w_{k-1}^{(i)} \\
    & \texttt{END FOR} \\
    & \\
    & \text{(4) 粒子重要性权重归一化：}\widetilde{w}_k^{(i)}= \frac{w_k^{(i)}}{\sum\limits_{i=0}^{N-1}w_k^{(i)}} \\
    & \\
    & \widehat{N_{eff}}=\frac{1}{\sum\limits_{i=0}^N(\widetilde{w}_k^{(i)})^2} \\
    & \\
    & \texttt{IF} \quad \widehat{N_{eff} }\lt N_{thr} \\
    & \qquad \text{(5) 重采样：}\{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1}=\texttt{SystematicResampling}\big[\{ \mathcal{X}_k^{(i)}, \widetilde{w}_k^{(i)} \}_{i=0}^{N-1}, N\big] \\
    & \texttt{END IF}\\
    & \\
    & \text{(6) 期望估计：}
    \begin{cases}
        \{ \mathcal{X}_k^{(i)}, w_k^{(i)} \}_{i=0}^{N-1}=\{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1} \\
        \{ \widetilde{w}_k^{(i)}\}_{i=0}^{N-1}= \{ w_k^{\ast (j)}\}_{j=0}^{N-1} \\
        \mathrm{E}[g(X_k)|Z_{1:k}]\approx \sum\limits_{i=0}^{N-1}g(\mathcal{X}_k^{(i)})\widetilde{w}_k^{(i)}
    \end{cases}
\end{aligned}
}</script><p>其中，$N_{thr}$ 是用于决定是否执行重采样步骤的阈值，通常取 $N_{thr}=\frac{N}{2}$。</p>
<h1 id="4-SIR-滤波器" class="heading-control"><a href="#4-SIR-滤波器" class="headerlink" title="4 SIR 滤波器"></a>4 SIR 滤波器<a class="heading-anchor" href="#4-SIR-滤波器" aria-hidden="true"></a></h1><p>这里我们介绍一种常用的经典粒子滤波算法实现——采样重要性重采样（Sampling Importance Resampling，SIR）滤波。</p>
<p>在 3.2 节的结论中我们已经知道，假设我们取系统的先验状态转移概率分布 $p(x_k|x_{k-1})$ 作为条件建议分布，便可以根据系统的状态转移方程进行粒子的序贯采样；同时，只要完成了粒子的序贯采样，并确定了系统的似然概率分布，便可以根据系统的观测方程以及上一时刻粒子的重要性权重递推地更新当前时刻粒子的重要性权重（非归一化的）。据此，我们对 3.3.3 节中的基本粒子滤波算法框架中的建议分布稍加修改，并在每次计算完归一化的重要性权重后都实施一次重采样，便可得到 SIR 滤波算法框架：</p>
<script type="math/tex; mode=display">
\boxed{
    \begin{aligned}
    & \color{red}{\big[\{ \mathcal{X}_k^{(i)}, w_k^{(i)} \}_{i=0}^{N-1}, \mathrm{E}(·)\big]=\texttt{SIR}\big[\{ \mathcal{X}_{k-1}^{(i)}, w_{k-1}^{(i)} \}_{i=0}^{N-1}, z_k\big]} \\
    & \\
    & \texttt{FOR} \quad i=0:N-1 \\
    & \qquad \text{(1) 0 时刻粒子及其重要性权重初始化：}\mathcal{X}_0^{(i)}\sim q(x_0), \quad w_0^{(i)}=\frac{1}{N}\\
    & \texttt{END FOR} \\
    & \\
    & \texttt{FOR} \quad i=0:N-1 \\
    & \qquad \text{(2) 预测步。粒子序贯采样：}\mathcal{X}_k^{(i)}\sim p(x_k|\mathcal{X}_{k-1}^{(i)}) \\
    & \qquad \text{(3) 更新步。粒子重要性权重序贯更新：}w_k^{(i)}\propto p(z_k|\mathcal{X}_k^{(i)}) w_{k-1}^{(i)} \\
    & \texttt{END FOR} \\
    & \\
    & \text{(4) 粒子重要性权重归一化：}\widetilde{w}_k^{(i)}= \frac{w_k^{(i)}}{\sum\limits_{i=0}^{N-1}w_k^{(i)}} \\
    & \\
    & \text{(5) 重采样：}\{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1}=\texttt{SystematicResampling}\big[\{ \mathcal{X}_k^{(i)}, \widetilde{w}_k^{(i)} \}_{i=0}^{N-1}, N\big] \\
    & \\
    & \text{(6) 期望估计：}
    \begin{cases}
        \{ \mathcal{X}_k^{(i)}, w_k^{(i)} \}_{i=0}^{N-1}=\{ \mathcal{X}_k^{\ast (j)}, w_k^{\ast (j)} \}_{j=0}^{N-1} \\
        \{ \widetilde{w}_k^{(i)}\}_{i=0}^{N-1}= \{ w_k^{\ast (j)}\}_{j=0}^{N-1} \\
        \mathrm{E}[g(X_k)|Z_{1:k}]\approx \sum\limits_{i=0}^{N-1}g(\mathcal{X}_k^{(i)})\widetilde{w}_k^{(i)}
    \end{cases}
\end{aligned}
}</script><p>从框架中我们可以看出，SIR 的粒子序贯采样依赖上一时刻的粒子状态及系统的状态转移方程，我们称之为预测步；SIR 的粒子重要性权重序贯更新依赖上一时刻的粒子重要性权重及预测步粒子对应的似然概率，我们称之为更新步。<strong>预测步只改变粒子的位置，不改变粒子的权重；更新步只改变粒子的权重，不改变粒子的位置。</strong> SIR 算法的流程示意图如下图所示（出自参考 24，P681）。</p>
<p><img data-src="https://image.shipengx.com/SIR%20%E7%AE%97%E6%B3%95%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="SIR 算法流程示意图"></p>
<h1 id="5-应用实例——基于粒子滤波的无人车定位" class="heading-control"><a href="#5-应用实例——基于粒子滤波的无人车定位" class="headerlink" title="5 应用实例——基于粒子滤波的无人车定位"></a>5 应用实例——基于粒子滤波的无人车定位<a class="heading-anchor" href="#5-应用实例——基于粒子滤波的无人车定位" aria-hidden="true"></a></h1><h2 id="5-1-问题描述" class="heading-control"><a href="#5-1-问题描述" class="headerlink" title="5.1 问题描述"></a>5.1 问题描述<a class="heading-anchor" href="#5-1-问题描述" aria-hidden="true"></a></h2><p>粒子滤波常被用于解决无人车的定位问题。假设我们有一辆无人车，且已知下面的输入条件：</p>
<ul>
<li>无人车系统初始化瞬间的 GPS 输出（全局坐标系下的自车位置及航向），GPS 观测的不确定度（即位置与航向的标准差）</li>
<li>每一时刻的外部控制输入（车速及航向角速率）</li>
<li>一系列地图路标在全局坐标系下的位置及 id（假设 id 是从 $1$ 开始顺序排列的正整数）</li>
<li>每一时刻若干个观测到的路标位置（自车坐标系），路标观测的不确定度</li>
<li>用于路标感知的传感器有效测量范围</li>
</ul>
<p>我们如何估计每个时刻无人车的定位信息（位置及航向）？这里我们使用粒子滤波，下图给出了基于粒子滤波的无人车定位流程（图片出自 Udacity）。</p>
<p><img data-src="https://image.shipengx.com/%E5%9F%BA%E4%BA%8E%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2%E7%9A%84%E6%97%A0%E4%BA%BA%E8%BD%A6%E5%AE%9A%E4%BD%8D%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="基于粒子滤波的无人车定位流程示意图"></p>
<p>下面我们结合 SIR 算法框架及具体代码来详细阐述，代码实现基于 Udacity 的工程框架并进行了优化重构，点击<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VkYWNpdHkvQ2FyTkQtS2lkbmFwcGVkLVZlaGljbGUtUHJvamVjdA==" title="https://github.com/udacity/CarND-Kidnapped-Vehicle-Project">这里<i class="fa fa-external-link"></i></span>查看 Udacity 源码。这里我们只关注核心算法本身，因此没有做仿真环节，相比理论分析，经典粒子滤波的代码实现要简单得多，实际效果在工程开发中去调试体会即可。</p>
<h2 id="5-2-代码实现" class="heading-control"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现<a class="heading-anchor" href="#5-2-代码实现" aria-hidden="true"></a></h2><h3 id="5-2-1-初始化" class="heading-control"><a href="#5-2-1-初始化" class="headerlink" title="5.2.1 初始化"></a>5.2.1 初始化<a class="heading-anchor" href="#5-2-1-初始化" aria-hidden="true"></a></h3><p>我们假设 GPS 的位置及航向输出服从正态分布，因此在得到 GPS 的初始输出后，我们可以根据初始值（均值 $\mu$）和 GPS 观测不确定度（标准差 $\sigma$）构造无人车的定位初始分布，并通过对初始分布进行随机采样完成粒子集的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Initialize the particle filter.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param x Initial x position [m] from GPS.</span></span><br><span class="line"><span class="comment"> * @param y Initial y position [m] from GPS.</span></span><br><span class="line"><span class="comment"> * @param theta Initial heading angle [rad] from GPS.</span></span><br><span class="line"><span class="comment"> * @param std_pos Array of dimension 3 [standard deviation of x [m],</span></span><br><span class="line"><span class="comment"> *   standard deviation of y [m], standard deviation of theta [rad]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::Init</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;x, <span class="keyword">const</span> <span class="keyword">double</span> &amp;y, <span class="keyword">const</span> <span class="keyword">double</span> &amp;theta,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="keyword">double</span> std_pos[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsInited())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// create normal distributions around the initial gps measurement values</span></span><br><span class="line">        <span class="built_in">std</span>::default_random_engine gen;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::normal_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">norm_dist_x</span><span class="params">(x, std_pos[<span class="number">0</span>])</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::normal_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">norm_dist_y</span><span class="params">(y, std_pos[<span class="number">1</span>])</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::normal_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">norm_dist_theta</span><span class="params">(theta, std_pos[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize particles one by one</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n_p; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            particles(<span class="number">0</span>, i) = norm_dist_x(gen);</span><br><span class="line">            particles(<span class="number">1</span>, i) = norm_dist_y(gen);</span><br><span class="line">            particles(<span class="number">2</span>, i) = norm_dist_theta(gen);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// initialize weights to 1 / n_p</span></span><br><span class="line">        weights_nonnormalized.fill(<span class="number">1</span> / n_p);</span><br><span class="line">        weights_normalized.fill(<span class="number">1</span> / n_p);</span><br><span class="line"></span><br><span class="line">        is_inited = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有几点说明如下：</p>
<ul>
<li>这里使用了 C++ 的随机数引擎 <code>std::default_random_engine</code> 和正态分布模板类 <code>std::normal_distribution</code> 实现了高斯随机数的生成</li>
<li><code>particles</code> 是 $3\times n_p$ 的粒子 Eigen 矩阵，$n_p$ 表示粒子数目，我们在构造函数的初始值列表中将其初始化为了 $1000$，矩阵的每一列表示一个粒子的状态，矩阵的第 $0$、$1$、$2$ 行分别表示粒子的横向位置 $x$、纵向位置 $y$ 和航向角 $\theta$</li>
<li><code>weights_nonnormalized</code> 和 <code>weights_normalized</code> 分别表示未归一化和归一化的重要性权重，数据类型都是 $n_p\times 1$ 的 Eigen 向量。很多粒子滤波教程中使用同一个变量存放未归一化和归一化的重要性权重，这样也是可以的，这里我们的目的是使代码逻辑更加清晰。</li>
</ul>
<h3 id="5-2-2-预测" class="heading-control"><a href="#5-2-2-预测" class="headerlink" title="5.2.2 预测"></a>5.2.2 预测<a class="heading-anchor" href="#5-2-2-预测" aria-hidden="true"></a></h3><p>在预测步中，我们需要根据无人车的运动模型、车速、航向角速率、相邻两帧的时间间隔等将上一步的粒子集向当前时刻进行预测。这里我们我们假设自车遵从 CRTV 运动模型，关于 CRTV，在此前文章<a href="https://blog.shipengx.com/archives/cfd8b171.html">《从贝叶斯滤波到无迹卡尔曼滤波》</a>中我们已经介绍过，不再赘述，这里我们这里直接给出不计噪声时的 CRTV 状态方程</p>
<script type="math/tex; mode=display">
X_k = X_{k-1} +
\begin{cases}
    \begin{bmatrix}
        \frac{v}{\omega} \bigl(\mathrm{sin}(\psi_{k-1}+\omega\Delta t)-\mathrm{sin}(\psi_{k-1}) \bigr) \\
        \frac{v}{\omega} \bigl(-\mathrm{cos}(\psi_{k-1}+\omega\Delta t)+\mathrm{cos}(\psi_{k-1}) \bigr) \\
        0 \\
        \omega \Delta t \\
        0
    \end{bmatrix} \quad & \omega \neq 0 \\
    \\
    \begin{bmatrix}
        v·\mathrm{cos}(\psi_{k-1})\Delta t \\
        v·\mathrm{sin}(\psi_{k-1})\Delta t \\
        0 \\
        0 \\
        0
    \end{bmatrix} \quad & \omega = 0
\end{cases} \tag{5.1}</script><p>式 (5.1) 中，$\omega$ 即自车的航向角速率。CTRV 是 CV 的一般形式，当 $\omega = 0$ 时，CTRV 退化为 CV。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Predict new state of particle according to the system motion model.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param velocity Velocity of car [m/s]</span></span><br><span class="line"><span class="comment"> * @param yaw_rate Yaw rate of car [rad/s]</span></span><br><span class="line"><span class="comment"> * @param delta_t delta time between last timestamp and current timestamp [s]</span></span><br><span class="line"><span class="comment"> * @param std_pos Array of dimension 3 [standard deviation of x [m],</span></span><br><span class="line"><span class="comment"> *   standard deviation of y [m], standard deviation of yaw [rad]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::Predict</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;velocity, <span class="keyword">const</span> <span class="keyword">double</span> &amp;yaw_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="keyword">double</span> &amp;<span class="keyword">delta_t</span>, <span class="keyword">const</span> <span class="keyword">double</span> std_pos[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!IsInited())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create process noise's normal distributions of which the mean is zero</span></span><br><span class="line">    <span class="built_in">std</span>::default_random_engine gen;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::normal_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">norm_dist_x</span><span class="params">(<span class="number">0</span>, std_pos[<span class="number">0</span>])</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::normal_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">norm_dist_y</span><span class="params">(<span class="number">0</span>, std_pos[<span class="number">1</span>])</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::normal_distribution&lt;<span class="keyword">double</span>&gt; <span class="title">norm_dist_theta</span><span class="params">(<span class="number">0</span>, std_pos[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// predict state of particles one by one</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n_p; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> theta_last = particles(<span class="number">2</span>, i);</span><br><span class="line"></span><br><span class="line">        Eigen::Vector3d state_trans_item_motion;</span><br><span class="line">        Eigen::Vector3d state_trans_item_noise;</span><br><span class="line"></span><br><span class="line">        state_trans_item_noise &lt;&lt; norm_dist_x(gen), norm_dist_y(gen), norm_dist_theta(gen);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">std</span>::<span class="built_in">fabs</span>(yaw_rate) &gt; <span class="number">0.001</span>) <span class="comment">// CTRV model</span></span><br><span class="line">        &#123;</span><br><span class="line">            state_trans_item_motion &lt;&lt; velocity / yaw_rate * (<span class="built_in">sin</span>(theta_last + yaw_rate * <span class="keyword">delta_t</span>) - <span class="built_in">sin</span>(theta_last)),</span><br><span class="line">                velocity / yaw_rate * (-<span class="built_in">cos</span>(theta_last + yaw_rate * <span class="keyword">delta_t</span>) + <span class="built_in">cos</span>(theta_last)),</span><br><span class="line">                yaw_rate * <span class="keyword">delta_t</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">// approximate CV model</span></span><br><span class="line">        &#123;</span><br><span class="line">            state_trans_item_motion &lt;&lt; velocity * <span class="built_in">cos</span>(theta_last) * <span class="keyword">delta_t</span>,</span><br><span class="line">                velocity * <span class="built_in">sin</span>(theta_last) * <span class="keyword">delta_t</span>,</span><br><span class="line">                yaw_rate * <span class="keyword">delta_t</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// predict new state of the ith particle</span></span><br><span class="line">        particles.col(i) = particles.col(i) + state_trans_item_motion + state_trans_item_noise;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// normalize theta</span></span><br><span class="line">        NormalizeAngle(particles(<span class="number">2</span>, i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>状态转移过程中的过程噪声我们假设为零均值的高斯白噪声。很明显预测步只改变了每个粒子的状态，未改变粒子的权重。每个粒子的预测航向角我们都做了 $[-\pi, \pi]$ 的归一化处理，后面在计算系统最终的加权状态估计时不需要重复处理。</p>
<h3 id="5-2-3-更新" class="heading-control"><a href="#5-2-3-更新" class="headerlink" title="5.2.3 更新"></a>5.2.3 更新<a class="heading-anchor" href="#5-2-3-更新" aria-hidden="true"></a></h3><p>更新步的目的是根据最新的路标观测结果（自车局部坐标系下的横纵向相对位置），更新预测步后每个粒子的重要性权重。更新步主要由以下四个子步骤组成，需要对粒子集中的每个粒子依次执行以下步骤，我们结合代码进行阐述。</p>
<p><strong>步骤 (1)： 坐标变换</strong></p>
<p>无人车实时观测到的路标结果基于自车局部坐标系，我们将其转换到地图的全局坐标系，关于坐标系变换推导并不复杂，可见参考 34。假设当前时刻自车观测到某个路标 $lmrk(x_c, y_c)$，下角标 $c$ 表示自车坐标系，该路标对应于地图坐标系中的位置为 $lmrk(x_m, y_m)$，下角标 $m$ 表示地图坐标系。对于粒子 $p(x_p, y_p, \theta_p)$，下角标 $p$ 表示粒子，我们直接给出从 $lmrk(x_c, y_c)$ 到 $lmrk(x_m, y_m)$ 的坐标变换方程。</p>
<script type="math/tex; mode=display">
\begin{cases}
    x_m=x_c*\cos\theta-y_c*\sin\theta+x_p \\
    y_m=x_c*\sin\theta+y_c*\cos\theta+y_p
\end{cases} \tag{5.2}</script><p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Transform observed landmarks from local ego vehicle coordinate to</span></span><br><span class="line"><span class="comment"> *   global map coordinate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param lmrks_obs Observed landmarks in ego vehicle coordinate.</span></span><br><span class="line"><span class="comment"> * @param particle Single particle with state of [x, y, theta]</span></span><br><span class="line"><span class="comment"> * @param lmrks_trans2map Observed landmarks transformed from local ego vehicle</span></span><br><span class="line"><span class="comment"> *   coordinate to global map coordinate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::TransLandmarksFromVehicle2Map</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Obs&gt; &amp;lmrks_obs,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   <span class="keyword">const</span> Eigen::Vector3d &amp;particle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; &amp;lmrks_trans2map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; lmrks_obs.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        lmrks_trans2map[i].x = lmrks_obs[i].x * <span class="built_in">cos</span>(particle(<span class="number">2</span>)) -</span><br><span class="line">                               lmrks_obs[i].y * <span class="built_in">sin</span>(particle(<span class="number">2</span>)) + particle(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        lmrks_trans2map[i].y = lmrks_obs[i].x * <span class="built_in">sin</span>(particle(<span class="number">2</span>)) +</span><br><span class="line">                               lmrks_obs[i].y * <span class="built_in">cos</span>(particle(<span class="number">2</span>)) + particle(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>步骤 (2)： 查找传感器感知范围内的地图路标</strong></p>
<p>传感器的实际感知范围是有限的，我们需要找到每个粒子对应的传感器感知范围内的地图路标。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Find map landmarks within the sensor measuremet range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param lmrks_map All map landmarks.</span></span><br><span class="line"><span class="comment"> * @param particle Single particle with state of [x, y, theta]</span></span><br><span class="line"><span class="comment"> * @param snsr_range Sensor measuremet range.</span></span><br><span class="line"><span class="comment"> * @param lmrks_within_range Map landmarks within the sensor measuremet range.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::FindMapLandmarksWithinSensorRange</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; &amp;lmrks_map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       <span class="keyword">const</span> Eigen::Vector3d &amp;particle,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       <span class="keyword">const</span> <span class="keyword">double</span> &amp;snsr_range,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                       <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; &amp;lmrks_within_range)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">double</span> distance_threshold_square = snsr_range * snsr_range;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> landmark : lmrks_map)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> distance_square = <span class="built_in">std</span>::<span class="built_in">pow</span>(particle(<span class="number">0</span>) - landmark.x, <span class="number">2</span>) +</span><br><span class="line">                                 <span class="built_in">std</span>::<span class="built_in">pow</span>(particle(<span class="number">1</span>) - landmark.y, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (distance_square &lt;= distance_threshold_square)</span><br><span class="line">            lmrks_within_range.push_back(landmark);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>步骤 (1) 和步骤 (2) 作为步骤 (3) 的输入，其顺序无关紧要。</p>
<p><strong>步骤 (3)： 数据关联</strong></p>
<p>数据关联的目的是找到观测路标与实际地图路标的一一对应关系，步骤 (4) 中需要通过这个对应关系更新每个粒子的权重。这里我们使用一种最为简单的数据关联方法——最近邻（Nearest Neighbor，NN）数据关联，其核心思想很直观：对于两个待关联的数据集，数据间的欧氏距离越小，关联的概率越高。NN 数据关联方法的优缺点总结如下（图片出自 Udacity）。</p>
<p><img data-src="https://image.shipengx.com/%E6%9C%80%E8%BF%91%E9%82%BB%E6%95%B0%E6%8D%AE%E5%85%B3%E8%81%94%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.png" alt="最近邻数据关联的优缺点"></p>
<p>下面我们给出基于 NN 的数据关联 C++ 实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Associate observed landmarks which have been transformed to global</span></span><br><span class="line"><span class="comment"> *   map coordinate with map landmarks within the sensor measuremet range.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param lmrks_within_range Map landmarks within the sensor measuremet range.</span></span><br><span class="line"><span class="comment"> * @param lmrks_trans2map Observed landmarks transformed from local ego vehicle</span></span><br><span class="line"><span class="comment"> *   coordinate to global map coordinate.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::DataAssociation</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; &amp;lmrks_within_range,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; &amp;lmrks_trans2map)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;landmark_trans2map : lmrks_trans2map)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> distance_min = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">double</span>&gt;::max();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;landmark_within_range : lmrks_within_range)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> distance_square = <span class="built_in">std</span>::<span class="built_in">pow</span>(landmark_trans2map.x - landmark_within_range.x, <span class="number">2</span>) +</span><br><span class="line">                                     <span class="built_in">std</span>::<span class="built_in">pow</span>(landmark_trans2map.y - landmark_within_range.y, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (distance_square &lt; distance_min)</span><br><span class="line">            &#123;</span><br><span class="line">                distance_min = distance_square;</span><br><span class="line">                landmark_trans2map.id = landmark_within_range.id;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于数据关联匹配，还有很多其它优秀算法，后面会单独开几篇文章进行介绍。</p>
<p><strong>步骤 (4)： 粒子权重更新</strong></p>
<p>执行完关联步后，每个观测路标都对应一个地图路标，我们需要根据每个观测路标与地图路标的关联匹配程度来计算粒子的似然概率。这里我们假设对每个路标的观测都服从二元高斯分布，且相互独立，观测噪声也是高斯的，则每个观测路标的似然概率密度为</p>
<script type="math/tex; mode=display">
P(x, y)=\frac{1}{2\pi\sigma_x\sigma_y}\mathrm{e}^{-\big[\frac{(x-\mu_x)^2}{2\sigma_x^2}+\frac{(y-\mu_y)^2}{2\sigma_y^2}\big]} \tag{5.3}</script><p>其中，$x$ 和 $y$ 分别表示观测路标转换到地图坐标系后的横向位置和纵向位置，$\mu_x$ 和 $\mu_y$ 分别表示观测路标关联上的地图路标的横向位置和纵向位置， $\sigma_x$ 和 $\sigma_y$ 表示路标观测的标准差。由于对每个路标的观测相互独立，粒子的总的似然概率密度为</p>
<script type="math/tex; mode=display">
P=\prod_{i=1}^m\frac{1}{2\pi\sigma_x\sigma_y}\mathrm{e}^{-\big[\frac{(x_i-\mu_{x_i})^2}{2\sigma_x^2}+\frac{(y_i-\mu_{y_i})^2}{2\sigma_y^2}\big]} \tag{5.4}</script><p>其中，$m$ 表示观测路标的数量。将每个观测路标转换到地图坐标系后的测量值代入式 (5.4) 便可得到粒子总的似然概率，结合粒子上一时刻的权重便可近似地序贯更新粒子当前时刻的权重（未归一化的）。下面我们给出权重更新部分的 C++ 实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief For each observed landmark with an associated landmark, calculate</span></span><br><span class="line"><span class="comment"> *   its' weight contribution, and then multiply to particle's final weight.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param lmrks_trans2map Observed landmarks transformed from local ego vehicle</span></span><br><span class="line"><span class="comment"> *   coordinate to global map coordinate.</span></span><br><span class="line"><span class="comment"> * @param lmrks_map All map landmarks.</span></span><br><span class="line"><span class="comment"> * @param std_lmrks Array of dimension 2 [Landmark measurement uncertainty</span></span><br><span class="line"><span class="comment"> *   [x [m], y [m]]]</span></span><br><span class="line"><span class="comment"> * @param weight Non-normalized weight of particle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::UpdateWeight</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; &amp;lmrks_trans2map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; &amp;lmrks_map,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">const</span> <span class="keyword">double</span> std_lmrks[],</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">double</span> &amp;weight)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> likelyhood_probability_particle = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">double</span> sigma_x = std_lmrks[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">double</span> sigma_y = std_lmrks[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;landmark_trans2map : lmrks_trans2map)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> x = landmark_trans2map.x;</span><br><span class="line">        <span class="keyword">double</span> y = landmark_trans2map.y;</span><br><span class="line">        <span class="keyword">double</span> ux = lmrks_map.at(landmark_trans2map.id - <span class="number">1</span>).x;</span><br><span class="line">        <span class="keyword">double</span> uy = lmrks_map.at(landmark_trans2map.id - <span class="number">1</span>).y;</span><br><span class="line">        <span class="keyword">double</span> exponent = -(<span class="built_in">std</span>::<span class="built_in">pow</span>(x - ux, <span class="number">2</span>) / (<span class="number">2</span> * <span class="built_in">std</span>::<span class="built_in">pow</span>(sigma_x, <span class="number">2</span>)) +</span><br><span class="line">                            <span class="built_in">std</span>::<span class="built_in">pow</span>(y - uy, <span class="number">2</span>) / (<span class="number">2</span> * <span class="built_in">std</span>::<span class="built_in">pow</span>(sigma_y, <span class="number">2</span>)));</span><br><span class="line">        <span class="keyword">double</span> likelyhood_probability_landmark = <span class="number">1.0</span> / (<span class="number">2</span> * M_PI * sigma_x * sigma_y) *</span><br><span class="line">                                                 <span class="built_in">std</span>::<span class="built_in">exp</span>(exponent);</span><br><span class="line">        likelyhood_probability_particle *= likelyhood_probability_landmark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    weight *= likelyhood_probability_particle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是整个更新步的代码实现。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param lmrks_obs Observed landmarks in local ego vehicle coordinate.</span></span><br><span class="line"><span class="comment"> * @param snsr_range Sensor measuremet range.</span></span><br><span class="line"><span class="comment"> * @param lmrks_map All map landmarks.</span></span><br><span class="line"><span class="comment"> * @param std_lmrks Array of dimension 2 [Landmark measurement uncertainty</span></span><br><span class="line"><span class="comment"> *   [x [m], y [m]]]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::Update</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Ego&gt; &amp;lmrks_obs,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">double</span> &amp;snsr_range,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; &amp;lmrks_map,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="keyword">double</span> std_lmrks[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// process particles one by one</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; n_p; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// step1: transform observed landmarks from local ego vehicle coordinate</span></span><br><span class="line">        <span class="comment">// to global map coordinate</span></span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; <span class="title">landmarks_trans2map</span><span class="params">(lmrks_obs.size())</span></span>;</span><br><span class="line">        TransLandmarksFromVehicle2Map(lmrks_obs, particles.col(i), landmarks_trans2map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step2: find map landmarks within the sensor measuremet range</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; landmarks_within_sensor_range;</span><br><span class="line">        FindMapLandmarksWithinSensorRange(lmrks_map, particles.col(i), snsr_range,</span><br><span class="line">                                          landmarks_within_sensor_range);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step3: associate observed landmarks which have been transformed to</span></span><br><span class="line">        <span class="comment">// global map coordinate with map landmarks within the sensor measuremet</span></span><br><span class="line">        <span class="comment">// range</span></span><br><span class="line">        DataAssociation(landmarks_within_sensor_range, landmarks_trans2map);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// step4: for each observed landmark with an associated landmark, calculate</span></span><br><span class="line">        <span class="comment">// its' weight contribution, and then multiply to particle's final weight</span></span><br><span class="line">        UpdateWeight(landmarks_trans2map, lmrks_map, std_lmrks, weights_nonnormalized(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显更新步只改变了每个粒子的权重，未改变粒子的状态。</p>
<h3 id="5-2-4-粒子权重归一化" class="heading-control"><a href="#5-2-4-粒子权重归一化" class="headerlink" title="5.2.4 粒子权重归一化"></a>5.2.4 粒子权重归一化<a class="heading-anchor" href="#5-2-4-粒子权重归一化" aria-hidden="true"></a></h3><p>完成粒子非归一化权重的更新后，我们需要计算粒子新的归一化的权重，作为后面重采样步骤的输入。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Normalize the weights of particles.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param w_nonnormalized Weights to be normalized.</span></span><br><span class="line"><span class="comment"> * @param w_normalized Weights which have been normalized.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NormalizeWeights</span><span class="params">(<span class="keyword">const</span> Eigen::VectorXd &amp;w_nonnormalized,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Eigen::VectorXd &amp;w_normalized)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    w_normalized = w_nonnormalized / w_nonnormalized.sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-5-重采样" class="heading-control"><a href="#5-2-5-重采样" class="headerlink" title="5.2.5 重采样"></a>5.2.5 重采样<a class="heading-anchor" href="#5-2-5-重采样" aria-hidden="true"></a></h3><p>完成粒子权重归一化后，我们需要对粒子集进行重采样。对于重采样步骤，大多数基于 Udacity 工程框架的开源项目使用了 C++ 标准库中的离散分布模板类 <code>std::discrete_distribution</code> ，这里我们“舍近求远”，手工实现 3.3.1 节中介绍的四种重采样算法，以加深对重采样的理解，随机数的生成我们通过模板类 <code>std::uniform_real_distribution</code> 实现。</p>
<p><strong>多项式重采样</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Multinomial resampling method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param particles_ori Particles before resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_ori_norm Normalized weights before resampling.</span></span><br><span class="line"><span class="comment"> * @param particles_resampled Particles after resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_resampled Weights after resampling.</span></span><br><span class="line"><span class="comment"> * @param N_r Number of particles to resample.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::MultinomialResampling</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;particles_ori,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">const</span> Eigen::VectorXd &amp;weights_ori_norm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Eigen::MatrixXd &amp;particles_resampled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           Eigen::VectorXd &amp;weights_resampled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">uint32_t</span> N_r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> N = weights_ori_norm.size();</span><br><span class="line">    <span class="keyword">uint32_t</span> left, right, middle;</span><br><span class="line"></span><br><span class="line">    Eigen::VectorXd weights_cum_sum = CalcWeightsCumSum(weights_ori_norm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = N - N_r; j &lt; N; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// produces random values u, uniformly distributed on the interval [0.0, 1.0)</span></span><br><span class="line">        <span class="built_in">std</span>::random_device rd;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::uniform_real_distribution&lt;&gt; <span class="title">uniform_dist</span><span class="params">(<span class="number">0.0</span>, <span class="number">1.0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">double</span> u = uniform_dist(gen);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select the resampled particle using binary search</span></span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = N - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            middle = <span class="built_in">std</span>::<span class="built_in">floor</span>((left + right) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (u &gt; weights_cum_sum(middle))</span><br><span class="line">                left = middle + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = middle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        particles_resampled(j) = particles_ori(right);</span><br><span class="line">        weights_resampled(j) = <span class="number">1</span> / N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>分层重采样</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Stratified resampling method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param particles_ori Particles before resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_ori_norm Normalized weights before resampling.</span></span><br><span class="line"><span class="comment"> * @param particles_resampled Particles after resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_resampled Weights after resampling.</span></span><br><span class="line"><span class="comment"> * @param N_r Number of particles to resample.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::StratifiedResampling</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;particles_ori,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> Eigen::VectorXd &amp;weights_ori_norm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Eigen::MatrixXd &amp;particles_resampled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Eigen::VectorXd &amp;weights_resampled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">uint32_t</span> N_r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> N = weights_ori_norm.size();</span><br><span class="line"></span><br><span class="line">    Eigen::VectorXd weights_cum_sum = CalcWeightsCumSum(weights_ori_norm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = N - N_r; j &lt; N; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// produces random values u0, uniformly distributed on the interval [0.0, 1.0 / N_r)</span></span><br><span class="line">        <span class="comment">// then calculate u = u0 + (j - (N - N_r)) / N_r</span></span><br><span class="line">        <span class="built_in">std</span>::random_device rd;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::uniform_real_distribution&lt;&gt; <span class="title">uniform_dist</span><span class="params">(<span class="number">0.0</span>, <span class="number">1</span> / N_r)</span></span>;</span><br><span class="line">        <span class="keyword">double</span> u0 = uniform_dist(gen);</span><br><span class="line">        <span class="keyword">double</span> u = u0 + (j - (N - N_r)) / N_r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select the resampled particle</span></span><br><span class="line">        <span class="keyword">while</span> (weights_cum_sum(i) &lt; u)</span><br><span class="line">            ++i;</span><br><span class="line"></span><br><span class="line">        particles_resampled(j) = particles_ori(i);</span><br><span class="line">        weights_resampled(j) = <span class="number">1</span> / N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>系统重采样</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Systematic resampling method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param particles_ori Particles before resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_ori_norm Normalized weights before resampling.</span></span><br><span class="line"><span class="comment"> * @param particles_resampled Particles after resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_resampled Weights after resampling.</span></span><br><span class="line"><span class="comment"> * @param N_r Number of particles to resample.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::SystematicResampling</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;particles_ori,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> Eigen::VectorXd &amp;weights_ori_norm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Eigen::MatrixXd &amp;particles_resampled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Eigen::VectorXd &amp;weights_resampled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">uint32_t</span> N_r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> N = weights_ori_norm.size();</span><br><span class="line"></span><br><span class="line">    Eigen::VectorXd weights_cum_sum = CalcWeightsCumSum(weights_ori_norm);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint32_t</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// produces random values u0, uniformly distributed on the interval [0.0, 1.0 / N_r)</span></span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::uniform_real_distribution&lt;&gt; <span class="title">uniform_dist</span><span class="params">(<span class="number">0.0</span>, <span class="number">1</span> / N_r)</span></span>;</span><br><span class="line">    <span class="keyword">double</span> u0 = uniform_dist(gen);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> j = N - N_r; j &lt; N; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// calculate u = u0 + (j - (N - N_r)) / N_r</span></span><br><span class="line">        <span class="keyword">double</span> u = u0 + (j - (N - N_r)) / N_r;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// select the resampled particle</span></span><br><span class="line">        <span class="keyword">while</span> (weights_cum_sum(i) &lt; u)</span><br><span class="line">            ++i;</span><br><span class="line"></span><br><span class="line">        particles_resampled(j) = particles_ori(i);</span><br><span class="line">        weights_resampled(j) = <span class="number">1</span> / N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>残差重采样</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Residual resampling method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param particles_ori Particles before resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_ori_norm Normalized weights before resampling.</span></span><br><span class="line"><span class="comment"> * @param particles_resampled Particles after resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_resampled Weights after resampling.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ParticleFilter::ResidualResampling</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;particles_ori,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        <span class="keyword">const</span> Eigen::VectorXd &amp;weights_ori_norm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Eigen::MatrixXd &amp;particles_resampled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        Eigen::VectorXd &amp;weights_resampled)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> N = weights_ori_norm.size();</span><br><span class="line">    <span class="keyword">uint32_t</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="function">Eigen::VectorXi <span class="title">N_k1</span><span class="params">(N)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1: deterministic copy sampling</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; N; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        N_k1(i) = <span class="built_in">std</span>::<span class="built_in">floor</span>(N * weights_ori_norm(i));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> m = <span class="number">0</span>; m &lt; N_k1(i); ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            particles_resampled(j) = particles_ori(i);</span><br><span class="line">            weights_resampled(j) = <span class="number">1</span> / N;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step2: residual random sampling</span></span><br><span class="line">    <span class="keyword">uint32_t</span> N_k2 = N - j;</span><br><span class="line">    Eigen::VectorXd weights_residual_norm = (N * weights_ori_norm - N_k1) / N_k2;</span><br><span class="line">    MultinomialResampling(particles_ori, weights_residual_norm, particles_resampled,</span><br><span class="line">                          weights_resampled, N_k2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-6-状态估计" class="heading-control"><a href="#5-2-6-状态估计" class="headerlink" title="5.2.6 状态估计"></a>5.2.6 状态估计<a class="heading-anchor" href="#5-2-6-状态估计" aria-hidden="true"></a></h3><p>完成重采样后，我们将所有的重采样粒子及其对应的重采样权重（$\frac{1}{N}$）进行加权求和，便可得到系统最终的状态估计结果，即每个时刻无人车的位置、航向估计。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief Estimate the final state of system by combing all particles.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param particles_resampled Particles after resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_resampled Weights after resampling.</span></span><br><span class="line"><span class="comment"> * @param particles_ori Particles before resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_ori_norm Normalized weights before resampling.</span></span><br><span class="line"><span class="comment"> * @param weights_ori Non-normalized weights before resampling.</span></span><br><span class="line"><span class="comment"> * @return Eigen::Vector3d The final estimated state of system.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Eigen::Vector3d <span class="title">EstimateState</span><span class="params">(<span class="keyword">const</span> Eigen::MatrixXd &amp;particles_resampled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">const</span> Eigen::VectorXd &amp;weights_resampled,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Eigen::MatrixXd &amp;particles_ori,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Eigen::VectorXd &amp;weights_ori_norm,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Eigen::VectorXd &amp;weights_ori)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    particles_ori = particles_resampled;</span><br><span class="line">    weights_ori = weights_resampled;</span><br><span class="line">    weights_ori_norm = weights_resampled;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> particles_ori * weights_ori_norm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是我们的 <code>main.cpp</code> 中的内容。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ParticleFilter.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ParticleFilter pf;                   <span class="comment">// particle filter instance</span></span><br><span class="line">    <span class="keyword">double</span> x, y, theta;                  <span class="comment">// gps measurement data</span></span><br><span class="line">    <span class="keyword">double</span> v, yaw_rate;                  <span class="comment">// input control data</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Ego&gt; lmrks_obs; <span class="comment">// observed landmarks in local ego vehicle coordinate</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;LandMark_Map&gt; lmrks_map; <span class="comment">// map landmarks</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pf.RecvRawData(x, y, theta, v, yaw_rate, lmrks_obs, lmrks_map);</span><br><span class="line"></span><br><span class="line">        pf.Init(x, y, theta, pf.sigma_gps);</span><br><span class="line">        pf.Predict(v, yaw_rate, pf.dt, pf.sigma_gps);</span><br><span class="line">        pf.Update(lmrks_obs, pf.sensor_range, lmrks_map, pf.sigma_landmark);</span><br><span class="line">        pf.NormalizeWeights(pf.weights_nonnormalized, pf.weights_normalized);</span><br><span class="line">        pf.SystematicResampling(pf.particles, pf.weights_normalized,</span><br><span class="line">                                pf.particles_re, pf.weights_re, pf.n_p);</span><br><span class="line">        pf.estimated_state = pf.EstimateState(pf.particles_re, pf.weights_re,</span><br><span class="line">                                              pf.particles, pf.weights_normalized,</span><br><span class="line">                                              pf.weights_nonnormalized);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点击<a href="/download/ParticleFilter.zip">这里</a>下载完整代码工程。</p>
<h1 id="6-总结" class="heading-control"><a href="#6-总结" class="headerlink" title="6 总结"></a>6 总结<a class="heading-anchor" href="#6-总结" aria-hidden="true"></a></h1><p>首先，我们回顾了用于解决线性高斯问题的卡尔曼滤波，用于解决非线性高斯问题的扩展卡尔曼滤波与无迹卡尔曼滤波，为解决强非线性非高斯问题我们引入了粒子滤波的概念。</p>
<p>粒子滤波基于随机采样实现。我们从蒙特卡罗方法讲起，为解决原分布难以采样甚至无法采样的问题引入了重要性采样。为序贯地进行粒子采样，并递推地更新粒子的重要性权重，又引入了序贯重要性采样。序贯重要性采样存在粒子退化问题，为应对该问题，可以选择恰当的建议分布并实施重采样步骤，文中介绍了四种重采样方法。通过将系统的状态转移概率分布选择为建议分布，并辅以重采样方法，我们由序贯重要性采样得到了采样重要性重采样滤波器。</p>
<p>最后，我们优化重构了 Udacity 工程框架，完整展示了如何通过粒子滤波实现无人车的匹配定位。</p>
<h1 id="参考" class="heading-control"><a href="#参考" class="headerlink" title="参考"></a>参考<a class="heading-anchor" href="#参考" aria-hidden="true"></a></h1><ol>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3JsYWJiZS9LYWxtYW4tYW5kLUJheWVzaWFuLUZpbHRlcnMtaW4tUHl0aG9u" title="https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python">Kalman-and-Bayesian-Filters-in-Python<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXhXNDExTjdmMT9wPTg=" title="https://www.bilibili.com/video/BV1xW411N7f1?p=8">b 站徐亦达机器学习：Particle Filter 粒子滤波<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODQ0MTE3NA==" title="https://zhuanlan.zhihu.com/p/38441174">概率机器人——粒子滤波<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvUGFydGljbGVfZmlsdGVy" title="https://en.wikipedia.org/wiki/Particle_filter">维基百科：Particle filter<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JUE3JUU2JTk1JUIwJUU1JUFFJTlBJUU1JUJFJThC" title="https://zh.wikipedia.org/wiki/%E5%A4%A7%E6%95%B0%E5%AE%9A%E5%BE%8B">维基百科：大数定律<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5hYXMubmV0LmNuL2ZpbGVaREhYQi9qb3VybmFsL2FydGljbGUvemRoeGIvMjAxNS8xMi9QREYvMjAxNS0xMi0xOTgxLnBkZg==" title="http://www.aas.net.cn/fileZDHXB/journal/article/zdhxb/2015/12/PDF/2015-12-1981.pdf">粒子滤波理论、方法及其在多目标跟踪中的应用<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93dzIubWF0aHdvcmtzLmNuL2hlbHAvcm9ib3RpY3MvdWcvcGFydGljbGUtZmlsdGVyLXBhcmFtZXRlcnMuaHRtbCNidTU3b2Y4" title="https://ww2.mathworks.cn/help/robotics/ug/particle-filter-parameters.html#bu57of8">MathWorks：Particle Filter Parameters<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cueHVlYnV5dWFuLmNvbS8zMjMyNjYzLmh0bWw=" title="https://www.xuebuyuan.com/3232663.html">粒子滤波（PF：Particle Filter）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVJLNDExTDdNdA==" title="https://www.bilibili.com/video/BV1RK411L7Mt">b 站贝叶斯滤波与卡尔曼滤波第九讲：粒子滤波原理详述<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVJLNDExTDdNdA==" title="https://www.bilibili.com/video/BV1RK411L7Mt">b 站贝叶斯滤波与卡尔曼滤波第十讲：重采样<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVJLNDExTDdNdA==" title="https://www.bilibili.com/video/BV1RK411L7Mt">b 站贝叶斯滤波与卡尔曼滤波第十二讲：粒子滤波拾遗——采样方法、预测方程<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9nYW95aWNoYW8uY29tL1hpYW90dS8/Ym9vaz10dXJ0bGVib3QmYW1wO3RpdGxlPSVFNyVCMiU5MiVFNSVBRCU5MCVFNiVCQiVBNCVFNiVCMyVBMiVFNSU5OSVBOA==" title="https://gaoyichao.com/Xiaotu/?book=turtlebot&amp;title=%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2%E5%99%A8">粒子滤波器<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMjYxOTg0MTY=" title="https://zhuanlan.zhihu.com/p/126198416">粒子滤波<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXJpc2EuZnIvYXNwaS9sZWdsYW5kL2Vuc3RhL3JlZi9hcnVsYW1wYWxhbTAyYS5wZGY=" title="https://www.irisa.fr/aspi/legland/ensta/ref/arulampalam02a.pdf">A Tutorial on Particle Filters for Online Nonlinear/Non-Gaussian Bayesian Tracking<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXlpamlhLmJsb2cuY3Nkbi5uZXQvYXJ0aWNsZS9kZXRhaWxzLzQwODk5ODE5" title="https://heyijia.blog.csdn.net/article/details/40899819">Particle Filter Tutorial 粒子滤波：从推导到应用（一）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXlpamlhLmJsb2cuY3Nkbi5uZXQvYXJ0aWNsZS9kZXRhaWxzLzQwOTI5MDk3" title="https://heyijia.blog.csdn.net/article/details/40929097">Particle Filter Tutorial 粒子滤波：从推导到应用（二）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXlpamlhLmJsb2cuY3Nkbi5uZXQvYXJ0aWNsZS9kZXRhaWxzLzQxMTIyMTI1" title="https://heyijia.blog.csdn.net/article/details/41122125">Particle Filter Tutorial 粒子滤波：从推导到应用（三）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9oZXlpamlhLmJsb2cuY3Nkbi5uZXQvYXJ0aWNsZS9kZXRhaWxzLzQxMTQyNjc5" title="https://heyijia.blog.csdn.net/article/details/41142679">Particle Filter Tutorial 粒子滤波：从推导到应用（四）<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93ZW5rdS5iYWlkdS5jb20vdmlldy84ODg5NmQyYjQ1MzYxMDY2MWVkOWY0YjQuaHRtbA==" title="https://wenku.baidu.com/view/88896d2b453610661ed9f4b4.html">百度文库：粒子滤波理论<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9qb2V5b3MuZ2l0aHViLmlvLzIwMTcvMDcvMjAvJUU3JUIyJTkyJUU1JUFEJTkwJUU2JUJCJUE0JUU2JUIzJUEyJUU1JThFJTlGJUU3JTkwJTg2Lw==" title="https://joeyos.github.io/2017/07/20/%E7%B2%92%E5%AD%90%E6%BB%A4%E6%B3%A2%E5%8E%9F%E7%90%86/">粒子滤波原理<i class="fa fa-external-link"></i></span></li>
<li>《卡尔曼滤波与组合导航原理》（第 3 版）</li>
<li>《概率机器人》</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZG9jODguY29tL3AtMjkwMTM4Nzg5NDQxMS5odG1s" title="https://www.doc88.com/p-2901387894411.html">Bayesian Signal Processing : Classical, Modern, and Particle Filtering Methods<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9ib29rcy5nb29nbGUuY29tL2Jvb2tzP2lkPW1FdVpEZ0FBUUJBSiZhbXA7cGc9UFIzJmFtcDtscGc9UFIzJmFtcDtkcT1Db21wdXRlcitWaXNpb25fUHJpbmNpcGxlc19BbGdvcml0aG1zX0FwcGxpY2F0aW9uc19MZWFybmluZ19GaWZ0aCtFZGl0aW9uJmFtcDtzb3VyY2U9YmwmYW1wO290cz1Gd0szc2pRbl9XJmFtcDtzaWc9QUNmVTNVM3E2SFRJNXI3OENybTZacnNHc2FJNGx5ZGxZQSZhbXA7aGw9ZW4mYW1wO3NhPVgmYW1wO3ZlZD0yYWhVS0V3aWh5cEhUNU5YdUFoWFNsNTRLSGJFQ0N5UVE2QUV3QlhvRUNBZ1FBZyN2PW9uZXBhZ2UmYW1wO3EmYW1wO2Y9ZmFsc2U=" title="https://books.google.com/books?id=mEuZDgAAQBAJ&amp;pg=PR3&amp;lpg=PR3&amp;dq=Computer+Vision_Principles_Algorithms_Applications_Learning_Fifth+Edition&amp;source=bl&amp;ots=FwK3sjQn_W&amp;sig=ACfU3U3q6HTI5r78Crm6ZrsGsaI4lydlYA&amp;hl=en&amp;sa=X&amp;ved=2ahUKEwihypHT5NXuAhXSl54KHbECCyQQ6AEwBXoECAgQAg#v=onepage&amp;q&amp;f=false">Computer Vision - Principles, Algorithms, Applications, Learning (5th)<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3d3dy5pcmlzYS5mci9hc3BpL2xlZ2xhbmQvcmVmL2dvcmRvbjkzYS5wZGY=" title="http://www.irisa.fr/aspi/legland/ref/gordon93a.pdf">Novel approach to nonlinear/non-Gaussian Bayesian state estimation<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9tc2Vhcy5taXQuZWR1L2dyb3VwL1JlZmVyZW5jZXMvQU1JU1NJT04vU21vb3RoaW5nL2tpdGFnYXdhX21jX2ZpbHRlcl9zbW9vdGhlcl9ub25nYXVzc2lhbl85Ni5wZGY=" title="https://mseas.mit.edu/group/References/AMISSION/Smoothing/kitagawa_mc_filter_smoother_nongaussian_96.pdf">Monte Carlo Filter and Smoother for Non-Gaussian Nonlinear State Space Models<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL3Blb3BsZS5pc3kubGl1LnNlL3J0L3NjaG9uL1B1YmxpY2F0aW9ucy9Ib2xTRzIwMDYucGRm" title="http://people.isy.liu.se/rt/schon/Publications/HolSG2006.pdf">On Resampling Algorithms For Particle Filters<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cucmVzZWFyY2hnYXRlLm5ldC9wcm9maWxlL1RpYW5jaGVuZ19MaTMvcHVibGljYXRpb24vMjc0NDA0MTI3X1Jlc2FtcGxpbmdfTWV0aG9kc19mb3JfUGFydGljbGVfRmlsdGVyaW5nX0NsYXNzaWZpY2F0aW9uX2ltcGxlbWVudGF0aW9uX2FuZF9zdHJhdGVnaWVzL2xpbmtzLzU1OThkYjU2MDhhZTc5M2QxMzdlMjFmZi9SZXNhbXBsaW5nLU1ldGhvZHMtZm9yLVBhcnRpY2xlLUZpbHRlcmluZy1DbGFzc2lmaWNhdGlvbi1pbXBsZW1lbnRhdGlvbi1hbmQtc3RyYXRlZ2llcy5wZGY=" title="https://www.researchgate.net/profile/Tiancheng_Li3/publication/274404127_Resampling_Methods_for_Particle_Filtering_Classification_implementation_and_strategies/links/5598db5608ae793d137e21ff/Resampling-Methods-for-Particle-Filtering-Classification-implementation-and-strategies.pdf">Resampling Methods for Particle Filtering-Classification, implementation, and strategies<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly93dzIubWF0aHdvcmtzLmNuL21hdGxhYmNlbnRyYWwvZmlsZWV4Y2hhbmdlLzM1NDY4LXBhcnRpY2xlLWZpbHRlci10dXRvcmlhbD9zX3RpZD1td2Ffb3NhX2E=" title="https://ww2.mathworks.cn/matlabcentral/fileexchange/35468-particle-filter-tutorial?s_tid=mwa_osa_a">MathWorks: Particle filter tutorial<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VkYWNpdHkvQ2FyTkQtS2lkbmFwcGVkLVZlaGljbGUtUHJvamVjdA==" title="https://github.com/udacity/CarND-Kidnapped-Vehicle-Project">udacity/CarND-Kidnapped-Vehicle-Project<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xMDE0MTc0" title="https://cloud.tencent.com/developer/article/1014174">粒子滤波简介<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDcyMjMwMTI=" title="https://zhuanlan.zhihu.com/p/107223012">无人驾驶技术入门（二十）| 手把手教你用粒子滤波实现无人车定位<i class="fa fa-external-link"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9lbi5jcHByZWZlcmVuY2UuY29tL3cvY3BwL251bWVyaWMvcmFuZG9tL3VuaWZvcm1fcmVhbF9kaXN0cmlidXRpb24=" title="https://en.cppreference.com/w/cpp/numeric/random/uniform_real_distribution">std::uniform_real_distribution<i class="fa fa-external-link"></i></span></li>
<li><a href="https://blog.shipengx.com/archives/b10733db.html">（十二）无人驾驶中的坐标转换</a></li>
</ol>
<hr>
]]></content>
      <categories>
        <category>自动驾驶</category>
        <category>多传感器信息融合</category>
      </categories>
      <tags>
        <tag>自动驾驶</tag>
        <tag>数学</tag>
        <tag>滤波</tag>
        <tag>粒子滤波</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ Primer - 第 9 章 顺序容器</title>
    <url>/archives/4c58da67.html</url>
    <content><![CDATA[<h1 id="9-1-顺序容器概述" class="heading-control"><a href="#9-1-顺序容器概述" class="headerlink" title="9.1 顺序容器概述"></a>9.1 顺序容器概述<a class="heading-anchor" href="#9-1-顺序容器概述" aria-hidden="true"></a></h1><ol>
<li><p>所有顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：</p>
<ul>
<li>向容器添加或从容器中删除元素的代价</li>
<li>非顺序访问容器中元素的代价<br><br></li>
</ul>
<table>
 <thead>
 <tr>
     <th colspan="2"><center>顺序容器类型</center></th>
 </tr>
 </thead>
 <tbody>
 <tr>
     <td>vector</td>
     <td>可变大小数组。支持快速随机访问。在尾部之外的位置插入或删除元素可能很慢</td>
 </tr>
 <tr>
     <td>deque</td>
     <td>双端队列。支持快速随机访问。在头尾位置插入/删除速度很快</td>
 </tr>
 <tr>
     <td>list</td>
     <td>双向链表。只支持双向顺序访问。在list中任何位置进行插入/删除操作速度都很快</td>
 </tr>
 <tr>
     <td>forward_list</td>
     <td>单向链表。只支持单向顺序访问。在链表任何位置进行插入/删除操作速度都很快</td>
 </tr>
 <tr>
     <td>array</td>
     <td>固定大小数组。支持快速随机访问。不能添加或删除元素</td>
 </tr>
 <tr>
     <td>string</td>
     <td>与 vector 相似的容器，但专门用于保存字符。随机访问快。在尾部插入/删除速度快</td>
 </tr>
 </tbody>
 </table>

<p><strong><code>string</code> 和 <code>vector</code> 将元素保存在连续的内存空间中。</strong> 由于元素是连续存储的，由元素的下标来计算其地址是非常快速的。但是，在这两种容器的中间位置添加或删除元素就会非常耗时：在一次插入或删除操作后，需要移动插入/删除位置之后的所有元素，来保持连续存储。而且，添加一个元素有时可能还需要分配额外的存储空间。在这种情况下，每个元素都必须移动到新的存储空间中。</p>
<p><code>list</code> 和 <code>forward_list</code> 两个容器的设计目的是令容器任何位置的添加和删除操作都很快速。作为代价，这两个容器不支持元素的随机访问：为了访问一个元素，我们只能遍历整个容器。而且，与<code>vector</code>、<code>deque</code> 和 <code>array</code> 相比，这两个容器的额外内存开销也很大。</p>
<p><code>deque</code>是一个更为复杂的数据结构。与 <code>string</code> 和 <code>vector</code> 类似，<code>deque</code> 支持快速的随机访问。与 <code>string</code> 和 <code>vector</code> 一样，在 <code>deque</code> 的中间位置添加或删除元素的代价（可能）很高。但是，在 <code>deque</code> 的两端添加或删除元素都是很快的，与 <code>list</code> 或 <code>forward_list</code> 添加删除元素的速度相当。<code>forward_list</code> 和 <code>array</code> 是新 C++ 标准增加的类型。与内置数组相比，<code>array</code> 是一种更安全、更容易使用的数组类型。与内置数组类似，<code>array</code> 对象的大小是固定的。因此，<code>array</code> 不支持添加和删除元素以及改变容器大小的操作。</p>
<p><code>forward_list</code> 的设计目标是达到与最好的手写的单向链表数据结构相当的性能。因此，<code>forward_list</code> 没有 <code>size</code> 操作，因为保存或计算其大小就会比手写链表多出额外的开销。对其他容器而言，<code>size</code> 保证是一个快速的常量时间的操作。</p>
<blockquote>
<p>最佳实践：如果你不确定应该使用哪种容器，那么可以在程序中只使用 vector 和 list 公共的操作：使用迭代器，不使用下标操作，避免随机访问。这样，在必要时选择使用 vector 或 list 都很方便。</p>
</blockquote>
</li>
<li><blockquote>
<p>Tip：通常，使用 <code>vector</code> 是最好的选择。</p>
</blockquote>
</li>
<li><p>如果程序只有在读取输入时才需要在容器中间位置插入元素，随后需要随机访问元素，则</p>
<ul>
<li>首先，确定是否真的需要在容器中间位置添加元素。当处理输入数据时，通常可以很容易地向 <code>vector</code> 追加数据，然后再调用标准库的 <code>sort</code> 函数来重排容器中的元素，从而避免在中间位置添加元素。</li>
<li>如果必须在中间位置插入元素，考虑在输入阶段使用 <code>1ist</code>，一旦输入完成，将 <code>list</code> 中的内容拷贝到一个 <code>vector</code> 中。</li>
</ul>
</li>
</ol>
<h1 id="9-2-容器库概览" class="heading-control"><a href="#9-2-容器库概览" class="headerlink" title="9.2 容器库概览"></a>9.2 容器库概览<a class="heading-anchor" href="#9-2-容器库概览" aria-hidden="true"></a></h1><ol>
<li><p>容器均定义为模板类，必须提供额外信息来生成特定的容器类型。</p>
</li>
<li><blockquote>
<p>Note：较旧的编译器可能需要在两个尖括号之间键入空格，例如，<code>vector&lt;vector&lt;string&gt; &gt;</code>。</p>
</blockquote>
</li>
<li><p>顺序容器构造函数的一个版本接受容器大小参数，它使用了元素类型的默认构造函数。但某些类没有默认构造函数。我们可以定义一个保存这种类型对象的容器，但我们在构造这种容器时不能只传递给它一个元素数目参数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假定 noDefault 是一个没有默认构造函数的类型</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;noDefault&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>, init)</span></span>; <span class="comment">// 正确：提供了元素初始化器</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;noDefault&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>)</span></span>;       <span class="comment">// 错误：必须提供一个元素初始化器</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>常用容器操作：<br><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>容器操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <th class="tg-fymr" colspan="2">类型别名</th>
  </tr>
  <tr>
    <td class="tg-0pky">iterator</td>
    <td class="tg-0pky">此容器类型的迭代器类型</td>
  </tr>
  <tr>
    <td class="tg-0pky">const_iterator</td>
    <td class="tg-0pky">可以读取元素，但不能修改元素的迭代器类型</td>
  </tr>
  <tr>
    <td class="tg-0pky">size_type</td>
    <td class="tg-0pky">无符号整数类型，足够保存此种容器类型最大可能容器的大小</td>
  </tr>
  <tr>
    <td class="tg-0pky">difference_type</td>
    <td class="tg-0pky">带符号整数类型，足够保存两个迭代器之间的距离</td>
  </tr>
  <tr>
    <td class="tg-0pky">value_type</td>
    <td class="tg-0pky">元素类型</td>
  </tr>
  <tr>
    <td class="tg-0pky">reference</td>
    <td class="tg-0pky">元素的左值类型；与 value_type&amp; 含义相同</td>
  </tr>
  <tr>
    <td class="tg-0pky">const_reference</td>
    <td class="tg-0pky">元素的 const 左值类型（即，const value_type&amp;）</td>
  </tr>
  <tr>
    <th class="tg-fymr" colspan="2">构造函数</th>
  </tr>
  <tr>
    <td class="tg-0pky">C c;</td>
    <td class="tg-0pky">默认构造函数，构造空容器</td>
  </tr>
  <tr>
    <td class="tg-0pky">C c1(c2);</td>
    <td class="tg-0pky">构造 c2 的拷贝 c1</td>
  </tr>
  <tr>
    <td class="tg-0pky">C c(b, e);</td>
    <td class="tg-0pky">构造 c，将迭代器 b 和 e 指定的范围内的元素拷贝到 c（array 不支持）</td>
  </tr>
  <tr>
    <td class="tg-0pky">C c{a, b, c...};</td>
    <td class="tg-0pky">列表初始化 c</td>
  </tr>
  <tr>
    <th class="tg-fymr" colspan="2">赋值与 swap</th>
  </tr>
  <tr>
    <td class="tg-0pky">c1 = c2</td>
    <td class="tg-0pky">将 c1 中的元素替换为 c2 中元素</td>
  </tr>
  <tr>
    <td class="tg-0pky">c1 = {a, b, c...}</td>
    <td class="tg-0pky">将 c1 中的元素替换为列表中元素（不适用于 array）</td>
  </tr>
  <tr>
    <td class="tg-0pky">a.swap(b)</td>
    <td class="tg-0pky">交换 a 和 b 的元素</td>
  </tr>
  <tr>
    <td class="tg-0pky">swap(a,b)</td>
    <td class="tg-0pky">与 a.swap(b) 等价</td>
  </tr>
  <tr>
    <th class="tg-fymr" colspan="2">大小</th>
  </tr>
  <tr>
    <td class="tg-0pky">c.size()</td>
    <td class="tg-0pky">c 中元素的数目（不支持 forward_list）</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.max_size()</td>
    <td class="tg-0pky">c 可保存的最大元素数目</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.empty()</td>
    <td class="tg-0pky">若 c 中存储了元素，返回 false，否则返回 true</td>
  </tr>
  <tr>
    <th class="tg-fymr" colspan="2">添加/删除元素（不适用于 array）<br>注：在不同容器中，这些操作的接口都不同</th>
  </tr>
  <tr>
    <td class="tg-0pky">c.insert(args)</td>
    <td class="tg-0pky">将 args 中的元素拷贝进 c</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.emplace(inits)</td>
    <td class="tg-0pky">使用 inits 构造 c 中的一个元素</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.erase(args)</td>
    <td class="tg-0pky">删除 args 指定的元素</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.clear()</td>
    <td class="tg-0pky">删除 c 中的所有元素，返回 void</td>
  </tr>
  <tr>
    <th class="tg-fymr" colspan="2">关系运算符</th>
  </tr>
  <tr>
    <td class="tg-0pky">==, !=</td>
    <td class="tg-0pky">所有容器都支持相等（不等）运算符</td>
  </tr>
  <tr>
    <td class="tg-0pky">&lt;, &lt;=, &gt;, &gt;=</td>
    <td class="tg-0pky">关系运算符（无序关联容器不支持）</td>
  </tr>
  <tr>
    <th class="tg-fymr" colspan="2">获取迭代器</th>
  </tr>
  <tr>
    <td class="tg-0pky">c.begin(), c.end()</td>
    <td class="tg-0pky">返回指向 c 的首元素和尾元素之后位置的迭代器</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.cbegin(), c.cend()</td>
    <td class="tg-0pky">返回 const_iterator</td>
  </tr>
  <tr>
    <th class="tg-fymr" colspan="2">反向容器的额外成员（不支持 forward_list）</th>
  </tr>
  <tr>
    <td class="tg-0pky">reverse_iterator</td>
    <td class="tg-0pky">按逆序寻址元素的迭代器</td>
  </tr>
  <tr>
    <td class="tg-0pky">const_reverse_iterator</td>
    <td class="tg-0pky">不能修改元素的逆序迭代器</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.rbegin(), c.rend()</td>
    <td class="tg-0pky">返回指向 c 的尾元素和首元素之前位置的迭代器</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.crbegin(), c.crend()</td>
    <td class="tg-0pky">返回 const_reverse_iterator</td>
  </tr>
</tbody>
</table>

</li>
</ol>
<h2 id="9-2-1-迭代器" class="heading-control"><a href="#9-2-1-迭代器" class="headerlink" title="9.2.1 迭代器"></a>9.2.1 迭代器<a class="heading-anchor" href="#9-2-1-迭代器" aria-hidden="true"></a></h2><ol>
<li><p><code>forward_list</code> 迭代器不支持递减运算符（<code>- -</code>）（因为是单向的——博主注）。</p>
</li>
<li><p>一个选代器范围（iterator range）由一对迭代器表示，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置（one past the last element），这两个迭代器通常被称为 <code>begin</code> 和 <code>end</code>，<code>begin</code> 和 <code>end</code> 必须指向相同的容器，<code>end</code> 可以与 <code>begin</code> 指向相同的位置，但不能指向 <code>begin</code> 之前的位置。迭代器范围是<strong>左闭合区间</strong>（left-inclusive interval）。</p>
</li>
<li><p>假定 <code>begin</code> 和 <code>end</code> 构成一个合法的迭代器范围，则：</p>
<ul>
<li>如果 <code>begin</code> 与 <code>end</code> 相等，则范围为空</li>
<li>如果 <code>begin</code> 与 <code>end</code> 不等，则范围至少包含一个元素，且 <code>begin</code> 指向该范围中的第一个元素</li>
<li>可以对 <code>begin</code> 递增若干次，使得 <code>begin == end</code><br><br></li>
</ul>
</li>
<li><p><strong>练习 9.6：</strong> 下面程序有何错误？你应该如何修改它？</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst1;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator iter1 = lst1.begin(),</span><br><span class="line">                    iter2 = lst1.end();</span><br><span class="line"><span class="keyword">while</span> (iter1 &lt; iter2) <span class="comment">/*...*/</span></span><br></pre></td></tr></table></figure>
<p>vscode 提示信息为：没有与这些操作数匹配的 “&lt;” 运算符 — 操作数类型为: std::_List_iterator<int> &lt; std::_List_iterator<int></int></int></p>
</li>
</ol>
<h2 id="9-2-2-容器类型成员" class="heading-control"><a href="#9-2-2-容器类型成员" class="headerlink" title="9.2.2 容器类型成员"></a>9.2.2 容器类型成员<a class="heading-anchor" href="#9-2-2-容器类型成员" aria-hidden="true"></a></h2><ol>
<li><p>反向迭代器就是一种反向遍历容器的迭代器，与正向迭代器相比，各种操作的含义也都发生了颠倒。例如，对一个反向迭代器执行 <code>++</code> 操作，会得到上一个元素。</p>
</li>
<li><p>如果需要元素类型，可以使用容器的 <code>value_type</code>。如果需要元素类型的一个引用，可以使用 <code>reference</code> 或 <code>const_reference</code>。</p>
</li>
</ol>
<h2 id="9-2-3-begin-和-end-成员" class="heading-control"><a href="#9-2-3-begin-和-end-成员" class="headerlink" title="9.2.3 begin 和 end 成员"></a>9.2.3 begin 和 end 成员<a class="heading-anchor" href="#9-2-3-begin-和-end-成员" aria-hidden="true"></a></h2><ol>
<li><p><code>begin</code> 和 <code>end</code> 操作生成指向容器中第一个元素和尾元素之后位置的迭代器。这两个迭代器最常见的用途是形成一个包含容器中所有元素的迭代器范围。<code>begin</code> 和 <code>end</code> 有多个版本：带 <code>r</code> 的版本返回反向迭代器；以 <code>c</code> 开头的版本则返回 <code>const</code> 迭代器：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; a = &#123;<span class="string">"Milton"</span>, <span class="string">"Shakespeare"</span>, <span class="string">"Austen"</span>&#125;;</span><br><span class="line"><span class="keyword">auto</span> itl = a.begin();   <span class="comment">// list&lt;string&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = a.rbegin();  <span class="comment">// list&lt;string&gt;::reverse_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it3 = a.cbegin();  <span class="comment">// list&lt;string&gt;::const_iterator</span></span><br><span class="line"><span class="keyword">auto</span> it4 = a.crbegin(); <span class="comment">// list&lt;string&gt;::const_reverse iterator</span></span><br></pre></td></tr></table></figure>
<p>当我们对一个非常量对象调用这些成员时，得到的是返回 <code>iterator</code> 的版本。只有在对一个 <code>const</code> 对象调用这些函数时，才会得到一个 <code>const</code> 版本。与 <code>const</code> 指针和引用类似，可以将一个普通的 <code>iterator</code> 转换为对应的 <code>const_iterator</code>，但反之不行。</p>
<p>当 <code>auto</code> 与 <code>begin</code> 或 <code>end</code> 结合使用时，获得的迭代器类型依赖于容器类型，与我们想要如何使用迭代器毫不相干。但以 <code>c</code> 开头的版本还是可以获得 <code>const_iterator</code> 的，而不管容器的类型是什么。</p>
</li>
<li><blockquote>
<p>Best Practices：当不需要写访问时，应使用 <code>cbegin</code> 和 <code>cend</code>。</p>
</blockquote>
</li>
</ol>
<h2 id="9-2-4-容器定义和初始化" class="heading-control"><a href="#9-2-4-容器定义和初始化" class="headerlink" title="9.2.4 容器定义和初始化"></a>9.2.4 容器定义和初始化<a class="heading-anchor" href="#9-2-4-容器定义和初始化" aria-hidden="true"></a></h2><ol>
<li><p>除 <code>array</code> 之外，其他容器的默认构造函数都会创建一个指定类型的空容器，且都可以接受指定容器大小和元素初始值的参数。</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2">容器定义和初始化</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">C c;</td>
    <td class="tg-0pky">默认构造函数。如果 c 是一个 array，则 c 中元素按默认方式初始化；否则 c 为空</td>
  </tr>
  <tr>
    <td class="tg-0pky">C c1(c2)</td>
    <td class="tg-lboi" rowspan="2">c1 初始化为 c2 的拷贝。c1 和 c2 必须是相同类型（即，它们必须是相同的容器类型，且保存的是相同的元素类型；对于 array 类型，两者还必须具有相同大小）</td>
  </tr>
  <tr>
    <td class="tg-0pky">C c1 = c2</td>
  </tr>
  <tr>
    <td class="tg-0pky">C c{a, b, c...}</td>
    <td class="tg-lboi" rowspan="2">c 初始化为初始化列表中元素的拷贝。列表中元素的类型必须与 c 的元素类型相容。对于 array 类型，列表中元素数目必须等于或小于 array 的大小，任何遗漏的元素都进行值初始化</td>
  </tr>
  <tr>
    <td class="tg-0pky">C c = {a, b, c...}</td>
  </tr>
  <tr>
    <td class="tg-0pky">C c(b, e)</td>
    <td class="tg-0pky">c 初始化为迭代器 b 和 e 指定范围中的元素的拷贝。范围中元素的类型必须与 c 的元素类型相容（array 不适用）</td>
  </tr>
  <tr>
    <td class="tg-fymr" colspan="2">只有顺序容器（不包括 array）的构造函数才能接受大小参数</td>
  </tr>
  <tr>
    <td class="tg-0pky">C seq(n)</td>
    <td class="tg-0pky">seq 包含 n 个元素，这些元素进行了值初始化；此构造函数是 explicit 的（string 不适用）</td>
  </tr>
  <tr>
    <td class="tg-0pky">C seq(n, t)</td>
    <td class="tg-0pky">seq 包含 n 个初始化为值 t 的元素</td>
  </tr>
</tbody>
</table>
</li>
<li><p>将一个新容器创建为另一个容器的拷贝的方法有两种：可以直接拷贝整个容器，或者（<code>array</code> 除外）拷贝由一个迭代器对指定的元素范围（指针对也可以——博主注）。为了创建一个容器为另一个容器的拷贝，两个容器的类型及其元素类型必须匹配。不过，当传递迭代器参数来拷贝一个范围时，就不要求容器类型是相同的了。而且，新容器和原容器中的元素类型也可以不同，只要能将要拷贝的元素转换为要初始化的容器的元素类型即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个容器有三个元素，用给定的初始化器进行初始化</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; authors = &#123;<span class="string">"Milton"</span>, <span class="string">"Shakespeare"</span>, <span class="string">"Austen"</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; articles = &#123;<span class="string">"a"</span>, <span class="string">"an"</span>, <span class="string">"the"</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">list2</span><span class="params">(authors)</span></span>;     <span class="comment">// 正确：类型匹配</span></span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; <span class="title">authList</span><span class="params">(authors)</span></span>; <span class="comment">// 错误：容器类型不匹配</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">words</span><span class="params">(articles)</span></span>;  <span class="comment">// 错误：容器类型必须匹配</span></span><br><span class="line"><span class="comment">// 正确：可以将 const char* 元素转换为 string</span></span><br><span class="line"><span class="function">forward_list&lt;<span class="built_in">string</span>&gt; <span class="title">words</span><span class="params">(articles.begin(), articles.end())</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note：当将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型都必须相同。</p>
</blockquote>
<p>接受两个迭代器参数的构造函数用这两个迭代器表示我们想要拷贝的一个元素范围。与以往一样，两个迭代器分别标记想要拷贝的第一个元素和尾元素之后的位置。新容器的大小与范围中元素的数目相同。新容器中的每个元素都用范围中对应元素的值进行初始化。<strong>由于两个迭代器表示一个范围，因此可以使用这种构造函数来拷贝一个容器中的子序列</strong>（很实用，这个技巧在一些 LeetCode 题目中经常会用到——博主注）。</p>
</li>
<li><p>在新标准中，我们可以对一个容器进行<strong>列表初始化</strong>。</p>
</li>
<li><p>除了与关联容器相同的构造函数外，顺序容器（<code>array</code> 除外）还提供另一个构造函数，它接受一个容器大小和一个（可选的）元素初始值。如果我们不提供元素初始值，则标准库会创建一个值初始化器。如果元素类型是内置类型或者是具有默认构造函数的类类型，可以只为构造函数提供一个容器大小参数。<strong>如果元素类型没有默认构造函数，除了大小参数外，还必须指定一个显式的元素初始值。</strong></p>
<blockquote>
<p>Note：只有顺序容器的构造函数才接受大小参数，关联容器并不支持。</p>
</blockquote>
</li>
<li><p>与内置数组一样，标准库 <code>array</code> 的大小也是类型的一部分。当定义一个 <code>array</code> 时，除了指定元素类型，还要指定容器大小。<code>array</code> 大小固定的特性也影响了它所定义的构造函数的行为。与其他容器不同，<strong>一个默认构造的 <code>array</code> 是非空的：它包含了与其大小一样多的元素。这些元素都被默认初始化</strong>。</p>
</li>
<li><p>如果我们对 <code>array</code> 进行列表初始化，初始值的数目必须等于或小于 <code>array</code> 的大小。如果初始值数目小于 <code>array</code> 的大小，则它们被用来初始化 <code>array</code> 中靠前的元素，所有剩余元素都会进行值初始化（对 <code>array</code> 的列表赋值也是如此——博主注）。在这两种情况下，如果元素类型是一个类类型，那么该类必须有一个默认构造函数，以使值初始化能够进行：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia1;                                  <span class="comment">// 10 个默认初始化的 int</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia2 = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;; <span class="comment">// 列表初始化</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; ia3 = &#123;<span class="number">42</span>&#125;;                           <span class="comment">// ia3[0] 为42，剩余元素为 0</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然我们不能对内置数组类型进行拷贝或对象赋值操作，但 <code>array</code> 并无此限制：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> digs[<span class="number">10</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> cpy[<span class="number">10</span>] = digs; <span class="comment">// 错误：内置数组不支持拷贝或赋值</span></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; digits = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt; copy = digits; <span class="comment">// 正确：只要数组类型匹配即合法</span></span><br></pre></td></tr></table></figure>
<p>与其他容器一样，<code>array</code> 也要求初始值的类型必须与要创建的容器类型相同。此外，<code>array</code> 还要求元素类型和大小也都一样，因为大小是 <code>array</code> 类型的一部分。</p>
</li>
</ol>
<h2 id="9-2-5-赋值和-swap" class="heading-control"><a href="#9-2-5-赋值和-swap" class="headerlink" title="9.2.5 赋值和 swap"></a>9.2.5 赋值和 swap<a class="heading-anchor" href="#9-2-5-赋值和-swap" aria-hidden="true"></a></h2><ol>
<li><p>与赋值相关的运算符可用于所有容器。赋值运算符将其左边容器中的全部元素替换为右边容器中元素的拷贝。与内置数组不同，标准库 <code>array</code> 类型允许赋值。赋值号左右两边的运算对象必须具有相同的类型。由于右边运算对象的大小可能与左边运算对象的大小不同，因此 <code>array</code> 类型不支持 <code>assign</code>，关联容器同样不支持：</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-amwm{font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-amwm" colspan="2"><center>容器的 assign 操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">seq.assign(b, e)</td>
    <td class="tg-0lax">将 seq 中的元素替换为迭代器 b 和 e 所表示的范围中的元素。迭代器 b 和 e 不能指向 seq 中的元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">seq.assign(il)</td>
    <td class="tg-0lax">将 seq 中的元素替换为初始化列表 il 中的元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">seq.assign(n, t)</td>
    <td class="tg-0lax">将 seq 中的元素替换为 n 个值为 t 的元素</td>
  </tr>
</tbody>
</table>

<blockquote>
<p>WARNING：赋值相关运算会导致指向左边容器内部的迭代器、引用和指针失效。而 <code>swap</code> 操作将容器内容交换不会导致指向容器的迭代器、引用和指针失效（容器类型为 <code>array</code> 和 <code>string</code> 的情况除外）。</p>
</blockquote>
<p><code>assign</code> 操作用参数所指定的元素（的拷贝）替换左边容器中的所有元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; names;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">const</span> <span class="keyword">char</span> *&gt; oldstyle;</span><br><span class="line"><span class="comment">// names = oldstyle; // 错误：容器类型不匹配</span></span><br><span class="line"><span class="comment">// 正确：可以将 const char* 转换为 string</span></span><br><span class="line">names.assign(oldstyle.cbegin(), oldstyle.cend());</span><br></pre></td></tr></table></figure>
<blockquote>
<p>WARNING：由于其旧元素被替换，因此传递给 <code>assign</code> 的迭代器不能指向调用 <code>assign</code> 的容器。</p>
</blockquote>
<p><code>assign</code> 的第二个版本接受一个整型值和一个元素值。它用指定数目且具有相同给定值的元素替换容器中原有的元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 等价于 slist1.clear();</span></span><br><span class="line"><span class="comment">// 后跟 slist1.insert(slist1.begin(), 10, "Hiya!");</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist1</span><span class="params">(<span class="number">1</span>)</span></span>;     <span class="comment">// 1 个元素，为空 string</span></span><br><span class="line">slist1.assign(<span class="number">10</span>, <span class="string">"Hiya!"</span>); <span class="comment">// 10 个元素，每个都是 "Hiya!"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>swap</code> 操作交换两个相同类型容器的内容，被交换的两个容器大小可以不同。除 <code>array</code> 外，交换两个容器内容的操作保证会很快——元素本身并未交换，<code>swap</code> 只是交换了两个容器的内部数据结构。</p>
<blockquote>
<p>Note：除 <code>array</code> 外，<code>swap</code> 不对任何元素进行拷贝、删除或插入操作，因此可以保证在常数时间内完成。</p>
</blockquote>
<p>元素不会被移动的事实意味着，除 <code>string</code> 外，指向容器的迭代器、引用和指针在 <code>swap</code> 操作之后都不会失效。它们仍指向 <code>swap</code> 操作之前所指向的那些元素。但是，在 <code>swap</code> 之后，这些元素已经属于不同的容器了。与其他容器不同，对一个 <code>string</code> 调用 <code>swap</code> 会导致迭代器、引用和指针失效。与其他容器不同，<code>swap</code> 两个 <code>array</code> 会真正交换它们的元素。因此，交换两个 <code>array</code> 所需的时间与 <code>array</code> 中元素的数目成正比。因此，对于 <code>array</code>，在 <code>swap</code> 操作之后，指针、引用和迭代器所绑定的元素保持不变，但元素值已经与另一个 <code>array</code> 中对应元素的值进行了交换。在新标准库中，容器既提供成员函数版本的 <code>swap</code>，也提供非成员版本的 <code>swap</code>。而早期标准库版本只提供成员函数版本的 <code>swap</code>。非成员版本的 <code>swap</code> 在泛型编程中是非常重要的。统一使用非成员版本的 <code>swap</code> 是一个好习惯。</p>
</li>
</ol>
<h2 id="9-2-6-容器大小操作" class="heading-control"><a href="#9-2-6-容器大小操作" class="headerlink" title="9.2.6 容器大小操作"></a>9.2.6 容器大小操作<a class="heading-anchor" href="#9-2-6-容器大小操作" aria-hidden="true"></a></h2><ol>
<li><code>max_size</code> 返回一个大于或等于该类型容器所能容纳的最大元素数的值。<code>forward_list</code> 支持 <code>max_size</code> 和 <code>empty</code>，但不支持 <code>size</code>。</li>
</ol>
<h2 id="9-2-7-关系运算符" class="heading-control"><a href="#9-2-7-关系运算符" class="headerlink" title="9.2.7 关系运算符"></a>9.2.7 关系运算符<a class="heading-anchor" href="#9-2-7-关系运算符" aria-hidden="true"></a></h2><ol>
<li><p>每个容器类型都支持相等运算符（<code>==</code> 和 <code>!=</code>）；除了无序关联容器外的所有容器都支持关系运算符（<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code>）。关系运算符左右两边的运算对象必须是相同类型的容器，且必须保存相同类型的元素。即，我们只能将一个 <code>vector&lt;int&gt;</code> 与另一个 <code>vector&lt;int&gt;</code> 进行比较，而不能将一个 <code>vector&lt;int&gt;</code> 与一个 <code>list&lt;int&gt;</code> 或一个 <code>vector&lt;double&gt;</code> 进行比较。比较两个容器实际上是进行元素的逐对比较。这些运算符的工作方式与 <code>string</code> 的关系运算类似：</p>
<ul>
<li>如果两个容器具有相同大小且所有元素都两两对应相等，则这两个容器相等；否则两个容器不等。</li>
<li>如果两个容器大小不同，但较小容器中每个元素都等于较大容器中的对应元素，则较小容器小于较大容器。</li>
<li>如果两个容器都不是另一个容器的<strong>前缀子序列</strong>，则它们的比较结果取决于<strong>第一个不相等的元素的比较结果</strong>。<br><br></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4 = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">12</span>&#125;;</span><br><span class="line">v1 &lt; v2   <span class="comment">// true；v1 和 v2 在元素 [2] 处不同：v1[2] 小于等于 v2[2]</span></span><br><span class="line">v1 &lt; v3   <span class="comment">// false；所有元素都相等，但 v3 中元素数目更少</span></span><br><span class="line">v1 == v4  <span class="comment">// true；每个元素都相等，且 v1 和 v4 大小相同</span></span><br><span class="line">v1 == v2  <span class="comment">// false；v2 元素数目比 v1 少</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note：只有当其元素类型也定义了相应的比较运算符时，我们才可以使用关系运算符来比较两个容器。</p>
</blockquote>
</li>
</ol>
<h1 id="9-3-顺序容器操作" class="heading-control"><a href="#9-3-顺序容器操作" class="headerlink" title="9.3 顺序容器操作"></a>9.3 顺序容器操作<a class="heading-anchor" href="#9-3-顺序容器操作" aria-hidden="true"></a></h1><ol>
<li>顺序容器和关联容器的不同之处在于两者组织元素的方式。这些不同之处直接关系到了元素如何存储、访问、添加以及删除。</li>
</ol>
<h2 id="9-3-1-向顺序容器添加元素" class="heading-control"><a href="#9-3-1-向顺序容器添加元素" class="headerlink" title="9.3.1 向顺序容器添加元素"></a>9.3.1 向顺序容器添加元素<a class="heading-anchor" href="#9-3-1-向顺序容器添加元素" aria-hidden="true"></a></h2><ol>
<li><p>除 <code>array</code> 外，所有标准库容器都提供灵活的内存管理。在运行时可以动态添加或删除元素来改变容器大小。下面这些操作会改变容器的大小，<code>array</code> 不支持这些操作。<code>forward_list</code> 有自己专有版本的 <code>insert</code> 和 <code>emplace</code>。<code>forward_list</code> 不支持 <code>push_back</code> 和 <code>emplace_back</code>。<code>vector</code> 和 <code>string</code> 不支持 <code>push_front</code> 和 <code>emplace_front</code>。</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>向顺序容器添加元素的操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">c.push_back(t)</td>
    <td class="tg-lboi" rowspan="2">在 c 的尾部创建一个值为 t 或由 args 创建的元素。返回 void</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.emplace_back(args)</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.push_front(t)</td>
    <td class="tg-lboi" rowspan="2">在 c 的头部创建一个值为 t 或由 args 创建的元素。返回 void</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.emplace_front(args)</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.insert(p, t)</td>
    <td class="tg-lboi" rowspan="2">在迭代器 p 指向的元素之前创建一个值为 t 或由 args 创建的元素。返回指向新添加的元素的迭代器</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.emplace(p, args)</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.insert(p, n, t)</td>
    <td class="tg-0pky">在迭代器 p 指向的元素之前插入 n 个值为 t 的元素。返回指向新添加的第一个元素的迭代器；若 n 为 0，则返回 p</td>
  </tr>
  <tr>
    <td class="tg-0pky">c. insert(p, b, e)</td>
    <td class="tg-0pky">将迭代器 b 和 e 指定的范围内的元素插入到迭代器 p 指向的元素之前。b 和 e 不能指向 c 中的元素。返回指向新添加的第一个元素的迭代器；若范围为空，则返回 p</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.insert(p, il)</td>
    <td class="tg-0pky">il 是一个花括号包围的元素值列表。将这些给定值插入到迭代器 p 指向的元素之前。返回指向新添加的第一个元素的迭代器；若列表为空，则返回 p</td>
  </tr>
</tbody>
</table>

<blockquote>
<p>WARNING：向一个 <code>vector</code>、<code>string</code> 或 <code>deque</code> 插入元素会使所有指向容器的迭代器、引用和指针失效。</p>
</blockquote>
</li>
<li><p>在一个 <code>vector</code> 或 <code>string</code> 的尾部之外的任何位置，或是一个 <code>deque</code> 的首尾之外的任何位置添加元素，都需要移动元素。而且，<strong>向一个 <code>vector</code> 或 <code>string</code> 添加元素可能引起整个对象存储空间的重新分配。重新分配一个对象的存储空间需要分配新的内存，并将元素从旧的空间移动到新的空间中</strong>。</p>
</li>
<li><p>对 <code>push_back</code> 的调用在 container 尾部创建了一个新的元素，将 container 的 <code>size</code> 增大了 1。</p>
</li>
<li><blockquote>
<p><strong>关键概念：容器元素是拷贝</strong>。当我们用一个对象来初始化容器时，或将一个对象插入到容器中时，实际上放入到容器中的是对象值的一个拷贝，而不是对象本身。</p>
</blockquote>
</li>
<li><p>除了 <code>push_back</code>，<code>list</code>、<code>forward_list</code> 和 <code>deque</code> 容器还支持名为 <code>push_front</code> 的类似操作。<code>deque</code> 像 <code>vector</code> 一样提供了随机访问元素的能力，但它提供了 <code>vector</code> 所不支持的 <code>push_front</code>。<code>deque</code> 保证在容器首尾进行插入和删除元素的操作都只花费常数时间。与 <code>vector</code> 一样，在 <code>deque</code> 首尾之外的位置插入元素会很耗时。</p>
</li>
<li><p><code>insert</code> 成员提供了更一般的添加功能，它允许我们在容器中任意位置插入 0 个或多个元素。<code>vector</code>、<code>deque</code>、<code>list</code> 和 <code>string</code> 都支持 <code>insert</code> 成员。<code>forward_list</code> 提供了特殊版本的 <code>insert</code> 成员。每个 <code>insert</code> 函数都接受一个迭代器作为其第一个参数。迭代器指出了在容器中什么位置放置新元素。它可以指向容器中任何位置，包括容器尾部之后的下一个位置（意即 <code>insert</code> 的迭代器参数可以是尾后迭代器——博主注）。</p>
<blockquote>
<p>将元素插入到 <code>vector</code>、<code>deque</code> 和 <code>string</code> 中的任何位置都是合法的。然而，这样做可能很耗时。</p>
</blockquote>
</li>
<li><p><code>insert</code> 函数下面的这个用法将指定数量的元素添加到指定位置之前，这些元素都按给定值初始化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">svec.insert(svec.end(), <span class="number">10</span>, <span class="string">"Anna"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>接受一对迭代器或一个初始化列表的 <code>insert</code> 版本将给定范围中的元素插入到指定位置之前：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; v = &#123;<span class="string">"quasi"</span>, <span class="string">"simba"</span>, <span class="string">"frollo"</span>, <span class="string">"scar"</span>&#125;;</span><br><span class="line"><span class="comment">// 将 v 的最后两个元素添加到 slist 的开始位置</span></span><br><span class="line">slist.insert(slist.begin(), v.end() - <span class="number">2</span>, v.end());</span><br><span class="line">slist.insert(slist.end(), &#123;<span class="string">"these"</span>, <span class="string">"words"</span>, <span class="string">"will"</span>,</span><br><span class="line">                           <span class="string">"go"</span>, <span class="string">"at"</span>, <span class="string">"the"</span>, <span class="string">"end"</span>&#125;);</span><br><span class="line"><span class="comment">// 运行时错误：迭代器表示要拷贝的范围，不能指向与目的位置相同的容器</span></span><br><span class="line">slist.insert(slist.begin(), slist.begin(), slist.end());</span><br></pre></td></tr></table></figure>
<p>如果我们传递给 <code>insert</code> 一对迭代器，它们不能指向添加元素的目标容器。</p>
<p><strong>在新标准下，接受元素个数或范围的 <code>insert</code> 版本返回指向第一个新加入元素的迭代器。</strong>（在旧版本的标准库中，这些操作返回 <code>void</code>。）<strong>如果范围为空，不插入任何元素，<code>insert</code> 操作会将第一个参数返回。</strong></p>
</li>
<li><p>通过使用 <code>insert</code> 的返回值，可以在容器中一个特定位置反复插入元素：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; lst;</span><br><span class="line"><span class="keyword">auto</span> iter = lst.begin();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; word)</span><br><span class="line">    iter = lst.insert(iter, word); <span class="comment">// 等价于调用 push_front</span></span><br></pre></td></tr></table></figure>
<p>上面的代码循环向链表头部插入数据。</p>
</li>
<li><p>新标准引入了三个新成员——<code>emplace_front</code>、<code>emplace</code> 和 <code>emplace_back</code>，这些操作构造而不是拷贝元素。这些操作分别对应 <code>push_front</code>、<code>insert</code> 和 <code>push_back</code>，允许我们将元素放置在容器头部、一个指定位置之前或容器尾部。</p>
</li>
<li><p><strong>当调用 <code>push</code> 或 <code>insert</code> 成员函数时，我们将元素类型的对象传递给它们，这些对象被拷贝到容器中。而当我们调用一个 <code>emplace</code> 成员函数时，则是将参数传递给元素类型的构造函数。<code>emplace</code> 成员使用这些参数在容器管理的内存空间中直接构造元素。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 c 的末尾构造一个 Sales_data 对象</span></span><br><span class="line"><span class="comment">// 使用三个参数的 Sales_data 构造函数</span></span><br><span class="line">c.emplace_back(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// 错误：没有接受三个参数的 push_back 版本</span></span><br><span class="line">c.push_back(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line"><span class="comment">// 正确：创建一个临时的 Sales_data 对象传递给 push_back</span></span><br><span class="line">c.<span class="function">push <span class="title">back</span><span class="params">(Sales_data(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>))</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中对 <code>emplace_back</code> 的调用和第二个 <code>push_back</code> 调用都会创建新的 <code>Sales_data</code> 对象。<strong>在调用 <code>emplace_back</code> 时，会在容器管理的内存空间中直接创建对象。</strong> 而调用 <code>push_back</code> 则会创建一个局部临时对象，并将其压入容器中。<code>emplace</code> 函数的参数根据元素类型而变化，参数必须与元素类型的构造函数相匹配。（<code>emplace</code> 相关操作更加高效——博主注）</p>
<blockquote>
<p>Note：emplace 函数在容器中直接构造元素。传递给 emplace 函数的参数必须与元素类型的构造函数相匹配。</p>
</blockquote>
</li>
</ol>
<h2 id="9-3-2-访问元素" class="heading-control"><a href="#9-3-2-访问元素" class="headerlink" title="9.3.2 访问元素"></a>9.3.2 访问元素<a class="heading-anchor" href="#9-3-2-访问元素" aria-hidden="true"></a></h2><ol>
<li><p>如果容器中没有元素，访问操作的结果是未定义的。包括 <code>array</code> 在内的每个顺序容器都有一个 <code>front</code> 成员函数，而除 <code>forward_list</code> 之外的所有顺序容器都有一个 <code>back</code> 成员函数。这两个操作分别返回首元素和尾元素的引用。在解引用一个迭代器或调用 <code>front</code> 或 <code>back</code> 之前应检查容器中是否有元素存在。</p>
</li>
<li><p>值得注意：迭代器 <code>end</code> 指向的是容器尾元素之后的（不存在的）元素。为了获取尾元素，必须首先递减此迭代器。另一个重要之处是，在调用 <code>front</code> 和 <code>back</code>（或解引用 <code>begin</code> 和 <code>end</code> 返回的迭代器）之前，要确保容器非空。</p>
</li>
<li><p><code>at</code> 和下标操作只适用于 <code>string</code>、<code>vector</code>、<code>deque</code> 和 <code>array</code>。<code>back</code> 不适用于 <code>forward_list</code>。</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>在顺序容器中访问元素的操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">c.back()</td>
    <td class="tg-0pky">返回 c 中尾元素的引用。若 c 为空，函数行为未定义</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.front()</td>
    <td class="tg-0pky">返回 c 中首元素的引用。若 c 为空，函数行为未定义</td>
  </tr>
  <tr>
    <td class="tg-0pky">c[n]</td>
    <td class="tg-0pky">返回 c 中下标为 n 的元素的引用，n 是一个无符号整数。若 n &gt;= c.size()，则函数行为未定义</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.at(n)</td>
    <td class="tg-lboi">返回下标为 n 的元素的引用。如果下标越界，则抛出 out_of_range 异常</td>
  </tr>
</tbody>
</table>

<blockquote>
<p>WARNING：对一个空容器调用 <code>front</code> 和 <code>back</code>，就像使用一个越界的下标一样，是一种严重的程序设计错误。</p>
</blockquote>
</li>
<li><p>在容器中访问元素的成员函数（即，<code>front</code>、<code>back</code>、下标和 <code>at</code>）返回的都是引用。如果容器是一个 <code>const</code> 对象，则返回值是 <code>const</code> 的引用。如果容器不是 <code>const</code> 的，则返回值是普通引用，我们可以用来改变元素的值。</p>
</li>
<li><p>下标运算符并不检查下标是否在合法范围内。使用越界的下标是一种严重的程序设计错误，而且编译器并不检查这种错误。如果我们希望确保下标是合法的，可以使用 <code>at</code> 成员函数。<code>at</code> 成员函数类似下标运算符，但如果下标越界，<code>at</code> 会抛出一个 out_of_range 异常。</p>
</li>
</ol>
<h2 id="9-3-3-删除元素" class="heading-control"><a href="#9-3-3-删除元素" class="headerlink" title="9.3.3 删除元素"></a>9.3.3 删除元素<a class="heading-anchor" href="#9-3-3-删除元素" aria-hidden="true"></a></h2><ol>
<li><p><code>array</code> 不支持删除操作，<code>forward_list</code> 有特殊版本的 <code>erase</code>。<code>forward_list</code> 不支持 <code>pop_back</code>；<code>vector</code> 和 <code>string</code> 不支持 <code>pop_front</code>。</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>顺序容器的删除操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">c.pop_back()</td>
    <td class="tg-0pky">删除 c 中尾元素。若 c 为空，则函数行为未定义。函数返回 void</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.pop_front()</td>
    <td class="tg-0pky">删除 c 中首元素。若 c 为空，则函数行为未定义。函数返回 void</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.erase(p)</td>
    <td class="tg-0pky">删除迭代器 p 所指定的元素，返回一个指向被删元素之后元素的迭代器，若 p 指向尾元素，则返回尾后（off-the-end）迭代器。若 p 是尾后迭代器，则函数行为未定义</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.erase(b, e)</td>
    <td class="tg-lboi">删除迭代器 b 和 e 所指定范围内的元素。返回一个指向最后一个被删元素之后元素的迭代器，若 e 本身就是尾后迭代器，则函数也返回尾后迭代器</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.clear()</td>
    <td class="tg-0lax">删除 c 中的所有元素。返回 void</td>
  </tr>
</tbody>
</table>

<blockquote>
<p>WARNING：删除 <code>deque</code> 中除首尾位置之外的任何元素都会使所有迭代器、引用和指针失效。指向 <code>vector</code> 或 <code>string</code> 中删除点之后位置的迭代器、引用和指针都会失效。</p>
</blockquote>
</li>
<li><p>与 <code>vector</code> 和 <code>string</code> 不支持 <code>push_front</code> 一样，这些类型也不支持 <code>pop_front</code>。类似的，<code>forward_list</code> 不支持 <code>pop_back</code>。与元素访问成员函数类似，不能对一个空容器执行弹出操作。这些操作返回 <code>void</code>。如果你需要弹出的元素的值，就必须在执行弹出操作之前保存它。</p>
</li>
<li><p>成员函数 <code>erase</code> 从容器中指定位置删除元素。我们可以删除由一个迭代器指定的单个元素，也可以删除由一对迭代器指定的范围内的所有元素。两种形式的 <code>erase</code> 都返回指向删除的（最后一个）元素之后位置的迭代器。</p>
</li>
<li><p><strong>练习 9.26：</strong> 使用下面代码定义的 <code>ia</code>，将 <code>ia</code> 拷贝到一个 <code>vector</code> 和一个 <code>list</code> 中。使用单迭代器版本的 <code>erase</code> 从 <code>list</code> 中删除奇数元素，从 <code>vector</code> 中删除偶数元素。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[]=&#123;<span class="number">0</span>，<span class="number">1</span>，<span class="number">1</span>，<span class="number">2</span>，<span class="number">3</span>，<span class="number">5</span>，<span class="number">8</span>，<span class="number">13</span>，<span class="number">21</span>，<span class="number">55</span>，<span class="number">89</span>&#125;；</span><br></pre></td></tr></table></figure>
<p>解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 练习 9.26</span><br><span class="line">int ia[] &#x3D; &#123;0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89&#125;;</span><br><span class="line">std::vector&lt;int&gt; iv(ia, ia + sizeof(ia) &#x2F; sizeof(int));</span><br><span class="line">std::list&lt;int&gt; il(ia, ia + sizeof(ia) &#x2F; sizeof(int));</span><br><span class="line">for (auto iter &#x3D; iv.begin(); iter !&#x3D; iv.end();)</span><br><span class="line">&#123;</span><br><span class="line">if (*iter % 2)</span><br><span class="line">iter &#x3D; iv.erase(iter);</span><br><span class="line">else</span><br><span class="line">++iter;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; &quot;new vector: &quot; &lt;&lt; std::endl;</span><br><span class="line">for (auto &amp;i : iv)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; &quot;, &quot;;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; endl;</span><br><span class="line">for (auto iter &#x3D; il.begin(); iter !&#x3D; il.end();)</span><br><span class="line">&#123;</span><br><span class="line">if (0 &#x3D;&#x3D; (*iter % 2))</span><br><span class="line">iter &#x3D; il.erase(iter);</span><br><span class="line">else</span><br><span class="line">++iter;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; &quot;new list: &quot; &lt;&lt; std::endl;</span><br><span class="line">for (auto &amp;i : il)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; i &lt;&lt; &quot;, &quot;;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">## 9.3.4 特殊的 forward_list 操作</span><br><span class="line"></span><br><span class="line">48. &#96;forward_list&#96; 是单向链表。在一个单向链表中，没有简单的方法来获取一个元素的前驱。出于这个原因，**在一个 &#96;forward_list&#96; 中添加或删除元素的操作是通过改变给定元素之后的元素来完成的**。&#96;forward_list&#96; 并未定义 &#96;insert&#96;、&#96;emplace&#96; 和 &#96;erase&#96;，而是定义了名为 &#96;insert_after&#96;、&#96;emplace_after&#96; 和 &#96;erase_after&#96; 的操作，为了支持这些操作，&#96;forward_list&#96; 也定义了 &#96;before_begin&#96;，它返回一个**首前**（off-the-beginning）迭代器。这个迭代器允许我们在链表首元素之前并不存在的元素“之后”添加或删除元素（亦即在链表首元素之前添加删除元素）。</span><br><span class="line"></span><br><span class="line">    &lt;style type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">    .tg &#123;border-collapse:collapse;border-spacing:0;&#125;</span><br><span class="line">    .tg td&#123;border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;</span><br><span class="line">    overflow:hidden;padding:10px 5px;word-break:normal;&#125;</span><br><span class="line">    .tg th&#123;border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;</span><br><span class="line">    font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;&#125;</span><br><span class="line">    .tg .tg-cly1&#123;text-align:left;vertical-align:middle&#125;</span><br><span class="line">    .tg .tg-lboi&#123;border-color:inherit;text-align:left;vertical-align:middle&#125;</span><br><span class="line">    .tg .tg-7btt&#123;border-color:inherit;font-weight:bold;text-align:center;vertical-align:top&#125;</span><br><span class="line">    .tg .tg-0pky&#123;border-color:inherit;text-align:left;vertical-align:top&#125;</span><br><span class="line">    .tg .tg-0lax&#123;text-align:left;vertical-align:top&#125;</span><br><span class="line">    &lt;&#x2F;style&gt;</span><br><span class="line">    &lt;table class&#x3D;&quot;tg&quot;&gt;</span><br><span class="line">    &lt;thead&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;th class&#x3D;&quot;tg-7btt&quot; colspan&#x3D;&quot;2&quot;&gt;&lt;center&gt;在 forward_list 中插入或删除元素的操作&lt;&#x2F;center&gt;&lt;&#x2F;th&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;thead&gt;</span><br><span class="line">    &lt;tbody&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0pky&quot;&gt;lst.before_begin()&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-lboi&quot; rowspan&#x3D;&quot;2&quot;&gt;返回指向链表首元素之前不存在的元素的迭代器。此迭代器不能解引用。cbefore_begin() 返回一个 const_iterator&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0pky&quot;&gt;lst.cbefore_begin()&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0pky&quot;&gt;lst.insert_after(p, t)&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-lboi&quot; rowspan&#x3D;&quot;4&quot;&gt;在迭代器 p 之后的位置插入元素。t 是一个对象，n 是数量，b 和 e 是表示范围的一对迭代器（b 和 e 不能指向 lst 内），il 是一个花括号列表。返回一个指向最后一个插入元素的迭代器。如果范围为空，则返回 p。若 p 为尾后迭代器，则函数行为未定义&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0pky&quot;&gt;lst.insert_after(p, n, t)&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0lax&quot;&gt;lst. insert_after(p, b, e)&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0lax&quot;&gt;lst.insert_after(p, il)&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0lax&quot;&gt;emplace_after(p, args)&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0lax&quot;&gt;使用 args 在 p 指定的位置之后创建一个元素。返回一个指向这个新元素的迭代器。若 p 为尾后迭代器，则函数行为未定义&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0lax&quot;&gt;lst.erase_after(p)&lt;&#x2F;td&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-cly1&quot; rowspan&#x3D;&quot;2&quot;&gt;删除 p 指向的位置之后的元素，或删除从 b 之后直到（但不包含）e 之间的元素。返回一个指向被删元素之后元素的迭代器，若不存在这样的元素，则返回尾后迭代器。如果 p 指向 lst 的尾元素或者是一个尾后迭代器，则函数行为未定义&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">      &lt;tr&gt;</span><br><span class="line">        &lt;td class&#x3D;&quot;tg-0lax&quot;&gt;lst.erase_after(b, e)&lt;&#x2F;td&gt;</span><br><span class="line">      &lt;&#x2F;tr&gt;</span><br><span class="line">    &lt;&#x2F;tbody&gt;</span><br><span class="line">    &lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">49. **练习 9.27：** 编写程序，查找并删除 &#96;forward_list&lt;int&gt;&#96; 中的奇数元素。</span><br><span class="line"></span><br><span class="line">    解：</span><br><span class="line"></span><br><span class="line">    &#96;&#96;&#96;cpp</span><br><span class="line">    &#x2F;&#x2F; 练习 9.27</span><br><span class="line">    std::forward_list&lt;int&gt; fl &#x3D; &#123;0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89&#125;;</span><br><span class="line">    for (auto prev &#x3D; fl.before_begin(), curr &#x3D; fl.begin(); curr !&#x3D; fl.end();)</span><br><span class="line">    &#123;</span><br><span class="line">        if (*curr % 2)</span><br><span class="line">        &#123;</span><br><span class="line">            curr &#x3D; fl.erase_after(prev);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            prev &#x3D; curr;</span><br><span class="line">            ++curr;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; &quot;new forward_list:&quot; &lt;&lt; std::endl;</span><br><span class="line">    for (auto &amp;i : fl)</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; &quot;, &quot;;</span><br><span class="line">    std::cout &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 9.28：</strong> 编写函数，接受一个 <code>forward_list&lt;string&gt;</code> 和两个 <code>string</code> 共三个参数。函数应在链表中查找第一个 <code>string</code>，并将第二个 <code>string</code> 插入到紧接着第一个 <code>string</code> 之后的位置。若第一个 <code>string</code> 未在链表中，则将第二个 <code>string</code> 插入到链表末尾。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 练习 9.28</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">std</span>::forward_list&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; &amp;fl, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str1, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;str2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fl.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        fl.push_front(str2);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> prev = fl.before_begin();</span><br><span class="line">    <span class="keyword">auto</span> curr = fl.begin();</span><br><span class="line">    <span class="keyword">for</span> (; curr != fl.end(); ++prev, ++curr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str1 == *curr)</span><br><span class="line">        &#123;</span><br><span class="line">            fl.insert_after(curr, str2);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fl.insert_after(prev, str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="9-3-5-改变容器大小" class="heading-control"><a href="#9-3-5-改变容器大小" class="headerlink" title="9.3.5 改变容器大小"></a>9.3.5 改变容器大小<a class="heading-anchor" href="#9-3-5-改变容器大小" aria-hidden="true"></a></h2><ol>
<li><p>可以用 <code>resize</code> 来增大或缩小容器，与往常一样，<code>array</code> 不支持 <code>resize</code>。如果当前大小大于所要求的大小，容器后部的元素会被删除；如果当前大小小于新大小，会将新元素添加到容器后部：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">10</span>, <span class="number">42</span>)</span></span>; <span class="comment">// 10 个 int：每个的值都是 42</span></span><br><span class="line">ilist.resize(<span class="number">15</span>);        <span class="comment">// 将 5 个值为 0 的元素添加到 ilist 的末尾</span></span><br><span class="line">ilist.resize(<span class="number">25</span>, <span class="number">-1</span>);    <span class="comment">// 将 10 个值为 -1 的元素添加到 ilist 的末尾</span></span><br><span class="line">ilist.resize(<span class="number">5</span>);         <span class="comment">// 从 ilist 末尾删除 20 个元素</span></span><br></pre></td></tr></table></figure>
<p><code>resize</code> 操作接受一个可选的元素值参数，用来初始化添加到容器中的元素。如果调用者未提供此参数，新元素进行值初始化。<strong>如果容器保存的是类类型元素，且 <code>resize</code> 向容器添加新元素，则我们必须提供初始值，或者元素类型必须提供一个默认构造函数。</strong></p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2">顺序容器大小操作</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">c.resize(n)</td>
    <td class="tg-lboi">调整 c 的大小为 n 个元素。若 n &lt; c.size()，则多出的元素被丢弃。若必须添加新元素，对新元素进行值初始化</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.resize(n, t)</td>
    <td class="tg-0pky">调整 c 的大小为 n 个元素。任何新添加的元素都初始化为值 t</td>
  </tr>
</tbody>
</table>

<blockquote>
<p>WARNING：如果 <code>resize</code> 缩小容器，则指向被删除元素的迭代器、引用和指针都会失效；对 <code>vector</code>、<code>string</code> 或 <code>deque</code> 进行 <code>resize</code> 可能导致迭代器、指针和引用失效。</p>
</blockquote>
</li>
</ol>
<h2 id="9-3-6-容器操作可能使迭代器失效" class="heading-control"><a href="#9-3-6-容器操作可能使迭代器失效" class="headerlink" title="9.3.6 容器操作可能使迭代器失效"></a>9.3.6 容器操作可能使迭代器失效<a class="heading-anchor" href="#9-3-6-容器操作可能使迭代器失效" aria-hidden="true"></a></h2><ol>
<li><p>向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的指针、引用或迭代器失效。</p>
<p>在向容器添加元素后：</p>
<ul>
<li>如果容器是 <code>vector</code> 或 <code>string</code>，且存储空间被重新分配，则指向容器的迭代器、指针和引用都会失效。如果存储空间未重新分配，指向插入位置之前的元素的迭代器、指针和引用仍有效，但指向插入位置之后元素的迭代器、指针和引用将会失效。</li>
<li>对于 <code>deque</code>，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用失效。如果在首尾位置添加元素，迭代器会失效，但指向存在的元素的引用和指针不会失效。</li>
<li>对于 <code>list</code> 和 <code>forward_list</code>，指向容器的迭代器（包括尾后迭代器和首前迭代器）、指针和引用仍有效。<br><br></li>
</ul>
<p>当我们删除一个元素后：</p>
<ul>
<li>对于 <code>list</code> 和 <code>forward_list</code>，指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）、引用和指针仍有效。</li>
<li>对于 <code>deque</code>，如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器、引用或指针也会失效。如果是删除 <code>deque</code> 的尾元素，则尾后迭代器也会失效，但其他迭代器、引用和指针不受影响；如果是删除首元素，这些也不会受影响。</li>
<li>对于 <code>vector</code> 和 <code>string</code>，指向被删元素之前元素的迭代器、引用和指针仍有效。注意：<strong>当我们删除元素时，尾后迭代器总是会失效</strong>。<br><br></li>
</ul>
</li>
<li><p>添加/删除 <code>vector</code>、<code>string</code> 或 <code>deque</code> 元素的循环程序必须考虑迭代器、引用和指针可能失效的问题。程序必须保证每个循环步中都更新迭代器、引用或指针。如果循环中调用的是 <code>insert</code> 或 <code>erase</code>，那么更新迭代器很容易。这些操作都返回迭代器，我们可以用来更新：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除偶数元素，复制奇数元素</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = ivec.begin(); iter != ivec.end();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*iter % <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iter = ivec.insert(iter, *iter);</span><br><span class="line">        iter += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        iter = ivec.erase(iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"new vector:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : ivec)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当我们添加/删除 <code>vector</code> 或 <code>string</code> 的元素后，或在 <code>deque</code> 中首元素之外任何位置添加/删除元素后，原来 <code>end</code> 返回的迭代器总是会失效。因此，添加或删除元素的循环程序必须反复调用 <code>end</code>，而不能在循环之前保存 <code>end</code> 返回的迭代器，一直当作容器末尾使用（<code>begin</code> 也是如此，<a href="https://blog.shipengx.com/archives/ef26ff66.html">LeetCode 341</a> 题犯过类似错误——博主注）。</p>
<blockquote>
<p>Tip：如果在一个循环中插入/删除 <code>deque</code>、<code>string</code> 或 <code>vector</code> 中的元素，不要缓存 <code>end</code> 返回的迭代器。</p>
</blockquote>
</li>
<li><p><strong>练习 9.31：</strong> 条目 53 中删除偶数值元素并复制奇数值元素的程序不能用于 <code>list</code> 或 <code>forward_list</code>。为什么？修改程序，使之也能用于这些类型。</p>
<p>解：<code>list</code> 中没有重载 <code>+</code> 运算符和 <code>+=</code> 运算符，只能使用自增运算符和自减运算符移动迭代器；<code>forward_list</code> 中没有重载 <code>+</code> 运算符、<code>+=</code> 运算符和自减运算符，只能使用自增运算符移动迭代器，同时 <code>forward_list</code> 中没有 <code>insert</code>、<code>emplace</code> 和 <code>erase</code> 方法，取而代之的是 <code>insert_after</code>、<code>emplace_after</code> 和 <code>erase_after</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 练习 9.31：删除偶数元素，复制奇数元素</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; il = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> iter = il.begin(); iter != il.end();)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (*iter % <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iter = il.insert(iter, *iter);</span><br><span class="line">        ++iter;</span><br><span class="line">        ++iter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        iter = il.erase(iter);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"new list:"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : il)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">", "</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="9-4-vector-对象是如何增长的" class="heading-control"><a href="#9-4-vector-对象是如何增长的" class="headerlink" title="9.4 vector 对象是如何增长的"></a>9.4 vector 对象是如何增长的<a class="heading-anchor" href="#9-4-vector-对象是如何增长的" aria-hidden="true"></a></h1><ol>
<li><p>为了支持快速随机访问，<code>vector</code> 将元素连续存储——每个元素紧挨着前一个元素存储。</p>
<p>假定容器中元素是连续存储的，且容器的大小是可变的，考虑向 <code>vector</code> 或 <code>string</code> 中添加元素会发生什么：如果没有空间容纳新元素，容器不可能简单地将它添加到内存中其他位置——因为元素必须连续存储。容器必须分配新的内存空间来保存已有元素和新元素，将已有元素从旧位置移动到新空间中，然后添加新元素，释放旧存储空间。如果我们每添加一个新元素，<code>vector</code> 就执行一次这样的内存分配和释放操作，性能会慢到不可接受。为了避免这种代价，标准库实现者采用了可以减少容器空间重新分配次数的策略。当不得不获取新的内存空间时，<code>vector</code> 和 <code>string</code> 的实现通常会分配比新的空间需求更大的内存空间。容器预留这些空间作为备用，可用来保存更多的新元素。这样，就不需要每次添加新元素都重新分配容器的内存空间了。（<code>vector</code> 往往是成倍扩容——博主注）</p>
</li>
<li><p><code>shrink_to_fit</code> 只适用于 <code>vector</code>、<code>string</code> 和 <code>deque</code>。<code>capacity</code> 和 <code>reserve</code> 只适用于 <code>vector</code> 和 <code>string</code>。</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-lboi{border-color:inherit;text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2">容器大小管理操作</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">c.shrink_to_fit()</td>
    <td class="tg-lboi">请将 capacity() 减少为与 size() 相同大小</td>
  </tr>
  <tr>
    <td class="tg-0pky">c.capacity()</td>
    <td class="tg-0pky">不重新分配内存空间的话，c 可以保存多少元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">c.reserve(n)</td>
    <td class="tg-0lax">分配至少能容纳 n 个元素的内存空间</td>
  </tr>
</tbody>
</table>

<blockquote>
<p>Note：<code>reserve</code> 并不改变容器中元素的数量，它仅影响 <code>vector</code> 预先分配多大的内存空间。</p>
</blockquote>
<p>如果需求大小小于或等于当前容量，<code>reserve</code> 什么也不做。特别是，当需求大小小于当前容量时，容器不会退回内存空间。因此，<strong>在调用 <code>reserve</code> 之后，<code>capacity</code> 将会大于或等于传递给 reserve 的参数</strong>。</p>
</li>
<li><p>调用 <code>reserve</code> 永远也不会减少容器占用的内存空间。类似的，同样不能使用 <code>resize</code> 来减少容器预留的内存空间。</p>
</li>
<li><p>在新标准库中，我们可以调用 <code>shrink_to_fit</code> 来要求 <code>deque</code>、<code>vector</code> 或 <code>string</code> 退回不需要的内存空间。此函数指出我们不再需要任何多余的内存空间。但是，具体的实现可以选择忽略此请求。也就是说，<strong>调用 <code>shrink_to_fit</code> 也并不保证一定退回内存空间</strong>。</p>
</li>
<li><p>容器的 <code>size</code> 是指它已经保存的元素的数目；而 <code>capacity</code> 则是在不分配新的内存空间的前提下它最多可以保存多少元素。</p>
</li>
<li><blockquote>
<p>Note：每个 <code>vector</code> 实现都可以选择自己的内存分配策略。但是必须遵守的一条原则是：只有当迫不得已时才可以分配新的内存空间。</p>
</blockquote>
</li>
<li><p><strong>只有在执行 <code>insert</code> 操作时 <code>size</code> 与 <code>capacity</code> 相等，或者调用 <code>resize</code> 或 <code>reserve</code> 时给定的大小超过当前 <code>capacity</code>，<code>vector</code> 才可能重新分配内存空间。</strong> 会分配多少超过给定容量的额外空间，取决于具体实现。</p>
</li>
<li><p><strong>练习 9.37：</strong> 为什么 <code>list</code> 或 <code>array</code> 没有 <code>capacity</code> 成员函数？</p>
<p>答：因为 <code>list</code> 是链式存储结构，<code>array</code> 是定长的顺序存储结构。</p>
</li>
</ol>
<h1 id="9-5-额外的-string-操作" class="heading-control"><a href="#9-5-额外的-string-操作" class="headerlink" title="9.5 额外的 string 操作"></a>9.5 额外的 string 操作<a class="heading-anchor" href="#9-5-额外的-string-操作" aria-hidden="true"></a></h1><h2 id="9-5-1-构造-string-的其他方法" class="heading-control"><a href="#9-5-1-构造-string-的其他方法" class="headerlink" title="9.5.1 构造 string 的其他方法"></a>9.5.1 构造 string 的其他方法<a class="heading-anchor" href="#9-5-1-构造-string-的其他方法" aria-hidden="true"></a></h2><ol>
<li><p>构造 <code>string</code> 的其他方法：</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2">构造 string 的其他方法</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">string s(cp, n)</td>
    <td class="tg-0pky">s 是 cp 指向的数组中前 n 个字符的拷贝。此数组至少应该包含 n 个字符</td>
  </tr>
  <tr>
    <td class="tg-0pky">string s(s2, pos2)</td>
    <td class="tg-0pky">s 是 string s2 从下标 pos2 开始的字符的拷贝。若 pos2 &gt; s2.size()，构造函数的行为未定义</td>
  </tr>
  <tr>
    <td class="tg-0pky">string s(s2, pos2, len2)</td>
    <td class="tg-0pky">s 是 string s2 从下标 pos2 开始 len2 个字符的拷贝。若 pos2 &gt; s2.size()，构造函数的行为未定义。不管 len2 的值是多少，构造函数至多拷贝 s2.size() - pos2 个字符</td>
  </tr>
</tbody>
</table>
</li>
<li><p>观察下面的代码段</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"Hel1o World!!!"</span>; <span class="comment">// 以空字符结束的数组</span></span><br><span class="line"><span class="keyword">char</span> noNull[] = &#123;<span class="string">'H'</span>, <span class="string">'i'</span>&#125;;        <span class="comment">// 不是以空字符结束</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(cp)</span></span>;                     <span class="comment">// 拷贝 cp 中的字符直到遇到空字符；s1 == "Hello     World!!!"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(noNull, <span class="number">2</span>)</span></span>;              <span class="comment">// 从 noNull 拷贝两个字符；s2 == "Hi"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(noNull)</span></span>;                 <span class="comment">// 未定义：noNull 不是以空字符结束</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(cp + <span class="number">6</span>, <span class="number">5</span>)</span></span>;              <span class="comment">// 从 cp[6] 开始拷贝 5 个字符；s4 == "World"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s5</span><span class="params">(s1, <span class="number">6</span>, <span class="number">5</span>)</span></span>;               <span class="comment">// 从 s1[6] 开始拷贝 5 个字符；s5 == "World"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s6</span><span class="params">(s1, <span class="number">6</span>)</span></span>;                  <span class="comment">// 从 s1[6] 开始拷贝,直至 s1 末尾；s6 == "World!!!"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s7</span><span class="params">(s1, <span class="number">6</span>, <span class="number">20</span>)</span></span>;              <span class="comment">// 正确,只拷贝到 s1 末尾；s7 == "World!!!"</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s8</span><span class="params">(s1, <span class="number">16</span>)</span></span>;                 <span class="comment">// 抛出一个 out_of_range 异常</span></span><br></pre></td></tr></table></figure>
<p>通常当我们从一个 <code>const char*</code> 创建 <code>string</code> 时，指针指向的数组必须以空字符结尾，拷贝操作遇到空字符时停止。如果我们还传递给构造函数一个计数值，数组就不必以空字符结尾。如果我们未传递计数值且数组也未以空字符结尾，或者给定计数值大于数组大小，则构造函数的行为是未定义的。</p>
<p>当从一个 <code>string</code> 拷贝字符时，我们可以提供一个可选的开始位置和一个计数值。开始位置必须小于或等于给定的 <code>string</code> 的大小。如果位置大于 <code>size</code>，则构造函数抛出一个 <code>out_of_range</code> 异常。如果我们传递了一个计数值，则从给定位置开始拷贝这么多个字符。不管我们要求拷贝多少个字符，标准库最多拷贝到 <code>string</code> 结尾，不会更多。</p>
</li>
<li><p><code>substr</code> 操作返回一个 <code>string</code>，它是原始 <code>string</code> 的一部分或全部的拷贝。可以传递给 <code>substr</code> 一个可选的开始位置和计数值：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="string">"hello world"</span>)</span></span>;</span><br><span class="line"><span class="built_in">string</span> s2 = s.substr(<span class="number">0</span>, <span class="number">5</span>);  <span class="comment">// s2 = hello</span></span><br><span class="line"><span class="built_in">string</span> s3 = s.substr(<span class="number">6</span>);     <span class="comment">// s3 = world</span></span><br><span class="line"><span class="built_in">string</span> s4 = s.substr(<span class="number">6</span>, <span class="number">11</span>); <span class="comment">// s3 = world</span></span><br><span class="line"><span class="built_in">string</span> s5 = s.substr(<span class="number">12</span>);    <span class="comment">// 抛出一个 out_of_range 异常</span></span><br></pre></td></tr></table></figure>
<p>如果开始位置超过了 <code>string</code> 的大小，则 <code>substr</code> 函数抛出一个 <code>out_of_range</code> 异常。如果开始位置加上计数值大于 <code>string</code> 的大小，则 <code>substr</code> 会调整计数值，只拷贝到 <code>string</code> 的末尾。</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>子字符串操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">s.substr(pos, n)</td>
    <td class="tg-0pky">返回一个 string，包含 s 中从 pos 开始的 n 个字符的拷贝。pos 的默认值为 0。n 的默认值为 s.size() - pos，即拷贝从 pos 开始的所有字符</td>
  </tr>
</tbody>
</table>
</li>
<li><p><strong>练习 9.41：</strong> 编写程序，从一个 <code>vector&lt;char&gt;</code> 初始化一个 <code>string</code>。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; ivec = &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">str</span><span class="params">(ivec.begin(), ivec.end())</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 9.42：</strong> 假定你希望每次读取一个字符存入一个 <code>string</code> 中，而且知道最少需要读取 100 个字符，应该如何提高程序的性能？</p>
<p>解：预先为 <code>string</code> <code>reserve</code> 不小于 100 个字符的容量。</p>
</li>
</ol>
<h2 id="9-5-2-改变-string-的其他方法" class="heading-control"><a href="#9-5-2-改变-string-的其他方法" class="headerlink" title="9.5.2 改变 string 的其他方法"></a>9.5.2 改变 string 的其他方法<a class="heading-anchor" href="#9-5-2-改变-string-的其他方法" aria-hidden="true"></a></h2><ol>
<li><p><code>string</code> 类型支持顺序容器的赋值运算符以及 <code>assign</code>、<code>insert</code> 和 <code>erase</code> 操作，除了接受迭代器的 <code>insert</code> 和 <code>erase</code> 版本外，<code>string</code> 还提供了接受下标的版本。下标指出了开始删除的位置，或是 <code>insert</code> 到给定值之前的位置：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.insert(s.size(), <span class="number">5</span>, <span class="string">'!'</span>); <span class="comment">// 在 s 末尾插入 5 个感叹号</span></span><br><span class="line">s.erase(s.size() - <span class="number">5</span>, <span class="number">5</span>);   <span class="comment">// 从 s 删除最后 5 个字符</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>标准库 <code>string</code> 类型还提供了接受 C 风格字符数组的 <code>insert</code> 和 <code>assign</code> 版本。例如，我们可以将以空字符结尾的字符数组 <code>insert</code> 到或 <code>assign</code> 给一个 <code>string</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cp = <span class="string">"Stately, plump Buck"</span>;</span><br><span class="line">s.assign(cp, <span class="number">7</span>);            <span class="comment">// s == "Stately"</span></span><br><span class="line">s.insert(s.size(), cp + <span class="number">7</span>); <span class="comment">// s == "Stately, plump Buck"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>我们也可以指定将来自其他 <code>string</code> 或子字符串的字符插入到当前 <code>string</code> 中或赋予当前 <code>string</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">"some string"</span>, s2 = <span class="string">"some other string"</span>;</span><br><span class="line">s.insert(<span class="number">0</span>, s2); <span class="comment">// 在 s 中位置 0 之前插入 s2 的拷贝</span></span><br><span class="line"><span class="comment">// 在 s[0] 之前插入 s2 中 s2[0] 开始的 s2.size() 个字符</span></span><br><span class="line">s.insert(<span class="number">0</span>, s2, <span class="number">0</span>, s2.size());</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>string</code> 类定义了两个额外的成员函数；<code>append</code> 和 <code>replace</code>，这两个函数可以改变 <code>string</code> 的内容。<code>append</code> 用于向 <code>string</code> 末尾追加字符串，<code>replace</code> 用于对 <code>string</code> 中的字符进行替换：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">s.replace(<span class="number">11</span>, <span class="number">3</span>, <span class="string">"Fifth"</span>); <span class="comment">// s == "C++ Primer Fifth Ed."</span></span><br></pre></td></tr></table></figure>
<p>在此调用中，删除了 3 个字符，但在其位置插入了 5 个新字符。</p>
</li>
<li><p><strong>练习 9.43：</strong> 编写一个函数，接受三个 <code>string</code> 参数 s、oldVal 和 newVal。使用迭代器及 <code>insert</code> 和 <code>erase</code> 函数将 s 中所有 o1dVal 替换为 newVal。测试你的程序，用它替换通用的简写形式，如，将”tho”替换为”though”，将”thru”替换为”through”。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;oldVal, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;newVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.size(), oldLen = oldVal.size(), newLen = newVal.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldLen &gt; sLen || <span class="number">0</span> == oldLen)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> ptr = s.begin(); ptr != s.end();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.substr(ptr - s.begin(), oldLen) == oldVal)</span><br><span class="line">        &#123;</span><br><span class="line">            ptr = s.erase(ptr, ptr + oldLen);</span><br><span class="line">            ptr = s.insert(ptr, newVal.begin(), newVal.end()) + newLen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++ptr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 9.44：</strong> 重写上一题的函数，这次使用一个下标和 <code>replace</code>。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;oldVal, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;newVal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sLen = s.size(), oldLen = oldVal.size(), newLen = newVal.size();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oldLen &gt; sLen || <span class="number">0</span> == oldLen)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s.size();)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.substr(i, oldLen) == oldVal)</span><br><span class="line">        &#123;</span><br><span class="line">            s.replace(i, oldLen, newVal);</span><br><span class="line">            i += newLen;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ++i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 9.45：</strong> 编写一个函数，接受一个表示名字的 <code>string</code> 参数和两个分别表示前缀（如<br>“Mr.”或”Ms.”）和后缀（如”Jr.”或”II”）的字符串。使用迭代器及 <code>insert</code> 和 <code>append</code> 函数将前缀和后缀添加到给定的名字中，将生成的新 <code>string</code> 返回。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="title">func3</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="keyword">char</span> *prefix, <span class="keyword">const</span> <span class="keyword">char</span> *suffix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">pref</span><span class="params">(prefix)</span></span>;</span><br><span class="line">    s.insert(s.begin(), pref.begin(), pref.end());</span><br><span class="line">    s.append(suffix);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 9.46：</strong> 重写上一题的函数，这次使用位置和长度来管理 <code>string</code>，并只使用 <code>insert</code>。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> &amp;<span class="title">func4</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;s, <span class="keyword">const</span> <span class="keyword">char</span> *prefix, <span class="keyword">const</span> <span class="keyword">char</span> *suffix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    s.insert(<span class="number">0</span>, prefix);</span><br><span class="line">    s.insert(s.size(), suffix);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="9-5-3-string-搜索操作" class="heading-control"><a href="#9-5-3-string-搜索操作" class="headerlink" title="9.5.3 string 搜索操作"></a>9.5.3 string 搜索操作<a class="heading-anchor" href="#9-5-3-string-搜索操作" aria-hidden="true"></a></h2><ol>
<li><p><code>string</code> 类提供了 6 个不同的搜索函数，每个函数都有 4 个重载版本。每个搜索操作都返回一个 <code>string::size_type</code> 值，表示匹配发生位置的下标。如果搜索失败，则返回一个名为 <code>string::npos</code> 的 <code>static</code> 成员。标准库将 <code>npos</code> 定义为一个 <code>const string::size_type</code> 类型，并初始化为值 -1。由于 <code>npos</code> 是一个 <code>unsigned</code> 类型，此初始值意味着 <code>npos</code> 等于任何 <code>string</code> 最大的可能大小。</p>
</li>
<li><blockquote>
<p>WARNING：<code>string</code> 搜索函数返回 <code>string:：size_type</code> 值，该类型是一个 <code>unsigned</code> 类型。因此，用一个 <code>int</code> 或其他带符号类型来保存这些函数的返回值不是一个好主意。</p>
</blockquote>
</li>
<li><p>观察下述代码段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">name</span><span class="params">(<span class="string">"AnnaBelle"</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> pos1 = name.find(<span class="string">"Anna"</span>); <span class="comment">// pos1 == 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">lowercase</span><span class="params">(<span class="string">"annabelle"</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> pos2 = lowercase.find(<span class="string">"Anna"</span>); <span class="comment">// pos2 == npos</span></span><br><span class="line"></span><br><span class="line">string numbers("0123456789"), name("r2d2");</span><br><span class="line"><span class="comment">// 返回 1，即，name 中第一个数字的下标</span></span><br><span class="line"><span class="keyword">auto</span> pos3 = name.find_first_of(numbers);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">dept</span><span class="params">(<span class="string">"03714p3"</span>)</span></span>;</span><br><span class="line"><span class="comment">// 返回 5——字符 'p' 的下标</span></span><br><span class="line"><span class="keyword">auto</span> pos4 = dept.find_first_not_of(numbers);</span><br></pre></td></tr></table></figure>
<p>搜索操作返回指定字符出现的下标，如果未找到则返回 <code>npos</code>。</p>
<p><style type="text/css"><br>.tg  {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial,     sans-serif;font-size:14px;<br>  overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial,     sans-serif;font-size:14px;<br>  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}<br>.tg .tg-fymr{border-color:inherit;font-weight:bold;text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>string 搜索操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0pky">s.find(args)</td>
    <td class="tg-0pky">查找 s 中 args 第一次出现的位置</td>
  </tr>
  <tr>
    <td class="tg-0pky">s.rfind(args)</td>
    <td class="tg-0pky">查找 s 中 args 最后一次出现的位置</td>
  </tr>
  <tr>
    <td class="tg-0pky">s.find_first_of(args)</td>
    <td class="tg-0pky">在 s 中查找 args 中任何一个字符第一次出现的位置</td>
  </tr>
  <tr>
    <td class="tg-0pky">s.find_last_of(args)</td>
    <td class="tg-0pky">在 s 中查找 args 中任何一个字符最后一次出现的位置</td>
  </tr>
  <tr>
    <td class="tg-0pky">s.find_first_not_of(args)</td>
    <td class="tg-0pky">在 s 中查找第一个不在 args 中的字符</td>
  </tr>
  <tr>
    <td class="tg-0pky">s.find_last_not_of(args)</td>
    <td class="tg-0pky">在 s 中查找最后一个不在 args 中的字符</td>
  </tr>
  <tr>
    <th class="tg-7btt" colspan="2">args 必须是以下形式之一</th>
  </tr>
  <tr>
    <td class="tg-0pky">c, pos</td>
    <td class="tg-0pky">从 s 中位置 pos 开始查找字符 c。pos 默认为 0</td>
  </tr>
  <tr>
    <td class="tg-0pky">s2, pos</td>
    <td class="tg-0pky">从 s 中位置 pos 开始查找字符串 s2。pos 默认为 0</td>
  </tr>
  <tr>
    <td class="tg-0pky">cp, pos</td>
    <td class="tg-0pky">从 s 中位置 pos 开始查找指针 cp 指向的以空字符结尾的 C 风格字符串。pos 默认为 0 </td>
  </tr>
  <tr>
    <td class="tg-0pky">cp, pos, n</td>
    <td class="tg-0pky">从 s 中位置 pos 开始查找指针 cp 指向的数组的前 n 个字符。pos 和 n 无默认值</td>
  </tr>
</tbody>
</table>
</li>
<li><p>可以传递给 <code>find</code> 操作一个可选的开始位置。这个可选的参数指出从哪个位置开始进行搜索。默认情况下，此位置被置为 0。一种常见的程序设计模式是用这个可选参数在字符串中<strong>循环地搜索子字符串出现的所有位置</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span>::size_type pos = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 每步循环查找 name 中下一个数</span></span><br><span class="line"><span class="keyword">while</span> ((pos = name.find_first_of(numbers, pos)) != <span class="built_in">string</span>::npos)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"found number at index:"</span> &lt;&lt; pos</span><br><span class="line">         &lt;&lt; <span class="string">"element is"</span> &lt;&lt; name[pos] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++pos; <span class="comment">// 移动到下一个字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 9.47：</strong> 编写程序，首先查找 <code>string</code> “ab2c3d7R4E6” 中的每个数字字符，然后查找其中每个字母字符。编写两个版本的程序，第一个要使用 <code>find_first_of</code>，第二个要使用 <code>find_first_not_of</code>。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_947_1</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"ab2c3d7R4E6"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> numbers = <span class="string">"0123456789"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> letters = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = s.find_first_of(numbers, pos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"number occurs in s["</span> &lt;&lt; pos &lt;&lt; <span class="string">"]: "</span> &lt;&lt; s[pos] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = s.find_first_of(letters, pos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"letter occurs in s["</span> &lt;&lt; pos &lt;&lt; <span class="string">"]: "</span> &lt;&lt; s[pos] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func_947_2</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> s = <span class="string">"ab2c3d7R4E6"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> numbers = <span class="string">"0123456789"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> letters = <span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = s.find_first_not_of(letters, pos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"number occurs in s["</span> &lt;&lt; pos &lt;&lt; <span class="string">"]: "</span> &lt;&lt; s[pos] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = s.find_first_not_of(numbers, pos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"letter occurs in s["</span> &lt;&lt; pos &lt;&lt; <span class="string">"]: "</span> &lt;&lt; s[pos] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            ++pos;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>练习 9.49：</strong> 如果一个字母延伸到中线之上，如 d 或 f，则称其有上出头部分（ascender）。如果一个字母延伸到中线之下，如 p 或 g，则称其有下出头部分（descender）。编写程序，读入一个单词文件，输出最长的既不包含上出头部分，也不包含下出头部分的单词。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">func_949</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;file)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ifstream <span class="title">fin</span><span class="params">(file)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> word, cender_letters = <span class="string">"bdfghjklpqty"</span>;</span><br><span class="line">    std::pair&lt;int, std::string&gt; result(0, "");</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (fin &gt;&gt; word)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (word.find_first_of(cender_letters) == <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (word.size() &gt; result.first)</span><br><span class="line">            &#123;</span><br><span class="line">                result.first = word.size();</span><br><span class="line">                result.second = word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="9-5-4-compare-函数" class="heading-control"><a href="#9-5-4-compare-函数" class="headerlink" title="9.5.4 compare 函数"></a>9.5.4 compare 函数<a class="heading-anchor" href="#9-5-4-compare-函数" aria-hidden="true"></a></h2><ol>
<li><p>标准库 <code>string</code> 类型还提供了一组 <code>compare</code> 函数，根据 <code>s</code> 是等于、大于还是小于参数指定的字符串，<code>s.compare</code> 返回 0、正数或负数。</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>s.compare 的几种参数形式</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">s2</td>
    <td class="tg-0lax">比较 s 和 s2</td>
  </tr>
  <tr>
    <td class="tg-0lax">pos1, n1, s2</td>
    <td class="tg-0lax">将 s 中从 pos1 开始的 n1 个字符与 s2 进行比较</td>
  </tr>
  <tr>
    <td class="tg-0lax">pos1, n1, s2, pos2, n2</td>
    <td class="tg-0lax">将 s 中从 pos1 开始的 n1 个字符与 s2 中从 pos2 开始的 n2 个字符进行比较</td>
  </tr>
  <tr>
    <td class="tg-0lax">cp</td>
    <td class="tg-0lax">比较 s 与 cp 指向的以空字符结尾的字符数组</td>
  </tr>
  <tr>
    <td class="tg-0lax">pos1, n1, cp</td>
    <td class="tg-0lax">将 s 中从 pos1 开始的 n1 个字符与 cp 指向的以空字符结尾的字符数组进行比较</td>
  </tr>
  <tr>
    <td class="tg-0lax">pos1, n1, cp, n2</td>
    <td class="tg-0lax">将 s 中从 pos1 开始的 n1 个字符与指针 cp 指向的地址开始的 n2 个字符进行比较</td>
  </tr>
</tbody>
</table>

</li>
</ol>
<h2 id="9-5-5-数值转换" class="heading-control"><a href="#9-5-5-数值转换" class="headerlink" title="9.5.5 数值转换"></a>9.5.5 数值转换<a class="heading-anchor" href="#9-5-5-数值转换" aria-hidden="true"></a></h2><ol>
<li><p>要转换为数值的 <code>string</code> 中第一个非空白符必须是数值中可能出现的字符：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s2 = <span class="string">"pi=3.14"</span>;</span><br><span class="line"><span class="comment">// 转换 s 中以数字开始的第一个子串，结果 d = 3.14</span></span><br><span class="line"><span class="keyword">double</span> d = stod(s2.substr(s2.find_first_of(<span class="string">"+-.0123456789"</span>)));</span><br></pre></td></tr></table></figure>
<p>我们将 s2 中从此位置开始的子串传递给<code>stod</code>。<code>stod</code> 函数读取此参数，处理其中的字符，直至遇到不可能是数值的一部分的字符。然后它就将找到的这个数值的字符串表示形式转换为对应的双精度浮点值。</p>
<p><code>string</code> 参数中第一个非空白符必须是符号（+ 或 -）或数字。它可以以 0x 或 0x 开头来表示十六进制数。对那些将字符串转换为浮点值的函数，<code>string</code> 参数也可以以小数点（.）开头，并可以包含 e 或 E 来表示指数部分。对于那些将字符串转换为整型值的函数，根据基数不同，<code>string</code> 参数可以包含字母字符，对应大于数字 9 的数。</p>
<blockquote>
<p>Note：如果 <code>string</code> 不能转换为一个数值，这些函数抛出一个 <code>invalid_argument</code> 异常。如果转换得到的数值无法用任何类型来表示，则抛出一个 <code>out_of_range</code> 异常。</p>
</blockquote>
</li>
<li><p><code>string</code> 和数值之间的常见转换操作如下表所示：</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2">string 和数值之间的转换</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">to_string(val)</td>
    <td class="tg-0lax">一组重载函数，返回数值 val 的 string 表示。val 可以是任何算术类型。对每个浮点类型和 int 或更大的整型，都有相应版本的 to_string。与往常一样，小整型会被提升</td>
  </tr>
  <tr>
    <td class="tg-0lax">stoi(s, p, b)</td>
    <td class="tg-cly1" rowspan="5">返回 s 的起始子串（表示整数内容）的数值，返回值类型分别是 int、long、unsigned long、long long、unsigned long long。b 表示转换所用的基数，默认值为 10。p 是 size_t 指针，用来保存 s 中第一个非数值字符的下标，p 默认为 0，即，函数不保存下标</td>
  </tr>
  <tr>
    <td class="tg-0lax">stol(s, p, b)</td>
  </tr>
  <tr>
    <td class="tg-0lax">stoul(s, p, b)</td>
  </tr>
  <tr>
    <td class="tg-0lax">stoll(s, p, b)</td>
  </tr>
  <tr>
    <td class="tg-0lax">stoull(s, p, b)</td>
  </tr>
  <tr>
    <td class="tg-0lax">stof(s, p)</td>
    <td class="tg-cly1" rowspan="3">返回 s 的起始子串（表示浮点数内容）的数值，返回值类型分别是 float、double 或 long double。参数 p 的作用与整数转换函数中一样</td>
  </tr>
  <tr>
    <td class="tg-0lax">stod(s, p)</td>
  </tr>
  <tr>
    <td class="tg-0lax">stold(s, p)</td>
  </tr>
</tbody>
</table>
</li>
<li><p><strong>练习 9.51：</strong> 设计一个类，它有三个 <code>unsigned</code> 成员，分别表示年、月和日。为其编写构造函数，接受一个表示日期的 <code>string</code> 参数。你的构造函数应该能处理不同数据格式，如 January 1，1900、1/1/1990、Jan 1 1900 等。</p>
<p>解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyDate(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;date)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos_blank_1st = date.find_first_of(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos_blank_2nd = date.find_last_of(<span class="string">" "</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos_comma = date.find_first_of(<span class="string">","</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos_slash_1st = date.find_first_of(<span class="string">"/"</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span>::size_type pos_slash_2nd = date.find_last_of(<span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos_blank_1st != <span class="built_in">std</span>::<span class="built_in">string</span>::npos)</span><br><span class="line">        &#123;</span><br><span class="line">            month = map_month[date.substr(<span class="number">0</span>, pos_blank_1st)];</span><br><span class="line">            day = pos_comma != <span class="built_in">std</span>::<span class="built_in">string</span>::npos</span><br><span class="line">                      ? <span class="built_in">std</span>::stoi(date.substr(pos_blank_1st + <span class="number">1</span>, pos_comma - pos_blank_1st - <span class="number">1</span>))</span><br><span class="line">                      : <span class="built_in">std</span>::stoi(date.substr(pos_blank_1st + <span class="number">1</span>, pos_blank_2nd - pos_blank_1st - <span class="number">1</span>));</span><br><span class="line">            year = <span class="built_in">std</span>::stoi(date.substr(pos_blank_2nd + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            month = map_month[date.substr(<span class="number">0</span>, pos_slash_1st)];</span><br><span class="line">            day = <span class="built_in">std</span>::stoi(date.substr(pos_slash_1st + <span class="number">1</span>, pos_slash_2nd - pos_slash_1st - <span class="number">1</span>));</span><br><span class="line">            year = <span class="built_in">std</span>::stoi(date.substr(pos_slash_2nd + <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetDate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" Year: "</span> &lt;&lt; year &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Month: "</span> &lt;&lt; month &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"  Day: "</span> &lt;&lt; day &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> year;</span><br><span class="line">    <span class="keyword">int</span> month;</span><br><span class="line">    <span class="keyword">int</span> day;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt; map_month = &#123;</span><br><span class="line">        &#123;<span class="string">"January"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Jan"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"1"</span>, <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"February"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Feb"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"2"</span>, <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"March"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Mar"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"3"</span>, <span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"April"</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Apr"</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"4"</span>, <span class="number">4</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"May"</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"5"</span>, <span class="number">5</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"June"</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Jun"</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"6"</span>, <span class="number">6</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"July"</span>, <span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"7"</span>, <span class="number">7</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"August"</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Aug"</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"8"</span>, <span class="number">8</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"September"</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Sep"</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"9"</span>, <span class="number">9</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"October"</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Oct"</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"10"</span>, <span class="number">10</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"November"</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Nov"</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"11"</span>, <span class="number">11</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"December"</span>, <span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"Dec"</span>, <span class="number">12</span>&#125;,</span><br><span class="line">        &#123;<span class="string">"12"</span>, <span class="number">12</span>&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="9-6-容器适配器" class="heading-control"><a href="#9-6-容器适配器" class="headerlink" title="9.6 容器适配器"></a>9.6 容器适配器<a class="heading-anchor" href="#9-6-容器适配器" aria-hidden="true"></a></h1><ol>
<li><p>除了顺序容器外，标准库还定义了三个顺序容器适配器：<code>stack</code>、<code>queue</code> 和 <code>priority_queue</code>。<strong>适配器</strong>（adaptor）是标准库中的一个通用概念。容器、迭代器和函数都有适配器。每个适配器都定义两个构造函数：默认构造函数创建一个空对象，接受一个容器的构造函数拷贝该容器来初始化适配器。</p>
</li>
<li><p>默认情况下，<code>stack</code> 和 <code>queue</code> 是基于 <code>deque</code> 实现的，<code>priority_queue</code> 是在 <code>vector</code> 之上实现的。我们可以在创建一个适配器时将一个命名的顺序容器作为第二个类型参数，来重载默认容器类型。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 vector 上实现的空栈</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; str_stk;</span><br><span class="line"><span class="comment">// str_stk2 在 vector 上实现，初始化时保存 svec 的拷贝</span></span><br><span class="line">stack&lt;string, vector&lt;string&gt;&gt; str_stk2(svec);</span><br></pre></td></tr></table></figure>
</li>
<li><p>所有适配器都要求容器县有添加和删除元素的能力。因此，适配器不能构造在 <code>array</code> 之上。类似的，我们也不能用 <code>forward_list</code> 来构造适配器，因为所有适配器都要求容器具有添加、删除以及访问尾元素的能力。<code>stack</code> 只要求 <code>push_back</code>、<code>pop_back</code> 和 <code>back</code> 操作，因此可以使用除 <code>array</code> 和 <code>forward_list</code> 之外的任何容器类型采构造 <code>stack</code>。<code>queue</code> 适配器要求 <code>back</code>、<code>push_back</code>、<code>front</code> 和 <code>push_front</code>，因此它可以构造于 <code>list</code> 或 <code>deque</code> 之上，但不能基于 <code>vector</code> 构造。<code>priority_queue</code> 除了 <code>front</code>、<code>push_back</code> 和 <code>pop_back</code> 操作之外还要求随机访问能力，因此它可以构造于 <code>vector</code> 或 <code>deque</code> 之上，但不能基于 <code>list</code> 构造。</p>
</li>
<li><p>一些典型的 <code>stack</code> 操作：</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>一些典型的 stack 操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">s.pop()</td>
    <td class="tg-0lax">删除栈顶元素，但不返回该元素值</td>
  </tr>
  <tr>
    <td class="tg-0lax">s.push(item)</td>
    <td class="tg-cly1" rowspan="2">创建一个新元素压入栈顶，该元素通过拷贝或移动 item 而来，或者由 args 构造</td>
  </tr>
  <tr>
    <td class="tg-0lax">s.emplace(args)</td>
  </tr>
  <tr>
    <td class="tg-0lax">s.top()</td>
    <td class="tg-0lax">返回栈顶元素，但不将元素弹出栈</td>
  </tr>
</tbody>
</table>
</li>
<li><p><code>queue</code> 默认基于 <code>deque</code> 实现，<code>priority_queue</code> 默认基于 <code>vector</code> 实现；<code>queue</code> 也可以用 <code>list</code> 或 <code>vector</code> 实现，<code>priority_queue</code> 也可以用 <code>deque</code> 实现。一些典型的 <code>queue</code> 和 <code>priority_queue</code> 操作：</p>
<p><style type="text/css"><br>.tg {border-collapse:collapse;border-spacing:0;}<br>.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;<br>font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}<br>.tg .tg-cly1{text-align:left;vertical-align:middle}<br>.tg .tg-7btt{border-color:inherit;font-weight:bold;text-align:center;vertical-align:top}<br>.tg .tg-0lax{text-align:left;vertical-align:top}
</style></p>
<table class="tg">
<thead>
  <tr>
    <th class="tg-7btt" colspan="2"><center>一些典型的 queue 和 priority_queue 操作</center></th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">q.pop()</td>
    <td class="tg-0lax">删除 queue 的首元素或 priority_queue 的最高优先级的元素，但不返回此元素</td>
  </tr>
  <tr>
    <td class="tg-0lax">q.front()</td>
    <td class="tg-cly1" rowspan="2">返回首元素或尾元素，但不删除此元素，只适用于 queue</td>
  </tr>
  <tr>
    <td class="tg-0lax">q.back()</td>
  </tr>
  <tr>
    <td class="tg-0lax">q.top()</td>
    <td class="tg-0lax">返回最高优先级元素，但不删除该元素，只适用于 priority_queue</td>
  </tr>
  <tr>
    <td class="tg-0lax">q.push(item)</td>
    <td class="tg-cly1" rowspan="2">在 queue 末尾或 priority_queue 中恰当的位置创建一个元素，其值为 item，或者由 args 构造</td>
  </tr>
  <tr>
    <td class="tg-0lax">q.emplace(args)</td>
  </tr>
</tbody>
</table>
</li>
<li><p><code>priority_queue</code> 允许我们为队列中的元素建立优先级。新加入的元素会排在所有优先级比它低的已有元素之前。</p>
</li>
</ol>
<h1 id="术语表" class="heading-control"><a href="#术语表" class="headerlink" title="术语表"></a>术语表<a class="heading-anchor" href="#术语表" aria-hidden="true"></a></h1><ol>
<li><p><strong><code>forward_list</code></strong> 顺序容器，表示一个单向链表。<code>forward_list</code> 中的元素只能顺序访问。从一个给定元素开始，为了访问另一个元素，我们只能遍历两者之间的所有元素。<code>forward_list</code> 上的迭代器不支持递减运算（<code>--</code>）。<code>forward_list</code> 支持任意位置的快速插入（或删除）操作。与其他容器不同，插入和删除发生在一个给定的迭代器之后的位置。因此，除了通常的尾后迭代器之外，<code>forward_list</code> 还有一个“首前”迭代器。在添加新元素后，原有的指向 <code>forward_list</code> 的迭代器仍有效。在删除元素后，只有原来指向被删元素的迭代器才会失效。</p>
</li>
<li><p><strong>选代器范围（iterator range）</strong> 由一对迭代器指定的元素范围。第一个迭代器表示序列中第一个元素，第二个迭代器指向最后一个元素之后的位置。如果范围为空，则两个迭代器是相等的（反之亦然，如果两个迭代器不等，则它们表示一个非空范围）。如果范围非空，则必须保证，通过反复递增第一个迭代器，可以到达第二个迭代器。通过递增迭代器，序列中每个元素都能被访问到。</p>
</li>
<li><p><strong><code>list</code></strong> 顺序容器，表示一个双向链表。<code>list</code> 中的元素只能顺序访问。从一个给定元素开始，为了访问另一个元素，我们只能遍历两者之间的所有元素。<code>list</code> 上的迭代器既支持递增运算（<code>++</code>），也支持递减运算（<code>--</code>）。<code>list</code> 支持任意位置的快速插入（或删除）操作。当加入新元素后，迭代器仍然有效。当删除元素后，只有原来指向被删除元素的迭代器才会失效。</p>
</li>
<li><p><strong>首前迭代器（off-the-beginning iterator）</strong> 表示一个 <code>forward_list</code> 开始位置之前（不存在的）元素的迭代器。是 <code>forward_list</code> 的成员函数 <code>before_begin</code> 的返回值。与 <code>end()</code> 迭代器类似，不能被解引用。</p>
</li>
<li><p><strong><code>vector</code></strong> 顺序容器。<code>vector</code> 中的元素可以通过位置下标访问。支持快速的随机访问。我们只能在 <code>vector</code> 末尾实现高效的元素添加/删除。向 <code>vector</code> 添加元素可能导致内存空间的重新分配，从而使所有指向 <code>vector</code> 的迭代器失效。在 <code>vector</code> 内部添加（或删除）元素会使所有指向插入（删除）点之后元素的迭代器失效。</p>
</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>编码</category>
        <category>C/C++</category>
        <category>《C++ Primer》</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
</search>
